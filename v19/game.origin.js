var cc = cc || {};
cc._tmp = cc._tmp || {};
cc._LogInfos = {};
var _p = window,
    _p = Object.prototype,
    _p = null;
cc.ORIENTATION_PORTRAIT = 0;
cc.ORIENTATION_PORTRAIT_UPSIDE_DOWN = 1;
cc.ORIENTATION_LANDSCAPE_LEFT = 2;
cc.ORIENTATION_LANDSCAPE_RIGHT = 3;
cc._drawingUtil = null;
cc._renderContext = null;
cc._supportRender = !1;
cc._canvas = null;
cc.container = null;
cc._gameDiv = null;
cc.newElement = function(a) {
    return document.createElement(a)
};
cc.each = function(a, b, c) {
    if (a)
        if (a instanceof Array)
            for (var d = 0, e = a.length; d < e && !1 !== b.call(c, a[d], d); d++);
        else
            for (d in a)
                if (!1 === b.call(c, a[d], d)) break
};
cc.extend = function(a) {
    var b = 2 <= arguments.length ? Array.prototype.slice.call(arguments, 1) : [];
    cc.each(b, function(b) {
        for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d])
    });
    return a
};
cc.isFunction = function(a) {
    return "function" === typeof a
};
cc.isNumber = function(a) {
    return "number" === typeof a || "[object Number]" === Object.prototype.toString.call(a)
};
cc.isString = function(a) {
    return "string" === typeof a || "[object String]" === Object.prototype.toString.call(a)
};
cc.isArray = function(a) {
    return Array.isArray(a) || "object" === typeof a && "[object Array]" === Object.prototype.toString.call(a)
};
cc.isUndefined = function(a) {
    return "undefined" === typeof a
};
cc.isObject = function(a) {
    return "object" === typeof a && "[object Object]" === Object.prototype.toString.call(a)
};
cc.isCrossOrigin = function(a) {
    if (!a) return cc.log("invalid URL"), !1;
    var b = a.indexOf("://");
    if (-1 === b) return !1;
    b = a.indexOf("/", b + 3);
    return (-1 === b ? a : a.substring(0, b)) !== location.origin
};
cc.AsyncPool = function(a, b, c, d, e) {
    var f = this;
    f._srcObj = a;
    f._limit = b;
    f._pool = [];
    f._iterator = c;
    f._iteratorTarget = e;
    f._onEnd = d;
    f._onEndTarget = e;
    f._results = a instanceof Array ? [] : {};
    cc.each(a, function(a, b) {
        f._pool.push({
            index: b,
            value: a
        })
    });
    f.size = f._pool.length;
    f.finishedSize = 0;
    f._workingSize = 0;
    f._limit = f._limit || f.size;
    f.onIterator = function(a, b) {
        f._iterator = a;
        f._iteratorTarget = b
    };
    f.onEnd = function(a, b) {
        f._onEnd = a;
        f._onEndTarget = b
    };
    f._handleItem = function() {
        var a = this;
        if (!(0 === a._pool.length || a._workingSize >=
                a._limit)) {
            var b = a._pool.shift(),
                c = b.value,
                d = b.index;
            a._workingSize++;
            a._iterator.call(a._iteratorTarget, c, d, function(b) {
                a.finishedSize++;
                a._workingSize--;
                var c = Array.prototype.slice.call(arguments, 1);
                a._results[this.index] = c[0];
                a.finishedSize === a.size ? a._onEnd && a._onEnd.call(a._onEndTarget, null, a._results) : a._handleItem()
            }.bind(b), a)
        }
    };
    f.flow = function() {
        if (0 === this._pool.length) this._onEnd && this._onEnd.call(this._onEndTarget, null, []);
        else
            for (var a = 0; a < this._limit; a++) this._handleItem()
    }
};
cc.async = {
    series: function(a, b, c) {
        a = new cc.AsyncPool(a, 1, function(a, b, f) {
            a.call(c, f)
        }, b, c);
        a.flow();
        return a
    },
    parallel: function(a, b, c) {
        a = new cc.AsyncPool(a, 0, function(a, b, f) {
            a.call(c, f)
        }, b, c);
        a.flow();
        return a
    },
    waterfall: function(a, b, c) {
        var d = [],
            e = [null],
            f = new cc.AsyncPool(a, 1, function(b, f, k) {
                d.push(function(b) {
                    d = Array.prototype.slice.call(arguments, 1);
                    a.length - 1 === f && (e = e.concat(d));
                    k.apply(null, arguments)
                });
                b.apply(c, d)
            }, function(a) {
                if (b) {
                    if (a) return b.call(c, a);
                    b.apply(c, e)
                }
            });
        f.flow();
        return f
    },
    map: function(a, b, c, d) {
        var e = b;
        "object" === typeof b && (c = b.cb, d = b.iteratorTarget, e = b.iterator);
        a = new cc.AsyncPool(a, 0, e, c, d);
        a.flow();
        return a
    },
    mapLimit: function(a, b, c, d, e) {
        a = new cc.AsyncPool(a, b, c, d, e);
        a.flow();
        return a
    }
};
cc.path = {
    normalizeRE: /[^\.\/]+\/\.\.\//,
    join: function() {
        for (var a = arguments.length, b = "", c = 0; c < a; c++) b = (b + ("" === b ? "" : "/") + arguments[c]).replace(/(\/|\\\\)$/, "");
        return b
    },
    extname: function(a) {
        return (a = /(\.[^\.\/\?\\]*)(\?.*)?$/.exec(a)) ? a[1] : null
    },
    mainFileName: function(a) {
        if (a) {
            var b = a.lastIndexOf(".");
            if (-1 !== b) return a.substring(0, b)
        }
        return a
    },
    basename: function(a, b) {
        var c = a.indexOf("?");
        0 < c && (a = a.substring(0, c));
        c = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(a.replace(/(\/|\\\\)$/, ""));
        if (!c) return null;
        c = c[2];
        return b && a.substring(a.length - b.length).toLowerCase() === b.toLowerCase() ? c.substring(0, c.length - b.length) : c
    },
    dirname: function(a) {
        return a.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2")
    },
    changeExtname: function(a, b) {
        b = b || "";
        var c = a.indexOf("?"),
            d = "";
        0 < c && (d = a.substring(c), a = a.substring(0, c));
        c = a.lastIndexOf(".");
        return 0 > c ? a + b + d : a.substring(0, c) + b + d
    },
    changeBasename: function(a, b, c) {
        if (0 === b.indexOf(".")) return this.changeExtname(a, b);
        var d = a.indexOf("?"),
            e = "";
        c = c ? this.extname(a) : "";
        0 < d && (e = a.substring(d),
            a = a.substring(0, d));
        d = a.lastIndexOf("/");
        return a.substring(0, 0 >= d ? 0 : d + 1) + b + c + e
    },
    _normalize: function(a) {
        var b = a = String(a);
        do b = a, a = a.replace(this.normalizeRE, ""); while (b.length !== a.length);
        return a
    }
};
cc.loader = function() {
    var a = {},
        b = {},
        c = {},
        d = {},
        e = RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i");
    return {
        resPath: "",
        audioPath: "",
        cache: {},
        getXMLHttpRequest: function() {
            return window.XMLHttpRequest ?
                new window.XMLHttpRequest : new ActiveXObject("MSXML2.XMLHTTP")
        },
        _getArgs4Js: function(a) {
            var b = a[0],
                c = a[1],
                d = a[2],
                e = ["", null, null];
            if (1 === a.length) e[1] = b instanceof Array ? b : [b];
            else if (2 === a.length) "function" === typeof c ? (e[1] = b instanceof Array ? b : [b], e[2] = c) : (e[0] = b || "", e[1] = c instanceof Array ? c : [c]);
            else if (3 === a.length) e[0] = b || "", e[1] = c instanceof Array ? c : [c], e[2] = d;
            else throw Error("arguments error to load js!");
            return e
        },
        loadJs: function(b, c, d) {
            var e = this,
                m = e._getArgs4Js(arguments),
                n = m[0],
                p = m[1],
                m = m[2]; - 1 < navigator.userAgent.indexOf("Trident/5") ? e._loadJs4Dependency(n, p, 0, m) : cc.async.map(p, function(b, c, d) {
                b = cc.path.join(n, b);
                if (a[b]) return d(null);
                e._createScript(b, !1, d)
            }, m)
        },
        loadJsWithImg: function(a, b, c) {
            var d = this._loadJsImg(),
                e = this._getArgs4Js(arguments);
            this.loadJs(e[0], e[1], function(a) {
                if (a) throw Error(a);
                d.parentNode.removeChild(d);
                if (e[2]) e[2]()
            })
        },
        _createScript: function(b, c, d) {
            var e = document,
                m = document.createElement("script");
            m.async = c;
            a[b] = !0;
            cc.game.config.noCache && "string" ===
                typeof b ? this._noCacheRex.test(b) ? m.src = b + "\x26_t\x3d" + (new Date - 0) : m.src = b + "?_t\x3d" + (new Date - 0) : m.src = b;
            m.addEventListener("load", function() {
                m.parentNode.removeChild(m);
                this.removeEventListener("load", arguments.callee, !1);
                d()
            }, !1);
            m.addEventListener("error", function() {
                m.parentNode.removeChild(m);
                d("Load " + b + " failed!")
            }, !1);
            e.body.appendChild(m)
        },
        _loadJs4Dependency: function(a, b, c, d) {
            if (c >= b.length) d && d();
            else {
                var e = this;
                e._createScript(cc.path.join(a, b[c]), !1, function(n) {
                    if (n) return d(n);
                    e._loadJs4Dependency(a,
                        b, c + 1, d)
                })
            }
        },
        _loadJsImg: function() {
            var a = document,
                b = a.getElementById("cocos2d_loadJsImg");
            if (!b) {
                b = document.createElement("img");
                cc._loadingImage && (b.src = cc._loadingImage);
                a = a.getElementById(cc.game.config.id);
                a.style.backgroundColor = "transparent";
                a.parentNode.appendChild(b);
                var c = getComputedStyle ? getComputedStyle(a) : a.currentStyle;
                c || (c = {
                    width: a.width,
                    height: a.height
                });
                b.style.left = a.offsetLeft + (parseFloat(c.width) - b.width) / 2 + "px";
                b.style.top = a.offsetTop + (parseFloat(c.height) - b.height) / 2 + "px";
                b.style.position =
                    "absolute"
            }
            return b
        },
        loadTxt: function(a, b) {
            if (cc._isNodeJs) require("fs").readFile(a, function(a, c) {
                a ? b(a) : b(null, c.toString())
            });
            else {
                var c = this.getXMLHttpRequest(),
                    d = "load " + a + " failed!";
                c.open("GET", a, !0);
                /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? (c.setRequestHeader("Accept-Charset", "utf-8"), c.onreadystatechange = function() {
                    4 === c.readyState && (200 === c.status ? b(null, c.responseText) : b({
                        status: c.status,
                        errorMessage: d
                    }, null))
                }) : (c.overrideMimeType && c.overrideMimeType("text/plain; charset\x3dutf-8"),
                    c.onload = function() {
                        4 === c.readyState && (200 === c.status ? b(null, c.responseText) : b({
                            status: c.status,
                            errorMessage: d
                        }, null))
                    }, c.onerror = function() {
                        b({
                            status: c.status,
                            errorMessage: d
                        }, null)
                    });
                c.send(null)
            }
        },
        _loadTxtSync: function(a) {
            if (cc._isNodeJs) return require("fs").readFileSync(a).toString();
            var b = this.getXMLHttpRequest();
            b.open("GET", a, !1);
            /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) ? b.setRequestHeader("Accept-Charset", "utf-8") : b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dutf-8");
            b.send(null);
            return 4 === !b.readyState || 200 !== b.status ? null : b.responseText
        },
        loadCsb: function(a, b) {
            var c = new XMLHttpRequest,
                d = "load " + a + " failed!";
            c.open("GET", a, !0);
            c.responseType = "arraybuffer";
            c.onload = function() {
                var a = c.response;
                a && (window.msg = a);
                4 === c.readyState && (200 === c.status ? b(null, c.response) : b({
                    status: c.status,
                    errorMessage: d
                }, null))
            };
            c.onerror = function() {
                b({
                    status: c.status,
                    errorMessage: d
                }, null)
            };
            c.send(null)
        },
        loadJson: function(a, b) {
            this.loadTxt(a, function(c, d) {
                if (c) b(c);
                else {
                    try {
                        var e = JSON.parse(d)
                    } catch (n) {
                        throw Error("parse json [" +
                            a + "] failed : " + n);
                    }
                    b(null, e)
                }
            })
        },
        _checkIsImageURL: function(a) {
            return null != /(\.png)|(\.jpg)|(\.bmp)|(\.jpeg)|(\.gif)/.exec(a)
        },
        loadImg: function(a, b, c) {
            var d = {
                isCrossOrigin: !0
            };
            void 0 !== c ? d.isCrossOrigin = null === b.isCrossOrigin ? d.isCrossOrigin : b.isCrossOrigin : void 0 !== b && (c = b);
            var e = this.getRes(a);
            if (e) return c && c(null, e), e;
            e = new Image;
            d.isCrossOrigin && "file://" !== location.origin && (e.crossOrigin = "Anonymous");
            var n = function() {
                    this.removeEventListener("load", n, !1);
                    this.removeEventListener("error", s, !1);
                    c && c(null, e)
                },
                p = this,
                s = function() {
                    this.removeEventListener("error", s, !1);
                    e.crossOrigin && "anonymous" === e.crossOrigin.toLowerCase() ? (d.isCrossOrigin = !1, p.release(a), cc.loader.loadImg(a, d, c)) : "function" === typeof c && c("load image failed")
                };
            e.addEventListener("load", n);
            e.addEventListener("error", s);
            e.src = a;
            return e
        },
        _loadResIterator: function(a, c, d) {
            var k = this,
                m = null,
                n = a.type;
            n ? (n = "." + n.toLowerCase(), m = a.src ? a.src : a.name + n) : (m = a, n = cc.path.extname(m));
            if (c = k.getRes(m)) return d(null, c);
            c = null;
            n && (c = b[n.toLowerCase()]);
            if (!c) return cc.error("loader for [" + n + "] not exists!"), d();
            n = m;
            e.test(m) || (n = c.getBasePath ? c.getBasePath() : k.resPath, n = k.getUrl(n, m));
            cc.game.config.noCache && "string" === typeof n && (n = k._noCacheRex.test(n) ? n + ("\x26_t\x3d" + (new Date - 0)) : n + ("?_t\x3d" + (new Date - 0)));
            c.load(n, m, a, function(a, b) {
                a ? (cc.log(a), k.cache[m] = null, delete k.cache[m], d({
                    status: 520,
                    errorMessage: a
                }, null)) : (k.cache[m] = b, d(null, b))
            })
        },
        _noCacheRex: /\?/,
        getUrl: function(a, d) {
            var e = cc.path;
            if (void 0 !== a && void 0 === d) {
                d = a;
                var k = e.extname(d),
                    k = k ? k.toLowerCase() : "";
                a = (k = b[k]) ? k.getBasePath ? k.getBasePath() : this.resPath : this.resPath
            }
            d = cc.path.join(a || "", d);
            if (d.match(/[\/(\\\\)]lang[\/(\\\\)]/i)) {
                if (c[d]) return c[d];
                e = e.extname(d) || "";
                d = c[d] = d.substring(0, d.length - e.length) + "_" + cc.sys.language + e
            }
            return d
        },
        load: function(a, b, c) {
            var d = this,
                e = arguments.length;
            if (0 === e) throw Error("arguments error!");
            3 === e ? "function" === typeof b && (b = "function" === typeof c ? {
                trigger: b,
                cb: c
            } : {
                cb: b,
                cbTarget: c
            }) : 2 === e ? "function" === typeof b && (b = {
                cb: b
            }) : 1 === e && (b = {});
            a instanceof Array || (a = [a]);
            e = new cc.AsyncPool(a, 0, function(a, c, e, f) {
                d._loadResIterator(a, c, function(a) {
                    var c = Array.prototype.slice.call(arguments, 1);
                    b.trigger && b.trigger.call(b.triggerTarget, c[0], f.size, f.finishedSize);
                    e(a, c[0])
                })
            }, b.cb, b.cbTarget);
            e.flow();
            return e
        },
        _handleAliases: function(a, b) {
            var c = [],
                e;
            for (e in a) {
                var m = a[e];
                d[e] = m;
                c.push(m)
            }
            this.load(c, b)
        },
        loadAliases: function(a, b) {
            var c = this,
                d = c.getRes(a);
            d ? c._handleAliases(d.filenames, b) : c.load(a, function(a, d) {
                c._handleAliases(d[0].filenames,
                    b)
            })
        },
        register: function(a, c) {
            if (a && c) {
                if ("string" === typeof a) return b[a.trim().toLowerCase()] = c;
                for (var d = 0, e = a.length; d < e; d++) b["." + a[d].trim().toLowerCase()] = c
            }
        },
        getRes: function(a) {
            return this.cache[a] || this.cache[d[a]]
        },
        _getAliase: function(a) {
            return d[a]
        },
        release: function(a) {
            var b = this.cache;
            delete b[a];
            delete b[d[a]];
            delete d[a]
        },
        releaseAll: function() {
            var a = this.cache,
                b;
            for (b in a) delete a[b];
            for (b in d) delete d[b]
        }
    }
}();
cc.formatStr = function() {
    var a = arguments,
        b = a.length;
    if (1 > b) return "";
    var c = a[0],
        d = !0;
    "object" === typeof c && (d = !1);
    for (var e = 1; e < b; ++e) {
        var f = a[e];
        if (d)
            for (;;) {
                var g = null;
                if ("number" === typeof f && (g = c.match(/(%d)|(%s)/))) {
                    c = c.replace(/(%d)|(%s)/, f);
                    break
                }
                c = (g = c.match(/%s/)) ? c.replace(/%s/, f) : c + ("    " + f);
                break
            } else c += "    " + f
    }
    return c
};
(function() {
    function a(a) {
        var b = cc.game.CONFIG_KEY,
            c = parseInt(a[b.renderMode]) || 0;
        if (isNaN(c) || 2 < c || 0 > c) a[b.renderMode] = 0;
        cc._renderType = cc.game.RENDER_TYPE_CANVAS;
        cc._supportRender = !1;
        0 === c ? cc.sys.capabilities.opengl ? (cc._renderType = cc.game.RENDER_TYPE_WEBGL, cc._supportRender = !0) : cc.sys.capabilities.canvas && (cc._renderType = cc.game.RENDER_TYPE_CANVAS, cc._supportRender = !0) : 1 === c && cc.sys.capabilities.canvas ? (cc._renderType = cc.game.RENDER_TYPE_CANVAS, cc._supportRender = !0) : 2 === c && cc.sys.capabilities.opengl &&
            (cc._renderType = cc.game.RENDER_TYPE_WEBGL, cc._supportRender = !0)
    }

    function b(a, c, d) {
        if (h[c]) return null;
        d = d || "";
        var e = [],
            f = a[c];
        if (!f) throw Error("can not find module [" + c + "]");
        c = cc.path;
        for (var g = 0, k = f.length; g < k; g++) {
            var m = f[g];
            if (!h[m]) {
                var A = c.extname(m);
                A ? ".js" === A.toLowerCase() && e.push(c.join(d, m)) : (A = b(a, m, d)) && (e = e.concat(A));
                h[m] = 1
            }
        }
        return e
    }

    function c(a) {
        cc._initDebugSetting(a[cc.game.CONFIG_KEY.debugMode]);
        cc._engineLoaded = !0;
        cc.log(cc.ENGINE_VERSION);
        m && m()
    }

    function d(a) {
        var d = a[cc.game.CONFIG_KEY.engineDir],
            e = cc.loader;
        if (cc.Class) c(a);
        else {
            var f = cc.path.join(d, "moduleConfig.json");
            e.loadJson(f, function(e, f) {
                if (e) throw Error(e);
                var g = a.modules || [],
                    h = f.module,
                    k = [];
                cc.sys.capabilities.opengl && 0 > g.indexOf("base4webgl") ? g.splice(0, 0, "base4webgl") : 0 > g.indexOf("core") && g.splice(0, 0, "core");
                for (var m = 0, r = g.length; m < r; m++) {
                    var s = b(h, g[m], d);
                    s && (k = k.concat(s))
                }
                cc.loader.loadJsWithImg(k, function(b) {
                    if (b) throw b;
                    c(a)
                })
            })
        }
    }

    function e() {
        this.removeEventListener("load", e, !1);
        d(cc.game.config)
    }
    var f = document.createElement("canvas"),
        g = document.createElement("canvas");
    cc.create3DContext = function(a, b) {
        for (var c = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], d = null, e = 0; e < c.length; ++e) {
            try {
                d = a.getContext(c[e], b)
            } catch (f) {}
            if (d) break
        }
        return d
    };
    (function() {
        cc.sys = {};
        var a = cc.sys;
        a.LANGUAGE_ENGLISH = "en";
        a.LANGUAGE_CHINESE = "zh";
        a.LANGUAGE_FRENCH = "fr";
        a.LANGUAGE_ITALIAN = "it";
        a.LANGUAGE_GERMAN = "de";
        a.LANGUAGE_SPANISH = "es";
        a.LANGUAGE_DUTCH = "du";
        a.LANGUAGE_RUSSIAN = "ru";
        a.LANGUAGE_KOREAN = "ko";
        a.LANGUAGE_JAPANESE = "ja";
        a.LANGUAGE_HUNGARIAN =
            "hu";
        a.LANGUAGE_PORTUGUESE = "pt";
        a.LANGUAGE_ARABIC = "ar";
        a.LANGUAGE_NORWEGIAN = "no";
        a.LANGUAGE_POLISH = "pl";
        a.LANGUAGE_UNKNOWN = "unkonwn";
        a.OS_IOS = "iOS";
        a.OS_ANDROID = "Android";
        a.OS_WINDOWS = "Windows";
        a.OS_MARMALADE = "Marmalade";
        a.OS_LINUX = "Linux";
        a.OS_BADA = "Bada";
        a.OS_BLACKBERRY = "Blackberry";
        a.OS_OSX = "OS X";
        a.OS_WP8 = "WP8";
        a.OS_WINRT = "WINRT";
        a.OS_UNKNOWN = "Unknown";
        a.UNKNOWN = -1;
        a.WIN32 = 0;
        a.LINUX = 1;
        a.MACOS = 2;
        a.ANDROID = 3;
        a.IPHONE = 4;
        a.IPAD = 5;
        a.BLACKBERRY = 6;
        a.NACL = 7;
        a.EMSCRIPTEN = 8;
        a.TIZEN = 9;
        a.WINRT = 10;
        a.WP8 = 11;
        a.MOBILE_BROWSER = 100;
        a.DESKTOP_BROWSER = 101;
        a.BROWSER_TYPE_WECHAT = "wechat";
        a.BROWSER_TYPE_ANDROID = "androidbrowser";
        a.BROWSER_TYPE_IE = "ie";
        a.BROWSER_TYPE_QQ = "qqbrowser";
        a.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
        a.BROWSER_TYPE_UC = "ucbrowser";
        a.BROWSER_TYPE_360 = "360browser";
        a.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
        a.BROWSER_TYPE_BAIDU = "baidubrowser";
        a.BROWSER_TYPE_MAXTHON = "maxthon";
        a.BROWSER_TYPE_OPERA = "opera";
        a.BROWSER_TYPE_OUPENG = "oupeng";
        a.BROWSER_TYPE_MIUI = "miuibrowser";
        a.BROWSER_TYPE_FIREFOX = "firefox";
        a.BROWSER_TYPE_SAFARI = "safari";
        a.BROWSER_TYPE_CHROME = "chrome";
        a.BROWSER_TYPE_LIEBAO = "liebao";
        a.BROWSER_TYPE_QZONE = "qzone";
        a.BROWSER_TYPE_SOUGOU = "sogou";
        a.BROWSER_TYPE_UNKNOWN = "unknown";
        a.isNative = !1;
        var b = window,
            c = b.navigator,
            d = document,
            e = d.documentElement,
            h = c.userAgent.toLowerCase();
        a.isMobile = -1 !== h.indexOf("mobile") || -1 !== h.indexOf("android");
        a.platform = a.isMobile ? a.MOBILE_BROWSER : a.DESKTOP_BROWSER;
        var k = c.language,
            k = (k = k ? k : c.browserLanguage) ? k.split("-")[0] : a.LANGUAGE_ENGLISH;
        a.language = k;
        var k =
            h.match(/(iPad|iPhone|iPod)/i) ? !0 : !1,
            m = h.match(/android/i) || c.platform.match(/android/i) ? !0 : !1,
            A = a.OS_UNKNOWN; - 1 !== c.appVersion.indexOf("Win") ? A = a.OS_WINDOWS : k ? A = a.OS_IOS : -1 !== c.appVersion.indexOf("Mac") ? A = a.OS_OSX : -1 !== c.appVersion.indexOf("X11") && -1 === c.appVersion.indexOf("Linux") ? A = a.OS_UNIX : m ? A = a.OS_ANDROID : -1 !== c.appVersion.indexOf("Linux") && (A = a.OS_LINUX);
        a.os = A;
        a.browserType = a.BROWSER_TYPE_UNKNOWN;
        (function() {
            var b = /qqbrowser|chrome|safari|firefox|opr|oupeng|opera/i,
                c = /sogou|qzone|liebao|micromessenger|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|trident|miuibrowser/i.exec(h);
            c || (c = b.exec(h));
            b = c ? c[0] : a.BROWSER_TYPE_UNKNOWN;
            "micromessenger" === b ? b = a.BROWSER_TYPE_WECHAT : "safari" === b && h.match(/android.*applewebkit/) ? b = a.BROWSER_TYPE_ANDROID : "trident" === b ? b = a.BROWSER_TYPE_IE : "360 aphone" === b ? b = a.BROWSER_TYPE_360 : "mxbrowser" === b ? b = a.BROWSER_TYPE_MAXTHON : "opr" === b && (b = a.BROWSER_TYPE_OPERA);
            a.browserType = b
        })();
        a.browserVersion = "";
        (function() {
            var b = /(msie |rv:|firefox|chrome|ucbrowser|qq|oupeng|opera|opr|safari|miui)(mobile)?(browser)?\/?([\d.]+)/i,
                c = h.match(/(micromessenger|mx|maxthon|baidu|sogou)(mobile)?(browser)?\/?([\d.]+)/i);
            c || (c = h.match(b));
            a.browserVersion = c ? c[4] : ""
        })();
        k = window.devicePixelRatio || 1;
        a.windowPixelResolution = {
            width: k * (window.innerWidth || document.documentElement.clientWidth),
            height: k * (window.innerHeight || document.documentElement.clientHeight)
        };
        a._checkWebGLRenderMode = function() {
            if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL) throw Error("This feature supports WebGL render mode only.");
        };
        a._supportCanvasNewBlendModes = function() {
            f.width = 1;
            f.height = 1;
            var a = f.getContext("2d");
            a.fillStyle = "#000";
            a.fillRect(0,
                0, 1, 1);
            a.globalCompositeOperation = "multiply";
            g.width = 1;
            g.height = 1;
            var b = g.getContext("2d");
            b.fillStyle = "#fff";
            b.fillRect(0, 0, 1, 1);
            a.drawImage(g, 0, 0, 1, 1);
            return 0 === a.getImageData(0, 0, 1, 1).data[0]
        }();
        cc.sys.isMobile && (k = document.createElement("style"), k.type = "text/css", document.body.appendChild(k), k.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}");
        try {
            var C = a.localStorage = b.localStorage;
            C.setItem("storage", "");
            C.removeItem("storage");
            C = null
        } catch (E) {
            C = function() {
                cc.warn("Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option")
            }, a.localStorage = {
                getItem: C,
                setItem: C,
                removeItem: C,
                clear: C
            }
        }
        C = !!f.getContext("2d");
        k = !1;
        if (b.WebGLRenderingContext) {
            m = document.createElement("CANVAS");
            try {
                if (cc.create3DContext(m, {
                        stencil: !0
                    }) && (k = !0), k && a.os === a.OS_ANDROID) {
                    var x = parseFloat(a.browserVersion);
                    switch (a.browserType) {
                        case a.BROWSER_TYPE_MOBILE_QQ:
                        case a.BROWSER_TYPE_BAIDU:
                        case a.BROWSER_TYPE_BAIDU_APP:
                            k =
                                6.2 <= x ? !0 : !1;
                            break;
                        case a.BROWSER_TYPE_CHROME:
                            k = 30 <= x ? !0 : !1;
                            break;
                        case a.BROWSER_TYPE_ANDROID:
                            a.osMainVersion && 5 <= a.osMainVersion && (k = !0);
                            break;
                        case a.BROWSER_TYPE_UNKNOWN:
                        case a.BROWSER_TYPE_360:
                        case a.BROWSER_TYPE_MIUI:
                        case a.BROWSER_TYPE_UC:
                            k = !1
                    }
                }
            } catch (B) {}
            m = null
        }
        x = a.capabilities = {
            canvas: C,
            opengl: k
        };
        if (void 0 !== e.ontouchstart || void 0 !== d.ontouchstart || c.msPointerEnabled) x.touches = !0;
        void 0 !== e.onmouseup && (x.mouse = !0);
        void 0 !== e.onkeyup && (x.keyboard = !0);
        if (b.DeviceMotionEvent || b.DeviceOrientationEvent) x.accelerometer = !0;
        a.garbageCollect = function() {};
        a.dumpRoot = function() {};
        a.restartVM = function() {};
        a.cleanScript = function(a) {};
        a.isObjectValid = function(a) {
            return a ? !0 : !1
        };
        a.dump = function() {
            var a;
            a = "" + ("isMobile : " + this.isMobile + "\r\n");
            a += "language : " + this.language + "\r\n";
            a += "browserType : " + this.browserType + "\r\n";
            a += "capabilities : " + JSON.stringify(this.capabilities) + "\r\n";
            a += "os : " + this.os + "\r\n";
            a += "platform : " + this.platform + "\r\n";
            cc.log(a)
        };
        a.openURL = function(a) {
            window.open(a)
        }
    })();
    delete f;
    delete g;
    cc.log =
        cc.warn = cc.error = cc.assert = function() {};
    var h = {},
        k = !1,
        m = null;
    cc._engineLoaded = !1;
    cc.initEngine = function(b, c) {
        if (k) {
            var f = m;
            m = function() {
                f && f();
                c && c()
            }
        } else m = c, !cc.game.config && b ? cc.game.config = b : cc.game.config || cc.game._loadConfig(), b = cc.game.config, a(b), document.body ? d(b) : cc._addEventListener(window, "load", e, !1), k = !0
    }
})();
cc.game = {
    DEBUG_MODE_NONE: 0,
    DEBUG_MODE_INFO: 1,
    DEBUG_MODE_WARN: 2,
    DEBUG_MODE_ERROR: 3,
    DEBUG_MODE_INFO_FOR_WEB_PAGE: 4,
    DEBUG_MODE_WARN_FOR_WEB_PAGE: 5,
    DEBUG_MODE_ERROR_FOR_WEB_PAGE: 6,
    EVENT_HIDE: "game_on_hide",
    EVENT_SHOW: "game_on_show",
    EVENT_RESIZE: "game_on_resize",
    EVENT_RENDERER_INITED: "renderer_inited",
    RENDER_TYPE_CANVAS: 0,
    RENDER_TYPE_WEBGL: 1,
    RENDER_TYPE_OPENGL: 2,
    _eventHide: null,
    _eventShow: null,
    CONFIG_KEY: {
        width: "width",
        height: "height",
        engineDir: "engineDir",
        modules: "modules",
        debugMode: "debugMode",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        jsList: "jsList"
    },
    _paused: !0,
    _prepareCalled: !1,
    _prepared: !1,
    _rendererInitialized: !1,
    _renderContext: null,
    _intervalId: null,
    _lastTime: null,
    _frameTime: null,
    frame: null,
    container: null,
    canvas: null,
    config: null,
    onStart: null,
    onStop: null,
    bhide: !1,
    bhidetimeout: !1,
    _oldmusicvolume: 0,
    _oldeffectvolume: 0,
    setFrameRate: function(a) {
        this.config[this.CONFIG_KEY.frameRate] = a;
        this._intervalId && window.cancelAnimationFrame(this._intervalId);
        this._paused = !0;
        this._setAnimFrame();
        this._runMainLoop()
    },
    step: function() {
        cc.director.mainLoop()
    },
    pause: function() {
        this._paused || (this._paused = !0, cc.audioEngine && cc.audioEngine._pausePlaying(), this._intervalId && window.cancelAnimationFrame(this._intervalId), this._intervalId = 0)
    },
    resume: function() {
        this._paused && (this._paused = !1, cc.audioEngine && cc.audioEngine._resumePlaying(), this._runMainLoop())
    },
    isPaused: function() {
        return this._paused
    },
    restart: function() {
        cc.director.popToSceneStackLevel(0);
        cc.audioEngine && cc.audioEngine.end();
        cc.game.onStart()
    },
    prepare: function(a) {
        var b = this,
            c = b.config,
            d = b.CONFIG_KEY;
        this._loadConfig();
        this._prepared ? a && a() : this._prepareCalled || (cc._engineLoaded ? (this._prepareCalled = !0, this._initRenderer(c[d.width], c[d.height]), cc.view = cc.EGLView._getInstance(), cc.director = cc.Director._getInstance(), cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view), cc.winSize = cc.director.getWinSize(), this._initEvents(), this._setAnimFrame(), this._runMainLoop(), (c = c[d.jsList]) ? cc.loader.loadJsWithImg(c, function(c) {
            if (c) throw Error(c);
            b._prepared = !0;
            a && a()
        }) : a && a()) : cc.initEngine(this.config, function() {
            b.prepare(a)
        }))
    },
    run: function(a, b) {
        "function" === typeof a ? cc.game.onStart = a : (a && (cc.game.config = a), "function" === typeof b && (cc.game.onStart = b));
        this.prepare(cc.game.onStart && cc.game.onStart.bind(cc.game))
    },
    _setAnimFrame: function() {
        this._lastTime = new Date;
        this._frameTime = 1E3 / cc.game.config[cc.game.CONFIG_KEY.frameRate];
        cc.sys.os === cc.sys.OS_IOS && cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT || 60 !== cc.game.config[cc.game.CONFIG_KEY.frameRate] ?
            (window.requestAnimFrame = this._stTime, window.cancelAnimationFrame = this._ctTime) : (window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime, window.cancelAnimationFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame ||
                window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime)
    },
    _stTime: function(a) {
        var b = (new Date).getTime(),
            c = Math.max(0, cc.game._frameTime - (b - cc.game._lastTime)),
            d = window.setTimeout(function() {
                a()
            }, c);
        cc.game._lastTime = b + c;
        return d
    },
    _ctTime: function(a) {
        window.clearTimeout(a)
    },
    _runMainLoop: function() {
        var a = this,
            b, c = cc.director;
        c.setDisplayStats(a.config[a.CONFIG_KEY.showFPS]);
        b = function() {
            a._paused || (c.mainLoop(), a._intervalId &&
                window.cancelAnimationFrame(a._intervalId), a._intervalId = window.requestAnimFrame(b))
        };
        window.requestAnimFrame(b);
        a._paused = !1
    },
    hideGame: function() {
        var a = this,
            b, c = cc.director;
        b = function() {
            a.bhidetimeout = !1;
            !a._paused && a.bhide && (c.mainLoop(), window.setTimeout(b, 250), a.bhidetimeout = !0)
        };
        a.bhidetimeout || (window.setTimeout(b, 250), a.bhidetimeout = !0);
        a.bhide = !0;
        a._oldmusicvolume = cc.audioEngine.getMusicVolume();
        a._oldeffectvolume = cc.audioEngine.getEffectsVolume();
        cc.audioEngine.setMusicVolume(0);
        cc.audioEngine.setEffectsVolume(0)
    },
    showGame: function() {
        this.bhide && (this.bhide = !1, cc.audioEngine.setMusicVolume(this._oldmusicvolume), cc.audioEngine.setEffectsVolume(this._oldeffectvolume))
    },
    _loadConfig: function() {
        if (this.config) this._initConfig(this.config);
        else if (document.ccConfig) this._initConfig(document.ccConfig);
        else try {
            for (var a = document.getElementsByTagName("script"), b = 0; b < a.length; b++) {
                var c = a[b].getAttribute("cocos");
                if ("" === c || c) break
            }
            var d, e, f;
            if (b < a.length) {
                if (d = a[b].src) f = /(.*)\//.exec(d)[0], cc.loader.resPath = f, d = cc.path.join(f,
                    "project.json");
                e = cc.loader._loadTxtSync(d)
            }
            e || (e = cc.loader._loadTxtSync("project.json"));
            var g = JSON.parse(e);
            this._initConfig(g || {})
        } catch (h) {
            cc.log("Failed to read or parse project.json"), this._initConfig({})
        }
    },
    _initConfig: function(a) {
        var b = this.CONFIG_KEY,
            c = a[b.modules];
        a[b.showFPS] = "undefined" === typeof a[b.showFPS] ? !0 : a[b.showFPS];
        a[b.engineDir] = a[b.engineDir] || "frameworks/cocos2d-html5";
        null == a[b.debugMode] && (a[b.debugMode] = 0);
        a[b.frameRate] = a[b.frameRate] || 60;
        null == a[b.renderMode] && (a[b.renderMode] =
            0);
        null == a[b.registerSystemEvent] && (a[b.registerSystemEvent] = !0);
        c && 0 > c.indexOf("core") && c.splice(0, 0, "core");
        c && (a[b.modules] = c);
        this.config = a
    },
    _initRenderer: function(a, b) {
        if (!this._rendererInitialized) {
            if (!cc._supportRender) throw Error("The renderer doesn't support the renderMode " + this.config[this.CONFIG_KEY.renderMode]);
            var c = this.config[cc.game.CONFIG_KEY.id],
                d = window,
                e = cc.$(c) || cc.$("#" + c),
                f;
            "CANVAS" === e.tagName ? (a = a || e.width, b = b || e.height, this.canvas = cc._canvas = c = e, this.container = cc.container =
                f = document.createElement("DIV"), c.parentNode && c.parentNode.insertBefore(f, c)) : ("DIV" !== e.tagName && cc.log("Warning: target element is not a DIV or CANVAS"), a = a || e.clientWidth, b = b || e.clientHeight, this.canvas = cc._canvas = c = document.createElement("CANVAS"), this.container = cc.container = f = document.createElement("DIV"), e.appendChild(f));
            f.setAttribute("id", "Cocos2dGameContainer");
            f.appendChild(c);
            this.frame = f.parentNode === document.body ? document.documentElement : f.parentNode;
            c.addClass("gameCanvas");
            c.setAttribute("width",
                a || 480);
            c.setAttribute("height", b || 320);
            c.setAttribute("tabindex", 99);
            c.style.outline = "none";
            e = f.style;
            e.width = (a || 480) + "px";
            e.height = (b || 320) + "px";
            e.margin = "0 auto";
            e.position = "relative";
            e.overflow = "hidden";
            f.top = "100%";
            cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this._renderContext = cc._renderContext = cc.webglContext = cc.create3DContext(c, {
                stencil: !0,
                preserveDrawingBuffer: !0,
                antialias: !cc.sys.isMobile,
                alpha: !0
            }));
            this._renderContext ? (cc.renderer = cc.rendererWebGL, d.gl = this._renderContext, cc.shaderCache._init(),
                cc._drawingUtil = new cc.DrawingPrimitiveWebGL(this._renderContext), cc.textureCache._initializingRenderer()) : (cc.renderer = cc.rendererCanvas, this._renderContext = cc._renderContext = new cc.CanvasContextWrapper(c.getContext("2d")), cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(this._renderContext) : null);
            cc._gameDiv = f;
            cc.game.canvas.oncontextmenu = function() {
                if (!cc._isContextMenuEnable) return !1
            };
            this.dispatchEvent(this.EVENT_RENDERER_INITED, !0);
            this._rendererInitialized = !0
        }
    },
    _initEvents: function() {
        var a =
            window,
            b, c;
        this._eventHide = this._eventHide || new cc.EventCustom(this.EVENT_HIDE);
        this._eventHide.setUserData(this);
        this._eventShow = this._eventShow || new cc.EventCustom(this.EVENT_SHOW);
        this._eventShow.setUserData(this);
        this.config[this.CONFIG_KEY.registerSystemEvent] && cc.inputManager.registerSystemEvent(this.canvas);
        cc.isUndefined(document.hidden) ? cc.isUndefined(document.mozHidden) ? cc.isUndefined(document.msHidden) ? cc.isUndefined(document.webkitHidden) || (b = "webkitHidden", c = "webkitvisibilitychange") :
            (b = "msHidden", c = "msvisibilitychange") : (b = "mozHidden", c = "mozvisibilitychange") : (b = "hidden", c = "visibilitychange");
        var d = function() {
                cc.eventManager && cc.game._eventHide && cc.eventManager.dispatchEvent(cc.game._eventHide)
            },
            e = function() {
                cc.eventManager && cc.game._eventShow && cc.eventManager.dispatchEvent(cc.game._eventShow)
            };
        b ? document.addEventListener(c, function() {
            document[b] ? d() : e()
        }, !1) : (a.addEventListener("blur", d, !1), a.addEventListener("focus", e, !1)); - 1 < navigator.userAgent.indexOf("MicroMessenger") &&
            (a.onfocus = function() {
                e()
            });
        "onpageshow" in window && "onpagehide" in window && (a.addEventListener("pagehide", d, !1), a.addEventListener("pageshow", e, !1));
        cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
            cc.game.hideGame()
        });
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            cc.game.showGame()
        })
    }
};
Function.prototype.bind = Function.prototype.bind || function(a) {
    if (!cc.isFunction(this)) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    var b = Array.prototype.slice.call(arguments, 1),
        c = this,
        d = function() {},
        e = function() {
            return c.apply(this instanceof d && a ? this : a, b.concat(Array.prototype.slice.call(arguments)))
        };
    d.prototype = this.prototype;
    e.prototype = new d;
    return e
};
cc._urlRegExp = RegExp("^(?:(?:https?|ftp)://)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))|(?:localhost))(?::\\d{2,5})?(?:/\\S*)?$", "i");
cc.EventHelper = function() {};
cc.EventHelper.prototype = {
    constructor: cc.EventHelper,
    apply: function(a) {
        a.addEventListener = cc.EventHelper.prototype.addEventListener;
        a.hasEventListener = cc.EventHelper.prototype.hasEventListener;
        a.removeEventListener = cc.EventHelper.prototype.removeEventListener;
        a.dispatchEvent = cc.EventHelper.prototype.dispatchEvent
    },
    addEventListener: function(a, b, c) {
        if ("load" === a && this._textureLoaded) setTimeout(function() {
            b.call(c)
        }, 0);
        else {
            void 0 === this._listeners && (this._listeners = {});
            var d = this._listeners;
            void 0 ===
                d[a] && (d[a] = []);
            this.hasEventListener(a, b, c) || d[a].push({
                callback: b,
                eventTarget: c
            })
        }
    },
    hasEventListener: function(a, b, c) {
        if (void 0 === this._listeners) return !1;
        var d = this._listeners;
        if (void 0 !== d[a]) {
            a = 0;
            for (var e = d.length; a < e; a++) {
                var f = d[a];
                if (f.callback === b && f.eventTarget === c) return !0
            }
        }
        return !1
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners[a];
            if (void 0 !== c)
                for (var d = 0; d < c.length;) c[d].eventTarget === b ? c.splice(d, 1) : d++
        }
    },
    dispatchEvent: function(a, b) {
        if (void 0 !==
            this._listeners) {
            null == b && (b = !0);
            var c = this._listeners[a];
            if (void 0 !== c) {
                for (var d = [], e = c.length, f = 0; f < e; f++) d[f] = c[f];
                for (f = 0; f < e; f++) d[f].callback.call(d[f].eventTarget, this);
                b && (c.length = 0)
            }
        }
    }
};
cc.EventHelper.prototype.apply(cc.game);
cc._LogInfos = {
    ActionManager_addAction: "cc.ActionManager.addAction(): action must be non-null",
    ActionManager_removeAction: "cocos2d: removeAction: Target not found",
    ActionManager_removeActionByTag: "cc.ActionManager.removeActionByTag(): an invalid tag",
    ActionManager_removeActionByTag_2: "cc.ActionManager.removeActionByTag(): target must be non-null",
    ActionManager_getActionByTag: "cc.ActionManager.getActionByTag(): an invalid tag",
    ActionManager_getActionByTag_2: "cocos2d : getActionByTag(tag \x3d %s): Action not found",
    configuration_dumpInfo: "cocos2d: **** WARNING **** CC_ENABLE_PROFILERS is defined. Disable it when you finish profiling (from ccConfig.js)",
    configuration_loadConfigFile: "Expected 'data' dict, but not found. Config file: %s",
    configuration_loadConfigFile_2: "Please load the resource first : %s",
    Director_resume: "cocos2d: Director: Error in gettimeofday",
    Director_setProjection: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel: "cocos2d: Director: unrecognized projection",
    Director_popToSceneStackLevel_2: "cocos2d: Director: Error in gettimeofday",
    Director_popScene: "running scene should not null",
    Director_pushScene: "the scene should not null",
    arrayVerifyType: "element type is wrong!",
    Scheduler_scheduleCallbackForTarget: "CCSheduler#scheduleCallback. Callback already scheduled. Updating interval from:%s to %s",
    Scheduler_scheduleCallbackForTarget_2: "cc.scheduler.scheduleCallbackForTarget(): callback_fn should be non-null.",
    Scheduler_scheduleCallbackForTarget_3: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
    Scheduler_pauseTarget: "cc.Scheduler.pauseTarget():target should be non-null",
    Scheduler_resumeTarget: "cc.Scheduler.resumeTarget():target should be non-null",
    Scheduler_isTargetPaused: "cc.Scheduler.isTargetPaused():target should be non-null",
    Node_getZOrder: "getZOrder is deprecated. Please use getLocalZOrder instead.",
    Node_setZOrder: "setZOrder is deprecated. Please use setLocalZOrder instead.",
    Node_getRotation: "RotationX !\x3d RotationY. Don't know which one to return",
    Node_getScale: "ScaleX !\x3d ScaleY. Don't know which one to return",
    Node_addChild: "An Node can't be added as a child of itself.",
    Node_addChild_2: "child already added. It can't be added again",
    Node_addChild_3: "child must be non-null",
    Node_removeFromParentAndCleanup: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
    Node_boundingBox: "boundingBox is deprecated. Use getBoundingBox instead",
    Node_removeChildByTag: "argument tag is an invalid tag",
    Node_removeChildByTag_2: "cocos2d: removeChildByTag(tag \x3d %s): child not found!",
    Node_removeAllChildrenWithCleanup: "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
    Node_stopActionByTag: "cc.Node.stopActionBy(): argument tag an invalid tag",
    Node_getActionByTag: "cc.Node.getActionByTag(): argument tag is an invalid tag",
    Node_resumeSchedulerAndActions: "resumeSchedulerAndActions is deprecated, please use resume instead.",
    Node_pauseSchedulerAndActions: "pauseSchedulerAndActions is deprecated, please use pause instead.",
    Node__arrayMakeObjectsPerformSelector: "Unknown callback function",
    Node_reorderChild: "child must be non-null",
    Node_runAction: "cc.Node.runAction(): action must be non-null",
    Node_schedule: "callback function must be non-null",
    Node_schedule_2: "interval must be positive",
    Node_initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    AtlasNode_updateAtlasValues: "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
    AtlasNode_initWithTileFile: "",
    AtlasNode__initWithTexture: "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
    _EventListenerKeyboard_checkAvailable: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
    _EventListenerTouchOneByOne_checkAvailable: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
    _EventListenerTouchAllAtOnce_checkAvailable: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
    _EventListenerAcceleration_checkAvailable: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
    EventListener_create: "Invalid parameter.",
    __getListenerID: "Don't call this method if the event is for touch.",
    eventManager__forceAddEventListener: "Invalid scene graph priority!",
    eventManager_addListener: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
    eventManager_removeListeners: "Invalid listener type!",
    eventManager_setPriority: "Can't set fixed priority with scene graph based listener.",
    eventManager_addListener_2: "Invalid parameters.",
    eventManager_addListener_3: "listener must be a cc.EventListener object when adding a fixed priority listener",
    eventManager_addListener_4: "The listener has been registered, please don't register it again.",
    LayerMultiplex_initWithLayers: "parameters should not be ending with null in Javascript",
    LayerMultiplex_switchTo: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_switchToAndReleaseMe: "Invalid index in MultiplexLayer switchTo message",
    LayerMultiplex_addLayer: "cc.Layer.addLayer(): layer should be non-null",
    EGLView_setDesignResolutionSize: "Resolution not valid",
    EGLView_setDesignResolutionSize_2: "should set resolutionPolicy",
    inputManager_handleTouchesBegin: "The touches is more than MAX_TOUCHES, nUnusedIndex \x3d %s",
    swap: "cc.swap is being modified from original macro, please check usage",
    checkGLErrorDebug: "WebGL error %s",
    animationCache__addAnimationsWithDictionary: "cocos2d: cc.AnimationCache: No animations were found in provided dictionary.",
    animationCache__addAnimationsWithDictionary_2: "cc.AnimationCache. Invalid animation format",
    animationCache_addAnimations: "cc.AnimationCache.addAnimations(): File could not be found",
    animationCache__parseVersion1: "cocos2d: cc.AnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion1_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache__parseVersion1_3: "cocos2d: cc.AnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
    animationCache__parseVersion1_4: "cocos2d: cc.AnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
    animationCache__parseVersion2: "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
    animationCache__parseVersion2_2: "cocos2d: cc.AnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
    animationCache_addAnimations_2: "cc.AnimationCache.addAnimations(): Invalid texture file name",
    Sprite_reorderChild: "cc.Sprite.reorderChild(): this child is not in children list",
    Sprite_ignoreAnchorPointForPosition: "cc.Sprite.ignoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
    Sprite_setDisplayFrameWithAnimationName: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
    Sprite_setDisplayFrameWithAnimationName_2: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
    Sprite_setDisplayFrame: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
    Sprite__updateBlendFunc: "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
    Sprite_initWithSpriteFrame: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
    Sprite_initWithSpriteFrameName: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
    Sprite_initWithSpriteFrameName1: " is null, please check.",
    Sprite_initWithFile: "cc.Sprite.initWithFile(): filename should be non-null",
    Sprite_setDisplayFrameWithAnimationName_3: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
    Sprite_reorderChild_2: "cc.Sprite.reorderChild(): child should be non-null",
    Sprite_addChild: "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
    Sprite_addChild_2: "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
    Sprite_addChild_3: "cc.Sprite.addChild(): child should be non-null",
    Sprite_setTexture: "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
    Sprite_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_4: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    Sprite_addChild_5: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
    Sprite_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    Sprite_setSpriteFrame: "Invalid spriteFrameName",
    Sprite_setTexture_2: "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
    Sprite_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    Sprite_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    SpriteBatchNode_addSpriteWithoutQuad: "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
    SpriteBatchNode_increaseAtlasCapacity: "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
    SpriteBatchNode_increaseAtlasCapacity_2: "cocos2d: WARNING: Not enough memory to resize the atlas",
    SpriteBatchNode_reorderChild: "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
    SpriteBatchNode_removeChild: "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
    SpriteBatchNode_addSpriteWithoutQuad_2: "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
    SpriteBatchNode_reorderChild_2: "cc.SpriteBatchNode.addChild(): child should be non-null",
    spriteFrameCache__getFrameConfig: "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
    spriteFrameCache_addSpriteFrames: "cocos2d: WARNING: an alias with name %s already exists",
    spriteFrameCache__checkConflict: "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
    spriteFrameCache_getSpriteFrame: "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
    spriteFrameCache__getFrameConfig_2: "Please load the resource first : %s",
    spriteFrameCache_addSpriteFrames_2: "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
    spriteFrameCache_addSpriteFrames_3: "Argument must be non-nil",
    CCSpriteBatchNode_updateQuadFromSprite: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_insertQuadFromSprite: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_addChild: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
    CCSpriteBatchNode_initWithTexture: "Sprite.initWithTexture(): Argument must be non-nil ",
    CCSpriteBatchNode_addChild_2: "cc.Sprite.addChild(): child should be non-null",
    CCSpriteBatchNode_setSpriteFrame: "Invalid spriteFrameName",
    CCSpriteBatchNode_setTexture: "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
    CCSpriteBatchNode_updateQuadFromSprite_2: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_insertQuadFromSprite_2: "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
    CCSpriteBatchNode_addChild_3: "cc.SpriteBatchNode.addChild(): child should be non-null",
    TextureAtlas_initWithFile: "cocos2d: Could not open file: %s",
    TextureAtlas_insertQuad: "cc.TextureAtlas.insertQuad(): invalid totalQuads",
    TextureAtlas_initWithTexture: "cc.TextureAtlas.initWithTexture():texture should be non-null",
    TextureAtlas_updateQuad: "cc.TextureAtlas.updateQuad(): quad should be non-null",
    TextureAtlas_updateQuad_2: "cc.TextureAtlas.updateQuad(): Invalid index",
    TextureAtlas_insertQuad_2: "cc.TextureAtlas.insertQuad(): Invalid index",
    TextureAtlas_insertQuads: "cc.TextureAtlas.insertQuad(): Invalid index + amount",
    TextureAtlas_insertQuadFromIndex: "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
    TextureAtlas_insertQuadFromIndex_2: "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
    TextureAtlas_removeQuadAtIndex: "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
    TextureAtlas_removeQuadsAtIndex: "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
    TextureAtlas_moveQuadsFromIndex: "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
    TextureAtlas_moveQuadsFromIndex_2: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
    TextureAtlas_moveQuadsFromIndex_3: "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
    textureCache_addPVRTCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_addETCImage: "TextureCache:addPVRTCImage does not support on HTML5",
    textureCache_textureForKey: "textureForKey is deprecated. Please use getTextureForKey instead.",
    textureCache_addPVRImage: "addPVRImage does not support on HTML5",
    textureCache_addUIImage: "cocos2d: Couldn't add UIImage in TextureCache",
    textureCache_dumpCachedTextureInfo: "cocos2d: '%s' id\x3d%s %s x %s",
    textureCache_dumpCachedTextureInfo_2: "cocos2d: '%s' id\x3d HTMLCanvasElement %s x %s",
    textureCache_dumpCachedTextureInfo_3: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
    textureCache_addUIImage_2: "cc.Texture.addUIImage(): image should be non-null",
    Texture2D_initWithETCFile: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData: "initWithPVRTCData does not support on HTML5",
    Texture2D_addImage: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithImage: "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
    Texture2D_initWithImage_2: "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
    Texture2D_initWithString: "initWithString isn't supported on cocos2d-html5",
    Texture2D_initWithETCFile_2: "initWithETCFile does not support on HTML5",
    Texture2D_initWithPVRFile_2: "initWithPVRFile does not support on HTML5",
    Texture2D_initWithPVRTCData_2: "initWithPVRTCData does not support on HTML5",
    Texture2D_bitsPerPixelForFormat: "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
    Texture2D__initPremultipliedATextureWithImage: "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
    Texture2D_addImage_2: "cc.Texture.addImage(): path should be non-null",
    Texture2D_initWithData: "NSInternalInconsistencyException",
    MissingFile: "Missing file: %s",
    radiansToDegress: "cc.radiansToDegress() should be called cc.radiansToDegrees()",
    RectWidth: "Rect width exceeds maximum margin: %s",
    RectHeight: "Rect height exceeds maximum margin: %s",
    EventManager__updateListeners: "If program goes here, there should be event in dispatch.",
    EventManager__updateListeners_2: "_inDispatch should be 1 here."
};
cc._logToWebPage = function(a) {
    if (cc._canvas) {
        var b = cc._logList,
            c = document;
        if (!b) {
            var d = c.createElement("Div"),
                b = d.style;
            d.setAttribute("id", "logInfoDiv");
            cc._canvas.parentNode.appendChild(d);
            d.setAttribute("width", "200");
            d.setAttribute("height", cc._canvas.height);
            b.zIndex = "99999";
            b.position = "absolute";
            b.top = "0";
            b.left = "0";
            b = cc._logList = c.createElement("textarea");
            c = b.style;
            b.setAttribute("rows", "20");
            b.setAttribute("cols", "30");
            b.setAttribute("disabled", !0);
            d.appendChild(b);
            c.backgroundColor = "transparent";
            c.borderBottom = "1px solid #cccccc";
            c.borderRightWidth = "0px";
            c.borderLeftWidth = "0px";
            c.borderTopWidth = "0px";
            c.borderTopStyle = "none";
            c.borderRightStyle = "none";
            c.borderLeftStyle = "none";
            c.padding = "0px";
            c.margin = 0
        }
        b.value = b.value + a + "\r\n";
        b.scrollTop = b.scrollHeight
    }
};
cc._formatString = function(a) {
    if (cc.isObject(a)) try {
        return JSON.stringify(a)
    } catch (b) {
        return ""
    } else return a
};
cc._initDebugSetting = function(a) {
    var b = cc.game;
    if (a !== b.DEBUG_MODE_NONE) {
        var c;
        a > b.DEBUG_MODE_ERROR ? (c = cc._logToWebPage.bind(cc), cc.error = function() {
            c("ERROR :  " + cc.formatStr.apply(cc, arguments))
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var f = 2; f < arguments.length; f++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[f]));
                c("Assert: " + b)
            }
        }, a !== b.DEBUG_MODE_ERROR_FOR_WEB_PAGE && (cc.warn = function() {
            c("WARN :  " + cc.formatStr.apply(cc, arguments))
        }), a === b.DEBUG_MODE_INFO_FOR_WEB_PAGE && (cc.log = function() {
            c(cc.formatStr.apply(cc,
                arguments))
        })) : console && console.log.apply && (cc.error = function() {
            return console.error.apply(console, arguments)
        }, cc.assert = function(a, b) {
            if (!a && b) {
                for (var c = 2; c < arguments.length; c++) b = b.replace(/(%s)|(%d)/, cc._formatString(arguments[c]));
                throw Error(b);
            }
        }, a !== b.DEBUG_MODE_ERROR && (cc.warn = function() {
            return console.warn.apply(console, arguments)
        }), a === b.DEBUG_MODE_INFO && (cc.log = function() {
            return console.log.apply(console, arguments)
        }))
    }
};
cc.loader.loadBinary = function(a, b) {
    var c = this,
        d = this.getXMLHttpRequest(),
        e = "load " + a + " failed!";
    d.open("GET", a, !0);
    cc.loader.loadBinary._IEFilter ? (d.setRequestHeader("Accept-Charset", "x-user-defined"), d.onreadystatechange = function() {
        if (4 === d.readyState && 200 === d.status) {
            var a = cc._convertResponseBodyToText(d.responseBody);
            b(null, c._str2Uint8Array(a))
        } else b(e)
    }) : (d.overrideMimeType && d.overrideMimeType("text/plain; charset\x3dx-user-defined"), d.onload = function() {
        4 === d.readyState && 200 === d.status ? b(null,
            c._str2Uint8Array(d.responseText)) : b(e)
    });
    d.send(null)
};
cc.loader.loadBinary._IEFilter = /msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent) && window.IEBinaryToArray_ByteStr && window.IEBinaryToArray_ByteStr_Last;
cc.loader._str2Uint8Array = function(a) {
    if (!a) return null;
    for (var b = new Uint8Array(a.length), c = 0; c < a.length; c++) b[c] = a.charCodeAt(c) & 255;
    return b
};
cc.loader.loadBinarySync = function(a) {
    var b = this.getXMLHttpRequest(),
        c = "load " + a + " failed!";
    b.open("GET", a, !1);
    a = null;
    if (cc.loader.loadBinary._IEFilter) {
        b.setRequestHeader("Accept-Charset", "x-user-defined");
        b.send(null);
        if (200 !== b.status) return cc.log(c), null;
        (b = cc._convertResponseBodyToText(b.responseBody)) && (a = this._str2Uint8Array(b))
    } else {
        b.overrideMimeType && b.overrideMimeType("text/plain; charset\x3dx-user-defined");
        b.send(null);
        if (200 !== b.status) return cc.log(c), null;
        a = this._str2Uint8Array(b.responseText)
    }
    return a
};
window.Uint8Array = window.Uint8Array || window.Array;
if (cc.loader.loadBinary._IEFilter) {
    var IEBinaryToArray_ByteStr_Script = '\x3c!-- IEBinaryToArray_ByteStr --\x3e\r\nFunction IEBinaryToArray_ByteStr(Binary)\r\n   IEBinaryToArray_ByteStr \x3d CStr(Binary)\r\nEnd Function\r\nFunction IEBinaryToArray_ByteStr_Last(Binary)\r\n   Dim lastIndex\r\n   lastIndex \x3d LenB(Binary)\r\n   if lastIndex mod 2 Then\r\n       IEBinaryToArray_ByteStr_Last \x3d Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n   Else\r\n       IEBinaryToArray_ByteStr_Last \x3d ""\r\n   End If\r\nEnd Function\r\n',
        myVBScript =
        document.createElement("script");
    myVBScript.type = "text/vbscript";
    myVBScript.textContent = IEBinaryToArray_ByteStr_Script;
    document.body.appendChild(myVBScript);
    cc._convertResponseBodyToText = function(a) {
        for (var b = {}, c = 0; 256 > c; c++)
            for (var d = 0; 256 > d; d++) b[String.fromCharCode(c + 256 * d)] = String.fromCharCode(c) + String.fromCharCode(d);
        c = IEBinaryToArray_ByteStr(a);
        a = IEBinaryToArray_ByteStr_Last(a);
        return c.replace(/[\s\S]/g, function(a) {
            return b[a]
        }) + a
    }
};
cc = cc || {};
cc._loadingImage = "data:image/gif;base64,R0lGODlhEAAQALMNAD8/P7+/vyoqKlVVVX9/fxUVFUBAQGBgYMDAwC8vL5CQkP///wAAAP///wAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQFAAANACwAAAAAEAAQAAAEO5DJSau9OOvNex0IMnDIsiCkiW6g6BmKYlBFkhSUEgQKlQCARG6nEBwOgl+QApMdCIRD7YZ5RjlGpCUCACH5BAUAAA0ALAAAAgAOAA4AAAQ6kLGB0JA4M7QW0hrngRllkYyhKAYqKUGguAws0ypLS8JxCLQDgXAIDg+FRKIA6v0SAECCBpXSkstMBAAh+QQFAAANACwAAAAACgAQAAAEOJDJORAac6K1kDSKYmydpASBUl0mqmRfaGTCcQgwcxDEke+9XO2WkxQSiUIuAQAkls0n7JgsWq8RACH5BAUAAA0ALAAAAAAOAA4AAAQ6kMlplDIzTxWC0oxwHALnDQgySAdBHNWFLAvCukc215JIZihVIZEogDIJACBxnCSXTcmwGK1ar1hrBAAh+QQFAAANACwAAAAAEAAKAAAEN5DJKc4RM+tDyNFTkSQF5xmKYmQJACTVpQSBwrpJNteZSGYoFWjIGCAQA2IGsVgglBOmEyoxIiMAIfkEBQAADQAsAgAAAA4ADgAABDmQSVZSKjPPBEDSGucJxyGA1XUQxAFma/tOpDlnhqIYN6MEAUXvF+zldrMBAjHoIRYLhBMqvSmZkggAIfkEBQAADQAsBgAAAAoAEAAABDeQyUmrnSWlYhMASfeFVbZdjHAcgnUQxOHCcqWylKEohqUEAYVkgEAMfkEJYrFA6HhKJsJCNFoiACH5BAUAAA0ALAIAAgAOAA4AAAQ3kMlJq704611SKloCAEk4lln3DQgyUMJxCBKyLAh1EMRR3wiDQmHY9SQslyIQUMRmlmVTIyRaIgA7";
cc._fpsImage = "data:image/png;base64,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\x3d";
cc._loaderImage = "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAlAAD/4QMpaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjAtYzA2MCA2MS4xMzQ3NzcsIDIwMTAvMDIvMTItMTc6MzI6MDAgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4MDBEMDY2QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4MDBEMDY1QTU1MjExRTFBQTAzQjEzMUNFNzMxRkQwIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzUgV2luZG93cyI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU2RTk0OEM4OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU2RTk0OEM5OERCNDExRTE5NEUyRkE3M0M3QkE1NTlEIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+/+4ADkFkb2JlAGTAAAAAAf/bAIQADQkJCQoJDQoKDRMMCwwTFhENDREW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\x3d";
var cc = cc || {},
    ClassManager = {
        id: 0 | 998 * Math.random(),
        instanceId: 0 | 998 * Math.random(),
        getNewID: function() {
            return this.id++
        },
        getNewInstanceId: function() {
            return this.instanceId++
        }
    };
(function() {
    var a = /\b_super\b/;
    cc.Class = function() {};
    cc.Class.extend = function(b) {
        function c() {
            this.__instanceId = ClassManager.getNewInstanceId();
            this.ctor && this.ctor.apply(this, arguments)
        }
        var d = this.prototype,
            e = Object.create(d),
            f = ClassManager.getNewID();
        ClassManager[f] = d;
        var g = {
            writable: !0,
            enumerable: !1,
            configurable: !0
        };
        e.__instanceId = null;
        c.id = f;
        g.value = f;
        Object.defineProperty(e, "__pid", g);
        c.prototype = e;
        g.value = c;
        Object.defineProperty(c.prototype, "constructor", g);
        this.__getters__ && (c.__getters__ =
            cc.clone(this.__getters__));
        this.__setters__ && (c.__setters__ = cc.clone(this.__setters__));
        for (var f = 0, h = arguments.length; f < h; ++f) {
            var k = arguments[f],
                m;
            for (m in k) {
                var n = "function" === typeof k[m],
                    p = "function" === typeof d[m],
                    s = a.test(k[m]);
                n && p && s ? (g.value = function(a, b) {
                    return function() {
                        var c = this._super;
                        this._super = d[a];
                        var e = b.apply(this, arguments);
                        this._super = c;
                        return e
                    }
                }(m, k[m]), Object.defineProperty(e, m, g)) : n ? (g.value = k[m], Object.defineProperty(e, m, g)) : e[m] = k[m];
                if (n) {
                    var r, u;
                    if (this.__getters__ &&
                        this.__getters__[m]) {
                        var n = this.__getters__[m],
                            t;
                        for (t in this.__setters__)
                            if (this.__setters__[t] === n) {
                                u = t;
                                break
                            }
                        cc.defineGetterSetter(e, n, k[m], k[u] ? k[u] : e[u], m, u)
                    }
                    if (this.__setters__ && this.__setters__[m]) {
                        n = this.__setters__[m];
                        for (t in this.__getters__)
                            if (this.__getters__[t] === n) {
                                r = t;
                                break
                            }
                        cc.defineGetterSetter(e, n, k[r] ? k[r] : e[r], k[m], r, m)
                    }
                }
            }
        }
        c.extend = cc.Class.extend;
        c.implement = function(a) {
            for (var b in a) e[b] = a[b]
        };
        return c
    }
})();
cc.defineGetterSetter = function(a, b, c, d, e, f) {
    if (a.__defineGetter__) c && a.__defineGetter__(b, c), d && a.__defineSetter__(b, d);
    else if (Object.defineProperty) {
        var g = {
            enumerable: !1,
            configurable: !0
        };
        c && (g.get = c);
        d && (g.set = d);
        Object.defineProperty(a, b, g)
    } else throw Error("browser does not support getters");
    if (!e && !f)
        for (var g = null != c, h = void 0 != d, k = Object.getOwnPropertyNames(a), m = 0; m < k.length; m++) {
            var n = k[m];
            if ((a.__lookupGetter__ ? !a.__lookupGetter__(n) : !Object.getOwnPropertyDescriptor(a, n)) && "function" === typeof a[n]) {
                var p =
                    a[n];
                if (g && p === c && (e = n, !h || f)) break;
                if (h && p === d && (f = n, !g || e)) break
            }
        }
    a = a.constructor;
    e && (a.__getters__ || (a.__getters__ = {}), a.__getters__[e] = b);
    f && (a.__setters__ || (a.__setters__ = {}), a.__setters__[f] = b)
};
cc.clone = function(a) {
    var b = a.constructor ? new a.constructor : {},
        c;
    for (c in a) {
        var d = a[c];
        b[c] = "object" !== typeof d || !d || d instanceof cc.Node || d instanceof HTMLElement ? d : cc.clone(d)
    }
    return b
};
cc.inject = function(a, b) {
    for (var c in a) b[c] = a[c]
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.associateWithNative = function(a, b) {};
cc.KEY = {
    none: 0,
    back: 6,
    menu: 18,
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    ctrl: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    select: 41,
    insert: 45,
    Delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    num0: 96,
    num1: 97,
    num2: 98,
    num3: 99,
    num4: 100,
    num5: 101,
    num6: 102,
    num7: 103,
    num8: 104,
    num9: 105,
    "*": 106,
    "+": 107,
    "-": 109,
    numdel: 110,
    "/": 111,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    semicolon: 186,
    equal: 187,
    "\x3d": 187,
    ",": 188,
    comma: 188,
    dash: 189,
    ".": 190,
    period: 190,
    forwardslash: 191,
    grave: 192,
    "[": 219,
    openbracket: 219,
    backslash: 220,
    "]": 221,
    closebracket: 221,
    quote: 222,
    dpadLeft: 1E3,
    dpadRight: 1001,
    dpadUp: 1003,
    dpadDown: 1004,
    dpadCenter: 1005
};
cc.FMT_JPG = 0;
cc.FMT_PNG = 1;
cc.FMT_TIFF = 2;
cc.FMT_RAWDATA = 3;
cc.FMT_WEBP = 4;
cc.FMT_UNKNOWN = 5;
cc.getImageFormatByData = function(a) {
    return 8 < a.length && 137 === a[0] && 80 === a[1] && 78 === a[2] && 71 === a[3] && 13 === a[4] && 10 === a[5] && 26 === a[6] && 10 === a[7] ? cc.FMT_PNG : 2 < a.length && (73 === a[0] && 73 === a[1] || 77 === a[0] && 77 === a[1] || 255 === a[0] && 216 === a[1]) ? cc.FMT_TIFF : cc.FMT_UNKNOWN
};
cc.inherits = function(a, b) {
    function c() {}
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c;
    a.prototype.constructor = a
};
cc.base = function(a, b, c) {
    var d = arguments.callee.caller;
    if (d.superClass_) return ret = d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var e = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
        if (g.prototype[b] === d) f = !0;
        else if (f) return g.prototype[b].apply(a, e);
    if (a[b] === d) return a.constructor.prototype[b].apply(a, e);
    throw Error("cc.base called from a method of one name to a method of a different name");
};
cc.Point = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.p = function(a, b) {
    return void 0 === a ? {
        x: 0,
        y: 0
    } : void 0 === b ? {
        x: a.x,
        y: a.y
    } : {
        x: a,
        y: b
    }
};
cc.pointEqualToPoint = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y
};
cc.Size = function(a, b) {
    this.width = a || 0;
    this.height = b || 0
};
cc.size = function(a, b) {
    return void 0 === a ? {
        width: 0,
        height: 0
    } : void 0 === b ? {
        width: a.width,
        height: a.height
    } : {
        width: a,
        height: b
    }
};
cc.sizeEqualToSize = function(a, b) {
    return a && b && a.width === b.width && a.height === b.height
};
cc.Rect = function(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.width = c || 0;
    this.height = d || 0
};
cc.rect = function(a, b, c, d) {
    return void 0 === a ? {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    } : void 0 === b ? {
        x: a.x,
        y: a.y,
        width: a.width,
        height: a.height
    } : {
        x: a,
        y: b,
        width: c,
        height: d
    }
};
cc.rectEqualToRect = function(a, b) {
    return a && b && a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height
};
cc._rectEqualToZero = function(a) {
    return a && 0 === a.x && 0 === a.y && 0 === a.width && 0 === a.height
};
cc.rectContainsRect = function(a, b) {
    return a && b ? !(a.x >= b.x || a.y >= b.y || a.x + a.width <= b.x + b.width || a.y + a.height <= b.y + b.height) : !1
};
cc.rectGetMaxX = function(a) {
    return a.x + a.width
};
cc.rectGetMidX = function(a) {
    return a.x + a.width / 2
};
cc.rectGetMinX = function(a) {
    return a.x
};
cc.rectGetMaxY = function(a) {
    return a.y + a.height
};
cc.rectGetMidY = function(a) {
    return a.y + a.height / 2
};
cc.rectGetMinY = function(a) {
    return a.y
};
cc.rectContainsPoint = function(a, b) {
    return b.x >= cc.rectGetMinX(a) && b.x <= cc.rectGetMaxX(a) && b.y >= cc.rectGetMinY(a) && b.y <= cc.rectGetMaxY(a)
};
cc.rectIntersectsRect = function(a, b) {
    var c = a.y + a.height,
        d = b.x + b.width,
        e = b.y + b.height;
    return !(a.x + a.width < b.x || d < a.x || c < b.y || e < a.y)
};
cc.rectOverlapsRect = function(a, b) {
    return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y)
};
cc.rectUnion = function(a, b) {
    var c = cc.rect(0, 0, 0, 0);
    c.x = Math.min(a.x, b.x);
    c.y = Math.min(a.y, b.y);
    c.width = Math.max(a.x + a.width, b.x + b.width) - c.x;
    c.height = Math.max(a.y + a.height, b.y + b.height) - c.y;
    return c
};
cc.rectIntersection = function(a, b) {
    var c = cc.rect(Math.max(cc.rectGetMinX(a), cc.rectGetMinX(b)), Math.max(cc.rectGetMinY(a), cc.rectGetMinY(b)), 0, 0);
    c.width = Math.min(cc.rectGetMaxX(a), cc.rectGetMaxX(b)) - cc.rectGetMinX(c);
    c.height = Math.min(cc.rectGetMaxY(a), cc.rectGetMaxY(b)) - cc.rectGetMinY(c);
    return c
};
cc.SAXParser = cc.Class.extend({
    _parser: null,
    _isSupportDOMParser: null,
    ctor: function() {
        window.DOMParser ? (this._isSupportDOMParser = !0, this._parser = new DOMParser) : this._isSupportDOMParser = !1
    },
    parse: function(a) {
        return this._parseXML(a)
    },
    _parseXML: function(a) {
        var b;
        this._isSupportDOMParser ? b = this._parser.parseFromString(a, "text/xml") : (b = new ActiveXObject("Microsoft.XMLDOM"), b.async = "false", b.loadXML(a));
        return b
    }
});
cc.PlistParser = cc.SAXParser.extend({
    parse: function(a) {
        a = this._parseXML(a).documentElement;
        if ("plist" !== a.tagName) return cc.warn("Not a plist file!"), {};
        for (var b = null, c = 0, d = a.childNodes.length; c < d && (b = a.childNodes[c], 1 !== b.nodeType); c++);
        return this._parseNode(b)
    },
    _parseNode: function(a) {
        var b = null,
            c = a.tagName;
        if ("dict" === c) b = this._parseDict(a);
        else if ("array" === c) b = this._parseArray(a);
        else if ("string" === c)
            if (1 === a.childNodes.length) b = a.firstChild.nodeValue;
            else
                for (b = "", c = 0; c < a.childNodes.length; c++) b +=
                    a.childNodes[c].nodeValue;
        else "false" === c ? b = !1 : "true" === c ? b = !0 : "real" === c ? b = parseFloat(a.firstChild.nodeValue) : "integer" === c && (b = parseInt(a.firstChild.nodeValue, 10));
        return b
    },
    _parseArray: function(a) {
        for (var b = [], c = 0, d = a.childNodes.length; c < d; c++) {
            var e = a.childNodes[c];
            1 === e.nodeType && b.push(this._parseNode(e))
        }
        return b
    },
    _parseDict: function(a) {
        for (var b = {}, c = null, d = 0, e = a.childNodes.length; d < e; d++) {
            var f = a.childNodes[d];
            1 === f.nodeType && ("key" === f.tagName ? c = f.firstChild.nodeValue : b[c] = this._parseNode(f))
        }
        return b
    }
});
cc.saxParser = new cc.SAXParser;
cc.plistParser = new cc.PlistParser;
cc._txtLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadTxt(a, d)
    }
};
cc.loader.register(["txt", "xml", "vsh", "fsh", "atlas"], cc._txtLoader);
cc._jsonLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadJson(a, d)
    }
};
cc.loader.register(["json", "ExportJson"], cc._jsonLoader);
cc._jsLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadJs(a, d)
    }
};
cc.loader.register(["js"], cc._jsLoader);
cc._imgLoader = {
    load: function(a, b, c, d) {
        cc.loader.cache[b] = cc.loader.loadImg(a, function(a, c) {
            if (a) return d(a);
            cc.textureCache.handleLoadedTexture(b);
            d(null, c)
        })
    }
};
cc.loader.register("png jpg bmp jpeg gif ico tiff webp".split(" "), cc._imgLoader);
cc._serverImgLoader = {
    load: function(a, b, c, d) {
        cc.loader.cache[b] = cc.loader.loadImg(c.src, function(a, c) {
            if (a) return d(a);
            cc.textureCache.handleLoadedTexture(b);
            d(null, c)
        })
    }
};
cc.loader.register(["serverImg"], cc._serverImgLoader);
cc._plistLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadTxt(a, function(a, b) {
            if (a) return d(a);
            d(null, cc.plistParser.parse(b))
        })
    }
};
cc.loader.register(["plist"], cc._plistLoader);
cc._fontLoader = {
    TYPE: {
        ".eot": "embedded-opentype",
        ".ttf": "truetype",
        ".ttc": "truetype",
        ".woff": "woff",
        ".svg": "svg"
    },
    _loadFont: function(a, b, c) {
        var d = document,
            e = cc.path,
            f = this.TYPE,
            g = document.createElement("style");
        g.type = "text/css";
        d.body.appendChild(g);
        var h = "",
            h = isNaN(a - 0) ? h + ("@font-face { font-family:" + a + "; src:") : h + ("@font-face { font-family:'" + a + "'; src:");
        if (b instanceof Array)
            for (var k = 0, m = b.length; k < m; k++) c = e.extname(b[k]).toLowerCase(), h += "url('" + b[k] + "') format('" + f[c] + "')", h += k === m - 1 ? ";" :
                ",";
        else c = c.toLowerCase(), h += "url('" + b + "') format('" + f[c] + "');";
        g.textContent += h + "}";
        b = document.createElement("div");
        c = b.style;
        c.fontFamily = a;
        b.innerHTML = ".";
        c.position = "absolute";
        c.left = "-100px";
        c.top = "-100px";
        d.body.appendChild(b)
    },
    load: function(a, b, c, d) {
        b = c.type;
        a = c.name;
        b = c.srcs;
        cc.isString(c) ? (b = cc.path.extname(c), a = cc.path.basename(c, b), this._loadFont(a, c, b)) : this._loadFont(a, b);
        document.fonts ? document.fonts.load("1em " + a).then(function() {
            d(null, !0)
        }, function(a) {
            d(a)
        }) : d(null, !0)
    }
};
cc.loader.register("font eot ttf woff svg ttc".split(" "), cc._fontLoader);
cc._binaryLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadBinary(a, d)
    }
};
cc._csbLoader = {
    load: function(a, b, c, d) {
        cc.loader.loadCsb(a, d)
    }
};
cc.loader.register(["csb"], cc._csbLoader);
window.CocosEngine = cc.ENGINE_VERSION = "Cocos2d-JS v3.9";
cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL = 0;
cc.DIRECTOR_STATS_POSITION = cc.p(0, 0);
cc.DIRECTOR_FPS_INTERVAL = 0.5;
cc.COCOSNODE_RENDER_SUBPIXEL = 1;
cc.SPRITEBATCHNODE_RENDER_SUBPIXEL = 1;
cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA = 1;
cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP = 0;
cc.TEXTURE_ATLAS_USE_VAO = 0;
cc.TEXTURE_NPOT_SUPPORT = 0;
cc.RETINA_DISPLAY_SUPPORT = 1;
cc.RETINA_DISPLAY_FILENAME_SUFFIX = "-hd";
cc.USE_LA88_LABELS = 1;
cc.SPRITE_DEBUG_DRAW = 0;
cc.SPRITEBATCHNODE_DEBUG_DRAW = 0;
cc.LABELBMFONT_DEBUG_DRAW = 0;
cc.LABELATLAS_DEBUG_DRAW = 0;
cc.IS_RETINA_DISPLAY_SUPPORTED = 1;
cc.DEFAULT_ENGINE = cc.ENGINE_VERSION + "-canvas";
cc.ENABLE_STACKABLE_ACTIONS = 1;
cc.ENABLE_GL_STATE_CACHE = 1;
cc.$ = function(a) {
    var b = this === cc ? document : this;
    if (a = a instanceof HTMLElement ? a : b.querySelector(a)) a.find = a.find || cc.$, a.hasClass = a.hasClass || function(a) {
            return this.className.match(RegExp("(\\s|^)" + a + "(\\s|$)"))
        }, a.addClass = a.addClass || function(a) {
            this.hasClass(a) || (this.className && (this.className += " "), this.className += a);
            return this
        }, a.removeClass = a.removeClass || function(a) {
            this.hasClass(a) && (this.className = this.className.replace(a, ""));
            return this
        }, a.remove = a.remove || function() {
            this.parentNode &&
                this.parentNode.removeChild(this);
            return this
        }, a.appendTo = a.appendTo || function(a) {
            a.appendChild(this);
            return this
        }, a.prependTo = a.prependTo || function(a) {
            a.childNodes[0] ? a.insertBefore(this, a.childNodes[0]) : a.appendChild(this);
            return this
        }, a.transforms = a.transforms || function() {
            this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
            return this
        }, a.position = a.position || {
            x: 0,
            y: 0
        }, a.rotation = a.rotation || 0, a.scale = a.scale || {
            x: 1,
            y: 1
        }, a.skew =
        a.skew || {
            x: 0,
            y: 0
        }, a.translates = function(a, b) {
            this.position.x = a;
            this.position.y = b;
            this.transforms();
            return this
        }, a.rotate = function(a) {
            this.rotation = a;
            this.transforms();
            return this
        }, a.resize = function(a, b) {
            this.scale.x = a;
            this.scale.y = b;
            this.transforms();
            return this
        }, a.setSkew = function(a, b) {
            this.skew.x = a;
            this.skew.y = b;
            this.transforms();
            return this
        };
    return a
};
switch (cc.sys.browserType) {
    case cc.sys.BROWSER_TYPE_FIREFOX:
        cc.$.pfx = "Moz";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.$.pfx = "webkit";
        cc.$.hd = !0;
        break;
    case cc.sys.BROWSER_TYPE_OPERA:
        cc.$.pfx = "O";
        cc.$.hd = !1;
        break;
    case cc.sys.BROWSER_TYPE_IE:
        cc.$.pfx = "ms";
        cc.$.hd = !1;
        break;
    default:
        cc.$.pfx = "webkit", cc.$.hd = !0
}
cc.$.trans = cc.$.pfx + "Transform";
cc.$.translate = cc.$.hd ? function(a) {
    return "translate3d(" + a.x + "px, " + a.y + "px, 0) "
} : function(a) {
    return "translate(" + a.x + "px, " + a.y + "px) "
};
cc.$.rotate = cc.$.hd ? function(a) {
    return "rotateZ(" + a + "deg) "
} : function(a) {
    return "rotate(" + a + "deg) "
};
cc.$.scale = function(a) {
    return "scale(" + a.x + ", " + a.y + ") "
};
cc.$.skew = function(a) {
    return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)"
};
cc.$new = function(a) {
    return cc.$(document.createElement(a))
};
cc.$.findpos = function(a) {
    var b = 0,
        c = 0;
    do b += a.offsetLeft, c += a.offsetTop; while (a = a.offsetParent);
    return {
        x: b,
        y: c
    }
};
cc.INVALID_INDEX = -1;
cc.PI = Math.PI;
cc.FLT_MAX = parseFloat("3.402823466e+38F");
cc.FLT_MIN = parseFloat("1.175494351e-38F");
cc.RAD = cc.PI / 180;
cc.DEG = 180 / cc.PI;
cc.UINT_MAX = 4294967295;
cc.swap = function(a, b, c) {
    if (!cc.isObject(c) || cc.isUndefined(c.x) || cc.isUndefined(c.y)) cc.log(cc._LogInfos.swap);
    else {
        var d = c[a];
        c[a] = c[b];
        c[b] = d
    }
};
cc.lerp = function(a, b, c) {
    return a + (b - a) * c
};
cc.rand = function() {
    return 16777215 * Math.random()
};
cc.randomMinus1To1 = function() {
    return 2 * (Math.random() - 0.5)
};
cc.random0To1 = Math.random;
cc.degreesToRadians = function(a) {
    return a * cc.RAD
};
cc.radiansToDegrees = function(a) {
    return a * cc.DEG
};
cc.radiansToDegress = function(a) {
    cc.log(cc._LogInfos.radiansToDegress);
    return a * cc.DEG
};
cc.REPEAT_FOREVER = Number.MAX_VALUE - 1;
cc.nodeDrawSetup = function(a) {
    a._shaderProgram && (a._shaderProgram.use(), a._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4())
};
cc.enableDefaultGLStates = function() {};
cc.disableDefaultGLStates = function() {};
cc.incrementGLDraws = function(a) {
    cc.g_NumberOfDraws += a
};
cc.FLT_EPSILON = 1.192092896E-7;
cc.contentScaleFactor = cc.IS_RETINA_DISPLAY_SUPPORTED ? function() {
    return cc.director.getContentScaleFactor()
} : function() {
    return 1
};
cc.pointPointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x * b, a.y * b)
};
cc.pointPixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.p(a.x / b, a.y / b)
};
cc._pointPixelsToPointsOut = function(a, b) {
    var c = cc.contentScaleFactor();
    b.x = a.x / c;
    b.y = a.y / c
};
cc.sizePointsToPixels = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width * b, a.height * b)
};
cc.sizePixelsToPoints = function(a) {
    var b = cc.contentScaleFactor();
    return cc.size(a.width / b, a.height / b)
};
cc._sizePixelsToPointsOut = function(a, b) {
    var c = cc.contentScaleFactor();
    b.width = a.width / c;
    b.height = a.height / c
};
cc.rectPixelsToPoints = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x / b, a.y / b, a.width / b, a.height / b)
} : function(a) {
    return a
};
cc.rectPointsToPixels = cc.IS_RETINA_DISPLAY_SUPPORTED ? function(a) {
    var b = cc.contentScaleFactor();
    return cc.rect(a.x * b, a.y * b, a.width * b, a.height * b)
} : function(a) {
    return a
};
cc.ONE = 1;
cc.ZERO = 0;
cc.SRC_ALPHA = 770;
cc.SRC_ALPHA_SATURATE = 776;
cc.SRC_COLOR = 768;
cc.DST_ALPHA = 772;
cc.DST_COLOR = 774;
cc.ONE_MINUS_SRC_ALPHA = 771;
cc.ONE_MINUS_SRC_COLOR = 769;
cc.ONE_MINUS_DST_ALPHA = 773;
cc.ONE_MINUS_DST_COLOR = 775;
cc.ONE_MINUS_CONSTANT_ALPHA = 32772;
cc.ONE_MINUS_CONSTANT_COLOR = 32770;
cc.LINEAR = 9729;
cc.REPEAT = 10497;
cc.CLAMP_TO_EDGE = 33071;
cc.MIRRORED_REPEAT = 33648;
cc.BLEND_SRC = cc.SRC_ALPHA;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA && (cc.BLEND_SRC = cc.ONE)
});
cc.BLEND_DST = 771;
cc.checkGLErrorDebug = function() {
    if (cc.renderMode === cc.game.RENDER_TYPE_WEBGL) {
        var a = cc._renderContext.getError();
        a && cc.log(cc._LogInfos.checkGLErrorDebug, a)
    }
};
cc.DEVICE_ORIENTATION_PORTRAIT = 0;
cc.DEVICE_ORIENTATION_LANDSCAPE_LEFT = 1;
cc.DEVICE_ORIENTATION_PORTRAIT_UPSIDE_DOWN = 2;
cc.DEVICE_ORIENTATION_LANDSCAPE_RIGHT = 3;
cc.DEVICE_MAX_ORIENTATIONS = 2;
cc.VERTEX_ATTRIB_FLAG_NONE = 0;
cc.VERTEX_ATTRIB_FLAG_POSITION = 1;
cc.VERTEX_ATTRIB_FLAG_COLOR = 2;
cc.VERTEX_ATTRIB_FLAG_TEX_COORDS = 4;
cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX = cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
cc.GL_ALL = 0;
cc.VERTEX_ATTRIB_POSITION = 0;
cc.VERTEX_ATTRIB_COLOR = 1;
cc.VERTEX_ATTRIB_TEX_COORDS = 2;
cc.VERTEX_ATTRIB_MAX = 3;
cc.UNIFORM_PMATRIX = 0;
cc.UNIFORM_MVMATRIX = 1;
cc.UNIFORM_MVPMATRIX = 2;
cc.UNIFORM_TIME = 3;
cc.UNIFORM_SINTIME = 4;
cc.UNIFORM_COSTIME = 5;
cc.UNIFORM_RANDOM01 = 6;
cc.UNIFORM_SAMPLER = 7;
cc.UNIFORM_MAX = 8;
cc.SHADER_POSITION_TEXTURECOLOR = "ShaderPositionTextureColor";
cc.SHADER_POSITION_TEXTURECOLORALPHATEST = "ShaderPositionTextureColorAlphaTest";
cc.SHADER_POSITION_COLOR = "ShaderPositionColor";
cc.SHADER_POSITION_TEXTURE = "ShaderPositionTexture";
cc.SHADER_POSITION_TEXTURE_UCOLOR = "ShaderPositionTexture_uColor";
cc.SHADER_POSITION_TEXTUREA8COLOR = "ShaderPositionTextureA8Color";
cc.SHADER_POSITION_UCOLOR = "ShaderPosition_uColor";
cc.SHADER_POSITION_LENGTHTEXTURECOLOR = "ShaderPositionLengthTextureColor";
cc.UNIFORM_PMATRIX_S = "CC_PMatrix";
cc.UNIFORM_MVMATRIX_S = "CC_MVMatrix";
cc.UNIFORM_MVPMATRIX_S = "CC_MVPMatrix";
cc.UNIFORM_TIME_S = "CC_Time";
cc.UNIFORM_SINTIME_S = "CC_SinTime";
cc.UNIFORM_COSTIME_S = "CC_CosTime";
cc.UNIFORM_RANDOM01_S = "CC_Random01";
cc.UNIFORM_SAMPLER_S = "CC_Texture0";
cc.UNIFORM_ALPHA_TEST_VALUE_S = "CC_alpha_value";
cc.ATTRIBUTE_NAME_COLOR = "a_color";
cc.ATTRIBUTE_NAME_POSITION = "a_position";
cc.ATTRIBUTE_NAME_TEX_COORD = "a_texCoord";
cc.ITEM_SIZE = 32;
cc.CURRENT_ITEM = 3233828865;
cc.ZOOM_ACTION_TAG = 3233828866;
cc.NORMAL_TAG = 8801;
cc.SELECTED_TAG = 8802;
cc.DISABLE_TAG = 8803;
cc.arrayVerifyType = function(a, b) {
    if (a && 0 < a.length)
        for (var c = 0; c < a.length; c++)
            if (!(a[c] instanceof b)) return cc.log("element type is wrong!"), !1;
    return !0
};
cc.arrayRemoveObject = function(a, b) {
    for (var c = 0, d = a.length; c < d; c++)
        if (a[c] === b) {
            a.splice(c, 1);
            break
        }
};
cc.arrayRemoveArray = function(a, b) {
    for (var c = 0, d = b.length; c < d; c++) cc.arrayRemoveObject(a, b[c])
};
cc.arrayAppendObjectsToIndex = function(a, b, c) {
    a.splice.apply(a, [c, 0].concat(b));
    return a
};
cc.copyArray = function(a) {
    var b, c = a.length,
        d = Array(c);
    for (b = 0; b < c; b += 1) d[b] = a[b];
    return d
};
cc = cc || {};
cc._tmp = cc._tmp || {};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.color = function(a, c, d, e, f, g) {
            return void 0 === a ? new cc.Color(0, 0, 0, 255, f, g) : cc.isString(a) ? (a = cc.hexToColor(a), new cc.Color(a.r, a.g, a.b, a.a)) : cc.isObject(a) ? new cc.Color(a.r, a.g, a.b, a.a, a.arrayBuffer, a.offset) : new cc.Color(a, c, d, e, f, g)
        };
        cc.Color = function(a, c, d, e, f, g) {
            this._arrayBuffer = f || new ArrayBuffer(cc.Color.BYTES_PER_ELEMENT);
            this._offset = g || 0;
            f = this._arrayBuffer;
            g = this._offset;
            var h =
                Uint8Array.BYTES_PER_ELEMENT;
            this._rU8 = new Uint8Array(f, g, 1);
            this._gU8 = new Uint8Array(f, g + h, 1);
            this._bU8 = new Uint8Array(f, g + 2 * h, 1);
            this._aU8 = new Uint8Array(f, g + 3 * h, 1);
            this._rU8[0] = a || 0;
            this._gU8[0] = c || 0;
            this._bU8[0] = d || 0;
            this._aU8[0] = null == e ? 255 : e;
            void 0 === e && (this.a_undefined = !0)
        };
        cc.Color.BYTES_PER_ELEMENT = 4;
        var a = cc.Color.prototype;
        a._getR = function() {
            return this._rU8[0]
        };
        a._setR = function(a) {
            this._rU8[0] = 0 > a ? 0 : a
        };
        a._getG = function() {
            return this._gU8[0]
        };
        a._setG = function(a) {
            this._gU8[0] = 0 > a ? 0 : a
        };
        a._getB = function() {
            return this._bU8[0]
        };
        a._setB = function(a) {
            this._bU8[0] = 0 > a ? 0 : a
        };
        a._getA = function() {
            return this._aU8[0]
        };
        a._setA = function(a) {
            this._aU8[0] = 0 > a ? 0 : a
        };
        cc.defineGetterSetter(a, "r", a._getR, a._setR);
        cc.defineGetterSetter(a, "g", a._getG, a._setG);
        cc.defineGetterSetter(a, "b", a._getB, a._setB);
        cc.defineGetterSetter(a, "a", a._getA, a._setA);
        cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js");
        cc._tmp.PrototypeColor();
        delete cc._tmp.PrototypeColor;
        cc.Vertex2F =
            function(a, c, d, e) {
                this._arrayBuffer = d || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
                this._offset = e || 0;
                this._xF32 = new Float32Array(this._arrayBuffer, this._offset, 1);
                this._yF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
                this._xF32[0] = a || 0;
                this._yF32[0] = c || 0
            };
        cc.Vertex2F.BYTES_PER_ELEMENT = 8;
        a = cc.Vertex2F.prototype;
        a._getX = function() {
            return this._xF32[0]
        };
        a._setX = function(a) {
            this._xF32[0] = a
        };
        a._getY = function() {
            return this._yF32[0]
        };
        a._setY = function(a) {
            this._yF32[0] = a
        };
        cc.defineGetterSetter(a,
            "x", a._getX, a._setX);
        cc.defineGetterSetter(a, "y", a._getY, a._setY);
        cc.Vertex3F = function(a, c, d, e, f) {
            this._arrayBuffer = e || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
            this._offset = f || 0;
            e = this._arrayBuffer;
            f = this._offset;
            this._xF32 = new Float32Array(e, f, 1);
            this._xF32[0] = a || 0;
            this._yF32 = new Float32Array(e, f + Float32Array.BYTES_PER_ELEMENT, 1);
            this._yF32[0] = c || 0;
            this._zF32 = new Float32Array(e, f + 2 * Float32Array.BYTES_PER_ELEMENT, 1);
            this._zF32[0] = d || 0
        };
        cc.Vertex3F.BYTES_PER_ELEMENT = 12;
        a = cc.Vertex3F.prototype;
        a._getX = function() {
            return this._xF32[0]
        };
        a._setX = function(a) {
            this._xF32[0] = a
        };
        a._getY = function() {
            return this._yF32[0]
        };
        a._setY = function(a) {
            this._yF32[0] = a
        };
        a._getZ = function() {
            return this._zF32[0]
        };
        a._setZ = function(a) {
            this._zF32[0] = a
        };
        cc.defineGetterSetter(a, "x", a._getX, a._setX);
        cc.defineGetterSetter(a, "y", a._getY, a._setY);
        cc.defineGetterSetter(a, "z", a._getZ, a._setZ);
        cc.Tex2F = function(a, c, d, e) {
            this._arrayBuffer = d || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
            this._offset = e || 0;
            this._uF32 = new Float32Array(this._arrayBuffer,
                this._offset, 1);
            this._vF32 = new Float32Array(this._arrayBuffer, this._offset + 4, 1);
            this._uF32[0] = a || 0;
            this._vF32[0] = c || 0
        };
        cc.Tex2F.BYTES_PER_ELEMENT = 8;
        a = cc.Tex2F.prototype;
        a._getU = function() {
            return this._uF32[0]
        };
        a._setU = function(a) {
            this._uF32[0] = a
        };
        a._getV = function() {
            return this._vF32[0]
        };
        a._setV = function(a) {
            this._vF32[0] = a
        };
        cc.defineGetterSetter(a, "u", a._getU, a._setU);
        cc.defineGetterSetter(a, "v", a._getV, a._setV);
        cc.Quad2 = function(a, c, d, e, f, g) {
            this._arrayBuffer = f || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
            this._offset = g || 0;
            f = this._arrayBuffer;
            g = cc.Vertex2F.BYTES_PER_ELEMENT;
            this._tl = a ? new cc.Vertex2F(a.x, a.y, f, 0) : new cc.Vertex2F(0, 0, f, 0);
            this._tr = c ? new cc.Vertex2F(c.x, c.y, f, g) : new cc.Vertex2F(0, 0, f, g);
            this._bl = d ? new cc.Vertex2F(d.x, d.y, f, 2 * g) : new cc.Vertex2F(0, 0, f, 2 * g);
            this._br = e ? new cc.Vertex2F(e.x, e.y, f, 3 * g) : new cc.Vertex2F(0, 0, f, 3 * g)
        };
        cc.Quad2.BYTES_PER_ELEMENT = 32;
        a = cc.Quad2.prototype;
        a._getTL = function() {
            return this._tl
        };
        a._setTL = function(a) {
            this._tl.x = a.x;
            this._tl.y = a.y
        };
        a._getTR = function() {
            return this._tr
        };
        a._setTR = function(a) {
            this._tr.x = a.x;
            this._tr.y = a.y
        };
        a._getBL = function() {
            return this._bl
        };
        a._setBL = function(a) {
            this._bl.x = a.x;
            this._bl.y = a.y
        };
        a._getBR = function() {
            return this._br
        };
        a._setBR = function(a) {
            this._br.x = a.x;
            this._br.y = a.y
        };
        cc.defineGetterSetter(a, "tl", a._getTL, a._setTL);
        cc.defineGetterSetter(a, "tr", a._getTR, a._setTR);
        cc.defineGetterSetter(a, "bl", a._getBL, a._setBL);
        cc.defineGetterSetter(a, "br", a._getBR, a._setBR);
        cc.Quad3 = function(a, c, d, e) {
            this.bl = a || new cc.Vertex3F(0, 0, 0);
            this.br = c || new cc.Vertex3F(0,
                0, 0);
            this.tl = d || new cc.Vertex3F(0, 0, 0);
            this.tr = e || new cc.Vertex3F(0, 0, 0)
        };
        cc.V3F_C4B_T2F = function(a, c, d, e, f) {
            this._arrayBuffer = e || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
            this._offset = f || 0;
            e = this._arrayBuffer;
            f = this._offset;
            var g = cc.Vertex3F.BYTES_PER_ELEMENT;
            this._vertices = a ? new cc.Vertex3F(a.x, a.y, a.z, e, f) : new cc.Vertex3F(0, 0, 0, e, f);
            this._colors = c ? cc.color(c.r, c.g, c.b, c.a, e, f + g) : cc.color(0, 0, 0, 0, e, f + g);
            this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + g + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0,
                0, e, f + g + cc.Color.BYTES_PER_ELEMENT)
        };
        cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
        a = cc.V3F_C4B_T2F.prototype;
        a._getVertices = function() {
            return this._vertices
        };
        a._setVertices = function(a) {
            var c = this._vertices;
            c.x = a.x;
            c.y = a.y;
            c.z = a.z
        };
        a._getColor = function() {
            return this._colors
        };
        a._setColor = function(a) {
            var c = this._colors;
            c.r = a.r;
            c.g = a.g;
            c.b = a.b;
            c.a = a.a
        };
        a._getTexCoords = function() {
            return this._texCoords
        };
        a._setTexCoords = function(a) {
            this._texCoords.u = a.u;
            this._texCoords.v = a.v
        };
        cc.defineGetterSetter(a, "vertices",
            a._getVertices, a._setVertices);
        cc.defineGetterSetter(a, "colors", a._getColor, a._setColor);
        cc.defineGetterSetter(a, "texCoords", a._getTexCoords, a._setTexCoords);
        cc.V3F_C4B_T2F_Quad = function(a, c, d, e, f, g) {
            this._arrayBuffer = f || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
            this._offset = g || 0;
            f = this._arrayBuffer;
            g = this._offset;
            var h = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
            this._tl = a ? new cc.V3F_C4B_T2F(a.vertices, a.colors, a.texCoords, f, g) : new cc.V3F_C4B_T2F(null, null, null, f, g);
            this._bl = c ? new cc.V3F_C4B_T2F(c.vertices,
                c.colors, c.texCoords, f, g + h) : new cc.V3F_C4B_T2F(null, null, null, f, g + h);
            this._tr = d ? new cc.V3F_C4B_T2F(d.vertices, d.colors, d.texCoords, f, g + 2 * h) : new cc.V3F_C4B_T2F(null, null, null, f, g + 2 * h);
            this._br = e ? new cc.V3F_C4B_T2F(e.vertices, e.colors, e.texCoords, f, g + 3 * h) : new cc.V3F_C4B_T2F(null, null, null, f, g + 3 * h)
        };
        cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
        a = cc.V3F_C4B_T2F_Quad.prototype;
        a._getTL = function() {
            return this._tl
        };
        a._setTL = function(a) {
            var c = this._tl;
            c.vertices = a.vertices;
            c.colors = a.colors;
            c.texCoords = a.texCoords
        };
        a._getBL = function() {
            return this._bl
        };
        a._setBL = function(a) {
            var c = this._bl;
            c.vertices = a.vertices;
            c.colors = a.colors;
            c.texCoords = a.texCoords
        };
        a._getTR = function() {
            return this._tr
        };
        a._setTR = function(a) {
            var c = this._tr;
            c.vertices = a.vertices;
            c.colors = a.colors;
            c.texCoords = a.texCoords
        };
        a._getBR = function() {
            return this._br
        };
        a._setBR = function(a) {
            var c = this._br;
            c.vertices = a.vertices;
            c.colors = a.colors;
            c.texCoords = a.texCoords
        };
        a._getArrayBuffer = function() {
            return this._arrayBuffer
        };
        cc.defineGetterSetter(a, "tl", a._getTL,
            a._setTL);
        cc.defineGetterSetter(a, "tr", a._getTR, a._setTR);
        cc.defineGetterSetter(a, "bl", a._getBL, a._setBL);
        cc.defineGetterSetter(a, "br", a._getBR, a._setBR);
        cc.defineGetterSetter(a, "arrayBuffer", a._getArrayBuffer, null);
        cc.V3F_C4B_T2F_QuadZero = function() {
            return new cc.V3F_C4B_T2F_Quad
        };
        cc.V3F_C4B_T2F_QuadCopy = function(a) {
            if (!a) return cc.V3F_C4B_T2F_QuadZero();
            var c = a.tl,
                d = a.bl,
                e = a.tr;
            a = a.br;
            return {
                tl: {
                    vertices: {
                        x: c.vertices.x,
                        y: c.vertices.y,
                        z: c.vertices.z
                    },
                    colors: {
                        r: c.colors.r,
                        g: c.colors.g,
                        b: c.colors.b,
                        a: c.colors.a
                    },
                    texCoords: {
                        u: c.texCoords.u,
                        v: c.texCoords.v
                    }
                },
                bl: {
                    vertices: {
                        x: d.vertices.x,
                        y: d.vertices.y,
                        z: d.vertices.z
                    },
                    colors: {
                        r: d.colors.r,
                        g: d.colors.g,
                        b: d.colors.b,
                        a: d.colors.a
                    },
                    texCoords: {
                        u: d.texCoords.u,
                        v: d.texCoords.v
                    }
                },
                tr: {
                    vertices: {
                        x: e.vertices.x,
                        y: e.vertices.y,
                        z: e.vertices.z
                    },
                    colors: {
                        r: e.colors.r,
                        g: e.colors.g,
                        b: e.colors.b,
                        a: e.colors.a
                    },
                    texCoords: {
                        u: e.texCoords.u,
                        v: e.texCoords.v
                    }
                },
                br: {
                    vertices: {
                        x: a.vertices.x,
                        y: a.vertices.y,
                        z: a.vertices.z
                    },
                    colors: {
                        r: a.colors.r,
                        g: a.colors.g,
                        b: a.colors.b,
                        a: a.colors.a
                    },
                    texCoords: {
                        u: a.texCoords.u,
                        v: a.texCoords.v
                    }
                }
            }
        };
        cc.V3F_C4B_T2F_QuadsCopy = function(a) {
            if (!a) return [];
            for (var c = [], d = 0; d < a.length; d++) c.push(cc.V3F_C4B_T2F_QuadCopy(a[d]));
            return c
        };
        cc.V2F_C4B_T2F = function(a, c, d, e, f) {
            this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
            this._offset = f || 0;
            e = this._arrayBuffer;
            f = this._offset;
            var g = cc.Vertex2F.BYTES_PER_ELEMENT;
            this._vertices = a ? new cc.Vertex2F(a.x, a.y, e, f) : new cc.Vertex2F(0, 0, e, f);
            this._colors = c ? cc.color(c.r, c.g, c.b, c.a, e, f + g) : cc.color(0,
                0, 0, 0, e, f + g);
            this._texCoords = d ? new cc.Tex2F(d.u, d.v, e, f + g + cc.Color.BYTES_PER_ELEMENT) : new cc.Tex2F(0, 0, e, f + g + cc.Color.BYTES_PER_ELEMENT)
        };
        cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
        a = cc.V2F_C4B_T2F.prototype;
        a._getVertices = function() {
            return this._vertices
        };
        a._setVertices = function(a) {
            this._vertices.x = a.x;
            this._vertices.y = a.y
        };
        a._getColor = function() {
            return this._colors
        };
        a._setColor = function(a) {
            var c = this._colors;
            c.r = a.r;
            c.g = a.g;
            c.b = a.b;
            c.a = a.a
        };
        a._getTexCoords = function() {
            return this._texCoords
        };
        a._setTexCoords =
            function(a) {
                this._texCoords.u = a.u;
                this._texCoords.v = a.v
            };
        cc.defineGetterSetter(a, "vertices", a._getVertices, a._setVertices);
        cc.defineGetterSetter(a, "colors", a._getColor, a._setColor);
        cc.defineGetterSetter(a, "texCoords", a._getTexCoords, a._setTexCoords);
        cc.V2F_C4B_T2F_Triangle = function(a, c, d, e, f) {
            this._arrayBuffer = e || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
            this._offset = f || 0;
            e = this._arrayBuffer;
            f = this._offset;
            var g = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            this._a = a ? new cc.V2F_C4B_T2F(a.vertices,
                a.colors, a.texCoords, e, f) : new cc.V2F_C4B_T2F(null, null, null, e, f);
            this._b = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, e, f + g) : new cc.V2F_C4B_T2F(null, null, null, e, f + g);
            this._c = d ? new cc.V2F_C4B_T2F(d.vertices, d.colors, d.texCoords, e, f + 2 * g) : new cc.V2F_C4B_T2F(null, null, null, e, f + 2 * g)
        };
        cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
        a = cc.V2F_C4B_T2F_Triangle.prototype;
        a._getA = function() {
            return this._a
        };
        a._setA = function(a) {
            var c = this._a;
            c.vertices = a.vertices;
            c.colors = a.colors;
            c.texCoords = a.texCoords
        };
        a._getB = function() {
            return this._b
        };
        a._setB = function(a) {
            var c = this._b;
            c.vertices = a.vertices;
            c.colors = a.colors;
            c.texCoords = a.texCoords
        };
        a._getC = function() {
            return this._c
        };
        a._setC = function(a) {
            var c = this._c;
            c.vertices = a.vertices;
            c.colors = a.colors;
            c.texCoords = a.texCoords
        };
        cc.defineGetterSetter(a, "a", a._getA, a._setA);
        cc.defineGetterSetter(a, "b", a._getB, a._setB);
        cc.defineGetterSetter(a, "c", a._getC, a._setC)
    }
});
cc._tmp.PrototypeColor = function() {
    var a = cc.color;
    a._getWhite = function() {
        return a(255, 255, 255)
    };
    a._getYellow = function() {
        return a(255, 255, 0)
    };
    a._getBlue = function() {
        return a(0, 0, 255)
    };
    a._getGreen = function() {
        return a(0, 255, 0)
    };
    a._getRed = function() {
        return a(255, 0, 0)
    };
    a._getMagenta = function() {
        return a(255, 0, 255)
    };
    a._getBlack = function() {
        return a(0, 0, 0)
    };
    a._getOrange = function() {
        return a(255, 127, 0)
    };
    a._getGray = function() {
        return a(166, 166, 166)
    };
    cc.defineGetterSetter(a, "WHITE", a._getWhite);
    cc.defineGetterSetter(a,
        "YELLOW", a._getYellow);
    cc.defineGetterSetter(a, "BLUE", a._getBlue);
    cc.defineGetterSetter(a, "GREEN", a._getGreen);
    cc.defineGetterSetter(a, "RED", a._getRed);
    cc.defineGetterSetter(a, "MAGENTA", a._getMagenta);
    cc.defineGetterSetter(a, "BLACK", a._getBlack);
    cc.defineGetterSetter(a, "ORANGE", a._getOrange);
    cc.defineGetterSetter(a, "GRAY", a._getGray);
    cc.BlendFunc._disable = function() {
        return new cc.BlendFunc(cc.ONE, cc.ZERO)
    };
    cc.BlendFunc._alphaPremultiplied = function() {
        return new cc.BlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._alphaNonPremultiplied = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA)
    };
    cc.BlendFunc._additive = function() {
        return new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE)
    };
    cc.defineGetterSetter(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
    cc.defineGetterSetter(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive)
};
cc.Color = function(a, b, c, d) {
    this.r = a || 0;
    this.g = b || 0;
    this.b = c || 0;
    this.a = null == d ? 255 : d
};
cc.color = function(a, b, c, d) {
    return void 0 === a ? {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    } : cc.isString(a) ? cc.hexToColor(a) : cc.isObject(a) ? {
        r: a.r,
        g: a.g,
        b: a.b,
        a: null == a.a ? 255 : a.a
    } : {
        r: a,
        g: b,
        b: c,
        a: null == d ? 255 : d
    }
};
cc.colorEqual = function(a, b) {
    return a.r === b.r && a.g === b.g && a.b === b.b
};
cc.Acceleration = function(a, b, c, d) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.timestamp = d || 0
};
cc.Vertex2F = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
cc.vertex2 = function(a, b) {
    return new cc.Vertex2F(a, b)
};
cc.Vertex3F = function(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
};
cc.vertex3 = function(a, b, c) {
    return new cc.Vertex3F(a, b, c)
};
cc.Tex2F = function(a, b) {
    this.u = a || 0;
    this.v = b || 0
};
cc.tex2 = function(a, b) {
    return new cc.Tex2F(a, b)
};
cc.BlendFunc = function(a, b) {
    this.src = a;
    this.dst = b
};
cc.blendFuncDisable = function() {
    return new cc.BlendFunc(cc.ONE, cc.ZERO)
};
cc.hexToColor = function(a) {
    a = a.replace(/^#?/, "0x");
    a = parseInt(a);
    return cc.color(a >> 16, (a >> 8) % 256, a % 256)
};
cc.colorToHex = function(a) {
    var b = a.r.toString(16),
        c = a.g.toString(16),
        d = a.b.toString(16);
    return "#" + (16 > a.r ? "0" + b : b) + (16 > a.g ? "0" + c : c) + (16 > a.b ? "0" + d : d)
};
cc.TEXT_ALIGNMENT_LEFT = 0;
cc.TEXT_ALIGNMENT_CENTER = 1;
cc.TEXT_ALIGNMENT_RIGHT = 2;
cc.VERTICAL_TEXT_ALIGNMENT_TOP = 0;
cc.VERTICAL_TEXT_ALIGNMENT_CENTER = 1;
cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM = 2;
cc._Dictionary = cc.Class.extend({
    _keyMapTb: null,
    _valueMapTb: null,
    __currId: 0,
    ctor: function() {
        this._keyMapTb = {};
        this._valueMapTb = {};
        this.__currId = 2 << (0 | 10 * Math.random())
    },
    __getKey: function() {
        this.__currId++;
        return "key_" + this.__currId
    },
    setObject: function(a, b) {
        if (null != b) {
            var c = this.__getKey();
            this._keyMapTb[c] = b;
            this._valueMapTb[c] = a
        }
    },
    objectForKey: function(a) {
        if (null == a) return null;
        var b = this._keyMapTb,
            c;
        for (c in b)
            if (b[c] === a) return this._valueMapTb[c];
        return null
    },
    valueForKey: function(a) {
        return this.objectForKey(a)
    },
    removeObjectForKey: function(a) {
        if (null != a) {
            var b = this._keyMapTb,
                c;
            for (c in b)
                if (b[c] === a) {
                    delete this._valueMapTb[c];
                    delete b[c];
                    break
                }
        }
    },
    removeObjectsForKeys: function(a) {
        if (null != a)
            for (var b = 0; b < a.length; b++) this.removeObjectForKey(a[b])
    },
    allKeys: function() {
        var a = [],
            b = this._keyMapTb,
            c;
        for (c in b) a.push(b[c]);
        return a
    },
    removeAllObjects: function() {
        this._keyMapTb = {};
        this._valueMapTb = {}
    },
    count: function() {
        return this.allKeys().length
    }
});
cc.FontDefinition = function(a) {
    this.fontName = "Arial";
    this.fontSize = 12;
    this.textAlign = cc.TEXT_ALIGNMENT_CENTER;
    this.verticalAlign = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
    this.fillStyle = cc.color(255, 255, 255, 255);
    this.boundingHeight = this.boundingWidth = 0;
    this.strokeEnabled = !1;
    this.strokeStyle = cc.color(255, 255, 255, 255);
    this.lineWidth = 1;
    this.fontWeight = this.fontStyle = this.lineHeight = "normal";
    this.shadowEnabled = !1;
    this.shadowBlur = this.shadowOffsetY = this.shadowOffsetX = 0;
    this.shadowOpacity = 1;
    if (a && a instanceof Object)
        for (var b in a) this[b] =
            a[b]
};
cc.FontDefinition.prototype._getCanvasFontStr = function() {
    return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + (this.lineHeight.charAt ? this.lineHeight : this.lineHeight + "px") + " '" + this.fontName + "'"
};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    cc._renderType === cc.game.RENDER_TYPE_CANVAS && (cc.assert(cc.isFunction(cc._tmp.PrototypeColor), cc._LogInfos.MissingFile, "CCTypesPropertyDefine.js"), cc._tmp.PrototypeColor(), delete cc._tmp.PrototypeColor)
});
cc.Touches = [];
cc.TouchesIntergerDict = {};
cc.DENSITYDPI_DEVICE = "device-dpi";
cc.DENSITYDPI_HIGH = "high-dpi";
cc.DENSITYDPI_MEDIUM = "medium-dpi";
cc.DENSITYDPI_LOW = "low-dpi";
cc.__BrowserGetter = {
    init: function() {
        this.html = document.getElementsByTagName("html")[0]
    },
    availWidth: function(a) {
        return a && a !== this.html ? a.clientWidth : window.innerWidth
    },
    availHeight: function(a) {
        return a && a !== this.html ? a.clientHeight : window.innerHeight
    },
    meta: {
        width: "device-width",
        "user-scalable": "no"
    },
    adaptationType: cc.sys.browserType
}; -
1 < window.navigator.userAgent.indexOf("OS 8_1_") && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI);
cc.sys.os === cc.sys.OS_IOS && (cc.__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
switch (cc.__BrowserGetter.adaptationType) {
    case cc.sys.BROWSER_TYPE_SAFARI:
        cc.__BrowserGetter.meta["minimal-ui"] = "true";
        cc.__BrowserGetter.availWidth = function(a) {
            return a.clientWidth
        };
        cc.__BrowserGetter.availHeight = function(a) {
            return a.clientHeight
        };
        break;
    case cc.sys.BROWSER_TYPE_CHROME:
        cc.__BrowserGetter.__defineGetter__("target-densitydpi", function() {
            return cc.view._targetDensityDPI
        });
    case cc.sys.BROWSER_TYPE_SOUGOU:
    case cc.sys.BROWSER_TYPE_UC:
        cc.__BrowserGetter.availWidth = function(a) {
            return a.clientWidth
        };
        cc.__BrowserGetter.availHeight = function(a) {
            return a.clientHeight
        };
        break;
    case cc.sys.BROWSER_TYPE_MIUI:
        cc.__BrowserGetter.init = function(a) {
            if (!a.__resizeWithBrowserSize) {
                var b = function() {
                    a.setDesignResolutionSize(a._designResolutionSize.width, a._designResolutionSize.height, a._resolutionPolicy);
                    window.removeEventListener("resize", b, !1)
                };
                window.addEventListener("resize", b, !1)
            }
        }
}
cc.EGLView = cc.Class.extend({
    _delegate: null,
    _frameSize: null,
    _designResolutionSize: null,
    _originalDesignResolutionSize: null,
    _viewPortRect: null,
    _visibleRect: null,
    _retinaEnabled: !1,
    _autoFullScreen: !0,
    _devicePixelRatio: 1,
    _viewName: "",
    _resizeCallback: null,
    _scaleX: 1,
    _originalScaleX: 1,
    _scaleY: 1,
    _originalScaleY: 1,
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _resolutionPolicy: null,
    _rpExactFit: null,
    _rpShowAll: null,
    _rpNoBorder: null,
    _rpFixedHeight: null,
    _rpFixedWidth: null,
    _initialized: !1,
    _captured: !1,
    _wnd: null,
    _hDC: null,
    _hRC: null,
    _supportTouch: !1,
    _contentTranslateLeftTop: null,
    _frame: null,
    _frameZoomFactor: 1,
    __resizeWithBrowserSize: !1,
    _isAdjustViewPort: !0,
    _targetDensityDPI: null,
    ctor: function() {
        var a = document,
            b = cc.ContainerStrategy,
            c = cc.ContentStrategy;
        cc.__BrowserGetter.init(this);
        this._frame = cc.container.parentNode === a.body ? a.documentElement : cc.container.parentNode;
        this._frameSize = cc.size(0, 0);
        this._initFrameSize();
        var a = cc._canvas.width,
            d = cc._canvas.height;
        this._designResolutionSize = cc.size(a, d);
        this._originalDesignResolutionSize =
            cc.size(a, d);
        this._viewPortRect = cc.rect(0, 0, a, d);
        this._visibleRect = cc.rect(0, 0, a, d);
        this._contentTranslateLeftTop = {
            left: 0,
            top: 0
        };
        this._viewName = "Cocos2dHTML5";
        this.enableRetina(!0);
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        this._rpExactFit = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.EXACT_FIT);
        this._rpShowAll = new cc.ResolutionPolicy(b.PROPORTION_TO_FRAME, c.SHOW_ALL);
        this._rpNoBorder = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.NO_BORDER);
        this._rpFixedHeight = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME,
            c.FIXED_HEIGHT);
        this._rpFixedWidth = new cc.ResolutionPolicy(b.EQUAL_TO_FRAME, c.FIXED_WIDTH);
        this._hDC = cc._canvas;
        this._hRC = cc._renderContext;
        this._targetDensityDPI = cc.DENSITYDPI_HIGH
    },
    _resizeEvent: function() {
        var a;
        a = this.setDesignResolutionSize ? this : cc.view;
        var b = a._frameSize.width,
            c = a._frameSize.height;
        a._initFrameSize();
        if (a._frameSize.width !== b || a._frameSize.height !== c) a._resizeCallback && a._resizeCallback.call(), b = a._originalDesignResolutionSize.width, c = a._originalDesignResolutionSize.height, 0 <
            b && a.setDesignResolutionSize(b, c, a._resolutionPolicy)
    },
    setTargetDensityDPI: function(a) {
        this._targetDensityDPI = a;
        this._adjustViewportMeta()
    },
    getTargetDensityDPI: function() {
        return this._targetDensityDPI
    },
    resizeWithBrowserSize: function(a) {
        a ? this.__resizeWithBrowserSize || (this.__resizeWithBrowserSize = !0, window.addEventListener("resize", this._resizeEvent), window.addEventListener("orientationchange", this._resizeEvent)) : this.__resizeWithBrowserSize && (this.__resizeWithBrowserSize = !1, window.removeEventListener("resize",
            this._resizeEvent), window.removeEventListener("orientationchange", this._resizeEvent))
    },
    setResizeCallback: function(a) {
        if (cc.isFunction(a) || null == a) this._resizeCallback = a
    },
    _initFrameSize: function() {
        var a = this._frameSize;
        a.width = cc.__BrowserGetter.availWidth(this._frame);
        a.height = cc.__BrowserGetter.availHeight(this._frame)
    },
    _adjustSizeKeepCanvasSize: function() {
        var a = this._originalDesignResolutionSize.width,
            b = this._originalDesignResolutionSize.height;
        0 < a && this.setDesignResolutionSize(a, b, this._resolutionPolicy)
    },
    _setViewportMeta: function(a, b) {
        var c = document.getElementById("cocosMetaElement");
        c && b && document.head.removeChild(c);
        var d = document.getElementsByName("viewport"),
            d = d ? d[0] : null,
            e, f, g;
        e = d ? d.content : "";
        c = c || document.createElement("meta");
        c.id = "cocosMetaElement";
        c.name = "viewport";
        c.content = "";
        for (f in a) - 1 == e.indexOf(f) ? e += "," + f + "\x3d" + a[f] : b && (g = RegExp(f + "s*\x3ds*[^,]+"), e.replace(g, f + "\x3d" + a[f]));
        /^,/.test(e) && (e = e.substr(1));
        c.content = e;
        d && (d.content = e);
        document.head.appendChild(c)
    },
    _adjustViewportMeta: function() {
        this._isAdjustViewPort &&
            this._setViewportMeta(cc.__BrowserGetter.meta, !1)
    },
    _setScaleXYForRenderTexture: function() {
        var a = cc.contentScaleFactor();
        this._scaleY = this._scaleX = a
    },
    _resetScale: function() {
        this._scaleX = this._originalScaleX;
        this._scaleY = this._originalScaleY
    },
    _adjustSizeToBrowser: function() {},
    initialize: function() {
        this._initialized = !0
    },
    adjustViewPort: function(a) {
        this._isAdjustViewPort = a
    },
    enableRetina: function(a) {
        this._retinaEnabled = a ? !0 : !1
    },
    isRetinaEnabled: function() {
        return this._retinaEnabled
    },
    enableAutoFullScreen: function(a) {
        this._autoFullScreen =
            a ? !0 : !1
    },
    isAutoFullScreenEnabled: function() {
        return this._autoFullScreen
    },
    end: function() {},
    isOpenGLReady: function() {
        return null !== this._hDC && null !== this._hRC
    },
    setFrameZoomFactor: function(a) {
        this._frameZoomFactor = a;
        this.centerWindow();
        cc.director.setProjection(cc.director.getProjection())
    },
    swapBuffers: function() {},
    setIMEKeyboardState: function(a) {},
    setContentTranslateLeftTop: function(a, b) {
        this._contentTranslateLeftTop = {
            left: a,
            top: b
        }
    },
    getContentTranslateLeftTop: function() {
        return this._contentTranslateLeftTop
    },
    getCanvasSize: function() {
        return cc.size(cc._canvas.width, cc._canvas.height)
    },
    getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height)
    },
    setFrameSize: function(a, b) {
        this._frameSize.width = a;
        this._frameSize.height = b;
        this._frame.style.width = a + "px";
        this._frame.style.height = b + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection())
    },
    centerWindow: function() {},
    getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height)
    },
    getVisibleSizeInPixel: function() {
        return cc.size(this._visibleRect.width *
            this._scaleX, this._visibleRect.height * this._scaleY)
    },
    getVisibleOrigin: function() {
        return cc.p(this._visibleRect.x, this._visibleRect.y)
    },
    getVisibleOriginInPixel: function() {
        return cc.p(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY)
    },
    canSetContentScaleFactor: function() {
        return !0
    },
    getResolutionPolicy: function() {
        return this._resolutionPolicy
    },
    setResolutionPolicy: function(a) {
        if (a instanceof cc.ResolutionPolicy) this._resolutionPolicy = a;
        else {
            var b = cc.ResolutionPolicy;
            a === b.EXACT_FIT && (this._resolutionPolicy =
                this._rpExactFit);
            a === b.SHOW_ALL && (this._resolutionPolicy = this._rpShowAll);
            a === b.NO_BORDER && (this._resolutionPolicy = this._rpNoBorder);
            a === b.FIXED_HEIGHT && (this._resolutionPolicy = this._rpFixedHeight);
            a === b.FIXED_WIDTH && (this._resolutionPolicy = this._rpFixedWidth)
        }
    },
    setDesignResolutionSize: function(a, b, c) {
        if (0 < a || 0 < b)
            if (this.setResolutionPolicy(c), c = this._resolutionPolicy) {
                c.preApply(this);
                cc.sys.isMobile && this._adjustViewportMeta();
                this._initFrameSize();
                this._originalDesignResolutionSize.width = this._designResolutionSize.width =
                    a;
                this._originalDesignResolutionSize.height = this._designResolutionSize.height = b;
                var d = c.apply(this, this._designResolutionSize);
                d.scale && 2 === d.scale.length && (this._scaleX = d.scale[0], this._scaleY = d.scale[1]);
                d.viewport && (a = this._viewPortRect, b = this._visibleRect, d = d.viewport, a.x = d.x, a.y = d.y, a.width = d.width, a.height = d.height, b.x = -a.x / this._scaleX, b.y = -a.y / this._scaleY, b.width = cc._canvas.width / this._scaleX, b.height = cc._canvas.height / this._scaleY, cc._renderContext.setOffset && cc._renderContext.setOffset(a.x, -a.y));
                a = cc.director;
                a._winSizeInPoints.width = this._designResolutionSize.width;
                a._winSizeInPoints.height = this._designResolutionSize.height;
                c.postApply(this);
                cc.winSize.width = a._winSizeInPoints.width;
                cc.winSize.height = a._winSizeInPoints.height;
                cc._renderType === cc.game.RENDER_TYPE_WEBGL && a.setGLDefaultValues();
                this._originalScaleX = this._scaleX;
                this._originalScaleY = this._scaleY;
                cc.DOM && cc.DOM._resetEGLViewDiv();
                cc.visibleRect && cc.visibleRect.init(this._visibleRect)
            } else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize_2);
        else cc.log(cc._LogInfos.EGLView_setDesignResolutionSize)
    },
    getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height)
    },
    setRealPixelResolution: function(a, b, c) {
        this._setViewportMeta({
            width: a,
            "target-densitydpi": cc.DENSITYDPI_DEVICE,
            "user-scalable": "no"
        }, !0);
        document.body.style.width = a + "px";
        document.body.style.left = "0px";
        document.body.style.top = "0px";
        this.setDesignResolutionSize(a, b, c)
    },
    setViewPortInPoints: function(a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.viewport(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    setScissorInPoints: function(a, b, c, d) {
        var e = this._frameZoomFactor,
            f = this._scaleX,
            g = this._scaleY;
        cc._renderContext.scissor(a * f * e + this._viewPortRect.x * e, b * g * e + this._viewPortRect.y * e, c * f * e, d * g * e)
    },
    isScissorEnabled: function() {
        var a = cc._renderContext;
        return a.isEnabled(a.SCISSOR_TEST)
    },
    getScissorRect: function() {
        var a = cc._renderContext,
            b = this._scaleX,
            c = this._scaleY,
            a = a.getParameter(a.SCISSOR_BOX);
        return cc.rect((a[0] - this._viewPortRect.x) / b, (a[1] - this._viewPortRect.y) / c, a[2] / b, a[3] / c)
    },
    setViewName: function(a) {
        null != a && 0 < a.length && (this._viewName = a)
    },
    getViewName: function() {
        return this._viewName
    },
    getViewPortRect: function() {
        return this._viewPortRect
    },
    getScaleX: function() {
        return this._scaleX
    },
    getScaleY: function() {
        return this._scaleY
    },
    getDevicePixelRatio: function() {
        return this._devicePixelRatio
    },
    convertToLocationInView: function(a, b, c) {
        return {
            x: this._devicePixelRatio * (a - c.left),
            y: this._devicePixelRatio *
                (c.top + c.height - b)
        }
    },
    _convertMouseToLocationInView: function(a, b) {
        var c = this._viewPortRect;
        a.x = (this._devicePixelRatio * (a.x - b.left) - c.x) / this._scaleX;
        a.y = (this._devicePixelRatio * (b.top + b.height - a.y) - c.y) / this._scaleY
    },
    _convertTouchesWithScale: function(a) {
        for (var b = this._viewPortRect, c = this._scaleX, d = this._scaleY, e, f, g, h = 0; h < a.length; h++) e = a[h], f = e._point, g = e._prevPoint, e._setPoint((f.x - b.x) / c, (f.y - b.y) / d), e._setPrevPoint((g.x - b.x) / c, (g.y - b.y) / d)
    }
});
cc.EGLView._getInstance = function() {
    this._instance || (this._instance = this._instance || new cc.EGLView, this._instance.initialize());
    return this._instance
};
cc.ContainerStrategy = cc.Class.extend({
    preApply: function(a) {},
    apply: function(a, b) {},
    postApply: function(a) {},
    _setupContainer: function(a, b, c) {
        var d = a._frame;
        cc.view._autoFullScreen && cc.sys.isMobile && d === document.documentElement && cc.screen.autoFullScreen(d);
        var d = cc._canvas,
            e = cc.container;
        e.style.width = d.style.width = b + "px";
        e.style.height = d.style.height = c + "px";
        e = a._devicePixelRatio = 1;
        a.isRetinaEnabled() && cc.sys.capabilities.opengl && (e = cc.sys.os === cc.sys.OS_IOS || cc.sys.os === cc.sys.OS_OSX ? a._devicePixelRatio =
            window.devicePixelRatio || 1 : 2 > window.devicePixelRatio ? a._devicePixelRatio = window.devicePixelRatio || 1 : a._devicePixelRatio = 2);
        d.width = b * e;
        d.height = c * e;
        cc._renderContext.resetCache && cc._renderContext.resetCache();
        a = document.body;
        var f;
        a && (f = a.style) && (f.paddingTop = f.paddingTop || "0px", f.paddingRight = f.paddingRight || "0px", f.paddingBottom = f.paddingBottom || "0px", f.paddingLeft = f.paddingLeft || "0px", f.borderTop = f.borderTop || "0px", f.borderRight = f.borderRight || "0px", f.borderBottom = f.borderBottom || "0px", f.borderLeft =
            f.borderLeft || "0px", f.marginTop = f.marginTop || "0px", f.marginRight = f.marginRight || "0px", f.marginBottom = f.marginBottom || "0px", f.marginLeft = f.marginLeft || "0px")
    },
    _fixContainer: function() {
        document.body.insertBefore(cc.container, document.body.firstChild);
        var a = document.body.style;
        a.width = window.innerWidth + "px";
        a.height = window.innerHeight + "px";
        a.overflow = "hidden";
        a = cc.container.style;
        a.position = "fixed";
        a.left = a.top = "0px";
        document.body.scrollTop = 0
    }
});
cc.ContentStrategy = cc.Class.extend({
    _result: {
        scale: [1, 1],
        viewport: null
    },
    _buildResult: function(a, b, c, d, e, f) {
        2 > Math.abs(a - c) && (c = a);
        2 > Math.abs(b - d) && (d = b);
        a = cc.rect(Math.round((a - c) / 2), Math.round((b - d) / 2), c, d);
        this._result.scale = [e, f];
        this._result.viewport = a;
        return this._result
    },
    preApply: function(a) {},
    apply: function(a, b) {
        return {
            scale: [1, 1]
        }
    },
    postApply: function(a) {}
});
(function() {
    var a = cc.ContainerStrategy.extend({
            apply: function(a) {
                this._setupContainer(a, a._frameSize.width, a._frameSize.height)
            }
        }),
        b = cc.ContainerStrategy.extend({
            apply: function(a, b) {
                var c = a._frameSize.width,
                    d = a._frameSize.height,
                    e = cc.container.style,
                    n = b.width,
                    p = b.height,
                    s = c / n,
                    r = d / p,
                    u, t;
                s < r ? (u = c, t = p * s) : (u = n * r, t = d);
                n = Math.round((c - u) / 2);
                t = Math.round((d - t) / 2);
                this._setupContainer(a, c - 2 * n, d - 2 * t);
                e.marginLeft = n + "px";
                e.marginRight = n + "px";
                e.marginTop = t + "px";
                e.marginBottom = t + "px"
            }
        });
    a.extend({
        preApply: function(a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function(a) {
            this._super(a);
            this._fixContainer()
        }
    });
    b.extend({
        preApply: function(a) {
            this._super(a);
            a._frame = document.documentElement
        },
        apply: function(a, b) {
            this._super(a, b);
            this._fixContainer()
        }
    });
    var c = cc.ContainerStrategy.extend({
        apply: function(a) {
            this._setupContainer(a, cc._canvas.width, cc._canvas.height)
        }
    });
    cc.ContainerStrategy.EQUAL_TO_FRAME = new a;
    cc.ContainerStrategy.PROPORTION_TO_FRAME = new b;
    cc.ContainerStrategy.ORIGINAL_CONTAINER = new c;
    var a = cc.ContentStrategy.extend({
            apply: function(a,
                b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height;
                return this._buildResult(c, d, c, d, c / b.width, d / b.height)
            }
        }),
        b = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = b.width,
                    n = b.height,
                    p = c / e,
                    s = d / n,
                    r = 0,
                    u, t;
                p < s ? (r = p, u = c, t = n * r) : (r = s, u = e * r, t = d);
                return this._buildResult(c, d, u, t, r, r)
            }
        }),
        c = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = b.width,
                    n = b.height,
                    p = c / e,
                    s = d / n,
                    r, u, t;
                p < s ? (r = s, u = e * r, t = d) : (r = p, u = c, t = n * r);
                return this._buildResult(c,
                    d, u, t, r, r)
            }
        }),
        d = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = d / b.height;
                return this._buildResult(c, d, c, d, e, e)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        }),
        e = cc.ContentStrategy.extend({
            apply: function(a, b) {
                var c = cc._canvas.width,
                    d = cc._canvas.height,
                    e = c / b.width;
                return this._buildResult(c, d, c, d, e, e)
            },
            postApply: function(a) {
                cc.director._winSizeInPoints = a.getVisibleSize()
            }
        });
    cc.ContentStrategy.EXACT_FIT = new a;
    cc.ContentStrategy.SHOW_ALL =
        new b;
    cc.ContentStrategy.NO_BORDER = new c;
    cc.ContentStrategy.FIXED_HEIGHT = new d;
    cc.ContentStrategy.FIXED_WIDTH = new e
})();
cc.ResolutionPolicy = cc.Class.extend({
    _containerStrategy: null,
    _contentStrategy: null,
    ctor: function(a, b) {
        this.setContainerStrategy(a);
        this.setContentStrategy(b)
    },
    preApply: function(a) {
        this._containerStrategy.preApply(a);
        this._contentStrategy.preApply(a)
    },
    apply: function(a, b) {
        this._containerStrategy.apply(a, b);
        return this._contentStrategy.apply(a, b)
    },
    postApply: function(a) {
        this._containerStrategy.postApply(a);
        this._contentStrategy.postApply(a)
    },
    setContainerStrategy: function(a) {
        a instanceof cc.ContainerStrategy &&
            (this._containerStrategy = a)
    },
    setContentStrategy: function(a) {
        a instanceof cc.ContentStrategy && (this._contentStrategy = a)
    }
});
cc.ResolutionPolicy.EXACT_FIT = 0;
cc.ResolutionPolicy.NO_BORDER = 1;
cc.ResolutionPolicy.SHOW_ALL = 2;
cc.ResolutionPolicy.FIXED_HEIGHT = 3;
cc.ResolutionPolicy.FIXED_WIDTH = 4;
cc.ResolutionPolicy.UNKNOWN = 5;
cc.screen = {
    _supportsFullScreen: !1,
    _preOnFullScreenChange: null,
    _touchEvent: "",
    _fn: null,
    _fnMap: [
        ["requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement"],
        ["requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement"],
        ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement"],
        ["mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen",
            "mozFullScreenElement"
        ],
        ["msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement"]
    ],
    init: function() {
        this._fn = {};
        var a, b, c = this._fnMap,
            d;
        a = 0;
        for (l = c.length; a < l; a++)
            if ((b = c[a]) && b[1] in document) {
                a = 0;
                for (d = b.length; a < d; a++) this._fn[c[0][a]] = b[a];
                break
            }
        this._supportsFullScreen = "undefined" !== typeof this._fn.requestFullscreen;
        this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown"
    },
    fullScreen: function() {
        return this._supportsFullScreen ? void 0 ===
            document[this._fn.fullscreenElement] || null === document[this._fn.fullscreenElement] ? !1 : !0 : !1
    },
    requestFullScreen: function(a, b) {
        if (this._supportsFullScreen) {
            a = a || document.documentElement;
            if (b) {
                var c = this._fn.fullscreenchange;
                this._preOnFullScreenChange && document.removeEventListener(c, this._preOnFullScreenChange);
                this._preOnFullScreenChange = b;
                document.addEventListener(c, b, !1)
            }
            return a[this._fn.requestFullscreen]()
        }
    },
    exitFullScreen: function() {
        return this._supportsFullScreen ? document[this._fn.exitFullscreen]() :
            !0
    },
    autoFullScreen: function(a, b) {
        function c() {
            e.requestFullScreen(a, b);
            d.removeEventListener(e._touchEvent, c)
        }
        a = a || document.body;
        var d = cc._canvas || a,
            e = this;
        this.requestFullScreen(a, b);
        d.addEventListener(this._touchEvent, c)
    }
};
cc.screen.init();
cc.visibleRect = {
    topLeft: cc.p(0, 0),
    topRight: cc.p(0, 0),
    top: cc.p(0, 0),
    bottomLeft: cc.p(0, 0),
    bottomRight: cc.p(0, 0),
    bottom: cc.p(0, 0),
    center: cc.p(0, 0),
    left: cc.p(0, 0),
    right: cc.p(0, 0),
    width: 0,
    height: 0,
    init: function(a) {
        var b = this.width = a.width,
            c = this.height = a.height,
            d = a.x;
        a = a.y;
        var e = a + c,
            f = d + b;
        this.topLeft.x = d;
        this.topLeft.y = e;
        this.topRight.x = f;
        this.topRight.y = e;
        this.top.x = d + b / 2;
        this.top.y = e;
        this.bottomLeft.x = d;
        this.bottomLeft.y = a;
        this.bottomRight.x = f;
        this.bottomRight.y = a;
        this.bottom.x = d + b / 2;
        this.bottom.y =
            a;
        this.center.x = d + b / 2;
        this.center.y = a + c / 2;
        this.left.x = d;
        this.left.y = a + c / 2;
        this.right.x = f;
        this.right.y = a + c / 2
    }
};
cc.UIInterfaceOrientationLandscapeLeft = -90;
cc.UIInterfaceOrientationLandscapeRight = 90;
cc.UIInterfaceOrientationPortraitUpsideDown = 180;
cc.UIInterfaceOrientationPortrait = 0;
cc.inputManager = {
    _mousePressed: !1,
    _isRegisterEvent: !1,
    _preTouchPoint: cc.p(0, 0),
    _prevMousePoint: cc.p(0, 0),
    _preTouchPool: [],
    _preTouchPoolPointer: 0,
    _touches: [],
    _touchesIntegerDict: {},
    _indexBitsUsed: 0,
    _maxTouches: 5,
    _accelEnabled: !1,
    _accelInterval: 1 / 30,
    _accelMinus: 1,
    _accelCurTime: 0,
    _acceleration: null,
    _accelDeviceEvent: null,
    _getUnUsedIndex: function() {
        for (var a = this._indexBitsUsed, b = 0; b < this._maxTouches; b++) {
            if (!(a & 1)) return this._indexBitsUsed |= 1 << b, b;
            a >>= 1
        }
        return -1
    },
    _removeUsedIndexBit: function(a) {
        0 > a ||
            a >= this._maxTouches || (a = ~(1 << a), this._indexBitsUsed &= a)
    },
    _glView: null,
    handleTouchesBegin: function(a) {
        for (var b, c, d, e = [], f = this._touchesIntegerDict, g = 0, h = a.length; g < h; g++)
            if (b = a[g], d = b.getID(), c = f[d], null == c) {
                var k = this._getUnUsedIndex(); - 1 === k ? cc.log(cc._LogInfos.inputManager_handleTouchesBegin, k) : (c = this._touches[k] = new cc.Touch(b._point.x, b._point.y, b.getID()), c._setPrevPoint(b._prevPoint), f[d] = k, e.push(c))
            }
        0 < e.length && (this._glView._convertTouchesWithScale(e), a = new cc.EventTouch(e), a._eventCode =
            cc.EventTouch.EventCode.BEGAN, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesMove: function(a) {
        for (var b, c, d = [], e = this._touches, f = 0, g = a.length; f < g; f++) b = a[f], c = b.getID(), c = this._touchesIntegerDict[c], null != c && e[c] && (e[c]._setPoint(b._point), e[c]._setPrevPoint(b._prevPoint), d.push(e[c]));
        0 < d.length && (this._glView._convertTouchesWithScale(d), a = new cc.EventTouch(d), a._eventCode = cc.EventTouch.EventCode.MOVED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesEnd: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.ENDED, cc.eventManager.dispatchEvent(a))
    },
    handleTouchesCancel: function(a) {
        a = this.getSetOfTouchesEndOrCancel(a);
        0 < a.length && (this._glView._convertTouchesWithScale(a), a = new cc.EventTouch(a), a._eventCode = cc.EventTouch.EventCode.CANCELLED, cc.eventManager.dispatchEvent(a))
    },
    getSetOfTouchesEndOrCancel: function(a) {
        for (var b, c, d, e = [], f = this._touches, g = this._touchesIntegerDict, h = 0, k = a.length; h <
            k; h++) b = a[h], d = b.getID(), c = g[d], null != c && f[c] && (f[c]._setPoint(b._point), f[c]._setPrevPoint(b._prevPoint), e.push(f[c]), this._removeUsedIndexBit(c), delete g[d]);
        return e
    },
    getHTMLElementPosition: function(a) {
        var b = document.documentElement,
            c = window,
            d = null,
            d = cc.isFunction(a.getBoundingClientRect) ? a.getBoundingClientRect() : a instanceof HTMLCanvasElement ? {
                left: 0,
                top: 0,
                width: a.width,
                height: a.height
            } : {
                left: 0,
                top: 0,
                width: parseInt(a.style.width),
                height: parseInt(a.style.height)
            };
        return {
            left: d.left + c.pageXOffset -
                b.clientLeft,
            top: d.top + c.pageYOffset - b.clientTop,
            width: d.width,
            height: d.height
        }
    },
    getPreTouch: function(a) {
        for (var b = null, c = this._preTouchPool, d = a.getID(), e = c.length - 1; 0 <= e; e--)
            if (c[e].getID() === d) {
                b = c[e];
                break
            }
        b || (b = a);
        return b
    },
    setPreTouch: function(a) {
        for (var b = !1, c = this._preTouchPool, d = a.getID(), e = c.length - 1; 0 <= e; e--)
            if (c[e].getID() === d) {
                c[e] = a;
                b = !0;
                break
            }
        b || (50 >= c.length ? c.push(a) : (c[this._preTouchPoolPointer] = a, this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50))
    },
    getTouchByXY: function(a,
        b, c) {
        var d = this._preTouchPoint;
        a = this._glView.convertToLocationInView(a, b, c);
        b = new cc.Touch(a.x, a.y);
        b._setPrevPoint(d.x, d.y);
        d.x = a.x;
        d.y = a.y;
        return b
    },
    getMouseEvent: function(a, b, c) {
        var d = this._prevMousePoint;
        this._glView._convertMouseToLocationInView(a, b);
        b = new cc.EventMouse(c);
        b.setLocation(a.x, a.y);
        b._setPrevCursor(d.x, d.y);
        d.x = a.x;
        d.y = a.y;
        return b
    },
    getPointByEvent: function(a, b) {
        if (null != a.pageX) return {
            x: a.pageX,
            y: a.pageY
        };
        b.left -= document.body.scrollLeft;
        b.top -= document.body.scrollTop;
        return {
            x: a.clientX,
            y: a.clientY
        }
    },
    getTouchesByEvent: function(a, b) {
        for (var c = [], d = this._glView, e, f, g = this._preTouchPoint, h = a.changedTouches.length, k = 0; k < h; k++)
            if (e = a.changedTouches[k]) {
                var m;
                m = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? d.convertToLocationInView(e.pageX, e.pageY, b) : d.convertToLocationInView(e.clientX, e.clientY, b);
                null != e.identifier ? (e = new cc.Touch(m.x, m.y, e.identifier), f = this.getPreTouch(e).getLocation(), e._setPrevPoint(f.x, f.y), this.setPreTouch(e)) : (e = new cc.Touch(m.x, m.y), e._setPrevPoint(g.x, g.y));
                g.x = m.x;
                g.y = m.y;
                c.push(e)
            }
        return c
    },
    registerSystemEvent: function(a) {
        if (!this._isRegisterEvent) {
            this._glView = cc.view;
            var b = this,
                c = "mouse" in cc.sys.capabilities,
                d = "touches" in cc.sys.capabilities,
                e = !1;
            cc.sys.isMobile && (e = !0);
            c && (window.addEventListener("mousedown", function() {
                    b._mousePressed = !0
                }, !1), window.addEventListener("mouseup", function(c) {
                    if (!e) {
                        var d = b._mousePressed;
                        b._mousePressed = !1;
                        if (d) {
                            var d = b.getHTMLElementPosition(a),
                                f = b.getPointByEvent(c, d);
                            cc.rectContainsPoint(new cc.Rect(d.left, d.top,
                                d.width, d.height), f) || (b.handleTouchesEnd([b.getTouchByXY(f.x, f.y, d)]), d = b.getMouseEvent(f, d, cc.EventMouse.UP), d.setButton(c.button), cc.eventManager.dispatchEvent(d))
                        }
                    }
                }, !1), a.addEventListener("mousedown", function(c) {
                    if (!e) {
                        b._mousePressed = !0;
                        var d = b.getHTMLElementPosition(a),
                            f = b.getPointByEvent(c, d);
                        b.handleTouchesBegin([b.getTouchByXY(f.x, f.y, d)]);
                        d = b.getMouseEvent(f, d, cc.EventMouse.DOWN);
                        d.setButton(c.button);
                        cc.eventManager.dispatchEvent(d);
                        c.stopPropagation();
                        c.preventDefault();
                        a.focus()
                    }
                }, !1),
                a.addEventListener("mouseup", function(c) {
                    if (!e) {
                        b._mousePressed = !1;
                        var d = b.getHTMLElementPosition(a),
                            f = b.getPointByEvent(c, d);
                        b.handleTouchesEnd([b.getTouchByXY(f.x, f.y, d)]);
                        d = b.getMouseEvent(f, d, cc.EventMouse.UP);
                        d.setButton(c.button);
                        cc.eventManager.dispatchEvent(d);
                        c.stopPropagation();
                        c.preventDefault()
                    }
                }, !1), a.addEventListener("mousemove", function(c) {
                    if (!e) {
                        var d = b.getHTMLElementPosition(a),
                            f = b.getPointByEvent(c, d);
                        b.handleTouchesMove([b.getTouchByXY(f.x, f.y, d)]);
                        d = b.getMouseEvent(f, d, cc.EventMouse.MOVE);
                        b._mousePressed ? d.setButton(c.button) : d.setButton(null);
                        cc.eventManager.dispatchEvent(d);
                        c.stopPropagation();
                        c.preventDefault()
                    }
                }, !1), a.addEventListener("mousewheel", function(c) {
                    var d = b.getHTMLElementPosition(a),
                        e = b.getPointByEvent(c, d),
                        d = b.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                    d.setButton(c.button);
                    d.setScrollData(0, c.wheelDelta);
                    cc.eventManager.dispatchEvent(d);
                    c.stopPropagation();
                    c.preventDefault()
                }, !1), a.addEventListener("DOMMouseScroll", function(c) {
                    var d = b.getHTMLElementPosition(a),
                        e = b.getPointByEvent(c,
                            d),
                        d = b.getMouseEvent(e, d, cc.EventMouse.SCROLL);
                    d.setButton(c.button);
                    d.setScrollData(0, -120 * c.detail);
                    cc.eventManager.dispatchEvent(d);
                    c.stopPropagation();
                    c.preventDefault()
                }, !1));
            if (window.navigator.msPointerEnabled) {
                var c = {
                        MSPointerDown: b.handleTouchesBegin,
                        MSPointerMove: b.handleTouchesMove,
                        MSPointerUp: b.handleTouchesEnd,
                        MSPointerCancel: b.handleTouchesCancel
                    },
                    f;
                for (f in c)(function(c, d) {
                    a.addEventListener(c, function(c) {
                        var e = b.getHTMLElementPosition(a);
                        e.left -= document.documentElement.scrollLeft;
                        e.top -= document.documentElement.scrollTop;
                        d.call(b, [b.getTouchByXY(c.clientX, c.clientY, e)]);
                        c.stopPropagation()
                    }, !1)
                })(f, c[f])
            }
            d && (a.addEventListener("touchstart", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    b.handleTouchesBegin(b.getTouchesByEvent(c, d));
                    c.stopPropagation();
                    c.preventDefault();
                    a.focus()
                }
            }, !1), a.addEventListener("touchmove", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -=
                        document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    b.handleTouchesMove(b.getTouchesByEvent(c, d));
                    c.stopPropagation();
                    c.preventDefault()
                }
            }, !1), a.addEventListener("touchend", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -= document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    b.handleTouchesEnd(b.getTouchesByEvent(c, d));
                    c.stopPropagation();
                    c.preventDefault()
                }
            }, !1), a.addEventListener("touchcancel", function(c) {
                if (c.changedTouches) {
                    var d = b.getHTMLElementPosition(a);
                    d.left -=
                        document.body.scrollLeft;
                    d.top -= document.body.scrollTop;
                    b.handleTouchesCancel(b.getTouchesByEvent(c, d));
                    c.stopPropagation();
                    c.preventDefault()
                }
            }, !1));
            this._registerKeyboardEvent();
            this._registerAccelerometerEvent();
            this._isRegisterEvent = !0
        }
    },
    _registerKeyboardEvent: function() {},
    _registerAccelerometerEvent: function() {},
    update: function(a) {
        this._accelCurTime > this._accelInterval && (this._accelCurTime -= this._accelInterval, cc.eventManager.dispatchEvent(new cc.EventAcceleration(this._acceleration)));
        this._accelCurTime +=
            a
    }
};
_p = cc.inputManager;
_p.setAccelerometerEnabled = function(a) {
    this._accelEnabled !== a && (this._accelEnabled = a, a = cc.director.getScheduler(), this._accelCurTime = 0, a.scheduleUpdate(this))
};
_p.setAccelerometerInterval = function(a) {
    this._accelInterval !== a && (this._accelInterval = a)
};
_p._registerKeyboardEvent = function() {
    cc._canvas.addEventListener("keydown", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !0));
        a.stopPropagation();
        a.preventDefault()
    }, !1);
    cc._canvas.addEventListener("keyup", function(a) {
        cc.eventManager.dispatchEvent(new cc.EventKeyboard(a.keyCode, !1));
        a.stopPropagation();
        a.preventDefault()
    }, !1)
};
_p._registerAccelerometerEvent = function() {
    var a = window;
    this._acceleration = new cc.Acceleration;
    this._accelDeviceEvent = a.DeviceMotionEvent || a.DeviceOrientationEvent;
    cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (this._accelDeviceEvent = window.DeviceOrientationEvent);
    var b = this._accelDeviceEvent === a.DeviceMotionEvent ? "devicemotion" : "deviceorientation",
        c = navigator.userAgent;
    if (/Android/.test(c) || /Adr/.test(c) && cc.sys.browserType === cc.BROWSER_TYPE_UC) this._minus = -1;
    a.addEventListener(b, this.didAccelerate.bind(this), !1)
};
_p.didAccelerate = function(a) {
    var b = window;
    if (this._accelEnabled) {
        var c = this._acceleration,
            d, e, f;
        this._accelDeviceEvent === window.DeviceMotionEvent ? (f = a.accelerationIncludingGravity, d = this._accelMinus * f.x * 0.1, e = this._accelMinus * f.y * 0.1, f = 0.1 * f.z) : (d = a.gamma / 90 * 0.981, e = 0.981 * -(a.beta / 90), f = a.alpha / 90 * 0.981);
        cc.sys.os === cc.sys.OS_ANDROID ? (c.x = -d, c.y = -e) : (c.x = d, c.y = e);
        c.z = f;
        c.timestamp = a.timeStamp || Date.now();
        a = c.x;
        b.orientation === cc.UIInterfaceOrientationLandscapeRight ? (c.x = -c.y, c.y = a) : b.orientation === cc.UIInterfaceOrientationLandscapeLeft ?
            (c.x = c.y, c.y = -a) : b.orientation === cc.UIInterfaceOrientationPortraitUpsideDown && (c.x = -c.x, c.y = -c.y)
    }
};
delete _p;
cc.AffineTransform = function(a, b, c, d, e, f) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.tx = e;
    this.ty = f
};
cc.affineTransformMake = function(a, b, c, d, e, f) {
    return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: e,
        ty: f
    }
};
cc.pointApplyAffineTransform = function(a, b, c) {
    var d;
    void 0 === c ? (c = b, d = a.x, a = a.y) : (d = a, a = b);
    return {
        x: c.a * d + c.c * a + c.tx,
        y: c.b * d + c.d * a + c.ty
    }
};
cc._pointApplyAffineTransform = function(a, b, c) {
    return cc.pointApplyAffineTransform(a, b, c)
};
cc.sizeApplyAffineTransform = function(a, b) {
    return {
        width: b.a * a.width + b.c * a.height,
        height: b.b * a.width + b.d * a.height
    }
};
cc.affineTransformMakeIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.affineTransformIdentity = function() {
    return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    }
};
cc.rectApplyAffineTransform = function(a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc.pointApplyAffineTransform(d, c, b),
        c = cc.pointApplyAffineTransform(e, c, b),
        d = cc.pointApplyAffineTransform(d, f, b),
        h = cc.pointApplyAffineTransform(e, f, b),
        e = Math.min(g.x, c.x, d.x, h.x),
        f = Math.max(g.x, c.x, d.x, h.x),
        k = Math.min(g.y, c.y, d.y, h.y),
        g = Math.max(g.y, c.y, d.y, h.y);
    return cc.rect(e, k, f - e, g - k)
};
cc._rectApplyAffineTransformIn = function(a, b) {
    var c = cc.rectGetMinY(a),
        d = cc.rectGetMinX(a),
        e = cc.rectGetMaxX(a),
        f = cc.rectGetMaxY(a),
        g = cc.pointApplyAffineTransform(d, c, b),
        c = cc.pointApplyAffineTransform(e, c, b),
        d = cc.pointApplyAffineTransform(d, f, b),
        h = cc.pointApplyAffineTransform(e, f, b),
        e = Math.min(g.x, c.x, d.x, h.x),
        f = Math.max(g.x, c.x, d.x, h.x),
        k = Math.min(g.y, c.y, d.y, h.y),
        g = Math.max(g.y, c.y, d.y, h.y);
    a.x = e;
    a.y = k;
    a.width = f - e;
    a.height = g - k;
    return a
};
cc.affineTransformTranslate = function(a, b, c) {
    return {
        a: a.a,
        b: a.b,
        c: a.c,
        d: a.d,
        tx: a.tx + a.a * b + a.c * c,
        ty: a.ty + a.b * b + a.d * c
    }
};
cc.affineTransformScale = function(a, b, c) {
    return {
        a: a.a * b,
        b: a.b * b,
        c: a.c * c,
        d: a.d * c,
        tx: a.tx,
        ty: a.ty
    }
};
cc.affineTransformRotate = function(a, b) {
    var c = Math.sin(b),
        d = Math.cos(b);
    return {
        a: a.a * d + a.c * c,
        b: a.b * d + a.d * c,
        c: a.c * d - a.a * c,
        d: a.d * d - a.b * c,
        tx: a.tx,
        ty: a.ty
    }
};
cc.affineTransformConcat = function(a, b) {
    return {
        a: a.a * b.a + a.b * b.c,
        b: a.a * b.b + a.b * b.d,
        c: a.c * b.a + a.d * b.c,
        d: a.c * b.b + a.d * b.d,
        tx: a.tx * b.a + a.ty * b.c + b.tx,
        ty: a.tx * b.b + a.ty * b.d + b.ty
    }
};
cc.affineTransformConcatIn = function(a, b) {
    var c = a.a,
        d = a.b,
        e = a.c,
        f = a.d,
        g = a.tx,
        h = a.ty;
    a.a = c * b.a + d * b.c;
    a.b = c * b.b + d * b.d;
    a.c = e * b.a + f * b.c;
    a.d = e * b.b + f * b.d;
    a.tx = g * b.a + h * b.c + b.tx;
    a.ty = g * b.b + h * b.d + b.ty;
    return a
};
cc.affineTransformEqualToTransform = function(a, b) {
    return a.a === b.a && a.b === b.b && a.c === b.c && a.d === b.d && a.tx === b.tx && a.ty === b.ty
};
cc.affineTransformInvert = function(a) {
    var b = 1 / (a.a * a.d - a.b * a.c);
    return {
        a: b * a.d,
        b: -b * a.b,
        c: -b * a.c,
        d: b * a.a,
        tx: b * (a.c * a.ty - a.d * a.tx),
        ty: b * (a.b * a.tx - a.a * a.ty)
    }
};
cc.POINT_EPSILON = parseFloat("1.192092896e-07F");
cc.pNeg = function(a) {
    return cc.p(-a.x, -a.y)
};
cc.pAdd = function(a, b) {
    return cc.p(a.x + b.x, a.y + b.y)
};
cc.pSub = function(a, b) {
    return cc.p(a.x - b.x, a.y - b.y)
};
cc.pMult = function(a, b) {
    return cc.p(a.x * b, a.y * b)
};
cc.pMidpoint = function(a, b) {
    return cc.pMult(cc.pAdd(a, b), 0.5)
};
cc.pDot = function(a, b) {
    return a.x * b.x + a.y * b.y
};
cc.pCross = function(a, b) {
    return a.x * b.y - a.y * b.x
};
cc.pPerp = function(a) {
    return cc.p(-a.y, a.x)
};
cc.pRPerp = function(a) {
    return cc.p(a.y, -a.x)
};
cc.pProject = function(a, b) {
    return cc.pMult(b, cc.pDot(a, b) / cc.pDot(b, b))
};
cc.pRotate = function(a, b) {
    return cc.p(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x)
};
cc.pUnrotate = function(a, b) {
    return cc.p(a.x * b.x + a.y * b.y, a.y * b.x - a.x * b.y)
};
cc.pLengthSQ = function(a) {
    return cc.pDot(a, a)
};
cc.pDistanceSQ = function(a, b) {
    return cc.pLengthSQ(cc.pSub(a, b))
};
cc.pLength = function(a) {
    return Math.sqrt(cc.pLengthSQ(a))
};
cc.pDistance = function(a, b) {
    return cc.pLength(cc.pSub(a, b))
};
cc.pNormalize = function(a) {
    var b = cc.pLength(a);
    return 0 === b ? cc.p(a) : cc.pMult(a, 1 / b)
};
cc.pForAngle = function(a) {
    return cc.p(Math.cos(a), Math.sin(a))
};
cc.pToAngle = function(a) {
    return Math.atan2(a.y, a.x)
};
cc.clampf = function(a, b, c) {
    if (b > c) {
        var d = b;
        b = c;
        c = d
    }
    return a < b ? b : a < c ? a : c
};
cc.pClamp = function(a, b, c) {
    return cc.p(cc.clampf(a.x, b.x, c.x), cc.clampf(a.y, b.y, c.y))
};
cc.pFromSize = function(a) {
    return cc.p(a.width, a.height)
};
cc.pCompOp = function(a, b) {
    return cc.p(b(a.x), b(a.y))
};
cc.pLerp = function(a, b, c) {
    return cc.pAdd(cc.pMult(a, 1 - c), cc.pMult(b, c))
};
cc.pFuzzyEqual = function(a, b, c) {
    return a.x - c <= b.x && b.x <= a.x + c && a.y - c <= b.y && b.y <= a.y + c ? !0 : !1
};
cc.pCompMult = function(a, b) {
    return cc.p(a.x * b.x, a.y * b.y)
};
cc.pAngleSigned = function(a, b) {
    var c = cc.pNormalize(a),
        d = cc.pNormalize(b),
        c = Math.atan2(c.x * d.y - c.y * d.x, cc.pDot(c, d));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pAngle = function(a, b) {
    var c = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
    return Math.abs(c) < cc.POINT_EPSILON ? 0 : c
};
cc.pRotateByAngle = function(a, b, c) {
    a = cc.pSub(a, b);
    var d = Math.cos(c);
    c = Math.sin(c);
    var e = a.x;
    a.x = e * d - a.y * c + b.x;
    a.y = e * c + a.y * d + b.y;
    return a
};
cc.pLineIntersect = function(a, b, c, d, e) {
    if (a.x === b.x && a.y === b.y || c.x === d.x && c.y === d.y) return !1;
    var f = b.x - a.x;
    b = b.y - a.y;
    var g = d.x - c.x;
    d = d.y - c.y;
    var h = a.x - c.x;
    a = a.y - c.y;
    c = d * f - g * b;
    e.x = g * a - d * h;
    e.y = f * a - b * h;
    if (0 === c) return 0 === e.x || 0 === e.y ? !0 : !1;
    e.x /= c;
    e.y /= c;
    return !0
};
cc.pSegmentIntersect = function(a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) && 0 <= e.x && 1 >= e.x && 0 <= e.y && 1 >= e.y ? !0 : !1
};
cc.pIntersectPoint = function(a, b, c, d) {
    var e = cc.p(0, 0);
    return cc.pLineIntersect(a, b, c, d, e) ? (c = cc.p(0, 0), c.x = a.x + e.x * (b.x - a.x), c.y = a.y + e.x * (b.y - a.y), c) : cc.p(0, 0)
};
cc.pSameAs = function(a, b) {
    return null != a && null != b ? a.x === b.x && a.y === b.y : !1
};
cc.pZeroIn = function(a) {
    a.x = 0;
    a.y = 0
};
cc.pIn = function(a, b) {
    a.x = b.x;
    a.y = b.y
};
cc.pMultIn = function(a, b) {
    a.x *= b;
    a.y *= b
};
cc.pSubIn = function(a, b) {
    a.x -= b.x;
    a.y -= b.y
};
cc.pAddIn = function(a, b) {
    a.x += b.x;
    a.y += b.y
};
cc.pNormalizeIn = function(a) {
    cc.pMultIn(a, 1 / Math.sqrt(a.x * a.x + a.y * a.y))
};
cc.vertexLineToPolygon = function(a, b, c, d, e) {
    e += d;
    if (!(1 >= e)) {
        b *= 0.5;
        for (var f, g = e - 1, h = d; h < e; h++) {
            f = 2 * h;
            var k = cc.p(a[2 * h], a[2 * h + 1]),
                m;
            if (0 === h) m = cc.pPerp(cc.pNormalize(cc.pSub(k, cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]))));
            else if (h === g) m = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]), k)));
            else {
                m = cc.p(a[2 * (h - 1)], a[2 * (h - 1) + 1]);
                var n = cc.p(a[2 * (h + 1)], a[2 * (h + 1) + 1]),
                    p = cc.pNormalize(cc.pSub(n, k)),
                    s = cc.pNormalize(cc.pSub(m, k)),
                    r = Math.acos(cc.pDot(p, s));
                m = r < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(p,
                    s))) : r < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(p, s)) : cc.pPerp(cc.pNormalize(cc.pSub(n, m)))
            }
            m = cc.pMult(m, b);
            c[2 * f] = k.x + m.x;
            c[2 * f + 1] = k.y + m.y;
            c[2 * (f + 1)] = k.x - m.x;
            c[2 * (f + 1) + 1] = k.y - m.y
        }
        for (h = 0 === d ? 0 : d - 1; h < g; h++) f = 2 * h, a = f + 2, b = cc.vertex2(c[2 * f], c[2 * f + 1]), e = cc.vertex2(c[2 * (f + 1)], c[2 * (f + 1) + 1]), f = cc.vertex2(c[2 * a], c[2 * a]), d = cc.vertex2(c[2 * (a + 1)], c[2 * (a + 1) + 1]), b = !cc.vertexLineIntersect(b.x, b.y, d.x, d.y, e.x, e.y, f.x, f.y), !b.isSuccess && (0 > b.value || 1 < b.value) && (b.isSuccess = !0), b.isSuccess && (c[2 * a] = d.x,
            c[2 * a + 1] = d.y, c[2 * (a + 1)] = f.x, c[2 * (a + 1) + 1] = f.y)
    }
};
cc.vertexLineIntersect = function(a, b, c, d, e, f, g, h) {
    if (a === c && b === d || e === g && f === h) return {
        isSuccess: !1,
        value: 0
    };
    c -= a;
    d -= b;
    e -= a;
    f -= b;
    g -= a;
    h -= b;
    a = Math.sqrt(c * c + d * d);
    c /= a;
    d /= a;
    b = e * c + f * d;
    f = f * c - e * d;
    e = b;
    b = g * c + h * d;
    h = h * c - g * d;
    g = b;
    return f === h ? {
        isSuccess: !1,
        value: 0
    } : {
        isSuccess: !0,
        value: (g + (e - g) * h / (h - f)) / a
    }
};
cc.vertexListIsClockwise = function(a) {
    for (var b = 0, c = a.length; b < c; b++) {
        var d = a[(b + 1) % c],
            e = a[(b + 2) % c];
        if (0 < cc.pCross(cc.pSub(d, a[b]), cc.pSub(e, d))) return !1
    }
    return !0
};
cc.CGAffineToGL = function(a, b) {
    b[2] = b[3] = b[6] = b[7] = b[8] = b[9] = b[11] = b[14] = 0;
    b[10] = b[15] = 1;
    b[0] = a.a;
    b[4] = a.c;
    b[12] = a.tx;
    b[1] = a.b;
    b[5] = a.d;
    b[13] = a.ty
};
cc.GLToCGAffine = function(a, b) {
    b.a = a[0];
    b.c = a[4];
    b.tx = a[12];
    b.b = a[1];
    b.d = a[5];
    b.ty = a[13]
};
cc.Touch = cc.Class.extend({
    _point: null,
    _prevPoint: null,
    _id: 0,
    _startPointCaptured: !1,
    _startPoint: null,
    ctor: function(a, b, c) {
        this.setTouchInfo(c, a, b)
    },
    getLocation: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getLocationX: function() {
        return this._point.x
    },
    getLocationY: function() {
        return this._point.y
    },
    getPreviousLocation: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocation: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getDelta: function() {
        return cc.pSub(this._point,
            this._prevPoint)
    },
    getLocationInView: function() {
        return {
            x: this._point.x,
            y: this._point.y
        }
    },
    getPreviousLocationInView: function() {
        return {
            x: this._prevPoint.x,
            y: this._prevPoint.y
        }
    },
    getStartLocationInView: function() {
        return {
            x: this._startPoint.x,
            y: this._startPoint.y
        }
    },
    getID: function() {
        return this._id
    },
    getId: function() {
        cc.log("getId is deprecated. Please use getID instead.");
        return this._id
    },
    setTouchInfo: function(a, b, c) {
        this._prevPoint = this._point;
        this._point = cc.p(b || 0, c || 0);
        this._id = a;
        this._startPointCaptured ||
            (this._startPoint = cc.p(this._point), this._startPointCaptured = !0)
    },
    _setPoint: function(a, b) {
        void 0 === b ? (this._point.x = a.x, this._point.y = a.y) : (this._point.x = a, this._point.y = b)
    },
    _setPrevPoint: function(a, b) {
        this._prevPoint = void 0 === b ? cc.p(a.x, a.y) : cc.p(a || 0, b || 0)
    }
});
cc.Event = cc.Class.extend({
    _type: 0,
    _isStopped: !1,
    _currentTarget: null,
    _setCurrentTarget: function(a) {
        this._currentTarget = a
    },
    ctor: function(a) {
        this._type = a
    },
    getType: function() {
        return this._type
    },
    stopPropagation: function() {
        this._isStopped = !0
    },
    isStopped: function() {
        return this._isStopped
    },
    getCurrentTarget: function() {
        return this._currentTarget
    }
});
cc.Event.TOUCH = 0;
cc.Event.KEYBOARD = 1;
cc.Event.ACCELERATION = 2;
cc.Event.MOUSE = 3;
cc.Event.FOCUS = 4;
cc.Event.CUSTOM = 6;
cc.EventCustom = cc.Event.extend({
    _eventName: null,
    _userData: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.CUSTOM);
        this._eventName = a
    },
    setUserData: function(a) {
        this._userData = a
    },
    getUserData: function() {
        return this._userData
    },
    getEventName: function() {
        return this._eventName
    }
});
cc.EventMouse = cc.Event.extend({
    _eventType: 0,
    _button: 0,
    _x: 0,
    _y: 0,
    _prevX: 0,
    _prevY: 0,
    _scrollX: 0,
    _scrollY: 0,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.MOUSE);
        this._eventType = a
    },
    setScrollData: function(a, b) {
        this._scrollX = a;
        this._scrollY = b
    },
    getScrollX: function() {
        return this._scrollX
    },
    getScrollY: function() {
        return this._scrollY
    },
    setLocation: function(a, b) {
        this._x = a;
        this._y = b
    },
    getLocation: function() {
        return {
            x: this._x,
            y: this._y
        }
    },
    getLocationInView: function() {
        return {
            x: this._x,
            y: cc.view._designResolutionSize.height -
                this._y
        }
    },
    _setPrevCursor: function(a, b) {
        this._prevX = a;
        this._prevY = b
    },
    getDelta: function() {
        return {
            x: this._x - this._prevX,
            y: this._y - this._prevY
        }
    },
    getDeltaX: function() {
        return this._x - this._prevX
    },
    getDeltaY: function() {
        return this._y - this._prevY
    },
    setButton: function(a) {
        this._button = a
    },
    getButton: function() {
        return this._button
    },
    getLocationX: function() {
        return this._x
    },
    getLocationY: function() {
        return this._y
    }
});
cc.EventMouse.NONE = 0;
cc.EventMouse.DOWN = 1;
cc.EventMouse.UP = 2;
cc.EventMouse.MOVE = 3;
cc.EventMouse.SCROLL = 4;
cc.EventMouse.BUTTON_LEFT = 0;
cc.EventMouse.BUTTON_RIGHT = 2;
cc.EventMouse.BUTTON_MIDDLE = 1;
cc.EventMouse.BUTTON_4 = 3;
cc.EventMouse.BUTTON_5 = 4;
cc.EventMouse.BUTTON_6 = 5;
cc.EventMouse.BUTTON_7 = 6;
cc.EventMouse.BUTTON_8 = 7;
cc.EventTouch = cc.Event.extend({
    _eventCode: 0,
    _touches: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.TOUCH);
        this._touches = a || []
    },
    getEventCode: function() {
        return this._eventCode
    },
    getTouches: function() {
        return this._touches
    },
    _setEventCode: function(a) {
        this._eventCode = a
    },
    _setTouches: function(a) {
        this._touches = a
    }
});
cc.EventTouch.MAX_TOUCHES = 5;
cc.EventTouch.EventCode = {
    BEGAN: 0,
    MOVED: 1,
    ENDED: 2,
    CANCELLED: 3
};
cc.EventFocus = cc.Event.extend({
    _widgetGetFocus: null,
    _widgetLoseFocus: null,
    ctor: function(a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.FOCUS);
        this._widgetGetFocus = b;
        this._widgetLoseFocus = a
    }
});
cc.EventListener = cc.Class.extend({
    _onEvent: null,
    _type: 0,
    _listenerID: null,
    _registered: !1,
    _fixedPriority: 0,
    _node: null,
    _paused: !0,
    _isEnabled: !0,
    ctor: function(a, b, c) {
        this._onEvent = c;
        this._type = a || 0;
        this._listenerID = b || ""
    },
    _setPaused: function(a) {
        this._paused = a
    },
    _isPaused: function() {
        return this._paused
    },
    _setRegistered: function(a) {
        this._registered = a
    },
    _isRegistered: function() {
        return this._registered
    },
    _getType: function() {
        return this._type
    },
    _getListenerID: function() {
        return this._listenerID
    },
    _setFixedPriority: function(a) {
        this._fixedPriority =
            a
    },
    _getFixedPriority: function() {
        return this._fixedPriority
    },
    _setSceneGraphPriority: function(a) {
        this._node = a
    },
    _getSceneGraphPriority: function() {
        return this._node
    },
    checkAvailable: function() {
        return null !== this._onEvent
    },
    clone: function() {
        return null
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    retain: function() {},
    release: function() {}
});
cc.EventListener.UNKNOWN = 0;
cc.EventListener.TOUCH_ONE_BY_ONE = 1;
cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
cc.EventListener.KEYBOARD = 3;
cc.EventListener.MOUSE = 4;
cc.EventListener.ACCELERATION = 5;
cc.EventListener.ACCELERATION = 6;
cc.EventListener.CUSTOM = 8;
cc.EventListener.FOCUS = 7;
cc._EventListenerCustom = cc.EventListener.extend({
    _onCustomEvent: null,
    ctor: function(a, b) {
        this._onCustomEvent = b;
        var c = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, a, function(a) {
            null !== c._onCustomEvent && c._onCustomEvent(a)
        })
    },
    checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent
    },
    clone: function() {
        return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent)
    }
});
cc._EventListenerCustom.create = function(a, b) {
    return new cc._EventListenerCustom(a, b)
};
cc._EventListenerMouse = cc.EventListener.extend({
    onMouseDown: null,
    onMouseUp: null,
    onMouseMove: null,
    onMouseScroll: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, function(b) {
            var c = cc.EventMouse;
            switch (b._eventType) {
                case c.DOWN:
                    if (a.onMouseDown) a.onMouseDown(b);
                    break;
                case c.UP:
                    if (a.onMouseUp) a.onMouseUp(b);
                    break;
                case c.MOVE:
                    if (a.onMouseMove) a.onMouseMove(b);
                    break;
                case c.SCROLL:
                    if (a.onMouseScroll) a.onMouseScroll(b)
            }
        })
    },
    clone: function() {
        var a = new cc._EventListenerMouse;
        a.onMouseDown = this.onMouseDown;
        a.onMouseUp = this.onMouseUp;
        a.onMouseMove = this.onMouseMove;
        a.onMouseScroll = this.onMouseScroll;
        return a
    },
    checkAvailable: function() {
        return !0
    }
});
cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
cc._EventListenerMouse.create = function() {
    return new cc._EventListenerMouse
};
cc._EventListenerTouchOneByOne = cc.EventListener.extend({
    _claimedTouches: null,
    swallowTouches: !1,
    onTouchBegan: null,
    onTouchMoved: null,
    onTouchEnded: null,
    onTouchCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
        this._claimedTouches = []
    },
    setSwallowTouches: function(a) {
        this.swallowTouches = a
    },
    isSwallowTouches: function() {
        return this.swallowTouches
    },
    clone: function() {
        var a = new cc._EventListenerTouchOneByOne;
        a.onTouchBegan = this.onTouchBegan;
        a.onTouchMoved = this.onTouchMoved;
        a.onTouchEnded = this.onTouchEnded;
        a.onTouchCancelled = this.onTouchCancelled;
        a.swallowTouches = this.swallowTouches;
        return a
    },
    checkAvailable: function() {
        return this.onTouchBegan ? !0 : (cc.log(cc._LogInfos._EventListenerTouchOneByOne_checkAvailable), !1)
    }
});
cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
cc._EventListenerTouchOneByOne.create = function() {
    return new cc._EventListenerTouchOneByOne
};
cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
    onTouchesBegan: null,
    onTouchesMoved: null,
    onTouchesEnded: null,
    onTouchesCancelled: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null)
    },
    clone: function() {
        var a = new cc._EventListenerTouchAllAtOnce;
        a.onTouchesBegan = this.onTouchesBegan;
        a.onTouchesMoved = this.onTouchesMoved;
        a.onTouchesEnded = this.onTouchesEnded;
        a.onTouchesCancelled = this.onTouchesCancelled;
        return a
    },
    checkAvailable: function() {
        return null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled ? (cc.log(cc._LogInfos._EventListenerTouchAllAtOnce_checkAvailable), !1) : !0
    }
});
cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
cc._EventListenerTouchAllAtOnce.create = function() {
    return new cc._EventListenerTouchAllAtOnce
};
cc.EventListener.create = function(a) {
    cc.assert(a && a.event, cc._LogInfos.EventListener_create);
    var b = a.event;
    delete a.event;
    var c = null;
    b === cc.EventListener.TOUCH_ONE_BY_ONE ? c = new cc._EventListenerTouchOneByOne : b === cc.EventListener.TOUCH_ALL_AT_ONCE ? c = new cc._EventListenerTouchAllAtOnce : b === cc.EventListener.MOUSE ? c = new cc._EventListenerMouse : b === cc.EventListener.CUSTOM ? (c = new cc._EventListenerCustom(a.eventName, a.callback), delete a.eventName, delete a.callback) : b === cc.EventListener.KEYBOARD ? c = new cc._EventListenerKeyboard :
        b === cc.EventListener.ACCELERATION ? (c = new cc._EventListenerAcceleration(a.callback), delete a.callback) : b === cc.EventListener.FOCUS && (c = new cc._EventListenerFocus);
    for (var d in a) c[d] = a[d];
    return c
};
cc._EventListenerFocus = cc.EventListener.extend({
    clone: function() {
        var a = new cc._EventListenerFocus;
        a.onFocusChanged = this.onFocusChanged;
        return a
    },
    checkAvailable: function() {
        return this.onFocusChanged ? !0 : (cc.log("Invalid EventListenerFocus!"), !1)
    },
    onFocusChanged: null,
    ctor: function() {
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.FOCUS, cc._EventListenerFocus.LISTENER_ID, function(a) {
            if (this.onFocusChanged) this.onFocusChanged(a._widgetLoseFocus, a._widgetGetFocus)
        })
    }
});
cc._EventListenerFocus.LISTENER_ID = "__cc_focus_event";
cc._EventListenerVector = cc.Class.extend({
    _fixedListeners: null,
    _sceneGraphListeners: null,
    gt0Index: 0,
    ctor: function() {
        this._fixedListeners = [];
        this._sceneGraphListeners = []
    },
    size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length
    },
    empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length
    },
    push: function(a) {
        0 === a._getFixedPriority() ? this._sceneGraphListeners.push(a) : this._fixedListeners.push(a)
    },
    clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length =
            0
    },
    clearFixedListeners: function() {
        this._fixedListeners.length = 0
    },
    clear: function() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0
    },
    getFixedPriorityListeners: function() {
        return this._fixedListeners
    },
    getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners
    }
});
cc.__getListenerID = function(a) {
    var b = cc.Event,
        c = a.getType();
    if (c === b.ACCELERATION) return cc._EventListenerAcceleration.LISTENER_ID;
    if (c === b.CUSTOM) return a.getEventName();
    if (c === b.KEYBOARD) return cc._EventListenerKeyboard.LISTENER_ID;
    if (c === b.MOUSE) return cc._EventListenerMouse.LISTENER_ID;
    if (c === b.FOCUS) return cc._EventListenerFocus.LISTENER_ID;
    c === b.TOUCH && cc.log(cc._LogInfos.__getListenerID);
    return ""
};
cc.eventManager = {
    DIRTY_NONE: 0,
    DIRTY_FIXED_PRIORITY: 1,
    DIRTY_SCENE_GRAPH_PRIORITY: 2,
    DIRTY_ALL: 3,
    _listenersMap: {},
    _priorityDirtyFlagMap: {},
    _nodeListenersMap: {},
    _nodePriorityMap: {},
    _globalZOrderNodeMap: {},
    _toAddedListeners: [],
    _dirtyNodes: [],
    _inDispatch: 0,
    _isEnabled: !1,
    _nodePriorityIndex: 0,
    _internalCustomListenerIDs: [cc.game.EVENT_HIDE, cc.game.EVENT_SHOW],
    _setDirtyForNode: function(a) {
        null != this._nodeListenersMap[a.__instanceId] && this._dirtyNodes.push(a);
        a = a.getChildren();
        for (var b = 0, c = a.length; b < c; b++) this._setDirtyForNode(a[b])
    },
    pauseTarget: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId],
            d, e;
        if (c)
            for (d = 0, e = c.length; d < e; d++) c[d]._setPaused(!0);
        if (!0 === b)
            for (c = a.getChildren(), d = 0, e = c.length; d < e; d++) this.pauseTarget(c[d], !0)
    },
    resumeTarget: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId],
            d, e;
        if (c)
            for (d = 0, e = c.length; d < e; d++) c[d]._setPaused(!1);
        this._setDirtyForNode(a);
        if (!0 === b)
            for (c = a.getChildren(), d = 0, e = c.length; d < e; d++) this.resumeTarget(c[d], !0)
    },
    _addListener: function(a) {
        0 === this._inDispatch ? this._forceAddEventListener(a) :
            this._toAddedListeners.push(a)
    },
    _forceAddEventListener: function(a) {
        var b = a._getListenerID(),
            c = this._listenersMap[b];
        c || (c = new cc._EventListenerVector, this._listenersMap[b] = c);
        c.push(a);
        0 === a._getFixedPriority() ? (this._setDirty(b, this.DIRTY_SCENE_GRAPH_PRIORITY), b = a._getSceneGraphPriority(), null === b && cc.log(cc._LogInfos.eventManager__forceAddEventListener), this._associateNodeAndEventListener(b, a), b.isRunning() && this.resumeTarget(b)) : this._setDirty(b, this.DIRTY_FIXED_PRIORITY)
    },
    _getListeners: function(a) {
        return this._listenersMap[a]
    },
    _updateDirtyFlagForSceneGraph: function() {
        if (0 !== this._dirtyNodes.length) {
            for (var a = this._dirtyNodes, b, c, d = this._nodeListenersMap, e = 0, f = a.length; e < f; e++)
                if (b = d[a[e].__instanceId])
                    for (var g = 0, h = b.length; g < h; g++)(c = b[g]) && this._setDirty(c._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
            this._dirtyNodes.length = 0
        }
    },
    _removeAllListenersInVector: function(a) {
        if (a)
            for (var b, c = 0; c < a.length;) b = a[c], b._setRegistered(!1), null != b._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(b._getSceneGraphPriority(),
                b), b._setSceneGraphPriority(null)), 0 === this._inDispatch ? cc.arrayRemoveObject(a, b) : ++c
    },
    _removeListenersForListenerID: function(a) {
        var b = this._listenersMap[a];
        if (b) {
            var c = b.getFixedPriorityListeners(),
                d = b.getSceneGraphPriorityListeners();
            this._removeAllListenersInVector(d);
            this._removeAllListenersInVector(c);
            delete this._priorityDirtyFlagMap[a];
            this._inDispatch || (b.clear(), delete this._listenersMap[a])
        }
        c = this._toAddedListeners;
        for (b = 0; b < c.length;)(d = c[b]) && d._getListenerID() === a ? cc.arrayRemoveObject(c,
            d) : ++b
    },
    _sortEventListeners: function(a) {
        var b = this.DIRTY_NONE,
            c = this._priorityDirtyFlagMap;
        c[a] && (b = c[a]);
        b !== this.DIRTY_NONE && (c[a] = this.DIRTY_NONE, b & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(a), b & this.DIRTY_SCENE_GRAPH_PRIORITY && ((b = cc.director.getRunningScene()) ? this._sortListenersOfSceneGraphPriority(a, b) : c[a] = this.DIRTY_SCENE_GRAPH_PRIORITY))
    },
    _sortListenersOfSceneGraphPriority: function(a, b) {
        var c = this._getListeners(a);
        if (c) {
            var d = c.getSceneGraphPriorityListeners();
            d && 0 !==
                d.length && (this._nodePriorityIndex = 0, this._nodePriorityMap = {}, this._visitTarget(b, !0), c.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes))
        }
    },
    _sortEventListenersOfSceneGraphPriorityDes: function(a, b) {
        var c = cc.eventManager._nodePriorityMap,
            d = a._getSceneGraphPriority(),
            e = b._getSceneGraphPriority();
        return b && e && c[e.__instanceId] ? a && d && c[d.__instanceId] ? c[b._getSceneGraphPriority().__instanceId] - c[a._getSceneGraphPriority().__instanceId] : 1 : -1
    },
    _sortListenersOfFixedPriority: function(a) {
        if (a =
            this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners();
            if (b && 0 !== b.length) {
                b.sort(this._sortListenersOfFixedPriorityAsc);
                for (var c = 0, d = b.length; c < d && !(0 <= b[c]._getFixedPriority());) ++c;
                a.gt0Index = c
            }
        }
    },
    _sortListenersOfFixedPriorityAsc: function(a, b) {
        return a._getFixedPriority() - b._getFixedPriority()
    },
    _onUpdateListeners: function(a) {
        if (a = this._listenersMap[a]) {
            var b = a.getFixedPriorityListeners(),
                c = a.getSceneGraphPriorityListeners(),
                d, e;
            if (c)
                for (d = 0; d < c.length;) e = c[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(c,
                    e);
            if (b)
                for (d = 0; d < b.length;) e = b[d], e._isRegistered() ? ++d : cc.arrayRemoveObject(b, e);
            c && 0 === c.length && a.clearSceneGraphListeners();
            b && 0 === b.length && a.clearFixedListeners()
        }
    },
    _updateListeners: function(a) {
        var b = this._inDispatch;
        cc.assert(0 < b, cc._LogInfos.EventManager__updateListeners);
        if (!(1 < b)) {
            a.getType() === cc.Event.TOUCH ? (this._onUpdateListeners(cc._EventListenerTouchOneByOne.LISTENER_ID), this._onUpdateListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID)) : this._onUpdateListeners(cc.__getListenerID(a));
            cc.assert(1 === b, cc._LogInfos.EventManager__updateListeners_2);
            a = this._listenersMap;
            var b = this._priorityDirtyFlagMap,
                c;
            for (c in a) a[c].empty() && (delete b[c], delete a[c]);
            c = this._toAddedListeners;
            if (0 !== c.length) {
                a = 0;
                for (b = c.length; a < b; a++) this._forceAddEventListener(c[a]);
                this._toAddedListeners.length = 0
            }
        }
    },
    _onTouchEventCallback: function(a, b) {
        if (!a._isRegistered) return !1;
        var c = b.event,
            d = b.selTouch;
        c._setCurrentTarget(a._node);
        var e = !1,
            f, g = c.getEventCode(),
            h = cc.EventTouch.EventCode;
        if (g === h.BEGAN) a.onTouchBegan &&
            (e = a.onTouchBegan(d, c)) && a._registered && a._claimedTouches.push(d);
        else if (0 < a._claimedTouches.length && -1 !== (f = a._claimedTouches.indexOf(d)))
            if (e = !0, g === h.MOVED && a.onTouchMoved) a.onTouchMoved(d, c);
            else if (g === h.ENDED) {
            if (a.onTouchEnded) a.onTouchEnded(d, c);
            a._registered && a._claimedTouches.splice(f, 1)
        } else if (g === h.CANCELLED) {
            if (a.onTouchCancelled) a.onTouchCancelled(d, c);
            a._registered && a._claimedTouches.splice(f, 1)
        }
        return c.isStopped() ? (cc.eventManager._updateListeners(c), !0) : e && a._registered && a.swallowTouches ?
            (b.needsMutableSet && b.touches.splice(d, 1), !0) : !1
    },
    _dispatchTouchEvent: function(a) {
        this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
        this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        var b = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID),
            c = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
        if (null !== b || null !== c) {
            var d = a.getTouches(),
                e = cc.copyArray(d),
                f = {
                    event: a,
                    needsMutableSet: b && c,
                    touches: e,
                    selTouch: null
                };
            if (b)
                for (var g = 0; g < d.length; g++)
                    if (f.selTouch =
                        d[g], this._dispatchEventToListeners(b, this._onTouchEventCallback, f), a.isStopped()) return;
            if (c && 0 < e.length && (this._dispatchEventToListeners(c, this._onTouchesEventCallback, {
                    event: a,
                    touches: e
                }), a.isStopped())) return;
            this._updateListeners(a)
        }
    },
    _onTouchesEventCallback: function(a, b) {
        if (!a._registered) return !1;
        var c = cc.EventTouch.EventCode,
            d = b.event,
            e = b.touches,
            f = d.getEventCode();
        d._setCurrentTarget(a._node);
        if (f === c.BEGAN && a.onTouchesBegan) a.onTouchesBegan(e, d);
        else if (f === c.MOVED && a.onTouchesMoved) a.onTouchesMoved(e,
            d);
        else if (f === c.ENDED && a.onTouchesEnded) a.onTouchesEnded(e, d);
        else if (f === c.CANCELLED && a.onTouchesCancelled) a.onTouchesCancelled(e, d);
        return d.isStopped() ? (cc.eventManager._updateListeners(d), !0) : !1
    },
    _associateNodeAndEventListener: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c || (c = [], this._nodeListenersMap[a.__instanceId] = c);
        c.push(b)
    },
    _dissociateNodeAndEventListener: function(a, b) {
        var c = this._nodeListenersMap[a.__instanceId];
        c && (cc.arrayRemoveObject(c, b), 0 === c.length && delete this._nodeListenersMap[a.__instanceId])
    },
    _dispatchEventToListeners: function(a, b, c) {
        var d = !1,
            e = a.getFixedPriorityListeners(),
            f = a.getSceneGraphPriorityListeners(),
            g = 0,
            h;
        if (e && 0 !== e.length)
            for (; g < a.gt0Index; ++g)
                if (h = e[g], h.isEnabled() && !h._isPaused() && h._isRegistered() && b(h, c)) {
                    d = !0;
                    break
                }
        if (f && !d)
            for (a = 0; a < f.length; a++)
                if (h = f[a], h.isEnabled() && !h._isPaused() && h._isRegistered() && b(h, c)) {
                    d = !0;
                    break
                }
        if (e && !d)
            for (; g < e.length && (h = e[g], !h.isEnabled() || h._isPaused() || !h._isRegistered() || !b(h, c)); ++g);
    },
    _setDirty: function(a, b) {
        var c = this._priorityDirtyFlagMap;
        c[a] = null == c[a] ? b : b | c[a]
    },
    _visitTarget: function(a, b) {
        var c = a.getChildren(),
            d = 0,
            e = c.length,
            f = this._globalZOrderNodeMap,
            g = this._nodeListenersMap;
        if (0 < e) {
            for (var h; d < e; d++)
                if ((h = c[d]) && 0 > h.getLocalZOrder()) this._visitTarget(h, !1);
                else break;
            null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
            for (; d < e; d++)(h = c[d]) && this._visitTarget(h, !1)
        } else null != g[a.__instanceId] && (f[a.getGlobalZOrder()] || (f[a.getGlobalZOrder()] = []), f[a.getGlobalZOrder()].push(a.__instanceId));
        if (b) {
            var c = [],
                k;
            for (k in f) c.push(k);
            c.sort(this._sortNumberAsc);
            k = c.length;
            h = this._nodePriorityMap;
            for (d = 0; d < k; d++)
                for (e = f[c[d]], g = 0; g < e.length; g++) h[e[g]] = ++this._nodePriorityIndex;
            this._globalZOrderNodeMap = {}
        }
    },
    _sortNumberAsc: function(a, b) {
        return a - b
    },
    addListener: function(a, b) {
        cc.assert(a && b, cc._LogInfos.eventManager_addListener_2);
        if (!(a instanceof cc.EventListener)) cc.assert(!cc.isNumber(b), cc._LogInfos.eventManager_addListener_3), a = cc.EventListener.create(a);
        else if (a._isRegistered()) {
            cc.log(cc._LogInfos.eventManager_addListener_4);
            return
        }
        if (a.checkAvailable()) {
            if (cc.isNumber(b)) {
                if (0 === b) {
                    cc.log(cc._LogInfos.eventManager_addListener);
                    return
                }
                a._setSceneGraphPriority(null);
                a._setFixedPriority(b);
                a._setRegistered(!0);
                a._setPaused(!1)
            } else a._setSceneGraphPriority(b), a._setFixedPriority(0), a._setRegistered(!0);
            this._addListener(a);
            return a
        }
    },
    addCustomListener: function(a, b) {
        var c = new cc._EventListenerCustom(a, b);
        this.addListener(c, 1);
        return c
    },
    removeListener: function(a) {
        if (null != a) {
            var b, c = this._listenersMap,
                d;
            for (d in c) {
                var e =
                    c[d],
                    f = e.getFixedPriorityListeners();
                b = e.getSceneGraphPriorityListeners();
                (b = this._removeListenerInVector(b, a)) ? this._setDirty(a._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY): (b = this._removeListenerInVector(f, a)) && this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                e.empty() && (delete this._priorityDirtyFlagMap[a._getListenerID()], delete c[d]);
                if (b) break
            }
            if (!b)
                for (c = this._toAddedListeners, d = 0, e = c.length; d < e; d++)
                    if (f = c[d], f === a) {
                        cc.arrayRemoveObject(c, f);
                        f._setRegistered(!1);
                        break
                    }
        }
    },
    _removeListenerInCallback: function(a,
        b) {
        if (null == a) return !1;
        for (var c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            if (e._onCustomEvent === b || e._onEvent === b) return e._setRegistered(!1), null != e._getSceneGraphPriority() && (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, e), !0
        }
        return !1
    },
    _removeListenerInVector: function(a, b) {
        if (null == a) return !1;
        for (var c = 0, d = a.length; c < d; c++) {
            var e = a[c];
            if (e === b) return e._setRegistered(!1), null != e._getSceneGraphPriority() &&
                (this._dissociateNodeAndEventListener(e._getSceneGraphPriority(), e), e._setSceneGraphPriority(null)), 0 === this._inDispatch && cc.arrayRemoveObject(a, e), !0
        }
        return !1
    },
    removeListeners: function(a, b) {
        if (a instanceof cc.Node) {
            delete this._nodePriorityMap[a.__instanceId];
            cc.arrayRemoveObject(this._dirtyNodes, a);
            var c = this._nodeListenersMap[a.__instanceId];
            if (c) {
                for (var d = cc.copyArray(c), c = 0; c < d.length; c++) this.removeListener(d[c]);
                d.length = 0
            }
            d = this._toAddedListeners;
            for (c = 0; c < d.length;) {
                var e = d[c];
                e._getSceneGraphPriority() ===
                    a ? (e._setSceneGraphPriority(null), e._setRegistered(!1), d.splice(c, 1)) : ++c
            }
            if (!0 === b)
                for (d = a.getChildren(), c = 0, e = d.length; c < e; c++) this.removeListeners(d[c], !0)
        } else a === cc.EventListener.TOUCH_ONE_BY_ONE ? this._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : a === cc.EventListener.TOUCH_ALL_AT_ONCE ? this._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : a === cc.EventListener.MOUSE ? this._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : a ===
            cc.EventListener.ACCELERATION ? this._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : a === cc.EventListener.KEYBOARD ? this._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.log(cc._LogInfos.eventManager_removeListeners)
    },
    removeCustomListeners: function(a) {
        this._removeListenersForListenerID(a)
    },
    removeAllListeners: function() {
        var a = this._listenersMap,
            b = this._internalCustomListenerIDs,
            c;
        for (c in a) - 1 === b.indexOf(c) && this._removeListenersForListenerID(c)
    },
    setPriority: function(a,
        b) {
        if (null != a) {
            var c = this._listenersMap,
                d;
            for (d in c) {
                var e = c[d].getFixedPriorityListeners();
                if (e && -1 !== e.indexOf(a)) {
                    null != a._getSceneGraphPriority() && cc.log(cc._LogInfos.eventManager_setPriority);
                    a._getFixedPriority() !== b && (a._setFixedPriority(b), this._setDirty(a._getListenerID(), this.DIRTY_FIXED_PRIORITY));
                    break
                }
            }
        }
    },
    setEnabled: function(a) {
        this._isEnabled = a
    },
    isEnabled: function() {
        return this._isEnabled
    },
    dispatchEvent: function(a) {
        if (this._isEnabled) {
            this._updateDirtyFlagForSceneGraph();
            this._inDispatch++;
            if (!a || !a.getType) throw Error("event is undefined");
            if (a.getType() === cc.Event.TOUCH) this._dispatchTouchEvent(a);
            else {
                var b = cc.__getListenerID(a);
                this._sortEventListeners(b);
                b = this._listenersMap[b];
                null != b && this._dispatchEventToListeners(b, this._onListenerCallback, a);
                this._updateListeners(a)
            }
            this._inDispatch--
        }
    },
    _onListenerCallback: function(a, b) {
        b._setCurrentTarget(a._getSceneGraphPriority());
        a._onEvent(b);
        return b.isStopped()
    },
    dispatchCustomEvent: function(a, b) {
        var c = new cc.EventCustom(a);
        c.setUserData(b);
        this.dispatchEvent(c)
    }
};
cc.EventAcceleration = cc.Event.extend({
    _acc: null,
    ctor: function(a) {
        cc.Event.prototype.ctor.call(this, cc.Event.ACCELERATION);
        this._acc = a
    }
});
cc.EventKeyboard = cc.Event.extend({
    _keyCode: 0,
    _isPressed: !1,
    ctor: function(a, b) {
        cc.Event.prototype.ctor.call(this, cc.Event.KEYBOARD);
        this._keyCode = a;
        this._isPressed = b
    }
});
cc._EventListenerAcceleration = cc.EventListener.extend({
    _onAccelerationEvent: null,
    ctor: function(a) {
        this._onAccelerationEvent = a;
        var b = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, function(a) {
            b._onAccelerationEvent(a._acc, a)
        })
    },
    checkAvailable: function() {
        cc.assert(this._onAccelerationEvent, cc._LogInfos._EventListenerAcceleration_checkAvailable);
        return !0
    },
    clone: function() {
        return new cc._EventListenerAcceleration(this._onAccelerationEvent)
    }
});
cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
cc._EventListenerAcceleration.create = function(a) {
    return new cc._EventListenerAcceleration(a)
};
cc._EventListenerKeyboard = cc.EventListener.extend({
    onKeyPressed: null,
    onKeyReleased: null,
    ctor: function() {
        var a = this;
        cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, function(b) {
            if (b._isPressed) {
                if (a.onKeyPressed) a.onKeyPressed(b._keyCode, b)
            } else if (a.onKeyReleased) a.onKeyReleased(b._keyCode, b)
        })
    },
    clone: function() {
        var a = new cc._EventListenerKeyboard;
        a.onKeyPressed = this.onKeyPressed;
        a.onKeyReleased = this.onKeyReleased;
        return a
    },
    checkAvailable: function() {
        return null ===
            this.onKeyPressed && null === this.onKeyReleased ? (cc.log(cc._LogInfos._EventListenerKeyboard_checkAvailable), !1) : !0
    }
});
cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
cc._EventListenerKeyboard.create = function() {
    return new cc._EventListenerKeyboard
};
cc.rendererCanvas = {
    childrenOrderDirty: !0,
    _transformNodePool: [],
    _renderCmds: [],
    _isCacheToCanvasOn: !1,
    _cacheToCanvasCmds: {},
    _cacheInstanceIds: [],
    _currentID: 0,
    _clearColor: cc.color(),
    _clearFillStyle: "rgb(0, 0, 0)",
    getRenderCmd: function(a) {
        return a._createRenderCmd()
    },
    rendering: function(a) {
        var b = this._renderCmds,
            c, d = cc.view.getScaleX(),
            e = cc.view.getScaleY(),
            f = a || cc._renderContext;
        f.computeRealOffsetY();
        a = 0;
        for (c = b.length; a < c; a++) b[a].rendering(f, d, e)
    },
    _renderingToCacheCanvas: function(a, b, c, d) {
        a || cc.log("The context of RenderTexture is invalid.");
        c = cc.isUndefined(c) ? 1 : c;
        d = cc.isUndefined(d) ? 1 : d;
        b = b || this._currentID;
        var e = this._cacheToCanvasCmds[b],
            f, g;
        a.computeRealOffsetY();
        f = 0;
        for (g = e.length; f < g; f++) e[f].rendering(a, c, d);
        e.length = 0;
        a = this._cacheInstanceIds;
        delete this._cacheToCanvasCmds[b];
        cc.arrayRemoveObject(a, b);
        0 === a.length ? this._isCacheToCanvasOn = !1 : this._currentID = a[a.length - 1]
    },
    _turnToCacheMode: function(a) {
        this._isCacheToCanvasOn = !0;
        a = a || 0;
        this._cacheToCanvasCmds[a] = []; - 1 === this._cacheInstanceIds.indexOf(a) && this._cacheInstanceIds.push(a);
        this._currentID = a
    },
    _turnToNormalMode: function() {
        this._isCacheToCanvasOn = !1
    },
    resetFlag: function() {
        this.childrenOrderDirty = !1;
        this._transformNodePool.length = 0
    },
    transform: function() {
        var a = this._transformNodePool;
        a.sort(this._sortNodeByLevelAsc);
        for (var b = 0, c = a.length; b < c; b++) 0 !== a[b]._dirtyFlag && a[b].updateStatus();
        a.length = 0
    },
    transformDirty: function() {
        return 0 < this._transformNodePool.length
    },
    _sortNodeByLevelAsc: function(a, b) {
        return a._curLevel - b._curLevel
    },
    pushDirtyNode: function(a) {
        this._transformNodePool.push(a)
    },
    clear: function() {
        var a = cc._canvas,
            b = cc._renderContext,
            c = b.getContext();
        c.setTransform(1, 0, 0, 1, 0, 0);
        c.clearRect(0, 0, a.width, a.height);
        if (0 !== this._clearColor.r || 0 !== this._clearColor.g || 0 !== this._clearColor.b) b.setFillStyle(this._clearFillStyle), b.setGlobalAlpha(this._clearColor.a), c.fillRect(0, 0, a.width, a.height)
    },
    clearRenderCommands: function() {
        this._renderCmds.length = 0;
        this._cacheInstanceIds.length = 0;
        this._isCacheToCanvasOn = !1
    },
    pushRenderCommand: function(a) {
        if (a._needDraw)
            if (this._isCacheToCanvasOn) {
                var b =
                    this._cacheToCanvasCmds[this._currentID]; - 1 === b.indexOf(a) && b.push(a)
            } else -1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
    }
};
(function() {
    cc.CanvasContextWrapper = function(a) {
        this._context = a;
        this._saveCount = 0;
        this._currentAlpha = a.globalAlpha;
        this._currentCompositeOperation = a.globalCompositeOperation;
        this._currentFillStyle = a.fillStyle;
        this._currentStrokeStyle = a.strokeStyle;
        this._offsetY = this._offsetX = 0;
        this._realOffsetY = this.height;
        this._armatureMode = 0
    };
    var a = cc.CanvasContextWrapper.prototype;
    a.resetCache = function() {
        var a = this._context;
        this._currentAlpha = a.globalAlpha;
        this._currentCompositeOperation = a.globalCompositeOperation;
        this._currentFillStyle = a.fillStyle;
        this._currentStrokeStyle = a.strokeStyle;
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.setOffset = function(a, c) {
        this._offsetX = a;
        this._offsetY = c;
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.computeRealOffsetY = function() {
        this._realOffsetY = this._context.canvas.height + this._offsetY
    };
    a.setViewScale = function(a, c) {
        this._scaleX = a;
        this._scaleY = c
    };
    a.getContext = function() {
        return this._context
    };
    a.save = function() {
        this._context.save();
        this._saveCount++
    };
    a.restore = function() {
        this._context.restore();
        this._saveCount--
    };
    a.setGlobalAlpha = function(a) {
        0 < this._saveCount ? this._context.globalAlpha = a : this._currentAlpha !== a && (this._currentAlpha = a, this._context.globalAlpha = a)
    };
    a.setCompositeOperation = function(a) {
        0 < this._saveCount ? this._context.globalCompositeOperation = a : this._currentCompositeOperation !== a && (this._currentCompositeOperation = a, this._context.globalCompositeOperation = a)
    };
    a.setFillStyle = function(a) {
        0 < this._saveCount ? this._context.fillStyle = a : this._currentFillStyle !==
            a && (this._currentFillStyle = a, this._context.fillStyle = a)
    };
    a.setStrokeStyle = function(a) {
        0 < this._saveCount ? this._context.strokeStyle = a : this._currentStrokeStyle !== a && (this._currentStrokeStyle = a, this._context.strokeStyle = a)
    };
    a.setTransform = function(a, c, d) {
        0 < this._armatureMode ? (this.restore(), this.save(), this._context.transform(a.a, -a.b, -a.c, a.d, a.tx * c, -(a.ty * d))) : this._context.setTransform(a.a, -a.b, -a.c, a.d, this._offsetX + a.tx * c, this._realOffsetY - a.ty * d)
    };
    a._switchToArmatureMode = function(a, c, d, e) {
        a ? (this._armatureMode++,
            this._context.setTransform(c.a, c.c, c.b, c.d, this._offsetX + c.tx * d, this._realOffsetY - c.ty * e), this.save()) : (this._armatureMode--, this.restore())
    }
})();
cc.rendererWebGL = {
    childrenOrderDirty: !0,
    _transformNodePool: [],
    _renderCmds: [],
    _isCacheToBufferOn: !1,
    _cacheToBufferCmds: {},
    _cacheInstanceIds: [],
    _currentID: 0,
    _clearColor: cc.color(),
    getRenderCmd: function(a) {
        return a._createRenderCmd()
    },
    rendering: function(a) {
        var b = this._renderCmds,
            c, d = a || cc._renderContext;
        a = 0;
        for (c = b.length; a < c; a++) b[a].rendering(d)
    },
    _turnToCacheMode: function(a) {
        this._isCacheToBufferOn = !0;
        a = a || 0;
        this._cacheToBufferCmds[a] = [];
        this._cacheInstanceIds.push(a);
        this._currentID = a
    },
    _turnToNormalMode: function() {
        this._isCacheToBufferOn = !1
    },
    _renderingToBuffer: function(a) {
        a = a || this._currentID;
        var b = this._cacheToBufferCmds[a],
            c, d, e = cc._renderContext,
            f = this._cacheInstanceIds;
        c = 0;
        for (d = b.length; c < d; c++) b[c].rendering(e);
        b.length = 0;
        delete this._cacheToBufferCmds[a];
        cc.arrayRemoveObject(f, a);
        0 === f.length ? this._isCacheToBufferOn = !1 : this._currentID = f[f.length - 1]
    },
    resetFlag: function() {
        this.childrenOrderDirty = !1;
        this._transformNodePool.length = 0
    },
    transform: function() {
        var a = this._transformNodePool;
        a.sort(this._sortNodeByLevelAsc);
        for (var b =
                0, c = a.length; b < c; b++) a[b].updateStatus();
        a.length = 0
    },
    transformDirty: function() {
        return 0 < this._transformNodePool.length
    },
    _sortNodeByLevelAsc: function(a, b) {
        return a._curLevel - b._curLevel
    },
    pushDirtyNode: function(a) {
        this._transformNodePool.push(a)
    },
    clearRenderCommands: function() {
        this._renderCmds.length = 0
    },
    clear: function() {
        var a = cc._renderContext;
        a.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    },
    setDepthTest: function(a) {
        var b =
            cc._renderContext;
        a ? (b.clearDepth(1), b.enable(b.DEPTH_TEST), b.depthFunc(b.LEQUAL)) : b.disable(b.DEPTH_TEST)
    },
    pushRenderCommand: function(a) {
        if (a._needDraw)
            if (this._isCacheToBufferOn) {
                var b = this._cacheToBufferCmds[this._currentID]; - 1 === b.indexOf(a) && b.push(a)
            } else -1 === this._renderCmds.indexOf(a) && this._renderCmds.push(a)
    }
};
cc._tmp.PrototypeCCNode = function() {
    var a = cc.Node.prototype;
    cc.defineGetterSetter(a, "x", a.getPositionX, a.setPositionX);
    cc.defineGetterSetter(a, "y", a.getPositionY, a.setPositionY);
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight);
    cc.defineGetterSetter(a, "anchorX", a._getAnchorX, a._setAnchorX);
    cc.defineGetterSetter(a, "anchorY", a._getAnchorY, a._setAnchorY);
    cc.defineGetterSetter(a, "skewX", a.getSkewX, a.setSkewX);
    cc.defineGetterSetter(a, "skewY",
        a.getSkewY, a.setSkewY);
    cc.defineGetterSetter(a, "zIndex", a.getLocalZOrder, a.setLocalZOrder);
    cc.defineGetterSetter(a, "vertexZ", a.getVertexZ, a.setVertexZ);
    cc.defineGetterSetter(a, "rotation", a.getRotation, a.setRotation);
    cc.defineGetterSetter(a, "rotationX", a.getRotationX, a.setRotationX);
    cc.defineGetterSetter(a, "rotationY", a.getRotationY, a.setRotationY);
    cc.defineGetterSetter(a, "scale", a.getScale, a.setScale);
    cc.defineGetterSetter(a, "scaleX", a.getScaleX, a.setScaleX);
    cc.defineGetterSetter(a, "scaleY", a.getScaleY,
        a.setScaleY);
    cc.defineGetterSetter(a, "children", a.getChildren);
    cc.defineGetterSetter(a, "childrenCount", a.getChildrenCount);
    cc.defineGetterSetter(a, "parent", a.getParent, a.setParent);
    cc.defineGetterSetter(a, "visible", a.isVisible, a.setVisible);
    cc.defineGetterSetter(a, "running", a.isRunning);
    cc.defineGetterSetter(a, "ignoreAnchor", a.isIgnoreAnchorPointForPosition, a.ignoreAnchorPointForPosition);
    cc.defineGetterSetter(a, "actionManager", a.getActionManager, a.setActionManager);
    cc.defineGetterSetter(a, "scheduler",
        a.getScheduler, a.setScheduler);
    cc.defineGetterSetter(a, "shaderProgram", a.getShaderProgram, a.setShaderProgram);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB);
    cc.defineGetterSetter(a, "cascadeOpacity", a.isCascadeOpacityEnabled, a.setCascadeOpacityEnabled);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "cascadeColor", a.isCascadeColorEnabled, a.setCascadeColorEnabled)
};
cc.NODE_TAG_INVALID = -1;
cc.s_globalOrderOfArrival = 1;
cc.Node = cc.Class.extend({
    _localZOrder: 0,
    _globalZOrder: 0,
    _vertexZ: 0,
    _rotationX: 0,
    _rotationY: 0,
    _scaleX: 1,
    _scaleY: 1,
    _position: null,
    _normalizedPosition: null,
    _usingNormalizedPosition: !1,
    _normalizedPositionDirty: !1,
    _skewX: 0,
    _skewY: 0,
    _children: null,
    _visible: !0,
    _anchorPoint: null,
    _contentSize: null,
    _running: !1,
    _parent: null,
    _ignoreAnchorPointForPosition: !1,
    tag: cc.NODE_TAG_INVALID,
    userData: null,
    userObject: null,
    _reorderChildDirty: !1,
    _shaderProgram: null,
    arrivalOrder: 0,
    _actionManager: null,
    _scheduler: null,
    _eventDispatcher: null,
    _additionalTransformDirty: !1,
    _additionalTransform: null,
    _componentContainer: null,
    _isTransitionFinished: !1,
    _className: "Node",
    _showNode: !1,
    _name: "",
    _realOpacity: 255,
    _realColor: null,
    _cascadeColorEnabled: !1,
    _cascadeOpacityEnabled: !1,
    _renderCmd: null,
    _camera: null,
    ctor: function() {
        this._initNode();
        this._initRendererCmd()
    },
    _initNode: function() {
        this._anchorPoint = cc.p(0, 0);
        this._contentSize = cc.size(0, 0);
        this._position = cc.p(0, 0);
        this._normalizedPosition = cc.p(0, 0);
        this._children = [];
        var a = cc.director;
        this._actionManager =
            a.getActionManager();
        this._scheduler = a.getScheduler();
        this._additionalTransform = cc.affineTransformMakeIdentity();
        cc.ComponentContainer && (this._componentContainer = new cc.ComponentContainer(this));
        this._realOpacity = 255;
        this._realColor = cc.color(255, 255, 255, 255);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1
    },
    init: function() {
        return !0
    },
    _arrayMakeObjectsPerformSelector: function(a, b) {
        if (a && 0 !== a.length) {
            var c, d = a.length,
                e;
            c = cc.Node._stateCallbackType;
            switch (b) {
                case c.onEnter:
                    for (c = 0; c < d; c++)
                        if (e =
                            a[c]) e.onEnter();
                    break;
                case c.onExit:
                    for (c = 0; c < d; c++)
                        if (e = a[c]) e.onExit();
                    break;
                case c.onEnterTransitionDidFinish:
                    for (c = 0; c < d; c++)
                        if (e = a[c]) e.onEnterTransitionDidFinish();
                    break;
                case c.cleanup:
                    for (c = 0; c < d; c++)(e = a[c]) && e.cleanup();
                    break;
                case c.updateTransform:
                    for (c = 0; c < d; c++)(e = a[c]) && e.updateTransform();
                    break;
                case c.onExitTransitionDidStart:
                    for (c = 0; c < d; c++)
                        if (e = a[c]) e.onExitTransitionDidStart();
                    break;
                case c.sortAllChildren:
                    for (c = 0; c < d; c++)(e = a[c]) && e.sortAllChildren();
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Node__arrayMakeObjectsPerformSelector)
            }
        }
    },
    attr: function(a) {
        for (var b in a) this[b] = a[b]
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewX: function(a) {
        this._skewX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getSkewY: function() {
        return this._skewY
    },
    setSkewY: function(a) {
        this._skewY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setLocalZOrder: function(a) {
        this._localZOrder = a;
        this._parent && this._parent.reorderChild(this, a);
        cc.eventManager._setDirtyForNode(this)
    },
    _setLocalZOrder: function(a) {
        this._localZOrder =
            a
    },
    getLocalZOrder: function() {
        return this._localZOrder
    },
    getZOrder: function() {
        cc.log(cc._LogInfos.Node_getZOrder);
        return this.getLocalZOrder()
    },
    setZOrder: function(a) {
        cc.log(cc._LogInfos.Node_setZOrder);
        this.setLocalZOrder(a)
    },
    setGlobalZOrder: function(a) {
        this._globalZOrder !== a && (this._globalZOrder = a, cc.eventManager._setDirtyForNode(this))
    },
    getGlobalZOrder: function() {
        return this._globalZOrder
    },
    getVertexZ: function() {
        return this._vertexZ
    },
    setVertexZ: function(a) {
        this._vertexZ = a
    },
    getRotation: function() {
        this._rotationX !==
            this._rotationY && cc.log(cc._LogInfos.Node_getRotation);
        return this._rotationX
    },
    setRotation: function(a) {
        this._rotationX = this._rotationY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationX: function() {
        return this._rotationX
    },
    setRotationX: function(a) {
        this._rotationX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getRotationY: function() {
        return this._rotationY
    },
    setRotationY: function(a) {
        this._rotationY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScale: function() {
        this._scaleX !== this._scaleY && cc.log(cc._LogInfos.Node_getScale);
        return this._scaleX
    },
    setScale: function(a, b) {
        this._scaleX = a;
        this._scaleY = b || 0 === b ? b : a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleX: function(a) {
        this._scaleX = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getScaleY: function() {
        return this._scaleY
    },
    setScaleY: function(a) {
        this._scaleY = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setPosition: function(a, b) {
        var c = this._position;
        if (void 0 === b) {
            if (c.x === a.x && c.y === a.y) return;
            c.x = a.x;
            c.y = a.y
        } else {
            if (c.x === a && c.y === b) return;
            c.x = a;
            c.y = b
        }
        this._usingNormalizedPosition = !1;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setNormalizedPosition: function(a, b) {
        var c = this._normalizedPosition;
        void 0 === b ? (c.x = a.x, c.y = a.y) : (c.x = a, c.y = b);
        this._normalizedPositionDirty = this._usingNormalizedPosition = !0;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPosition: function() {
        return cc.p(this._position)
    },
    getNormalizedPosition: function() {
        return cc.p(this._normalizedPosition)
    },
    getPositionX: function() {
        return this._position.x
    },
    setPositionX: function(a) {
        this._position.x = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPositionY: function() {
        return this._position.y
    },
    setPositionY: function(a) {
        this._position.y = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getChildrenCount: function() {
        return this._children.length
    },
    getChildren: function() {
        return this._children
    },
    isVisible: function() {
        return this._visible
    },
    setVisible: function(a) {
        this._visible !== a && (this._visible = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty), cc.renderer.childrenOrderDirty = !0)
    },
    getAnchorPoint: function() {
        return cc.p(this._anchorPoint)
    },
    setAnchorPoint: function(a, b) {
        var c = this._anchorPoint;
        if (void 0 === b) {
            if (a.x === c.x && a.y === c.y) return;
            c.x = a.x;
            c.y = a.y
        } else {
            if (a === c.x && b === c.y) return;
            c.x = a;
            c.y = b
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getAnchorX: function() {
        return this._anchorPoint.x
    },
    _setAnchorX: function(a) {
        this._anchorPoint.x !==
            a && (this._anchorPoint.x = a, this._renderCmd._updateAnchorPointInPoint())
    },
    _getAnchorY: function() {
        return this._anchorPoint.y
    },
    _setAnchorY: function(a) {
        this._anchorPoint.y !== a && (this._anchorPoint.y = a, this._renderCmd._updateAnchorPointInPoint())
    },
    getAnchorPointInPoints: function() {
        return this._renderCmd.getAnchorPointInPoints()
    },
    _getWidth: function() {
        return this._contentSize.width
    },
    _setWidth: function(a) {
        this._contentSize.width = a;
        this._renderCmd._updateAnchorPointInPoint()
    },
    _getHeight: function() {
        return this._contentSize.height
    },
    _setHeight: function(a) {
        this._contentSize.height = a;
        this._renderCmd._updateAnchorPointInPoint()
    },
    getContentSize: function() {
        return cc.size(this._contentSize)
    },
    setContentSize: function(a, b) {
        var c = this._contentSize;
        if (void 0 === b) {
            if (a.width === c.width && a.height === c.height) return;
            c.width = a.width;
            c.height = a.height
        } else {
            if (a === c.width && b === c.height) return;
            c.width = a;
            c.height = b
        }
        this._renderCmd._updateAnchorPointInPoint()
    },
    isRunning: function() {
        return this._running
    },
    getParent: function() {
        return this._parent
    },
    setParent: function(a) {
        this._parent =
            a
    },
    isIgnoreAnchorPointForPosition: function() {
        return this._ignoreAnchorPointForPosition
    },
    ignoreAnchorPointForPosition: function(a) {
        a !== this._ignoreAnchorPointForPosition && (this._ignoreAnchorPointForPosition = a, this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    getUserData: function() {
        return this.userData
    },
    setUserData: function(a) {
        this.userData = a
    },
    getUserObject: function() {
        return this.userObject
    },
    setUserObject: function(a) {
        this.userObject !== a && (this.userObject = a)
    },
    getOrderOfArrival: function() {
        return this.arrivalOrder
    },
    setOrderOfArrival: function(a) {
        this.arrivalOrder = a
    },
    getActionManager: function() {
        this._actionManager || (this._actionManager = cc.director.getActionManager());
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager !== a && (this.stopAllActions(), this._actionManager = a)
    },
    getScheduler: function() {
        this._scheduler || (this._scheduler = cc.director.getScheduler());
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler !== a && (this.unscheduleAllCallbacks(), this._scheduler = a)
    },
    boundingBox: function() {
        cc.log(cc._LogInfos.Node_boundingBox);
        return this.getBoundingBox()
    },
    getBoundingBox: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc._rectApplyAffineTransformIn(a, this.getNodeToParentTransform())
    },
    cleanup: function() {
        this.stopAllActions();
        this.unscheduleAllCallbacks();
        cc.eventManager.removeListeners(this);
        this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node._stateCallbackType.cleanup)
    },
    getChildByTag: function(a) {
        var b = this._children;
        if (null !== b)
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                if (d && d.tag === a) return d
            }
        return null
    },
    getChildByName: function(a) {
        if (!a) return cc.log("Invalid name"), null;
        for (var b = this._children, c = 0, d = b.length; c < d; c++)
            if (b[c]._name === a) return b[c];
        return null
    },
    addChild: function(a, b, c) {
        b = void 0 === b ? a._localZOrder : b;
        var d, e = !1;
        cc.isUndefined(c) ? (c = void 0, d = a._name) : cc.isString(c) ? (d = c, c = void 0) : cc.isNumber(c) && (e = !0, d = "");
        cc.assert(a,
            cc._LogInfos.Node_addChild_3);
        cc.assert(null === a._parent, "child already added. It can't be added again");
        this._addChildHelper(a, b, c, d, e)
    },
    _addChildHelper: function(a, b, c, d, e) {
        this._children || (this._children = []);
        this._insertChild(a, b);
        e ? a.setTag(c) : a.setName(d);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        if (this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish();
        this._cascadeColorEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
        this._cascadeOpacityEnabled && a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    removeFromParent: function(a) {
        this._parent && (void 0 === a && (a = !0), this._parent.removeChild(this, a))
    },
    removeFromParentAndCleanup: function(a) {
        cc.log(cc._LogInfos.Node_removeFromParentAndCleanup);
        this.removeFromParent(a)
    },
    removeChild: function(a, b) {
        0 !== this._children.length && (void 0 === b && (b = !0), -1 < this._children.indexOf(a) && this._detachChild(a, b), cc.renderer.childrenOrderDirty = !0)
    },
    removeChildByTag: function(a, b) {
        a ===
            cc.NODE_TAG_INVALID && cc.log(cc._LogInfos.Node_removeChildByTag);
        var c = this.getChildByTag(a);
        c ? this.removeChild(c, b) : cc.log(cc._LogInfos.Node_removeChildByTag_2, a)
    },
    removeAllChildrenWithCleanup: function(a) {
        this.removeAllChildren(a)
    },
    removeAllChildren: function(a) {
        var b = this._children;
        if (null !== b) {
            void 0 === a && (a = !0);
            for (var c = 0; c < b.length; c++) {
                var d = b[c];
                d && (this._running && (d.onExitTransitionDidStart(), d.onExit()), a && d.cleanup(), d.parent = null, d._renderCmd.detachFromParent())
            }
            this._children.length = 0;
            cc.renderer.childrenOrderDirty = !0
        }
    },
    _detachChild: function(a, b) {
        this._running && (a.onExitTransitionDidStart(), a.onExit());
        b && a.cleanup();
        a.parent = null;
        a._renderCmd.detachFromParent();
        cc.arrayRemoveObject(this._children, a)
    },
    _insertChild: function(a, b) {
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
        this._children.push(a);
        a._setLocalZOrder(b)
    },
    setNodeDirty: function() {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.Node_reorderChild);
        cc.renderer.childrenOrderDirty = this._reorderChildDirty = !0;
        a.arrivalOrder = cc.s_globalOrderOfArrival;
        cc.s_globalOrderOfArrival++;
        a._setLocalZOrder(b)
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b = a.length,
                c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
                    else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
                    else break;
                    d--
                }
                a[d + 1] = e
            }
            this._reorderChildDirty = !1
        }
    },
    draw: function(a) {},
    transformAncestors: function() {
        null !==
            this._parent && (this._parent.transformAncestors(), this._parent.transform())
    },
    onEnter: function() {
        this._isTransitionFinished = !1;
        this._running = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnter);
        this.resume()
    },
    onEnterTransitionDidFinish: function() {
        this._isTransitionFinished = !0;
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onEnterTransitionDidFinish)
    },
    onExitTransitionDidStart: function() {
        this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node._stateCallbackType.onExitTransitionDidStart)
    },
    onExit: function() {
        this._running = !1;
        this.pause();
        this._arrayMakeObjectsPerformSelector(this._children, cc.Node._stateCallbackType.onExit);
        this.removeAllComponents()
    },
    runAction: function(a) {
        cc.assert(a, cc._LogInfos.Node_runAction);
        this.actionManager.addAction(a, this, !this._running);
        return a
    },
    stopAllActions: function() {
        this.actionManager && this.actionManager.removeAllActionsFromTarget(this)
    },
    stopAction: function(a) {
        this.actionManager.removeAction(a)
    },
    stopActionByTag: function(a) {
        a === cc.ACTION_TAG_INVALID ? cc.log(cc._LogInfos.Node_stopActionByTag) : this.actionManager.removeActionByTag(a, this)
    },
    getActionByTag: function(a) {
        return a === cc.ACTION_TAG_INVALID ? (cc.log(cc._LogInfos.Node_getActionByTag), null) : this.actionManager.getActionByTag(a, this)
    },
    getNumberOfRunningActions: function() {
        return this.actionManager.numberOfRunningActionsInTarget(this)
    },
    scheduleUpdate: function() {
        this.scheduleUpdateWithPriority(0)
    },
    scheduleUpdateWithPriority: function(a) {
        this.scheduler.scheduleUpdate(this,
            a, !this._running)
    },
    unscheduleUpdate: function() {
        this.scheduler.unscheduleUpdate(this)
    },
    schedule: function(a, b, c, d, e) {
        var f = arguments.length;
        "function" === typeof a ? 1 === f ? (b = 0, c = cc.REPEAT_FOREVER, d = 0, e = this.__instanceId) : 2 === f ? "number" === typeof b ? (c = cc.REPEAT_FOREVER, d = 0, e = this.__instanceId) : (e = b, b = 0, c = cc.REPEAT_FOREVER, d = 0) : 3 === f ? ("string" === typeof c ? (e = c, c = cc.REPEAT_FOREVER) : e = this.__instanceId, d = 0) : 4 === f && (e = this.__instanceId) : 1 === f ? (b = 0, c = cc.REPEAT_FOREVER, d = 0) : 2 === f && (c = cc.REPEAT_FOREVER, d = 0);
        cc.assert(a,
            cc._LogInfos.Node_schedule);
        cc.assert(0 <= b, cc._LogInfos.Node_schedule_2);
        c = null == c ? cc.REPEAT_FOREVER : c;
        this.scheduler.schedule(a, this, b || 0, c, d || 0, !this._running, e)
    },
    scheduleOnce: function(a, b, c) {
        void 0 === c && (c = this.__instanceId);
        this.schedule(a, 0, 0, b, c)
    },
    unschedule: function(a) {
        a && this.scheduler.unschedule(a, this)
    },
    unscheduleAllCallbacks: function() {
        this.scheduler.unscheduleAllForTarget(this)
    },
    resumeSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_resumeSchedulerAndActions);
        this.resume()
    },
    resume: function() {
        this.scheduler.resumeTarget(this);
        this.actionManager && this.actionManager.resumeTarget(this);
        cc.eventManager.resumeTarget(this)
    },
    pauseSchedulerAndActions: function() {
        cc.log(cc._LogInfos.Node_pauseSchedulerAndActions);
        this.pause()
    },
    pause: function() {
        this.scheduler.pauseTarget(this);
        this.actionManager && this.actionManager.pauseTarget(this);
        cc.eventManager.pauseTarget(this)
    },
    setAdditionalTransform: function(a) {
        if (void 0 === a) return this._additionalTransformDirty = !1;
        this._additionalTransform = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._additionalTransformDirty = !0
    },
    getParentToNodeTransform: function() {
        this._renderCmd.getParentToNodeTransform()
    },
    parentToNodeTransform: function() {
        return this.getParentToNodeTransform()
    },
    getNodeToWorldTransform: function() {
        for (var a = this.getNodeToParentTransform(), b = this._parent; null !== b; b = b.parent) a = cc.affineTransformConcat(a, b.getNodeToParentTransform());
        return a
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getWorldToNodeTransform: function() {
        return cc.affineTransformInvert(this.getNodeToWorldTransform())
    },
    worldToNodeTransform: function() {
        return this.getWorldToNodeTransform()
    },
    convertToNodeSpace: function(a) {
        return cc.pointApplyAffineTransform(a, this.getWorldToNodeTransform())
    },
    convertToWorldSpace: function(a) {
        a = a || cc.p(0, 0);
        return cc.pointApplyAffineTransform(a, this.getNodeToWorldTransform())
    },
    convertToNodeSpaceAR: function(a) {
        return cc.pSub(this.convertToNodeSpace(a), this._renderCmd.getAnchorPointInPoints())
    },
    convertToWorldSpaceAR: function(a) {
        a = a || cc.p(0, 0);
        a = cc.pAdd(a, this._renderCmd.getAnchorPointInPoints());
        return this.convertToWorldSpace(a)
    },
    _convertToWindowSpace: function(a) {
        a = this.convertToWorldSpace(a);
        return cc.director.convertToUI(a)
    },
    convertTouchToNodeSpace: function(a) {
        a = a.getLocation();
        return this.convertToNodeSpace(a)
    },
    convertTouchToNodeSpaceAR: function(a) {
        a = cc.director.convertToGL(a.getLocation());
        return this.convertToNodeSpaceAR(a)
    },
    update: function(a) {
        this._componentContainer && !this._componentContainer.isEmpty() && this._componentContainer.visit(a)
    },
    updateTransform: function() {
        this._arrayMakeObjectsPerformSelector(this._children,
            cc.Node._stateCallbackType.updateTransform)
    },
    retain: function() {},
    release: function() {},
    getComponent: function(a) {
        return this._componentContainer ? this._componentContainer.getComponent(a) : null
    },
    addComponent: function(a) {
        this._componentContainer && this._componentContainer.add(a)
    },
    removeComponent: function(a) {
        return this._componentContainer ? this._componentContainer.remove(a) : !1
    },
    removeAllComponents: function() {
        this._componentContainer && this._componentContainer.removeAll()
    },
    grid: null,
    visit: function(a) {
        this._renderCmd.visit(a)
    },
    transform: function(a, b) {
        this._renderCmd.transform(a, b)
    },
    nodeToParentTransform: function() {
        return this.getNodeToParentTransform()
    },
    getNodeToParentTransform: function(a) {
        var b = this._renderCmd.getNodeToParentTransform();
        if (a)
            for (var b = {
                    a: b.a,
                    b: b.b,
                    c: b.c,
                    d: b.d,
                    tx: b.tx,
                    ty: b.ty
                }, c = this._parent; null != c && c != a; c = c.getParent()) cc.affineTransformConcatIn(b, c.getNodeToParentTransform());
        return b
    },
    getNodeToParentAffineTransform: function(a) {
        return this.getNodeToParentTransform(a)
    },
    getCamera: function() {
        this._camera ||
            (this._camera = new cc.Camera);
        return this._camera
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    getShaderProgram: function() {
        return this._renderCmd.getShaderProgram()
    },
    setShaderProgram: function(a) {
        this._renderCmd.setShaderProgram(a)
    },
    getGLServerState: function() {
        return 0
    },
    setGLServerState: function(a) {},
    getBoundingBoxToWorld: function() {
        var a = cc.rect(0, 0, this._contentSize.width, this._contentSize.height),
            b = this.getNodeToWorldTransform(),
            a = cc.rectApplyAffineTransform(a, b);
        if (!this._children) return a;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(b)) && (a = cc.rectUnion(a, e))
        }
        return a
    },
    _getBoundingBoxToCurrentNode: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        a = void 0 === a ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), a);
        b = cc.rectApplyAffineTransform(b, a);
        if (!this._children) return b;
        for (var c = this._children, d = 0; d < c.length; d++) {
            var e = c[d];
            e && e._visible && (e = e._getBoundingBoxToCurrentNode(a)) &&
                (b = cc.rectUnion(b, e))
        }
        return b
    },
    getOpacity: function() {
        return this._realOpacity
    },
    getDisplayedOpacity: function() {
        return this._renderCmd.getDisplayedOpacity()
    },
    setOpacity: function(a) {
        this._realOpacity = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    setOpacityEx: function(a) {
        this._realOpacity = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty);
        this._renderCmd._updateDisplayOpacity()
    },
    updateDisplayedOpacity: function(a) {
        this._renderCmd._updateDisplayOpacity(a)
    },
    isCascadeOpacityEnabled: function() {
        return this._cascadeOpacityEnabled
    },
    setCascadeOpacityEnabled: function(a) {
        this._cascadeOpacityEnabled !== a && (this._cascadeOpacityEnabled = a, this._renderCmd.setCascadeOpacityEnabledDirty())
    },
    getColor: function() {
        var a = this._realColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedColor: function() {
        return this._renderCmd.getDisplayedColor()
    },
    setColor: function(a) {
        var b = this._realColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    updateDisplayedColor: function(a) {
        this._renderCmd._updateDisplayColor(a)
    },
    isCascadeColorEnabled: function() {
        return this._cascadeColorEnabled
    },
    setCascadeColorEnabled: function(a) {
        this._cascadeColorEnabled !== a && (this._cascadeColorEnabled = a, this._renderCmd.setCascadeColorEnabledDirty())
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _initRendererCmd: function() {
        this._renderCmd = cc.renderer.getRenderCmd(this)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Node.CanvasRenderCmd(this) : new cc.Node.WebGLRenderCmd(this)
    },
    enumerateChildren: function(a, b) {
        cc.assert(a && 0 != a.length, "Invalid name");
        cc.assert(null != b, "Invalid callback function");
        var c = a.length,
            d = 0,
            e = c,
            f = !1;
        2 < c && "/" === a[0] && "/" === a[1] && (f = !0, d = 2, e -= 2);
        var g = !1;
        3 < c && "/" === a[c - 3] && "." === a[c - 2] && "." === a[c - 1] && (g = !0, e -= 3);
        c = a.substr(d, e);
        g && (c = "[[:alnum:]]+/" + c);
        f ? this.doEnumerateRecursive(this, c, b) : this.doEnumerate(c, b)
    },
    doEnumerateRecursive: function(a, b, c) {
        if (!a.doEnumerate(b, c))
            for (var d = a.getChildren(), e = d.length, f = 0; f < e && (a = d[f], !this.doEnumerateRecursive(a,
                    b, c)); f++);
    },
    doEnumerate: function(a, b) {
        var c = a.indexOf("/"),
            d = a,
            e = !1; - 1 !== c && (d = a.substr(0, c), e = !0);
        for (var c = !1, f, g = this._children, h = g.length, k = 0; k < h; k++)
            if (f = g[k], -1 !== f._name.indexOf(d))
                if (e) {
                    if (c = f.doEnumerate(a, b)) break
                } else if (b(f)) {
            c = !0;
            break
        }
        return c
    }
});
cc.Node.create = function() {
    return new cc.Node
};
cc.Node._stateCallbackType = {
    onEnter: 1,
    onExit: 2,
    cleanup: 3,
    onEnterTransitionDidFinish: 4,
    updateTransform: 5,
    onExitTransitionDidStart: 6,
    sortAllChildren: 7
};
cc.assert(cc.isFunction(cc._tmp.PrototypeCCNode), cc._LogInfos.MissingFile, "BaseNodesPropertyDefine.js");
cc._tmp.PrototypeCCNode();
delete cc._tmp.PrototypeCCNode;
cc.CustomRenderCmd = function(a, b) {
    this._needDraw = !0;
    this._target = a;
    this._callback = b;
    this.rendering = function(a, b, e) {
        this._callback && this._callback.call(this._target, a, b, e)
    }
};
cc.Node._dirtyFlags = {
    transformDirty: 1,
    visibleDirty: 2,
    colorDirty: 4,
    opacityDirty: 8,
    cacheDirty: 16,
    orderDirty: 32,
    textDirty: 64,
    gradientDirty: 128,
    all: 255
};
cc.Node.RenderCmd = function(a) {
    this._dirtyFlag = 1;
    this._node = a;
    this._needDraw = !1;
    this._anchorPointInPoints = new cc.Point(0, 0);
    this._transform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    };
    this._worldTransform = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    };
    this._inverse = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    };
    this._displayedOpacity = 255;
    this._displayedColor = cc.color(255, 255, 255, 255);
    this._cascadeOpacityEnabledDirty = this._cascadeColorEnabledDirty = !1;
    this._curLevel = -1
};
cc.Node.RenderCmd.prototype = {
    constructor: cc.Node.RenderCmd,
    getAnchorPointInPoints: function() {
        return cc.p(this._anchorPointInPoints)
    },
    getDisplayedColor: function() {
        var a = this._displayedColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getDisplayedOpacity: function() {
        return this._displayedOpacity
    },
    setCascadeColorEnabledDirty: function() {
        this._cascadeColorEnabledDirty = !0;
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    setCascadeOpacityEnabledDirty: function() {
        this._cascadeOpacityEnabledDirty = !0;
        this.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getParentToNodeTransform: function() {
        this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this._inverse = cc.affineTransformInvert(this.getNodeToParentTransform()));
        return this._inverse
    },
    detachFromParent: function() {},
    _updateAnchorPointInPoint: function() {
        var a = this._anchorPointInPoints,
            b = this._node._contentSize,
            c = this._node._anchorPoint;
        a.x = b.width * c.x;
        a.y = b.height * c.y;
        this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    setDirtyFlag: function(a) {
        0 === this._dirtyFlag && 0 !== a && cc.renderer.pushDirtyNode(this);
        this._dirtyFlag |= a
    },
    getParentRenderCmd: function() {
        return this._node && this._node._parent && this._node._parent._renderCmd ? this._node._parent._renderCmd : null
    },
    _updateDisplayColor: function(a) {
        var b = this._node,
            c = this._displayedColor,
            d = b._realColor,
            e;
        if (this._cascadeColorEnabledDirty && !b._cascadeColorEnabled) {
            c.r = d.r;
            c.g = d.g;
            c.b = d.b;
            c = new cc.Color(255, 255, 255, 255);
            a = b._children;
            b = 0;
            for (d = a.length; b < d; b++)(e = a[b]) && e._renderCmd && e._renderCmd._updateDisplayColor(c);
            this._cascadeColorEnabledDirty = !1
        } else if (void 0 ===
            a && (a = (a = b._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE), c.r = 0 | d.r * a.r / 255, c.g = 0 | d.g * a.g / 255, c.b = 0 | d.b * a.b / 255, b._cascadeColorEnabled)
            for (a = b._children, b = 0, d = a.length; b < d; b++)(e = a[b]) && e._renderCmd && (e._renderCmd._updateDisplayColor(c), e._renderCmd._updateColor());
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
    },
    _updateDisplayOpacity: function(a) {
        var b = this._node,
            c, d;
        if (this._cascadeOpacityEnabledDirty && !b._cascadeOpacityEnabled) {
            this._displayedOpacity = b._realOpacity;
            c = b._children;
            a = 0;
            for (b = c.length; a < b; a++)(d = c[a]) && d._renderCmd && d._renderCmd._updateDisplayOpacity(255);
            this._cascadeOpacityEnabledDirty = !1
        } else if (void 0 === a && (c = b._parent, a = 255, c && c._cascadeOpacityEnabled && (a = c.getDisplayedOpacity())), this._displayedOpacity = b._realOpacity * a / 255, b._cascadeOpacityEnabled)
            for (c = b._children, a = 0, b = c.length; a < b; a++)(d = c[a]) && d._renderCmd && (d._renderCmd._updateDisplayOpacity(this._displayedOpacity), d._renderCmd._updateColor());
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty
    },
    _syncDisplayColor: function(a) {
        var b = this._node,
            c = this._displayedColor,
            d = b._realColor;
        void 0 === a && (a = (a = b._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE);
        c.r = 0 | d.r * a.r / 255;
        c.g = 0 | d.g * a.g / 255;
        c.b = 0 | d.b * a.b / 255
    },
    _syncDisplayOpacity: function(a) {
        var b = this._node;
        if (void 0 === a) {
            var c = b._parent;
            a = 255;
            c && c._cascadeOpacityEnabled && (a = c.getDisplayedOpacity())
        }
        this._displayedOpacity = b._realOpacity * a / 255
    },
    _updateColor: function() {},
    updateStatus: function() {
        var a = cc.Node._dirtyFlags,
            b = this._dirtyFlag,
            c = b & a.colorDirty,
            d = b & a.opacityDirty;
        c && this._updateDisplayColor();
        d && this._updateDisplayOpacity();
        (c || d) && this._updateColor();
        b & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    },
    getNodeToParentTransform: function() {
        var a = this._node;
        if (a._usingNormalizedPosition && a._parent) {
            var b = a._parent._contentSize;
            a._position.x = a._normalizedPosition.x * b.width;
            a._position.y = a._normalizedPosition.y * b.height;
            a._normalizedPositionDirty = !1;
            this._dirtyFlag |= cc.Node._dirtyFlags.transformDirty
        }
        if (this._dirtyFlag & cc.Node._dirtyFlags.transformDirty) {
            b = this._transform;
            b.tx = a._position.x;
            b.ty = a._position.y;
            var c = 1,
                d = 0,
                e = 0,
                f = 1;
            a._rotationX && (f = 0.017453292519943295 * a._rotationX, e = Math.sin(f), f = Math.cos(f));
            a._rotationY && (d = 0.017453292519943295 * a._rotationY, c = Math.cos(d), d = -Math.sin(d));
            b.a = c;
            b.b = d;
            b.c = e;
            b.d = f;
            var g = a._scaleX,
                h = a._scaleY,
                k = this._anchorPointInPoints.x,
                m = this._anchorPointInPoints.y,
                n = 1E-6 > g && -1E-6 < g ? 1E-6 : g,
                p = 1E-6 > h && -1E-6 < h ?
                1E-6 : h;
            if (1 !== g || 1 !== h) c = b.a *= n, d = b.b *= n, e = b.c *= p, f = b.d *= p;
            if (a._skewX || a._skewY) g = Math.tan(-a._skewX * Math.PI / 180), h = Math.tan(-a._skewY * Math.PI / 180), Infinity === g && (g = 99999999), Infinity === h && (h = 99999999), n = m * g, p = k * h, b.a = c - e * h, b.b = d - f * h, b.c = e - c * g, b.d = f - d * g, b.tx += c * n + e * p, b.ty += d * n + f * p;
            b.tx -= c * k + e * m;
            b.ty -= d * k + f * m;
            a._ignoreAnchorPointForPosition && (b.tx += k, b.ty += m);
            a._additionalTransformDirty && (this._transform = cc.affineTransformConcat(b, a._additionalTransform))
        }
        return this._transform
    },
    _syncStatus: function(a) {
        var b =
            cc.Node._dirtyFlags,
            c = this._dirtyFlag,
            d = a ? a._node : null;
        d && d._cascadeColorEnabled && a._dirtyFlag & b.colorDirty && (c |= b.colorDirty);
        d && d._cascadeOpacityEnabled && a._dirtyFlag & b.opacityDirty && (c |= b.opacityDirty);
        a && a._dirtyFlag & b.transformDirty && (c |= b.transformDirty);
        var d = c & b.colorDirty,
            e = c & b.opacityDirty;
        this._dirtyFlag = c;
        d && this._syncDisplayColor();
        e && this._syncDisplayOpacity();
        d && this._updateColor();
        (cc._renderType === cc.game.RENDER_TYPE_WEBGL || c & b.transformDirty) && this.transform(a)
    },
    visitChildren: function() {
        var a =
            this._node,
            b = a._children,
            c, d = b.length;
        if (0 < d) {
            a.sortAllChildren();
            for (a = 0; a < d; a++)
                if (c = b[a], 0 > c._localZOrder) c._renderCmd.visit(this);
                else break;
            for (cc.renderer.pushRenderCommand(this); a < d; a++) b[a]._renderCmd.visit(this)
        } else cc.renderer.pushRenderCommand(this);
        this._dirtyFlag = 0
    }
};
(function() {
    cc.Node.CanvasRenderCmd = function(a) {
        cc.Node.RenderCmd.call(this, a);
        this._cachedParent = null;
        this._cacheDirty = !1
    };
    var a = cc.Node.CanvasRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    a.constructor = cc.Node.CanvasRenderCmd;
    a.transform = function(a, c) {
        var d = this.getNodeToParentTransform(),
            e = this._worldTransform;
        this._cacheDirty = !0;
        if (a) {
            var f = a._worldTransform;
            e.a = d.a * f.a + d.b * f.c;
            e.b = d.a * f.b + d.b * f.d;
            e.c = d.c * f.a + d.d * f.c;
            e.d = d.c * f.b + d.d * f.d;
            e.tx = f.a * d.tx + f.c * d.ty + f.tx;
            e.ty = f.d * d.ty +
                f.ty + f.b * d.tx
        } else e.a = d.a, e.b = d.b, e.c = d.c, e.d = d.d, e.tx = d.tx, e.ty = d.ty;
        if (c && (d = this._node._children) && 0 !== d.length)
            for (e = 0, f = d.length; e < f; e++) d[e]._renderCmd.transform(this, c)
    };
    a.visit = function(a) {
        if (this._node._visible) {
            if (a = a || this.getParentRenderCmd()) this._curLevel = a._curLevel + 1;
            this._syncStatus(a);
            this.visitChildren()
        }
    };
    a.setDirtyFlag = function(a, c) {
        cc.Node.RenderCmd.prototype.setDirtyFlag.call(this, a, c);
        this._setCacheDirty(c);
        this._cachedParent && this._cachedParent.setDirtyFlag(a, !0)
    };
    a._setCacheDirty =
        function() {
            if (!1 === this._cacheDirty) {
                this._cacheDirty = !0;
                var a = this._cachedParent;
                a && a !== this && a._setNodeDirtyForCache && a._setNodeDirtyForCache()
            }
        };
    a._setCachedParent = function(a) {
        if (this._cachedParent !== a) {
            this._cachedParent = a;
            for (var c = this._node._children, d = 0, e = c.length; d < e; d++) c[d]._renderCmd._setCachedParent(a)
        }
    };
    a.detachFromParent = function() {
        this._cachedParent = null;
        for (var a = this._node._children, c, d = 0, e = a.length; d < e; d++)(c = a[d]) && c._renderCmd && c._renderCmd.detachFromParent()
    };
    a.setShaderProgram =
        function(a) {};
    a.getShaderProgram = function() {
        return null
    };
    cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(a) {
        return a ? a.src === cc.SRC_ALPHA && a.dst === cc.ONE || a.src === cc.ONE && a.dst === cc.ONE ? "lighter" : a.src === cc.ZERO && a.dst === cc.SRC_ALPHA ? "destination-in" : a.src === cc.ZERO && a.dst === cc.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over"
    }
})();
(function() {
    cc.Node.WebGLRenderCmd = function(a) {
        cc.Node.RenderCmd.call(this, a);
        a = new cc.math.Matrix4;
        var c = a.mat;
        c[2] = c[3] = c[6] = c[7] = c[8] = c[9] = c[11] = c[14] = 0;
        c[10] = c[15] = 1;
        this._transform4x4 = a;
        this._stackMatrix = new cc.math.Matrix4;
        this._camera = this._shaderProgram = null
    };
    var a = cc.Node.WebGLRenderCmd.prototype = Object.create(cc.Node.RenderCmd.prototype);
    a.constructor = cc.Node.WebGLRenderCmd;
    a._updateColor = function() {};
    a.visit = function(a) {
        var c = this._node;
        c._visible && (a = a || this.getParentRenderCmd(), c._parent &&
            c._parent._renderCmd && (this._curLevel = c._parent._renderCmd._curLevel + 1), c = cc.current_stack, c.stack.push(c.top), this._syncStatus(a), c.top = this._stackMatrix, this.visitChildren(), c.top = c.stack.pop())
    };
    a.transform = function(a, c) {
        var d = this._transform4x4,
            e = this._stackMatrix,
            f = this._node,
            g = (a = a || this.getParentRenderCmd()) ? a._stackMatrix : cc.current_stack.top,
            h = this.getNodeToParentTransform();
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty;
        var k = d.mat;
        k[0] = h.a;
        k[4] = h.c;
        k[12] = h.tx;
        k[1] =
            h.b;
        k[5] = h.d;
        k[13] = h.ty;
        k[14] = f._vertexZ;
        cc.kmMat4Multiply(e, g, d);
        null === f._camera || null !== f.grid && f.grid.isActive() || (g = this._anchorPointInPoints.x, h = this._anchorPointInPoints.y, 0 !== g || 0 !== h ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (g |= 0, h |= 0), k = cc.math.Matrix4.createByTranslation(g, h, 0, d), e.multiply(k), f._camera._locateForRenderer(e), k = cc.math.Matrix4.createByTranslation(-g, -h, 0, k), e.multiply(k), d.identity()) : f._camera._locateForRenderer(e));
        if (c && f._children && 0 !== f._children.length)
            for (f = f._children,
                d = 0, e = f.length; d < e; d++) f[d]._renderCmd.transform(this, c)
    };
    a.setShaderProgram = function(a) {
        this._shaderProgram = a
    };
    a.getShaderProgram = function() {
        return this._shaderProgram
    }
})();
cc.AtlasNode = cc.Node.extend({
    textureAtlas: null,
    quadsToDraw: 0,
    _itemsPerRow: 0,
    _itemsPerColumn: 0,
    _itemWidth: 0,
    _itemHeight: 0,
    _opacityModifyRGB: !1,
    _blendFunc: null,
    _ignoreContentScaleFactor: !1,
    _className: "AtlasNode",
    _texture: null,
    _textureForCanvas: null,
    ctor: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._ignoreContentScaleFactor = !1;
        void 0 !== d && this.initWithTileFile(a, b, c, d)
    },
    _createRenderCmd: function() {
        this._renderCmd = cc._renderType === cc.game.RENDER_TYPE_CANVAS ?
            new cc.AtlasNode.CanvasRenderCmd(this) : new cc.AtlasNode.WebGLRenderCmd(this)
    },
    updateAtlasValues: function() {
        cc.log(cc._LogInfos.AtlasNode_updateAtlasValues)
    },
    getColor: function() {
        return this._opacityModifyRGB ? this._renderCmd._colorUnmodified : cc.Node.prototype.getColor.call(this)
    },
    setOpacityModifyRGB: function(a) {
        var b = this.color;
        this._opacityModifyRGB = a;
        this.setColor(b)
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a,
        b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    getQuadsToDraw: function() {
        return this.quadsToDraw
    },
    setQuadsToDraw: function(a) {
        this.quadsToDraw = a
    },
    initWithTileFile: function(a, b, c, d) {
        if (!a) throw Error("cc.AtlasNode.initWithTileFile(): title should not be null");
        a = cc.textureCache.addImage(a);
        return this.initWithTexture(a, b, c, d)
    },
    initWithTexture: function(a, b, c, d) {
        return this._renderCmd.initWithTexture(a,
            b, c, d)
    },
    setColor: function(a) {
        this._renderCmd.setColor(a)
    },
    setOpacity: function(a) {
        this._renderCmd.setOpacity(a)
    },
    getTexture: function() {
        return this._texture
    },
    setTexture: function(a) {
        this._texture = a
    },
    _setIgnoreContentScaleFactor: function(a) {
        this._ignoreContentScaleFactor = a
    }
});
_p = cc.AtlasNode.prototype;
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.EventHelper.prototype.apply(_p);
cc.AtlasNode.create = function(a, b, c, d) {
    return new cc.AtlasNode(a, b, c, d)
};
(function() {
    cc.AtlasNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1;
        this._colorUnmodified = cc.color.WHITE;
        this._textureToRender = null
    };
    var a = cc.AtlasNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.AtlasNode.CanvasRenderCmd;
    a.initWithTexture = function(a, c, d, e) {
        var f = this._node;
        f._itemWidth = c;
        f._itemHeight = d;
        f._opacityModifyRGB = !0;
        f._texture = a;
        if (!f._texture) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._textureToRender = a;
        this._calculateMaxItems();
        f.quadsToDraw = e;
        return !0
    };
    a.setColor = function(a) {
        var c = this._node._realColor;
        if (c.r !== a.r || c.g !== a.g || c.b !== a.b) this._colorUnmodified = a, this._changeTextureColor()
    };
    a._changeTextureColor = function() {
        var a = this._node._texture,
            c = this._colorUnmodified,
            d = a.getHtmlElementObj(),
            d = cc.rect(0, 0, d.width, d.height);
        a === this._textureToRender ? this._textureToRender = a._generateColorTexture(c.r, c.g, c.b, d) : a._generateColorTexture(c.r, c.g, c.b, d, this._textureToRender.getHtmlElementObj())
    };
    a.setOpacity = function(a) {
        cc.Node.prototype.setOpacity.call(this._node, a)
    };
    a._calculateMaxItems = function() {
        var a = this._node,
            c = a._texture.getContentSize();
        a._itemsPerColumn = 0 | c.height / a._itemHeight;
        a._itemsPerRow = 0 | c.width / a._itemWidth
    }
})();
(function() {
    cc.AtlasNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureAtlas = null;
        this._colorUnmodified = cc.color.WHITE;
        this._uniformColor = this._colorF32Array = null;
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        this._uniformColor = cc._renderContext.getUniformLocation(this._shaderProgram.getProgram(), "u_color")
    };
    var a = cc.AtlasNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor =
        cc.AtlasNode.WebGLRenderCmd;
    a._updateBlendFunc = function() {
        var a = this._node;
        this._textureAtlas.texture.hasPremultipliedAlpha() || (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    };
    a._updateOpacityModifyRGB = function() {
        this._node._opacityModifyRGB = this._textureAtlas.texture.hasPremultipliedAlpha()
    };
    a.rendering = function(a) {
        a = a || cc._renderContext;
        var c = this._node;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        cc.glBlendFunc(c._blendFunc.src,
            c._blendFunc.dst);
        this._uniformColor && this._colorF32Array && (a.uniform4fv(this._uniformColor, this._colorF32Array), this._textureAtlas.drawNumberOfQuads(c.quadsToDraw, 0))
    };
    a.initWithTexture = function(a, c, d, e) {
        var f = this._node;
        f._itemWidth = c;
        f._itemHeight = d;
        this._colorUnmodified = cc.color.WHITE;
        f._opacityModifyRGB = !0;
        f._blendFunc.src = cc.BLEND_SRC;
        f._blendFunc.dst = cc.BLEND_DST;
        c = f._realColor;
        this._colorF32Array = new Float32Array([c.r / 255, c.g / 255, c.b / 255, f._realOpacity / 255]);
        this._textureAtlas = new cc.TextureAtlas;
        this._textureAtlas.initWithTexture(a, e);
        if (!this._textureAtlas) return cc.log(cc._LogInfos.AtlasNode__initWithTexture), !1;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB();
        this._calculateMaxItems();
        f.quadsToDraw = e;
        return !0
    };
    a.setColor = function(a) {
        var c = cc.color(a.r, a.g, a.b),
            d = this._node;
        this._colorUnmodified = a;
        a = this._displayedOpacity;
        d._opacityModifyRGB && (c.r = c.r * a / 255, c.g = c.g * a / 255, c.b = c.b * a / 255);
        cc.Node.prototype.setColor.call(d, c)
    };
    a.setOpacity = function(a) {
        var c = this._node;
        cc.Node.prototype.setOpacity.call(c,
            a);
        c._opacityModifyRGB && (c.color = this._colorUnmodified)
    };
    a._updateColor = function() {
        var a = this._displayedColor;
        this._colorF32Array = new Float32Array([a.r / 255, a.g / 255, a.b / 255, this._displayedOpacity / 255])
    };
    a.getTexture = function() {
        return this._textureAtlas.texture
    };
    a.setTexture = function(a) {
        this._textureAtlas.texture = a;
        this._updateBlendFunc();
        this._updateOpacityModifyRGB()
    };
    a._calculateMaxItems = function() {
        var a = this._node,
            c = this._textureAtlas.texture,
            d = c.getContentSize();
        a._ignoreContentScaleFactor && (d =
            c.getContentSizeInPixels());
        a._itemsPerColumn = 0 | d.height / a._itemHeight;
        a._itemsPerRow = 0 | d.width / a._itemWidth
    }
})();
cc._tmp.WebGLTexture2D = function() {
    cc.Texture2D = cc.Class.extend({
        _pVRHaveAlphaPremultiplied: !0,
        _pixelFormat: null,
        _pixelsWide: 0,
        _pixelsHigh: 0,
        _name: "",
        _contentSize: null,
        maxS: 0,
        maxT: 0,
        _hasPremultipliedAlpha: !1,
        _hasMipmaps: !1,
        shaderProgram: null,
        _textureLoaded: !1,
        _htmlElementObj: null,
        _webTextureObj: null,
        url: null,
        ctor: function() {
            this._contentSize = cc.size(0, 0);
            this._pixelFormat = cc.Texture2D.defaultPixelFormat
        },
        releaseTexture: function() {
            this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
            cc.loader.release(this.url)
        },
        getPixelFormat: function() {
            return this._pixelFormat
        },
        getPixelsWide: function() {
            return this._pixelsWide
        },
        getPixelsHigh: function() {
            return this._pixelsHigh
        },
        getName: function() {
            return this._webTextureObj
        },
        getContentSize: function() {
            return cc.size(this._contentSize.width / cc.contentScaleFactor(), this._contentSize.height / cc.contentScaleFactor())
        },
        _getWidth: function() {
            return this._contentSize.width / cc.contentScaleFactor()
        },
        _getHeight: function() {
            return this._contentSize.height / cc.contentScaleFactor()
        },
        getContentSizeInPixels: function() {
            return this._contentSize
        },
        getMaxS: function() {
            return this.maxS
        },
        setMaxS: function(a) {
            this.maxS = a
        },
        getMaxT: function() {
            return this.maxT
        },
        setMaxT: function(a) {
            this.maxT = a
        },
        getShaderProgram: function() {
            return this.shaderProgram
        },
        setShaderProgram: function(a) {
            this.shaderProgram = a
        },
        hasPremultipliedAlpha: function() {
            return this._hasPremultipliedAlpha
        },
        hasMipmaps: function() {
            return this._hasMipmaps
        },
        description: function() {
            return "\x3ccc.Texture2D | Name \x3d " + this._name + " | Dimensions \x3d " +
                this._pixelsWide + " x " + this._pixelsHigh + " | Coordinates \x3d (" + this.maxS + ", " + this.maxT + ")\x3e"
        },
        releaseData: function(a) {},
        keepData: function(a, b) {
            return a
        },
        initWithData: function(a, b, c, d, e) {
            var f = cc.Texture2D,
                g = cc._renderContext,
                h = g.RGBA,
                k = g.UNSIGNED_BYTE,
                m = c * cc.Texture2D._B[b] / 8;
            0 === m % 8 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 8) : 0 === m % 4 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 4) : 0 === m % 2 ? g.pixelStorei(g.UNPACK_ALIGNMENT, 2) : g.pixelStorei(g.UNPACK_ALIGNMENT, 1);
            this._webTextureObj = g.createTexture();
            cc.glBindTexture2D(this);
            g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.LINEAR);
            g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.LINEAR);
            g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE);
            g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE);
            switch (b) {
                case f.PIXEL_FORMAT_RGBA8888:
                    h = g.RGBA;
                    break;
                case f.PIXEL_FORMAT_RGB888:
                    h = g.RGB;
                    break;
                case f.PIXEL_FORMAT_RGBA4444:
                    k = g.UNSIGNED_SHORT_4_4_4_4;
                    break;
                case f.PIXEL_FORMAT_RGB5A1:
                    k = g.UNSIGNED_SHORT_5_5_5_1;
                    break;
                case f.PIXEL_FORMAT_RGB565:
                    k = g.UNSIGNED_SHORT_5_6_5;
                    break;
                case f.PIXEL_FORMAT_AI88:
                    h = g.LUMINANCE_ALPHA;
                    break;
                case f.PIXEL_FORMAT_A8:
                    h = g.ALPHA;
                    break;
                case f.PIXEL_FORMAT_I8:
                    h = g.LUMINANCE;
                    break;
                default:
                    cc.assert(0, cc._LogInfos.Texture2D_initWithData)
            }
            g.texImage2D(g.TEXTURE_2D, 0, h, c, d, 0, h, k, a);
            this._contentSize.width = e.width;
            this._contentSize.height = e.height;
            this._pixelsWide = c;
            this._pixelsHigh = d;
            this._pixelFormat = b;
            this.maxS = e.width / c;
            this.maxT = e.height / d;
            this._hasMipmaps = this._hasPremultipliedAlpha = !1;
            this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
            return this._textureLoaded = !0
        },
        drawAtPoint: function(a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0],
                c = this._pixelsWide * this.maxS,
                d = this._pixelsHigh * this.maxT;
            a = [a.x, a.y, 0, c + a.x, a.y, 0, a.x, d + a.y, 0, c + a.x, d + a.y, 0];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            c = cc._renderContext;
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, c.FLOAT, !1, 0, b);
            c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
        },
        drawInRect: function(a) {
            var b = [0, this.maxT, this.maxS, this.maxT, 0, 0, this.maxS, 0];
            a = [a.x, a.y, a.x + a.width, a.y, a.x, a.y + a.height, a.x + a.width, a.y + a.height];
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
            this._shaderProgram.use();
            this._shaderProgram.setUniformsForBuiltins();
            cc.glBindTexture2D(this);
            var c = cc._renderContext;
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, a);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS,
                2, c.FLOAT, !1, 0, b);
            c.drawArrays(c.TRIANGLE_STRIP, 0, 4)
        },
        initWithImage: function(a) {
            if (null == a) return cc.log(cc._LogInfos.Texture2D_initWithImage), !1;
            var b = a.getWidth(),
                c = a.getHeight(),
                d = cc.configuration.getMaxTextureSize();
            if (b > d || c > d) return cc.log(cc._LogInfos.Texture2D_initWithImage_2, b, c, d, d), !1;
            this._textureLoaded = !0;
            return this._initPremultipliedATextureWithImage(a, b, c)
        },
        initWithElement: function(a) {
            a && (this._webTextureObj = cc._renderContext.createTexture(), this._htmlElementObj = a, this._textureLoaded = !0)
        },
        getHtmlElementObj: function() {
            return this._htmlElementObj
        },
        isLoaded: function() {
            return this._textureLoaded
        },
        handleLoadedTexture: function(a) {
            a = void 0 === a ? !1 : a;
            if (cc.game._rendererInitialized) {
                if (!this._htmlElementObj) {
                    var b = cc.loader.getRes(this.url);
                    if (!b) return;
                    this.initWithElement(b)
                }
                this._htmlElementObj.width && this._htmlElementObj.height && (b = cc._renderContext, cc.glBindTexture2D(this), b.pixelStorei(b.UNPACK_ALIGNMENT, 4), a && b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1), b.texImage2D(b.TEXTURE_2D,
                        0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, this._htmlElementObj), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE), cc.glBindTexture2D(null), a && b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), b = this._htmlElementObj.height, this._pixelsWide =
                    this._contentSize.width = this._htmlElementObj.width, this._pixelsHigh = this._contentSize.height = b, this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.maxT = this.maxS = 1, this._hasPremultipliedAlpha = a, this._hasMipmaps = !1, this.dispatchEvent("load"))
            }
        },
        initWithString: function(a, b, c, d, e, f) {
            cc.log(cc._LogInfos.Texture2D_initWithString);
            return null
        },
        initWithETCFile: function(a) {
            cc.log(cc._LogInfos.Texture2D_initWithETCFile_2);
            return !1
        },
        initWithPVRFile: function(a) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRFile_2);
            return !1
        },
        initWithPVRTCData: function(a, b, c, d, e, f) {
            cc.log(cc._LogInfos.Texture2D_initWithPVRTCData_2);
            return !1
        },
        setTexParameters: function(a, b, c, d) {
            var e = cc._renderContext;
            void 0 !== b && (a = {
                minFilter: a,
                magFilter: b,
                wrapS: c,
                wrapT: d
            });
            cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh) || a.wrapS === e.CLAMP_TO_EDGE && a.wrapT === e.CLAMP_TO_EDGE, "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures");
            cc.glBindTexture2D(this);
            e.texParameteri(e.TEXTURE_2D,
                e.TEXTURE_MIN_FILTER, a.minFilter);
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, a.magFilter);
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, a.wrapS);
            e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a.wrapT)
        },
        setAntiAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR)
        },
        setAliasTexParameters: function() {
            var a = cc._renderContext;
            cc.glBindTexture2D(this);
            this._hasMipmaps ? a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST_MIPMAP_NEAREST) : a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST);
            a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST)
        },
        generateMipmap: function() {
            cc.assert(this._pixelsWide === cc.NextPOT(this._pixelsWide) && this._pixelsHigh === cc.NextPOT(this._pixelsHigh), "Mimpap texture only works in POT textures");
            cc.glBindTexture2D(this);
            cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
            this._hasMipmaps = !0
        },
        stringForFormat: function() {
            return cc.Texture2D._M[this._pixelFormat]
        },
        bitsPerPixelForFormat: function(a) {
            a = a || this._pixelFormat;
            var b = cc.Texture2D._B[a];
            if (null != b) return b;
            cc.log(cc._LogInfos.Texture2D_bitsPerPixelForFormat, a);
            return -1
        },
        _initPremultipliedATextureWithImage: function(a, b, c) {
            var d = cc.Texture2D,
                e = a.getData(),
                f = null,
                f = null,
                g = a.hasAlpha(),
                h = cc.size(a.getWidth(), a.getHeight()),
                k = d.defaultPixelFormat,
                m = a.getBitsPerComponent();
            g || (8 <= m ? k = d.PIXEL_FORMAT_RGB888 : (cc.log(cc._LogInfos.Texture2D__initPremultipliedATextureWithImage), k = d.PIXEL_FORMAT_RGB565));
            var n = b * c;
            if (k === d.PIXEL_FORMAT_RGB565)
                if (g)
                    for (e = new Uint16Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 3 << 11 | (f[m] >> 8 & 255) >> 2 << 5 | (f[m] >> 16 & 255) >> 3 << 0;
                else
                    for (e = new Uint16Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] & 255) >> 3 << 11 | (f[m] & 255) >> 2 << 5 | (f[m] & 255) >> 3 << 0;
            else if (k === d.PIXEL_FORMAT_RGBA4444)
                for (e = new Uint16Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] >>
                    0 & 255) >> 4 << 12 | (f[m] >> 8 & 255) >> 4 << 8 | (f[m] >> 16 & 255) >> 4 << 4 | (f[m] >> 24 & 255) >> 4 << 0;
            else if (k === d.PIXEL_FORMAT_RGB5A1)
                for (e = new Uint16Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = (f[m] >> 0 & 255) >> 3 << 11 | (f[m] >> 8 & 255) >> 3 << 6 | (f[m] >> 16 & 255) >> 3 << 1 | (f[m] >> 24 & 255) >> 7 << 0;
            else if (k === d.PIXEL_FORMAT_A8)
                for (e = new Uint8Array(b * c), f = a.getData(), m = 0; m < n; ++m) e[m] = f >> 24 & 255;
            if (g && k === d.PIXEL_FORMAT_RGB888)
                for (f = a.getData(), e = new Uint8Array(b * c * 3), m = 0; m < n; ++m) e[3 * m] = f >> 0 & 255, e[3 * m + 1] = f >> 8 & 255, e[3 * m + 2] = f >> 16 & 255;
            this.initWithData(e,
                k, b, c, h);
            a.getData();
            this._hasPremultipliedAlpha = a.isPremultipliedAlpha();
            return !0
        },
        addLoadedEventListener: function(a, b) {
            this.addEventListener("load", a, b)
        },
        removeLoadedEventListener: function(a) {
            this.removeEventListener("load", a)
        }
    })
};
cc._tmp.WebGLTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    a._setupVBO = function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    };
    a._mapBuffers = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER,
            this._indices, a.STATIC_DRAW)
    };
    a.drawNumberOfQuads = function(a, c) {
        c = c || 0;
        if (0 !== a && this.texture && this.texture.isLoaded()) {
            var d = cc._renderContext;
            cc.glBindTexture2D(this.texture);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            d.bindBuffer(d.ARRAY_BUFFER, this._quadsWebBuffer);
            this.dirty && (d.bufferData(d.ARRAY_BUFFER, this._quadsArrayBuffer, d.DYNAMIC_DRAW), this.dirty = !1);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, d.FLOAT, !1, 24, 0);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, d.UNSIGNED_BYTE, !0, 24, 12);
            d.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, d.FLOAT, !1, 24, 16);
            d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? d.drawElements(d.TRIANGLE_STRIP, 6 * a, d.UNSIGNED_SHORT, 6 * c * this._indices.BYTES_PER_ELEMENT) : d.drawElements(d.TRIANGLES, 6 * a, d.UNSIGNED_SHORT, 6 * c * this._indices.BYTES_PER_ELEMENT);
            cc.g_NumberOfDraws++
        }
    }
};
cc._tmp.WebGLTextureCache = function() {
    var a = cc.textureCache;
    a.handleLoadedTexture = function(a) {
        var c = this._textures,
            d;
        cc.game._rendererInitialized || (c = this._loadedTexturesBefore);
        d = c[a];
        d || (d = c[a] = new cc.Texture2D, d.url = a);
        ".png" === cc.path.extname(a) ? d.handleLoadedTexture(!0) : d.handleLoadedTexture()
    };
    a.addImage = function(a, c, d) {
        cc.assert(a, cc._LogInfos.Texture2D_addImage_2);
        var e = this._textures;
        cc.game._rendererInitialized || (e = this._loadedTexturesBefore);
        var f = e[a] || e[cc.loader._getAliase(a)];
        if (f) return f.isLoaded() ?
            c && c.call(d, f) : f.addEventListener("load", function() {
                c && c.call(d, f)
            }, d), f;
        f = e[a] = new cc.Texture2D;
        f.url = a;
        (cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, a, function(f, h) {
            if (f) return c && c.call(d, f);
            cc.textureCache.handleLoadedTexture(a);
            var k = e[a];
            c && c.call(d, k)
        });
        return f
    };
    a.addImageAsync = a.addImage;
    a = null
};
cc._tmp.PrototypeTexture2D = function() {
    var a = cc.Texture2D;
    a.PVRImagesHavePremultipliedAlpha = function(a) {
        cc.PVRHaveAlphaPremultiplied_ = a
    };
    a.PIXEL_FORMAT_RGBA8888 = 2;
    a.PIXEL_FORMAT_RGB888 = 3;
    a.PIXEL_FORMAT_RGB565 = 4;
    a.PIXEL_FORMAT_A8 = 5;
    a.PIXEL_FORMAT_I8 = 6;
    a.PIXEL_FORMAT_AI88 = 7;
    a.PIXEL_FORMAT_RGBA4444 = 8;
    a.PIXEL_FORMAT_RGB5A1 = 7;
    a.PIXEL_FORMAT_PVRTC4 = 9;
    a.PIXEL_FORMAT_PVRTC2 = 10;
    a.PIXEL_FORMAT_DEFAULT = a.PIXEL_FORMAT_RGBA8888;
    a.defaultPixelFormat = a.PIXEL_FORMAT_DEFAULT;
    var b = cc.Texture2D._M = {};
    b[a.PIXEL_FORMAT_RGBA8888] =
        "RGBA8888";
    b[a.PIXEL_FORMAT_RGB888] = "RGB888";
    b[a.PIXEL_FORMAT_RGB565] = "RGB565";
    b[a.PIXEL_FORMAT_A8] = "A8";
    b[a.PIXEL_FORMAT_I8] = "I8";
    b[a.PIXEL_FORMAT_AI88] = "AI88";
    b[a.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
    b[a.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
    b[a.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
    b[a.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
    b = cc.Texture2D._B = {};
    b[a.PIXEL_FORMAT_RGBA8888] = 32;
    b[a.PIXEL_FORMAT_RGB888] = 24;
    b[a.PIXEL_FORMAT_RGB565] = 16;
    b[a.PIXEL_FORMAT_A8] = 8;
    b[a.PIXEL_FORMAT_I8] = 8;
    b[a.PIXEL_FORMAT_AI88] = 16;
    b[a.PIXEL_FORMAT_RGBA4444] =
        16;
    b[a.PIXEL_FORMAT_RGB5A1] = 16;
    b[a.PIXEL_FORMAT_PVRTC4] = 4;
    b[a.PIXEL_FORMAT_PVRTC2] = 3;
    a = cc.Texture2D.prototype;
    cc.defineGetterSetter(a, "name", a.getName);
    cc.defineGetterSetter(a, "pixelFormat", a.getPixelFormat);
    cc.defineGetterSetter(a, "pixelsWidth", a.getPixelsWide);
    cc.defineGetterSetter(a, "pixelsHeight", a.getPixelsHigh);
    cc.defineGetterSetter(a, "width", a._getWidth);
    cc.defineGetterSetter(a, "height", a._getHeight)
};
cc._tmp.PrototypeTextureAtlas = function() {
    var a = cc.TextureAtlas.prototype;
    cc.defineGetterSetter(a, "totalQuads", a.getTotalQuads);
    cc.defineGetterSetter(a, "capacity", a.getCapacity);
    cc.defineGetterSetter(a, "quads", a.getQuads, a.setQuads)
};
cc.ALIGN_CENTER = 51;
cc.ALIGN_TOP = 19;
cc.ALIGN_TOP_RIGHT = 18;
cc.ALIGN_RIGHT = 50;
cc.ALIGN_BOTTOM_RIGHT = 34;
cc.ALIGN_BOTTOM = 35;
cc.ALIGN_BOTTOM_LEFT = 33;
cc.ALIGN_LEFT = 49;
cc.ALIGN_TOP_LEFT = 17;
cc.PVRHaveAlphaPremultiplied_ = !1;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var a = {
            _contentSize: null,
            _textureLoaded: !1,
            _htmlElementObj: null,
            url: null,
            _pattern: null,
            ctor: function() {
                this._contentSize = cc.size(0, 0);
                this._textureLoaded = !1;
                this._htmlElementObj = null;
                this._pattern = ""
            },
            getPixelsWide: function() {
                return this._contentSize.width
            },
            getPixelsHigh: function() {
                return this._contentSize.height
            },
            getContentSize: function() {
                var a = cc.contentScaleFactor();
                return cc.size(this._contentSize.width /
                    a, this._contentSize.height / a)
            },
            _getWidth: function() {
                return this._contentSize.width / cc.contentScaleFactor()
            },
            _getHeight: function() {
                return this._contentSize.height / cc.contentScaleFactor()
            },
            getContentSizeInPixels: function() {
                return this._contentSize
            },
            initWithElement: function(a) {
                a && (this._htmlElementObj = a, this._contentSize.width = a.width, this._contentSize.height = a.height, this._textureLoaded = !0)
            },
            getHtmlElementObj: function() {
                return this._htmlElementObj
            },
            isLoaded: function() {
                return this._textureLoaded
            },
            handleLoadedTexture: function() {
                if (!this._textureLoaded) {
                    if (!this._htmlElementObj) {
                        var a =
                            cc.loader.getRes(this.url);
                        if (!a) return;
                        this.initWithElement(a)
                    }
                    a = this._htmlElementObj;
                    this._contentSize.width = a.width;
                    this._contentSize.height = a.height;
                    this.dispatchEvent("load")
                }
            },
            description: function() {
                return "\x3ccc.Texture2D | width \x3d " + this._contentSize.width + " height " + this._contentSize.height + "\x3e"
            },
            initWithData: function(a, c, d, e, f) {
                return !1
            },
            initWithImage: function(a) {
                return !1
            },
            initWithString: function(a, c, d, e, f, g) {
                return !1
            },
            releaseTexture: function() {
                cc.loader.release(this.url)
            },
            getName: function() {
                return null
            },
            getMaxS: function() {
                return 1
            },
            setMaxS: function(a) {},
            getMaxT: function() {
                return 1
            },
            setMaxT: function(a) {},
            getPixelFormat: function() {
                return null
            },
            getShaderProgram: function() {
                return null
            },
            setShaderProgram: function(a) {},
            hasPremultipliedAlpha: function() {
                return !1
            },
            hasMipmaps: function() {
                return !1
            },
            releaseData: function(a) {},
            keepData: function(a, c) {
                return a
            },
            drawAtPoint: function(a) {},
            drawInRect: function(a) {},
            initWithETCFile: function(a) {
                cc.log(cc._LogInfos.Texture2D_initWithETCFile);
                return !1
            },
            initWithPVRFile: function(a) {
                cc.log(cc._LogInfos.Texture2D_initWithPVRFile);
                return !1
            },
            initWithPVRTCData: function(a, c, d, e, f, g) {
                cc.log(cc._LogInfos.Texture2D_initWithPVRTCData);
                return !1
            },
            setTexParameters: function(a, c, d, e) {
                void 0 !== c && (a = {
                    minFilter: a,
                    magFilter: c,
                    wrapS: d,
                    wrapT: e
                });
                this._pattern = a.wrapS === cc.REPEAT && a.wrapT === cc.REPEAT ? "repeat" : a.wrapS === cc.REPEAT ? "repeat-x" : a.wrapT === cc.REPEAT ? "repeat-y" : ""
            },
            setAntiAliasTexParameters: function() {},
            setAliasTexParameters: function() {},
            generateMipmap: function() {},
            stringForFormat: function() {
                return ""
            },
            bitsPerPixelForFormat: function(a) {
                return -1
            },
            addLoadedEventListener: function(a, c) {
                this.addEventListener("load", a, c)
            },
            removeLoadedEventListener: function(a) {
                this.removeEventListener("load", a)
            },
            _generateColorTexture: function() {},
            _generateTextureCacheForColor: function() {
                if (this.channelCache) return this.channelCache;
                var a = [document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas")],
                    c = this._htmlElementObj,
                    d = c.width,
                    e = c.height;
                a[0].width = d;
                a[0].height = e;
                a[1].width = d;
                a[1].height =
                    e;
                a[2].width = d;
                a[2].height = e;
                a[3].width = d;
                a[3].height = e;
                var f = a[3].getContext("2d");
                f.drawImage(c, 0, 0);
                for (var f = f.getImageData(0, 0, d, e).data, g, h = 0; 4 > h; h++) {
                    g = a[h].getContext("2d");
                    for (var k = g.getImageData(0, 0, d, e), m = k.data, n = 0; n < f.length; n += 4) m[n] = 0 === h ? f[n] : 0, m[n + 1] = 1 === h ? f[n + 1] : 0, m[n + 2] = 2 === h ? f[n + 2] : 0, m[n + 3] = f[n + 3];
                    g.putImageData(k, 0, 0)
                }
                c.onload = null;
                return this.channelCache = a
            },
            _grayElementObj: null,
            _backupElement: null,
            _isGray: !1,
            _switchToGray: function(a) {
                this._textureLoaded && this._isGray !== a &&
                    ((this._isGray = a) ? (this._backupElement = this._htmlElementObj, this._grayElementObj || (this._grayElementObj = cc.Texture2D._generateGrayTexture(this._htmlElementObj)), this._htmlElementObj = this._grayElementObj) : null !== this._backupElement && (this._htmlElementObj = this._backupElement))
            }
        };
        a._generateColorTexture = cc.sys._supportCanvasNewBlendModes ? function(a, c, d, e, f) {
            var g = !1;
            f ? g = !0 : f = document.createElement("canvas");
            var h = this._htmlElementObj;
            e || (e = cc.rect(0, 0, h.width, h.height));
            f.width = e.width;
            f.height = e.height;
            var k = f.getContext("2d");
            k.globalCompositeOperation = "source-over";
            k.fillStyle = "rgb(" + (a | 0) + "," + (c | 0) + "," + (d | 0) + ")";
            k.fillRect(0, 0, e.width, e.height);
            k.globalCompositeOperation = "multiply";
            k.drawImage(h, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
            k.globalCompositeOperation = "destination-atop";
            k.drawImage(h, e.x, e.y, e.width, e.height, 0, 0, e.width, e.height);
            if (g) return f;
            a = new cc.Texture2D;
            a.initWithElement(f);
            a.handleLoadedTexture();
            return a
        } : function(a, c, d, e, f) {
            var g = !1;
            f ? g = !0 : f = document.createElement("canvas");
            var h = this._htmlElementObj;
            e || (e = cc.rect(0, 0, h.width, h.height));
            var k, m, h = e.x;
            k = e.y;
            m = e.width;
            e = e.height;
            if (m && e) {
                f.width = m;
                f.height = e;
                var n = f.getContext("2d"),
                    p = cc.textureCache.getTextureColors(this);
                n.globalCompositeOperation = "lighter";
                n.drawImage(p[3], h, k, m, e, 0, 0, m, e);
                0 < a && (n.globalAlpha = a / 255, n.drawImage(p[0], h, k, m, e, 0, 0, m, e));
                0 < c && (n.globalAlpha = c / 255, n.drawImage(p[1], h, k, m, e, 0, 0, m, e));
                0 < d && (n.globalAlpha = d / 255, n.drawImage(p[2], h, k, m, e, 0, 0, m, e));
                if (g) return f;
                a = new cc.Texture2D;
                a.initWithElement(f);
                a.handleLoadedTexture();
                return a
            }
        };
        cc.Texture2D = cc.Class.extend(a);
        cc.Texture2D._generateGrayTexture = function(a, c, d) {
            if (null === a) return null;
            d = d || document.createElement("canvas");
            c = c || cc.rect(0, 0, a.width, a.height);
            d.width = c.width;
            d.height = c.height;
            var e = d.getContext("2d");
            e.drawImage(a, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height);
            a = e.getImageData(0, 0, c.width, c.height);
            c = a.data;
            for (var f = 0, g = c.length; f < g; f += 4) c[f] = c[f + 1] = c[f + 2] = 0.34 * c[f] + 0.5 * c[f + 1] + 0.16 * c[f + 2];
            e.putImageData(a, 0, 0);
            return d
        }
    } else cc._renderType ===
        cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTexture2D), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTexture2D(), delete cc._tmp.WebGLTexture2D);
    cc.EventHelper.prototype.apply(cc.Texture2D.prototype);
    cc.assert(cc.isFunction(cc._tmp.PrototypeTexture2D), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
    cc._tmp.PrototypeTexture2D();
    delete cc._tmp.PrototypeTexture2D
});
cc.textureCache = {
    _textures: {},
    _textureColorsCache: {},
    _textureKeySeq: 0 | 1E3 * Math.random(),
    _loadedTexturesBefore: {},
    _initializingRenderer: function() {
        var a, b = this._loadedTexturesBefore,
            c = this._textures;
        for (a in b) {
            var d = b[a];
            d.handleLoadedTexture();
            c[a] = d
        }
        this._loadedTexturesBefore = {}
    },
    addPVRTCImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addPVRTCImage)
    },
    addETCImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addETCImage)
    },
    description: function() {
        return "\x3cTextureCache | Number of textures \x3d " +
            this._textures.length + "\x3e"
    },
    textureForKey: function(a) {
        cc.log(cc._LogInfos.textureCache_textureForKey);
        return this.getTextureForKey(a)
    },
    getTextureForKey: function(a) {
        return this._textures[a] || this._textures[cc.loader._getAliase(a)]
    },
    getKeyByTexture: function(a) {
        for (var b in this._textures)
            if (this._textures[b] === a) return b;
        return null
    },
    _generalTextureKey: function(a) {
        return "_textureKey_" + a
    },
    getTextureColors: function(a) {
        var b = a._htmlElementObj,
            c = this.getKeyByTexture(b);
        c || (c = b instanceof HTMLImageElement ?
            b.src : this._generalTextureKey(a.__instanceId));
        this._textureColorsCache[c] || (this._textureColorsCache[c] = a._generateTextureCacheForColor());
        return this._textureColorsCache[c]
    },
    addPVRImage: function(a) {
        cc.log(cc._LogInfos.textureCache_addPVRImage)
    },
    removeAllTextures: function() {
        var a = this._textures,
            b;
        for (b in a) a[b] && a[b].releaseTexture();
        this._textures = {}
    },
    removeTexture: function(a) {
        if (a) {
            var b = this._textures,
                c;
            for (c in b) b[c] === a && (b[c].releaseTexture(), delete b[c])
        }
    },
    removeTextureForKey: function(a) {
        null !=
            a && this._textures[a] && delete this._textures[a]
    },
    cacheImage: function(a, b) {
        if (b instanceof cc.Texture2D) this._textures[a] = b;
        else {
            var c = new cc.Texture2D;
            c.initWithElement(b);
            c.handleLoadedTexture();
            this._textures[a] = c
        }
    },
    addUIImage: function(a, b) {
        cc.assert(a, cc._LogInfos.textureCache_addUIImage_2);
        if (b && this._textures[b]) return this._textures[b];
        var c = new cc.Texture2D;
        c.initWithImage(a);
        null != b ? this._textures[b] = c : cc.log(cc._LogInfos.textureCache_addUIImage);
        return c
    },
    dumpCachedTextureInfo: function() {
        var a =
            0,
            b = 0,
            c = this._textures,
            d;
        for (d in c) {
            var e = c[d];
            a++;
            e.getHtmlElementObj() instanceof HTMLImageElement ? cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo, d, e.getHtmlElementObj().src, e.pixelsWidth, e.pixelsHeight) : cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, e.pixelsWidth, e.pixelsHeight);
            b += e.pixelsWidth * e.pixelsHeight * 4
        }
        c = this._textureColorsCache;
        for (d in c) {
            var e = c[d],
                f;
            for (f in e) {
                var g = e[f];
                a++;
                cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_2, d, g.width, g.height);
                b += g.width *
                    g.height * 4
            }
        }
        cc.log(cc._LogInfos.textureCache_dumpCachedTextureInfo_3, a, b / 1024, (b / 1048576).toFixed(2))
    },
    _clear: function() {
        this._textures = {};
        this._textureColorsCache = {};
        this._textureKeySeq = 0 | 1E3 * Math.random();
        this._loadedTexturesBefore = {}
    }
};
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var a = cc.textureCache;
        a.handleLoadedTexture = function(a) {
            var c = this._textures,
                d = c[a];
            d || (d = c[a] = new cc.Texture2D, d.url = a);
            d.handleLoadedTexture()
        };
        a.addImage = function(a, c, d) {
            cc.assert(a, cc._LogInfos.Texture2D_addImage);
            var e = this._textures,
                f = e[a] || e[cc.loader._getAliase(a)];
            if (f) return f.isLoaded() ? c && c.call(d, f) : f.addEventListener("load", function() {
                c && c.call(d, f)
            }, d), f;
            f = e[a] = new cc.Texture2D;
            f.url = a;
            (cc.loader._checkIsImageURL(a) ? cc.loader.load : cc.loader.loadImg).call(cc.loader, a, function(f, h) {
                if (f) return c && c.call(d, f);
                cc.textureCache.handleLoadedTexture(a);
                var k = e[a];
                c && c.call(d, k)
            });
            return f
        };
        a.addImageAsync = a.addImage;
        a = null
    } else cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureCache), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureCache(), delete cc._tmp.WebGLTextureCache)
});
cc.TextureAtlas = cc.Class.extend({
    dirty: !1,
    texture: null,
    _indices: null,
    _buffersVBO: null,
    _capacity: 0,
    _quads: null,
    _quadsArrayBuffer: null,
    _quadsWebBuffer: null,
    _quadsReader: null,
    ctor: function(a, b) {
        this._buffersVBO = [];
        cc.isString(a) ? this.initWithFile(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    },
    getTotalQuads: function() {
        return this._totalQuads
    },
    getCapacity: function() {
        return this._capacity
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture = a
    },
    setDirty: function(a) {
        this.dirty =
            a
    },
    isDirty: function() {
        return this.dirty
    },
    getQuads: function() {
        return this._quads
    },
    setQuads: function(a) {
        this._quads = a
    },
    _copyQuadsToTextureAtlas: function(a, b) {
        if (a)
            for (var c = 0; c < a.length; c++) this._setQuadToArray(a[c], b + c)
    },
    _setQuadToArray: function(a, b) {
        var c = this._quads;
        c[b] ? (c[b].bl = a.bl, c[b].br = a.br, c[b].tl = a.tl, c[b].tr = a.tr) : c[b] = new cc.V3F_C4B_T2F_Quad(a.tl, a.bl, a.tr, a.br, this._quadsArrayBuffer, b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT)
    },
    description: function() {
        return "\x3ccc.TextureAtlas | totalQuads \x3d" +
            this._totalQuads + "\x3e"
    },
    _setupIndices: function() {
        if (0 !== this._capacity)
            for (var a = this._indices, b = this._capacity, c = 0; c < b; c++) cc.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 0, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 1, a[6 * c + 4] = 4 * c + 3, a[6 * c + 5] = 4 * c + 3) : (a[6 * c + 0] = 4 * c + 0, a[6 * c + 1] = 4 * c + 1, a[6 * c + 2] = 4 * c + 2, a[6 * c + 3] = 4 * c + 3, a[6 * c + 4] = 4 * c + 2, a[6 * c + 5] = 4 * c + 1)
    },
    _setupVBO: function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        this._buffersVBO[1] = a.createBuffer();
        this._quadsWebBuffer = a.createBuffer();
        this._mapBuffers()
    },
    _mapBuffers: function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._quadsWebBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW)
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.addImage(a);
        if (c) return this.initWithTexture(c, b);
        cc.log(cc._LogInfos.TextureAtlas_initWithFile, a);
        return !1
    },
    initWithTexture: function(a, b) {
        cc.assert(a,
            cc._LogInfos.TextureAtlas_initWithTexture);
        this._capacity = b |= 0;
        this._totalQuads = 0;
        this.texture = a;
        this._quads = [];
        this._indices = new Uint16Array(6 * b);
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._quadsArrayBuffer = new ArrayBuffer(c * b);
        this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
        if ((!this._quads || !this._indices) && 0 < b) return !1;
        for (var d = this._quads, e = 0; e < b; e++) d[e] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, e * c);
        this._setupIndices();
        this._setupVBO();
        return this.dirty = !0
    },
    updateQuad: function(a, b) {
        cc.assert(a, cc._LogInfos.TextureAtlas_updateQuad);
        cc.assert(0 <= b && b < this._capacity, cc._LogInfos.TextureAtlas_updateQuad_2);
        this._totalQuads = Math.max(b + 1, this._totalQuads);
        this._setQuadToArray(a, b);
        this.dirty = !0
    },
    insertQuad: function(a, b) {
        cc.assert(b < this._capacity, cc._LogInfos.TextureAtlas_insertQuad_2);
        this._totalQuads++;
        if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = b * c,
                e = (this._totalQuads -
                    1 - b) * c;
            this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * c);
            this._quadsReader.set(this._quadsReader.subarray(d, d + e), d + c);
            this._setQuadToArray(a, b);
            this.dirty = !0
        }
    },
    insertQuads: function(a, b, c) {
        c = c || a.length;
        cc.assert(b + c <= this._capacity, cc._LogInfos.TextureAtlas_insertQuads);
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads += c;
        if (this._totalQuads > this._capacity) cc.log(cc._LogInfos.TextureAtlas_insertQuad);
        else {
            var e = b *
                d,
                f = (this._totalQuads - 1 - b - c) * d,
                g = this._totalQuads - 1 - c,
                h;
            for (h = 0; h < c; h++) this._quads[g + h] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * d);
            this._quadsReader.set(this._quadsReader.subarray(e, e + f), e + d * c);
            for (h = 0; h < c; h++) this._setQuadToArray(a[h], b + h);
            this.dirty = !0
        }
    },
    insertQuadFromIndex: function(a, b) {
        if (a !== b) {
            cc.assert(0 <= b || b < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex);
            cc.assert(0 <= a || a < this._totalQuads, cc._LogInfos.TextureAtlas_insertQuadFromIndex_2);
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = this._quadsReader,
                e = d.subarray(a * c, c),
                f;
            a > b ? (f = b * c, d.set(d.subarray(f, f + (a - b) * c), f + c), d.set(e, f)) : (f = (a + 1) * c, d.set(d.subarray(f, f + (b - a) * c), f - c), d.set(e, b * c));
            this.dirty = !0
        }
    },
    removeQuadAtIndex: function(a) {
        cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadAtIndex);
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
        this._totalQuads--;
        this._quads.length = this._totalQuads;
        if (a !== this._totalQuads) {
            var c = (a + 1) * b;
            this._quadsReader.set(this._quadsReader.subarray(c,
                c + (this._totalQuads - a) * b), c - b)
        }
        this.dirty = !0
    },
    removeQuadsAtIndex: function(a, b) {
        cc.assert(a + b <= this._totalQuads, cc._LogInfos.TextureAtlas_removeQuadsAtIndex);
        this._totalQuads -= b;
        if (a !== this._totalQuads) {
            var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
                d = (a + b) * c,
                e = a * c;
            this._quadsReader.set(this._quadsReader.subarray(d, d + (this._totalQuads - a) * c), e)
        }
        this.dirty = !0
    },
    removeAllQuads: function() {
        this._totalQuads = this._quads.length = 0
    },
    _setDirty: function(a) {
        this.dirty = a
    },
    resizeCapacity: function(a) {
        if (a === this._capacity) return !0;
        var b = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            c = this._capacity;
        this._totalQuads = Math.min(this._totalQuads, a);
        var d = this._capacity = 0 | a,
            e = this._totalQuads;
        if (null === this._quads)
            for (this._quads = [], this._quadsArrayBuffer = new ArrayBuffer(b * d), this._quadsReader = new Uint8Array(this._quadsArrayBuffer), a = 0; a < d; a++) this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, a * b);
        else {
            var f, g, h = this._quads;
            if (d > c) {
                f = [];
                g = new ArrayBuffer(b * d);
                for (a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl,
                    h[a].bl, h[a].tr, h[a].br, g, a * b);
                for (; a < d; a++) f[a] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, g, a * b)
            } else
                for (e = Math.max(e, d), f = [], g = new ArrayBuffer(b * d), a = 0; a < e; a++) f[a] = new cc.V3F_C4B_T2F_Quad(h[a].tl, h[a].bl, h[a].tr, h[a].br, g, a * b);
            this._quadsReader = new Uint8Array(g);
            this._quads = f;
            this._quadsArrayBuffer = g
        }
        null === this._indices ? this._indices = new Uint16Array(6 * d) : d > c ? (b = new Uint16Array(6 * d), b.set(this._indices, 0), this._indices = b) : this._indices = this._indices.subarray(0, 6 * d);
        this._setupIndices();
        this._mapBuffers();
        return this.dirty = !0
    },
    increaseTotalQuadsWith: function(a) {
        this._totalQuads += a
    },
    moveQuadsFromIndex: function(a, b, c) {
        if (void 0 === c) {
            if (c = b, b = this._totalQuads - a, cc.assert(c + (this._totalQuads - a) <= this._capacity, cc._LogInfos.TextureAtlas_moveQuadsFromIndex), 0 === b) return
        } else if (cc.assert(c + b <= this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_2), cc.assert(a < this._totalQuads, cc._LogInfos.TextureAtlas_moveQuadsFromIndex_3), a === c) return;
        var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            e = a * d,
            f = b * d,
            g = this._quadsReader,
            h = g.subarray(e, e + f),
            k = c * d;
        c < a ? (b = c * d, g.set(g.subarray(b, b + (a - c) * d), b + f)) : (b = (a + b) * d, g.set(g.subarray(b, b + (c - a) * d), e));
        g.set(h, k);
        this.dirty = !0
    },
    fillWithEmptyQuadsFromIndex: function(a, b) {
        for (var c = b * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, d = new Uint8Array(this._quadsArrayBuffer, a * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, c), e = 0; e < c; e++) d[e] = 0
    },
    drawQuads: function() {
        this.drawNumberOfQuads(this._totalQuads, 0)
    },
    _releaseBuffer: function() {
        var a = cc._renderContext;
        this._buffersVBO && (this._buffersVBO[0] && a.deleteBuffer(this._buffersVBO[0]),
            this._buffersVBO[1] && a.deleteBuffer(this._buffersVBO[1]));
        this._quadsWebBuffer && a.deleteBuffer(this._quadsWebBuffer)
    }
});
_p = cc.TextureAtlas.prototype;
cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
cc.TextureAtlas.create = function(a, b) {
    return new cc.TextureAtlas(a, b)
};
cc.TextureAtlas.createWithTexture = cc.TextureAtlas.create;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    cc._renderType === cc.game.RENDER_TYPE_WEBGL && (cc.assert(cc.isFunction(cc._tmp.WebGLTextureAtlas), cc._LogInfos.MissingFile, "TexturesWebGL.js"), cc._tmp.WebGLTextureAtlas(), delete cc._tmp.WebGLTextureAtlas)
});
cc.assert(cc.isFunction(cc._tmp.PrototypeTextureAtlas), cc._LogInfos.MissingFile, "TexturesPropertyDefine.js");
cc._tmp.PrototypeTextureAtlas();
delete cc._tmp.PrototypeTextureAtlas;
cc.Scene = cc.Node.extend({
    _className: "Scene",
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.director.getWinSize())
    }
});
cc.Scene.create = function() {
    return new cc.Scene
};
cc.LoaderScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoaderScene",
    cb: null,
    target: null,
    init: function() {
        var a = this,
            b = 200,
            c = a._bgLayer = new cc.LayerColor(cc.color(32, 32, 32, 255));
        a.addChild(c, 0);
        var d = 24,
            e = -b / 2 + 100;
        cc._loaderImage && (cc.loader.loadImg(cc._loaderImage, {
            isCrossOrigin: !1
        }, function(c, d) {
            b = d.height;
            a._initStage(d, cc.visibleRect.center)
        }), d = 14, e = -b / 2 - 10);
        d = a._label = new cc.LabelTTF("Loading... 0%", "Arial", d);
        d.setPosition(cc.pAdd(cc.visibleRect.center, cc.p(0, e)));
        d.setColor(cc.color(180,
            180, 180));
        c.addChild(this._label, 10);
        return !0
    },
    _initStage: function(a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        c = this._logo = new cc.Sprite(c);
        c.setScale(cc.contentScaleFactor());
        c.x = b.x;
        c.y = b.y;
        this._bgLayer.addChild(c, 10)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("Loading... 0%")
    },
    initWithResources: function(a, b, c) {
        cc.isString(a) &&
            (a = [a]);
        this.resources = a || [];
        this.cb = b;
        this.target = c
    },
    _startLoading: function() {
        var a = this;
        a.unschedule(a._startLoading);
        cc.loader.load(a.resources, function(b, c, d) {
            b = Math.min(d / c * 100 | 0, 100);
            a._label.setString("Loading... " + b + "%")
        }, function() {
            a.cb && a.cb.call(a.target)
        })
    },
    _updateTransform: function() {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._bgLayer._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._label._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._logo._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    }
});
cc.LoaderScene.preload = function(a, b, c) {
    var d = cc;
    d.loaderScene || (d.loaderScene = new cc.LoaderScene, d.loaderScene.init(), cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function() {
        d.loaderScene._updateTransform()
    }));
    d.loaderScene.initWithResources(a, b, c);
    cc.director.runScene(d.loaderScene);
    return d.loaderScene
};
cc.Layer = cc.Node.extend({
    _className: "Layer",
    ctor: function() {
        var a = cc.Node.prototype;
        a.ctor.call(this);
        this._ignoreAnchorPointForPosition = !0;
        a.setAnchorPoint.call(this, 0.5, 0.5);
        a.setContentSize.call(this, cc.winSize)
    },
    init: function() {
        this._ignoreAnchorPointForPosition = !0;
        this.setAnchorPoint(0.5, 0.5);
        this.setContentSize(cc.winSize);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !1;
        return !0
    },
    bake: function() {
        this._renderCmd.bake()
    },
    unbake: function() {
        this._renderCmd.unbake()
    },
    isBaked: function() {
        return this._renderCmd._isBaked
    },
    addChild: function(a, b, c) {
        cc.Node.prototype.addChild.call(this, a, b, c);
        this._renderCmd._bakeForAddChild(a)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Layer.CanvasRenderCmd(this) : new cc.Layer.WebGLRenderCmd(this)
    }
});
cc.Layer.create = function() {
    return new cc.Layer
};
cc.LayerColor = cc.Layer.extend({
    _blendFunc: null,
    _className: "LayerColor",
    getBlendFunc: function() {
        return this._blendFunc
    },
    changeWidthAndHeight: function(a, b) {
        this.width = a;
        this.height = b
    },
    changeWidth: function(a) {
        this.width = a
    },
    changeHeight: function(a) {
        this.height = a
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    ctor: function(a, b, c) {
        cc.Layer.prototype.ctor.call(this);
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        cc.LayerColor.prototype.init.call(this, a,
            b, c)
    },
    init: function(a, b, c) {
        cc._renderType !== cc.game.RENDER_TYPE_CANVAS && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR));
        var d = cc.director.getWinSize();
        a = a || cc.color(0, 0, 0, 255);
        b = void 0 === b ? d.width : b;
        c = void 0 === c ? d.height : c;
        d = this._realColor;
        d.r = a.r;
        d.g = a.g;
        d.b = a.b;
        this._realOpacity = a.a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty);
        cc.LayerColor.prototype.setContentSize.call(this, b, c);
        return !0
    },
    setBlendFunc: function(a, b) {
        var c =
            this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b);
        this._renderCmd.updateBlendFunc(c)
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._renderCmd._updateSquareVerticesWidth(a)
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._renderCmd._updateSquareVerticesHeight(a)
    },
    setContentSize: function(a, b) {
        cc.Layer.prototype.setContentSize.call(this, a, b);
        this._renderCmd._updateSquareVertices(a, b)
    },
    _createRenderCmd: function() {
        return cc._renderType ===
            cc.game.RENDER_TYPE_CANVAS ? new cc.LayerColor.CanvasRenderCmd(this) : new cc.LayerColor.WebGLRenderCmd(this)
    }
});
cc.LayerColor.create = function(a, b, c) {
    return new cc.LayerColor(a, b, c)
};
(function() {
    var a = cc.LayerColor.prototype;
    cc.defineGetterSetter(a, "width", a._getWidth, a._setWidth);
    cc.defineGetterSetter(a, "height", a._getHeight, a._setHeight)
})();
cc.LayerGradient = cc.LayerColor.extend({
    _endColor: null,
    _startOpacity: 255,
    _endOpacity: 255,
    _alongVector: null,
    _compressedInterpolation: !1,
    _className: "LayerGradient",
    _colorStops: [],
    ctor: function(a, b, c, d) {
        cc.LayerColor.prototype.ctor.call(this);
        this._endColor = cc.color(0, 0, 0, 255);
        this._alongVector = cc.p(0, -1);
        this._endOpacity = this._startOpacity = 255;
        d && d instanceof Array ? (this._colorStops = d, d.splice(0, 0, {
            p: 0,
            color: a || cc.color.BLACK
        }), d.push({
            p: 1,
            color: b || cc.color.BLACK
        })) : this._colorStops = [{
                p: 0,
                color: a || cc.color.BLACK
            },
            {
                p: 1,
                color: b || cc.color.BLACK
            }
        ];
        cc.LayerGradient.prototype.init.call(this, a, b, c, d)
    },
    init: function(a, b, c, d) {
        a = a || cc.color(0, 0, 0, 255);
        b = b || cc.color(0, 0, 0, 255);
        c = c || cc.p(0, -1);
        d = this._endColor;
        this._startOpacity = a.a;
        d.r = b.r;
        d.g = b.g;
        d.b = b.b;
        this._endOpacity = b.a;
        this._alongVector = c;
        this._compressedInterpolation = !0;
        cc.LayerColor.prototype.init.call(this, cc.color(a.r, a.g, a.b, 255));
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty);
        return !0
    },
    setContentSize: function(a, b) {
        cc.LayerColor.prototype.setContentSize.call(this, a, b);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setWidth: function(a) {
        cc.LayerColor.prototype._setWidth.call(this, a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    _setHeight: function(a) {
        cc.LayerColor.prototype._setHeight.call(this, a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getStartColor: function() {
        return cc.color(this._realColor)
    },
    setStartColor: function(a) {
        this.color =
            a;
        var b = this._colorStops;
        b && 0 < b.length && (b = b[0].color, b.r = a.r, b.g = a.g, b.b = a.b)
    },
    setEndColor: function(a) {
        var b = this._endColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        (b = this._colorStops) && 0 < b.length && (b = b[b.length - 1].color, b.r = a.r, b.g = a.g, b.b = a.b);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    getEndColor: function() {
        return cc.color(this._endColor)
    },
    setStartOpacity: function(a) {
        this._startOpacity = a;
        var b = this._colorStops;
        b && 0 < b.length && (b[0].color.a = a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getStartOpacity: function() {
        return this._startOpacity
    },
    setEndOpacity: function(a) {
        this._endOpacity = a;
        var b = this._colorStops;
        b && 0 < b.length && (b[b.length - 1].color.a = a);
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getEndOpacity: function() {
        return this._endOpacity
    },
    setVector: function(a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getVector: function() {
        return cc.p(this._alongVector.x, this._alongVector.y)
    },
    isCompressedInterpolation: function() {
        return this._compressedInterpolation
    },
    setCompressedInterpolation: function(a) {
        this._compressedInterpolation = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.gradientDirty)
    },
    getColorStops: function() {
        return this._colorStops
    },
    setColorStops: function(a) {
        this._colorStops = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty | cc.Node._dirtyFlags.gradientDirty)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.LayerGradient.CanvasRenderCmd(this) : new cc.LayerGradient.WebGLRenderCmd(this)
    }
});
cc.LayerGradient.create = function(a, b, c, d) {
    return new cc.LayerGradient(a, b, c, d)
};
(function() {
    var a = cc.LayerGradient.prototype;
    cc.defineGetterSetter(a, "startColor", a.getStartColor, a.setStartColor);
    cc.defineGetterSetter(a, "endColor", a.getEndColor, a.setEndColor);
    cc.defineGetterSetter(a, "startOpacity", a.getStartOpacity, a.setStartOpacity);
    cc.defineGetterSetter(a, "endOpacity", a.getEndOpacity, a.setEndOpacity);
    cc.defineGetterSetter(a, "vector", a.getVector, a.setVector);
    cc.defineGetterSetter(a, "colorStops", a.getColorStops, a.setColorStops)
})();
cc.LayerMultiplex = cc.Layer.extend({
    _enabledLayer: 0,
    _layers: null,
    _className: "LayerMultiplex",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this);
        a instanceof Array ? cc.LayerMultiplex.prototype.initWithLayers.call(this, a) : cc.LayerMultiplex.prototype.initWithLayers.call(this, Array.prototype.slice.call(arguments))
    },
    initWithLayers: function(a) {
        0 < a.length && null == a[a.length - 1] && cc.log(cc._LogInfos.LayerMultiplex_initWithLayers);
        this._layers = a;
        this._enabledLayer = 0;
        this.addChild(this._layers[this._enabledLayer]);
        return !0
    },
    switchTo: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchTo) : (this.removeChild(this._layers[this._enabledLayer], !0), this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    switchToAndReleaseMe: function(a) {
        a >= this._layers.length ? cc.log(cc._LogInfos.LayerMultiplex_switchToAndReleaseMe) : (this.removeChild(this._layers[this._enabledLayer], !0), this._layers[this._enabledLayer] = null, this._enabledLayer = a, this.addChild(this._layers[a]))
    },
    addLayer: function(a) {
        a ? this._layers.push(a) :
            cc.log(cc._LogInfos.LayerMultiplex_addLayer)
    }
});
cc.LayerMultiplex.create = function() {
    return new cc.LayerMultiplex(Array.prototype.slice.call(arguments))
};
(function() {
    cc.Layer.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._isBaked = !1;
        this._bakeSprite = null;
        this._updateCache = 2
    };
    var a = cc.Layer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.Layer.CanvasRenderCmd;
    a._setCacheDirty = function(a) {
        a && 0 === this._updateCache && (this._updateCache = 2);
        !1 === this._cacheDirty && (this._cacheDirty = !0, (a = this._cachedParent) && a !== this && a._setNodeDirtyForCache && a._setNodeDirtyForCache())
    };
    a.transform = function(a,
        c) {
        var d = this._worldTransform,
            e = d.a,
            f = d.b,
            g = d.c,
            h = d.d;
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, a, c);
        d.a === e && d.b === f && d.c === g && d.d === h || 0 !== this._updateCache || (this._updateCache = 2)
    };
    a.bake = function() {
        if (!this._isBaked) {
            this._needDraw = !0;
            this._isBaked = this._cacheDirty = cc.renderer.childrenOrderDirty = !0;
            0 === this._updateCache && (this._updateCache = 2);
            for (var a = this._node._children, c = 0, d = a.length; c < d; c++) a[c]._renderCmd._setCachedParent(this);
            this._bakeSprite || (this._bakeSprite = new cc.BakeSprite,
                this._bakeSprite.setAnchorPoint(0, 0))
        }
    };
    a.unbake = function() {
        if (this._isBaked) {
            cc.renderer.childrenOrderDirty = !0;
            this._isBaked = this._needDraw = !1;
            this._cacheDirty = !0;
            0 === this._updateCache && (this._updateCache = 2);
            for (var a = this._node._children, c = 0, d = a.length; c < d; c++) a[c]._renderCmd._setCachedParent(null)
        }
    };
    a.isBaked = function() {
        return this._isBaked
    };
    a.rendering = function() {
        if (this._cacheDirty) {
            var a = this._node,
                c = a._children,
                d = this._bakeSprite;
            this.transform(this.getParentRenderCmd(), !0);
            var e = this._getBoundingBoxForBake();
            e.width = 0 | e.width + 0.5;
            e.height = 0 | e.height + 0.5;
            var f = d.getCacheContext(),
                g = f.getContext();
            d.setPosition(e.x, e.y);
            if (0 < this._updateCache) {
                d.resetCanvasSize(e.width, e.height);
                f.setOffset(0 - e.x, g.canvas.height - e.height + e.y);
                a.sortAllChildren();
                cc.renderer._turnToCacheMode(this.__instanceId);
                a = 0;
                for (e = c.length; a < e; a++) c[a].visit(this);
                cc.renderer._renderingToCacheCanvas(f, this.__instanceId);
                d.transform();
                this._updateCache--
            }
            this._cacheDirty = !1
        }
    };
    a.visit = function(a) {
        if (this._isBaked) {
            var c = this._node,
                d =
                c._children.length;
            c._visible && 0 !== d && (this._syncStatus(a), cc.renderer.pushRenderCommand(this), this._cacheDirty = !0, 0 === this._updateCache && (this._updateCache = 2), this._bakeSprite.visit(this), this._dirtyFlag = 0)
        } else cc.Node.CanvasRenderCmd.prototype.visit.call(this, a)
    };
    a._bakeForAddChild = function(a) {
        a._parent === this._node && this._isBaked && a._renderCmd._setCachedParent(this)
    };
    a._getBoundingBoxForBake = function() {
        var a = null,
            c = this._node;
        if (!c._children || 0 === c._children.length) return cc.rect(0, 0, 10, 10);
        for (var d =
                c.getNodeToWorldTransform(), c = c._children, e = 0, f = c.length; e < f; e++) {
            var g = c[e];
            g && g._visible && (a ? (g = g._getBoundingBoxToCurrentNode(d)) && (a = cc.rectUnion(a, g)) : a = g._getBoundingBoxToCurrentNode(d))
        }
        return a
    }
})();
(function() {
    cc.LayerColor.CanvasRenderCmd = function(a) {
        cc.Layer.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._blendFuncStr = "source-over";
        this._bakeRenderCmd = new cc.CustomRenderCmd(this, this._bakeRendering)
    };
    var a = cc.LayerColor.CanvasRenderCmd.prototype = Object.create(cc.Layer.CanvasRenderCmd.prototype);
    a.constructor = cc.LayerColor.CanvasRenderCmd;
    a.unbake = function() {
        cc.Layer.CanvasRenderCmd.prototype.unbake.call(this);
        this._needDraw = !0
    };
    a.rendering = function(a, c, d) {
        a = a || cc._renderContext;
        var e =
            a.getContext(),
            f = this._node,
            g = this._displayedColor,
            h = this._displayedOpacity / 255,
            k = f._contentSize.width,
            f = f._contentSize.height;
        0 !== h && (a.setCompositeOperation(this._blendFuncStr), a.setGlobalAlpha(h), a.setFillStyle("rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + ", 1)"), a.setTransform(this._worldTransform, c, d), e.fillRect(0, 0, k * c, -f * d), cc.g_NumberOfDraws++)
    };
    a.updateBlendFunc = function(a) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
    };
    a._updateSquareVertices = a._updateSquareVerticesWidth =
        a._updateSquareVerticesHeight = function() {};
    a._bakeRendering = function() {
        if (this._cacheDirty) {
            var a = this._node,
                c = this._bakeSprite,
                d = a._children,
                e = d.length;
            this.transform(this.getParentRenderCmd(), !0);
            var f = this._getBoundingBoxForBake();
            f.width = 0 | f.width + 0.5;
            f.height = 0 | f.height + 0.5;
            var g = c.getCacheContext(),
                h = g.getContext();
            c.setPosition(f.x, f.y);
            if (0 < this._updateCache) {
                h.fillStyle = g._currentFillStyle;
                c.resetCanvasSize(f.width, f.height);
                g.setOffset(0 - f.x, h.canvas.height - f.height + f.y);
                cc.renderer._turnToCacheMode(this.__instanceId);
                if (0 < e) {
                    a.sortAllChildren();
                    for (a = 0; a < e; a++)
                        if (f = d[a], 0 > f._localZOrder) f._renderCmd.visit(this);
                        else break;
                    for (cc.renderer.pushRenderCommand(this); a < e; a++) d[a]._renderCmd.visit(this)
                } else cc.renderer.pushRenderCommand(this);
                cc.renderer._renderingToCacheCanvas(g, this.__instanceId);
                c.transform();
                this._updateCache--
            }
            this._cacheDirty = !1
        }
    };
    a.visit = function(a) {
        this._isBaked ? this._node._visible && (this._syncStatus(a), cc.renderer.pushRenderCommand(this._bakeRenderCmd), this._bakeSprite._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
            this._bakeSprite.visit(this), this._dirtyFlag = 0) : cc.Node.CanvasRenderCmd.prototype.visit.call(this)
    };
    a._getBoundingBoxForBake = function() {
        var a = this._node,
            c = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
            d = a.getNodeToWorldTransform(),
            c = cc.rectApplyAffineTransform(c, a.getNodeToWorldTransform());
        if (!a._children || 0 === a._children.length) return c;
        for (var a = a._children, e = 0; e < a.length; e++) {
            var f = a[e];
            f && f._visible && (f = f._getBoundingBoxToCurrentNode(d), c = cc.rectUnion(c, f))
        }
        return c
    }
})();
(function() {
    cc.LayerGradient.RenderCmd = {
        updateStatus: function() {
            var a = cc.Node._dirtyFlags,
                b = this._dirtyFlag,
                c = b & a.colorDirty,
                d = b & a.opacityDirty;
            c && this._updateDisplayColor();
            d && this._updateDisplayOpacity();
            (c || d || b & a.gradientDirty) && this._updateColor();
            b & a.transformDirty && this.transform(this.getParentRenderCmd(), !0);
            this._dirtyFlag = 0
        }
    }
})();
(function() {
    cc.LayerGradient.CanvasRenderCmd = function(a) {
        cc.LayerColor.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._startPoint = cc.p(0, 0);
        this._endPoint = cc.p(0, 0);
        this._endStopStr = this._startStopStr = null
    };
    var a = cc.LayerGradient.CanvasRenderCmd.prototype = Object.create(cc.LayerColor.CanvasRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, a);
    a.constructor = cc.LayerGradient.CanvasRenderCmd;
    a.rendering = function(a, c, d) {
        a = a || cc._renderContext;
        var e = a.getContext(),
            f = this._node,
            g = this._displayedOpacity /
            255;
        if (0 !== g) {
            var h = f._contentSize.width,
                k = f._contentSize.height;
            a.setCompositeOperation(this._blendFuncStr);
            a.setGlobalAlpha(g);
            g = e.createLinearGradient(this._startPoint.x * c, this._startPoint.y * d, this._endPoint.x * c, this._endPoint.y * d);
            if (f._colorStops)
                for (var m = 0; m < f._colorStops.length; m++) g.addColorStop(f._colorStops[m].p, this._colorStopsStr[m]);
            else g.addColorStop(0, this._startStopStr), g.addColorStop(1, this._endStopStr);
            a.setFillStyle(g);
            a.setTransform(this._worldTransform, c, d);
            e.fillRect(0, 0, h *
                c, -k * d);
            cc.g_NumberOfDraws++
        }
    };
    a._syncStatus = function(a) {
        var c = cc.Node._dirtyFlags,
            d = this._dirtyFlag,
            e = a ? a._node : null;
        e && e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty && (d |= c.colorDirty);
        e && e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty && (d |= c.opacityDirty);
        a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
        var e = d & c.colorDirty,
            f = d & c.opacityDirty;
        this._dirtyFlag = d;
        e && this._syncDisplayColor();
        f && this._syncDisplayOpacity();
        d & c.transformDirty && this.transform(a);
        (e || f || d & c.gradientDirty) &&
        this._updateColor()
    };
    a._updateColor = function() {
        var a = this._node,
            c = a._contentSize,
            d = 0.5 * c.width,
            c = 0.5 * c.height;
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
        var e = cc.pAngleSigned(cc.p(0, -1), a._alongVector),
            e = cc.pRotateByAngle(cc.p(0, -1), cc.p(0, 0), e),
            f = Math.min(Math.abs(1 / e.x), Math.abs(1 / e.y));
        this._startPoint.x = d * -e.x * f + d;
        this._startPoint.y = c * e.y * f - c;
        this._endPoint.x = d * e.x * f + d;
        this._endPoint.y = c * -e.y * f - c;
        d = this._displayedColor;
        c = a._endColor;
        e = a._startOpacity / 255;
        f = a._endOpacity /
            255;
        this._startStopStr = "rgba(" + Math.round(d.r) + "," + Math.round(d.g) + "," + Math.round(d.b) + "," + e.toFixed(4) + ")";
        this._endStopStr = "rgba(" + Math.round(c.r) + "," + Math.round(c.g) + "," + Math.round(c.b) + "," + f.toFixed(4) + ")";
        if (a._colorStops)
            for (this._endOpacity = this._startOpacity = 0, this._colorStopsStr = [], d = 0; d < a._colorStops.length; d++) c = a._colorStops[d].color, e = null == c.a ? 1 : c.a / 255, this._colorStopsStr.push("rgba(" + Math.round(c.r) + "," + Math.round(c.g) + "," + Math.round(c.b) + "," + e.toFixed(4) + ")")
    }
})();
(function() {
    cc.Layer.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a)
    };
    var a = cc.Layer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.Layer.WebGLRenderCmd;
    a.bake = function() {};
    a.unbake = function() {};
    a._bakeForAddChild = function() {}
})();
(function() {
    cc.LayerColor.WebGLRenderCmd = function(a) {
        cc.Layer.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._squareVerticesAB = new ArrayBuffer(32);
        this._squareColorsAB = new ArrayBuffer(16);
        a = this._squareVerticesAB;
        var c = this._squareColorsAB,
            d = cc.Vertex2F.BYTES_PER_ELEMENT,
            e = cc.Color.BYTES_PER_ELEMENT;
        this._squareVertices = [new cc.Vertex2F(0, 0, a, 0), new cc.Vertex2F(0, 0, a, d), new cc.Vertex2F(0, 0, a, 2 * d), new cc.Vertex2F(0, 0, a, 3 * d)];
        this._squareColors = [cc.color(0, 0, 0, 255, c, 0), cc.color(0, 0, 0, 255, c, e), cc.color(0,
            0, 0, 255, c, 2 * e), cc.color(0, 0, 0, 255, c, 3 * e)];
        this._verticesFloat32Buffer = cc._renderContext.createBuffer();
        this._colorsUint8Buffer = cc._renderContext.createBuffer()
    };
    var a = cc.LayerColor.WebGLRenderCmd.prototype = Object.create(cc.Layer.WebGLRenderCmd.prototype);
    a.constructor = cc.LayerColor.WebGLRenderCmd;
    a.rendering = function(a) {
        a = a || cc._renderContext;
        var c = this._node;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION |
            cc.VERTEX_ATTRIB_FLAG_COLOR);
        cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length)
    };
    a._updateSquareVertices = function(a, c) {
        var d = this._squareVertices;
        void 0 === c ? (d[1].x = a.width, d[2].y = a.height, d[3].x =
            a.width, d[3].y = a.height) : (d[1].x = a, d[2].y = c, d[3].x = a, d[3].y = c);
        this._bindLayerVerticesBufferData()
    };
    a._updateSquareVerticesWidth = function(a) {
        var c = this._squareVertices;
        c[1].x = a;
        c[3].x = a;
        this._bindLayerVerticesBufferData()
    };
    a._updateSquareVerticesHeight = function(a) {
        var c = this._squareVertices;
        c[2].y = a;
        c[3].y = a;
        this._bindLayerVerticesBufferData()
    };
    a._updateColor = function() {
        for (var a = this._displayedColor, c = this._displayedOpacity, d = this._squareColors, e = 0; 4 > e; e++) d[e].r = a.r, d[e].g = a.g, d[e].b = a.b, d[e].a =
            c;
        this._bindLayerColorsBufferData()
    };
    a._bindLayerVerticesBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareVerticesAB, a.STATIC_DRAW)
    };
    a._bindLayerColorsBufferData = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.bufferData(a.ARRAY_BUFFER, this._squareColorsAB, a.STATIC_DRAW)
    };
    a.updateBlendFunc = function(a) {}
})();
(function() {
    cc.LayerGradient.WebGLRenderCmd = function(a) {
        cc.LayerColor.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._clipRect = new cc.Rect;
        this._clippingRectDirty = !1
    };
    var a = cc.LayerGradient.WebGLRenderCmd.prototype = Object.create(cc.LayerColor.WebGLRenderCmd.prototype);
    cc.inject(cc.LayerGradient.RenderCmd, a);
    a.constructor = cc.LayerGradient.WebGLRenderCmd;
    a._syncStatus = function(a) {
        var c = cc.Node._dirtyFlags,
            d = this._dirtyFlag,
            e = a ? a._node : null;
        e && e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty && (d |=
            c.colorDirty);
        e && e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty && (d |= c.opacityDirty);
        a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
        var e = d & c.colorDirty,
            f = d & c.opacityDirty;
        this._dirtyFlag = d;
        e && this._syncDisplayColor();
        f && this._syncDisplayOpacity();
        this.transform(a);
        (e || f || d & c.gradientDirty) && this._updateColor()
    };
    a._updateColor = function() {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.gradientDirty;
        var a = this._node,
            c = a._colorStops;
        if (c && !(2 > c.length)) {
            this._clippingRectDirty = !0;
            var d = c.length,
                e = 2 * d,
                f, g = a._contentSize;
            this._squareVerticesAB = new ArrayBuffer(8 * e);
            this._squareColorsAB = new ArrayBuffer(4 * e);
            var h = this._squareVertices,
                k = this._squareColors;
            h.length = 0;
            k.length = 0;
            var m = this._squareVerticesAB,
                n = this._squareColorsAB,
                p = cc.Vertex2F.BYTES_PER_ELEMENT,
                s = cc.Color.BYTES_PER_ELEMENT;
            for (f = 0; f < e; f++) h.push(new cc.Vertex2F(0, 0, m, p * f)), k.push(cc.color(0, 0, 0, 255, n, s * f));
            n = Math.PI + cc.pAngleSigned(cc.p(0, -1), a._alongVector);
            a = cc.p(g.width / 2, g.height / 2);
            f = Math.round(cc.radiansToDegrees(n));
            e = cc.affineTransformMake(1, 0, 0, 1, a.x, a.y);
            e = cc.affineTransformRotate(e, n);
            90 > f ? (p = cc.p(-a.x, a.y), f = cc.p(a.x, a.y)) : 180 > f ? (p = cc.p(a.x, a.y), f = cc.p(a.x, -a.y)) : 270 > f ? (p = cc.p(a.x, -a.y), f = cc.p(-a.x, -a.y)) : (p = cc.p(-a.x, -a.y), f = cc.p(-a.x, a.y));
            m = Math.sin(n);
            n = Math.cos(n);
            p = Math.abs((p.x * n - p.y * m) / a.x);
            f = Math.abs((f.x * m + f.y * n) / a.y);
            e = cc.affineTransformScale(e, p, f);
            for (f = 0; f < d; f++) m = c[f].p * g.height, n = cc.pointApplyAffineTransform(-a.x, m - a.y, e), h[2 * f].x = n.x, h[2 * f].y = n.y, m = cc.pointApplyAffineTransform(g.width - a.x,
                m - a.y, e), h[2 * f + 1].x = m.x, h[2 * f + 1].y = m.y;
            g = this._displayedOpacity / 255;
            for (f = 0; f < d; f++) h = c[f].color, a = k[2 * f], e = k[2 * f + 1], a.r = h.r, a.g = h.g, a.b = h.b, a.a = h.a * g, e.r = h.r, e.g = h.g, e.b = h.b, e.a = h.a * g;
            this._bindLayerVerticesBufferData();
            this._bindLayerColorsBufferData()
        }
    };
    a.rendering = function(a) {
        a = a || cc._renderContext;
        var c = this._node,
            d = this._getClippingRect();
        a.enable(a.SCISSOR_TEST);
        cc.view.setScissorInPoints(d.x, d.y, d.width, d.height);
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR);
        cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesFloat32Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._colorsUint8Buffer);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0);
        a.drawArrays(a.TRIANGLE_STRIP, 0, this._squareVertices.length);
        a.disable(a.SCISSOR_TEST)
    };
    a._getClippingRect = function() {
        if (this._clippingRectDirty) {
            var a =
                this._node,
                c = cc.rect(0, 0, a._contentSize.width, a._contentSize.height),
                a = a.getNodeToWorldTransform();
            this._clipRect = cc._rectApplyAffineTransformIn(c, a)
        }
        return this._clipRect
    }
})();
cc._tmp.PrototypeSprite = function() {
    var a = cc.Sprite.prototype;
    cc.defineGetterSetter(a, "opacityModifyRGB", a.isOpacityModifyRGB, a.setOpacityModifyRGB);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "flippedX", a.isFlippedX, a.setFlippedX);
    cc.defineGetterSetter(a, "flippedY", a.isFlippedY, a.setFlippedY);
    cc.defineGetterSetter(a, "offsetX", a._getOffsetX);
    cc.defineGetterSetter(a, "offsetY", a._getOffsetY);
    cc.defineGetterSetter(a,
        "texture", a.getTexture, a.setTexture);
    cc.defineGetterSetter(a, "textureRectRotated", a.isTextureRectRotated);
    cc.defineGetterSetter(a, "batchNode", a.getBatchNode, a.setBatchNode);
    cc.defineGetterSetter(a, "quad", a.getQuad)
};
cc.Sprite = cc.Node.extend({
    dirty: !1,
    atlasIndex: 0,
    textureAtlas: null,
    _batchNode: null,
    _recursiveDirty: null,
    _hasChildren: null,
    _shouldBeHidden: !1,
    _transformToBatch: null,
    _blendFunc: null,
    _texture: null,
    _rect: null,
    _rectRotated: !1,
    _offsetPosition: null,
    _unflippedOffsetPositionFromCenter: null,
    _opacityModifyRGB: !1,
    _flippedX: !1,
    _flippedY: !1,
    _textureLoaded: !1,
    _className: "Sprite",
    ctor: function(a, b, c) {
        cc.Node.prototype.ctor.call(this);
        this._shouldBeHidden = !1;
        this._offsetPosition = cc.p(0, 0);
        this._unflippedOffsetPositionFromCenter =
            cc.p(0, 0);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._rect = cc.rect(0, 0, 0, 0);
        this._softInit(a, b, c)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    isDirty: function() {
        return this.dirty
    },
    setDirty: function(a) {
        this.dirty = a
    },
    isTextureRectRotated: function() {
        return this._rectRotated
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getTextureRect: function() {
        return cc.rect(this._rect)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    },
    getOffsetPosition: function() {
        return cc.p(this._offsetPosition)
    },
    _getOffsetX: function() {
        return this._offsetPosition.x
    },
    _getOffsetY: function() {
        return this._offsetPosition.y
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    initWithSpriteFrame: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrame);
        a.textureLoaded() || (this._textureLoaded = !1, a.addEventListener("load", this._renderCmd._spriteFrameLoadedCallback,
            this));
        var b = cc._renderType === cc.game.RENDER_TYPE_CANVAS ? !1 : a._rotated,
            b = this.initWithTexture(a.getTexture(), a.getRect(), b);
        this.setSpriteFrame(a);
        return b
    },
    initWithSpriteFrameName: function(a) {
        cc.assert(a, cc._LogInfos.Sprite_initWithSpriteFrameName);
        var b = cc.spriteFrameCache.getSpriteFrame(a);
        cc.assert(b, a + cc._LogInfos.Sprite_initWithSpriteFrameName1);
        return this.initWithSpriteFrame(b)
    },
    useBatchNode: function(a) {
        this.textureAtlas = a.getTextureAtlas();
        this._batchNode = a
    },
    setVertexRect: function(a) {
        var b =
            this._rect;
        b.x = a.x;
        b.y = a.y;
        b.width = a.width;
        b.height = a.height
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b = a.length,
                c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
                    else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
                    else break;
                    d--
                }
                a[d + 1] = e
            }
            this._batchNode && this._arrayMakeObjectsPerformSelector(a, cc.Node._stateCallbackType.sortAllChildren);
            this._reorderChildDirty = !1
        }
    },
    reorderChild: function(a,
        b) {
        cc.assert(a, cc._LogInfos.Sprite_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.Sprite_reorderChild) : b !== a.zIndex && (this._batchNode && !this._reorderChildDirty && (this._setReorderChildDirtyRecursively(), this._batchNode.reorderBatch(!0)), cc.Node.prototype.reorderChild.call(this, a, b))
    },
    removeChild: function(a, b) {
        this._batchNode && this._batchNode.removeSpriteFromAtlas(a);
        cc.Node.prototype.removeChild.call(this, a, b)
    },
    setVisible: function(a) {
        cc.Node.prototype.setVisible.call(this, a);
        this._renderCmd.setDirtyRecursively(!0)
    },
    removeAllChildren: function(a) {
        var b = this._children,
            c = this._batchNode;
        if (c && null != b)
            for (var d = 0, e = b.length; d < e; d++) c.removeSpriteFromAtlas(b[d]);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._hasChildren = !1
    },
    ignoreAnchorPointForPosition: function(a) {
        this._batchNode ? cc.log(cc._LogInfos.Sprite_ignoreAnchorPointForPosition) : cc.Node.prototype.ignoreAnchorPointForPosition.call(this, a)
    },
    setFlippedX: function(a) {
        this._flippedX !== a && (this._flippedX = a, this.setTextureRect(this._rect, this._rectRotated,
            this._contentSize), this.setNodeDirty(!0))
    },
    setFlippedY: function(a) {
        this._flippedY !== a && (this._flippedY = a, this.setTextureRect(this._rect, this._rectRotated, this._contentSize), this.setNodeDirty(!0))
    },
    isFlippedX: function() {
        return this._flippedX
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB !== a && (this._opacityModifyRGB = a, this._renderCmd._setColorDirty())
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setDisplayFrameWithAnimationName: function(a,
        b) {
        cc.assert(a, cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_3);
        var c = cc.animationCache.getAnimation(a);
        c ? (c = c.getFrames()[b]) ? this.setSpriteFrame(c.getSpriteFrame()) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName_2) : cc.log(cc._LogInfos.Sprite_setDisplayFrameWithAnimationName)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    _setReorderChildDirtyRecursively: function() {
        if (!this._reorderChildDirty) {
            this._reorderChildDirty = !0;
            for (var a = this._parent; a && a !== this._batchNode;) a._setReorderChildDirtyRecursively(),
                a = a.parent
        }
    },
    getTexture: function() {
        return this._texture
    },
    _softInit: function(a, b, c) {
        if (void 0 === a) cc.Sprite.prototype.init.call(this);
        else if (cc.isString(a)) "#" === a[0] ? (b = a.substr(1, a.length - 1), (b = cc.spriteFrameCache.getSpriteFrame(b)) ? this.initWithSpriteFrame(b) : cc.log("%s does not exist", a)) : cc.Sprite.prototype.init.call(this, a, b);
        else if ("object" === typeof a)
            if (a instanceof cc.Texture2D) this.initWithTexture(a, b, c);
            else if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a);
        else if (a instanceof HTMLImageElement || a instanceof HTMLCanvasElement) b = new cc.Texture2D, b.initWithElement(a), b.handleLoadedTexture(), this.initWithTexture(b)
    },
    getQuad: function() {
        return this._renderCmd.getQuad()
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc;
        void 0 === b ? (c.src = a.src, c.dst = a.dst) : (c.src = a, c.dst = b);
        this._renderCmd.updateBlendFunc(c)
    },
    init: function() {
        if (0 < arguments.length) return this.initWithFile(arguments[0], arguments[1]);
        cc.Node.prototype.init.call(this);
        this.dirty = this._recursiveDirty = !1;
        this._blendFunc.src =
            cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.texture = null;
        this._flippedX = this._flippedY = !1;
        this.anchorY = this.anchorX = 0.5;
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this._renderCmd._init();
        this.setTextureRect(cc.rect(0, 0, 0, 0), !1, cc.size(0, 0));
        return !0
    },
    initWithFile: function(a, b) {
        cc.assert(a, cc._LogInfos.Sprite_initWithFile);
        var c = cc.textureCache.getTextureForKey(a);
        if (c) {
            if (!b) {
                var d = c.getContentSize();
                b = cc.rect(0, 0, d.width, d.height)
            }
            return this.initWithTexture(c,
                b)
        }
        c = cc.textureCache.addImage(a);
        return this.initWithTexture(c, b || cc.rect(0, 0, c._contentSize.width, c._contentSize.height))
    },
    initWithTexture: function(a, b, c, d) {
        cc.assert(0 !== arguments.length, cc._LogInfos.CCSpriteBatchNode_initWithTexture);
        c = c || !1;
        a = this._renderCmd._handleTextureForRotatedTexture(a, b, c, d);
        if (!cc.Node.prototype.init.call(this)) return !1;
        this._batchNode = null;
        this.dirty = this._recursiveDirty = !1;
        this._opacityModifyRGB = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this._flippedX =
            this._flippedY = !1;
        this.setAnchorPoint(0.5, 0.5);
        this._offsetPosition.x = 0;
        this._offsetPosition.y = 0;
        this._hasChildren = !1;
        this._renderCmd._init();
        var e = a.isLoaded();
        this._textureLoaded = e;
        if (!e) return this._rectRotated = c, b && (this._rect.x = b.x, this._rect.y = b.y, this._rect.width = b.width, this._rect.height = b.height), this.texture && this.texture.removeEventListener("load", this), a.addEventListener("load", this._renderCmd._textureLoadedCallback, this), this.texture = a, !0;
        b || (b = cc.rect(0, 0, a.width, a.height));
        this._renderCmd._checkTextureBoundary(a,
            b, c);
        this.setTexture(a);
        this.setTextureRect(b, c);
        this.setBatchNode(null);
        return !0
    },
    setTextureRect: function(a, b, c, d) {
        this._rectRotated = b || !1;
        this.setContentSize(c || a);
        this.setVertexRect(a);
        this._renderCmd._setTextureCoords(a, d);
        a = this._unflippedOffsetPositionFromCenter.x;
        b = this._unflippedOffsetPositionFromCenter.y;
        this._flippedX && (a = -a);
        this._flippedY && (b = -b);
        c = this._rect;
        this._offsetPosition.x = a + (this._contentSize.width - c.width) / 2;
        this._offsetPosition.y = b + (this._contentSize.height - c.height) / 2;
        this._batchNode ?
            this.dirty = !0 : this._renderCmd._resetForBatchNode()
    },
    updateTransform: function() {
        this._renderCmd.updateTransform()
    },
    addChild: function(a, b, c) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_addChild_2);
        null == b && (b = a._localZOrder);
        null == c && (c = a.tag);
        this._renderCmd._setBatchNodeForAddChild(a) && (cc.Node.prototype.addChild.call(this, a, b, c), this._hasChildren = !0)
    },
    setSpriteFrame: function(a) {
        var b = this;
        cc.isString(a) && (a = cc.spriteFrameCache.getSpriteFrame(a), cc.assert(a, cc._LogInfos.Sprite_setSpriteFrame));
        this.setNodeDirty(!0);
        var c = a.getOffset();
        b._unflippedOffsetPositionFromCenter.x = c.x;
        b._unflippedOffsetPositionFromCenter.y = c.y;
        c = a.getTexture();
        a.textureLoaded() ? (c !== b._texture && (b.texture = c), b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize())) : (b._textureLoaded = !1, a.addEventListener("load", function(a) {
            b._textureLoaded = !0;
            var c = a.getTexture();
            c !== b._texture && (b.texture = c);
            b.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
            b.dispatchEvent("load");
            b.setColor(b.color)
        }, b));
        this._renderCmd._updateForSetSpriteFrame(c)
    },
    setDisplayFrame: function(a) {
        cc.log(cc._LogInfos.Sprite_setDisplayFrame);
        this.setSpriteFrame(a)
    },
    isFrameDisplayed: function(a) {
        return this._renderCmd.isFrameDisplayed(a)
    },
    displayFrame: function() {
        return this.getSpriteFrame()
    },
    getSpriteFrame: function() {
        return new cc.SpriteFrame(this._texture, cc.rectPointsToPixels(this._rect), this._rectRotated, cc.pointPointsToPixels(this._unflippedOffsetPositionFromCenter), cc.sizePointsToPixels(this._contentSize))
    },
    setBatchNode: function(a) {
        (this._batchNode = a) ? (this._transformToBatch =
            cc.affineTransformIdentity(), this.textureAtlas = this._batchNode.getTextureAtlas()) : (this.atlasIndex = cc.Sprite.INDEX_NOT_INITIALIZED, this.textureAtlas = null, this.dirty = this._recursiveDirty = !1, this._renderCmd._resetForBatchNode())
    },
    setTexture: function(a) {
        if (!a) return this._renderCmd._setTexture(null);
        var b = cc.isString(a);
        b && (a = cc.textureCache.addImage(a));
        a._textureLoaded ? (this._setTexture(a, b), this.setColor(this._realColor), this._textureLoaded = !0) : (this._renderCmd._setTexture(null), a.addEventListener("load",
            function() {
                this._setTexture(a, b);
                this.setColor(this._realColor);
                this._textureLoaded = !0
            }, this))
    },
    _setTexture: function(a, b) {
        this._renderCmd._setTexture(a);
        b && this._changeRectWithTexture(a)
    },
    _changeRectWithTexture: function(a) {
        a = a._contentSize;
        a = cc.rect(0, 0, a.width, a.height);
        this.setTextureRect(a)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Sprite.CanvasRenderCmd(this) : new cc.Sprite.WebGLRenderCmd(this)
    }
});
cc.Sprite.create = function(a, b, c) {
    return new cc.Sprite(a, b, c)
};
cc.Sprite.createWithTexture = cc.Sprite.create;
cc.Sprite.createWithSpriteFrameName = cc.Sprite.create;
cc.Sprite.createWithSpriteFrame = cc.Sprite.create;
cc.Sprite.INDEX_NOT_INITIALIZED = -1;
cc.EventHelper.prototype.apply(cc.Sprite.prototype);
cc.assert(cc.isFunction(cc._tmp.PrototypeSprite), cc._LogInfos.MissingFile, "SpritesPropertyDefine.js");
cc._tmp.PrototypeSprite();
delete cc._tmp.PrototypeSprite;
(function() {
    cc.Sprite.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureCoord = {
            renderX: 0,
            renderY: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            validRect: !1
        };
        this._blendFuncStr = "source-over";
        this._colorized = !1;
        this._textureToRender = null
    };
    var a = cc.Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.Sprite.CanvasRenderCmd;
    a._init = function() {};
    a.setDirtyRecursively = function(a) {};
    a._resetForBatchNode = function() {};
    a._setTexture = function(a) {
        var c =
            this._node;
        c._texture !== a && (c._textureLoaded = a ? a._textureLoaded : !1, c._texture = a, this._updateColor())
    };
    a._setColorDirty = function() {
        this.setDirtyFlag(cc.Node._dirtyFlags.colorDirty | cc.Node._dirtyFlags.opacityDirty)
    };
    a.isFrameDisplayed = function(a) {
        var c = this._node;
        return a.getTexture() !== c._texture ? !1 : cc.rectEqualToRect(a.getRect(), c._rect)
    };
    a.updateBlendFunc = function(a) {
        this._blendFuncStr = cc.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(a)
    };
    a._setBatchNodeForAddChild = function(a) {
        return !0
    };
    a._handleTextureForRotatedTexture = function(a, c, d, e) {
        d && a.isLoaded() && (a = a.getHtmlElementObj(), a = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(a, c, e), e = new cc.Texture2D, e.initWithElement(a), e.handleLoadedTexture(), a = e, c.x = c.y = 0, this._node._rect = cc.rect(0, 0, c.width, c.height));
        return a
    };
    a._checkTextureBoundary = function(a, c, d) {
        a && a.url && (d = c.y + c.height, c.x + c.width > a.width && cc.error(cc._LogInfos.RectWidth, a.url), d > a.height && cc.error(cc._LogInfos.RectHeight, a.url))
    };
    a.rendering = function(a, c, d) {
        var e =
            this._node,
            f = this._textureCoord,
            g = this._displayedOpacity / 255,
            h = this._textureToRender || e._texture;
        if ((!h || 0 !== f.width && 0 !== f.height && h._textureLoaded) && 0 !== g) {
            a = a || cc._renderContext;
            var k = a.getContext(),
                m = e._offsetPosition.x,
                n = e._rect.height,
                p = e._rect.width,
                s = -e._offsetPosition.y - n;
            a.setTransform(this._worldTransform, c, d);
            a.setCompositeOperation(this._blendFuncStr);
            a.setGlobalAlpha(g);
            (e._flippedX || e._flippedY) && a.save();
            e._flippedX && (m = -m - p, k.scale(-1, 1));
            e._flippedY && (s = e._offsetPosition.y, k.scale(1, -1));
            var r, u, t;
            this._colorized ? r = g = 0 : (g = f.renderX, r = f.renderY);
            u = f.width;
            t = f.height;
            m *= c;
            s *= d;
            p *= c;
            n *= d;
            h ? (c = h._htmlElementObj, "" !== h._pattern ? (a.setFillStyle(k.createPattern(c, h._pattern)), k.fillRect(m, s, p, n)) : k.drawImage(c, g, r, u, t, m, s, p, n)) : (h = e._contentSize, f.validRect && (f = this._displayedColor, a.setFillStyle("rgba(" + f.r + "," + f.g + "," + f.b + ",1)"), k.fillRect(m, s, h.width * c, h.height * d)));
            (e._flippedX || e._flippedY) && a.restore();
            cc.g_NumberOfDraws++
        }
    };
    a._updateColor = function() {
        var a = this._node._texture,
            c = this._textureCoord,
            d = this._displayedColor;
        a && (255 !== d.r || 255 !== d.g || 255 !== d.b ? (this._textureToRender = a._generateColorTexture(d.r, d.g, d.b, c), this._colorized = !0) : a && (this._textureToRender = a, this._colorized = !1))
    };
    a.getQuad = function() {
        return null
    };
    a._updateForSetSpriteFrame = function(a, c) {
        this._colorized = !1;
        this._textureCoord.renderX = this._textureCoord.x;
        this._textureCoord.renderY = this._textureCoord.y;
        if (c = c || a._textureLoaded) {
            var d = this._node.getColor();
            255 === d.r && 255 === d.g && 255 === d.b || this._updateColor()
        }
    };
    a.updateTransform = function() {
        var a = this._node;
        if (a.dirty) {
            var c = a._parent;
            !a._visible || c && c !== a._batchNode && c._shouldBeHidden ? a._shouldBeHidden = !0 : (a._shouldBeHidden = !1, a._transformToBatch = c && c !== a._batchNode ? cc.affineTransformConcat(this.getNodeToParentTransform(), c._transformToBatch) : this.getNodeToParentTransform());
            a._recursiveDirty = !1;
            a.dirty = !1
        }
        a._hasChildren && a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
    };
    a._updateDisplayColor = function(a) {
        cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this,
            a)
    };
    a._spriteFrameLoadedCallback = function(a) {
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this._renderCmd._updateColor();
        this.dispatchEvent("load")
    };
    a._textureLoadedCallback = function(a) {
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var c = this._rect,
                d = this._renderCmd;
            c ? cc._rectEqualToZero(c) && (c.width = a.width, c.height = a.height) : c = cc.rect(0, 0, a.width, a.height);
            this.texture = a;
            this.setTextureRect(c, this._rectRotated);
            a = d._displayedColor;
            255 === a.r && 255 === a.g && 255 === a.b || d._updateColor();
            this.setBatchNode(this._batchNode);
            this.dispatchEvent("load")
        }
    };
    a._setTextureCoords = function(a, c) {
        void 0 === c && (c = !0);
        var d = this._textureCoord,
            e = c ? cc.contentScaleFactor() : 1;
        d.renderX = d.x = 0 | a.x * e;
        d.renderY = d.y = 0 | a.y * e;
        d.width = 0 | a.width * e;
        d.height = 0 | a.height * e;
        d.validRect = !(0 === d.width || 0 === d.height || 0 > d.x || 0 > d.y)
    };
    cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(a, c, d) {
        if (!a) return null;
        if (!c) return a;
        d = null == d ? !0 : d;
        var e = document.createElement("canvas");
        e.width = c.width;
        e.height = c.height;
        var f = e.getContext("2d");
        f.translate(e.width / 2, e.height / 2);
        d ? f.rotate(-1.5707963267948966) : f.rotate(1.5707963267948966);
        f.drawImage(a, c.x, c.y, c.height, c.width, -c.height / 2, -c.width / 2, c.height, c.width);
        return e
    }
})();
(function() {
    cc.Sprite.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._quad = new cc.V3F_C4B_T2F_Quad;
        this._quadWebBuffer = cc._renderContext.createBuffer();
        this._quadDirty = !0;
        this._recursiveDirty = this._dirty = !1
    };
    var a = cc.Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.Sprite.WebGLRenderCmd;
    a.updateBlendFunc = function(a) {};
    a.setDirtyFlag = function(a) {
        cc.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, a);
        this._dirty = !0
    };
    a.setDirtyRecursively = function(a) {
        this._dirty = this._recursiveDirty = a;
        for (var c = this._node._children, d, e = c ? c.length : 0, f = 0; f < e; f++) d = c[f], d instanceof cc.Sprite && d._renderCmd.setDirtyRecursively(a)
    };
    a._setBatchNodeForAddChild = function(a) {
        var c = this._node;
        if (c._batchNode) {
            if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.Sprite_addChild), !1;
            a.texture._webTextureObj !== c.textureAtlas.texture._webTextureObj && cc.log(cc._LogInfos.Sprite_addChild_2);
            c._batchNode.appendChild(a);
            c._reorderChildDirty ||
                c._setReorderChildDirtyRecursively()
        }
        return !0
    };
    a._handleTextureForRotatedTexture = function(a) {
        return a
    };
    a.isFrameDisplayed = function(a) {
        var c = this._node;
        return cc.rectEqualToRect(a.getRect(), c._rect) && a.getTexture().getName() === c._texture.getName() && cc.pointEqualToPoint(a.getOffset(), c._unflippedOffsetPositionFromCenter)
    };
    a._init = function() {
        var a = {
                r: 255,
                g: 255,
                b: 255,
                a: 255
            },
            c = this._quad;
        c.bl.colors = a;
        c.br.colors = a;
        c.tl.colors = a;
        c.tr.colors = a;
        this._quadDirty = !0
    };
    a._resetForBatchNode = function() {
        var a = this._node,
            c = a._offsetPosition.x,
            d = a._offsetPosition.y,
            e = c + a._rect.width,
            a = d + a._rect.height,
            f = this._quad;
        f.bl.vertices = {
            x: c,
            y: d,
            z: 0
        };
        f.br.vertices = {
            x: e,
            y: d,
            z: 0
        };
        f.tl.vertices = {
            x: c,
            y: a,
            z: 0
        };
        f.tr.vertices = {
            x: e,
            y: a,
            z: 0
        };
        this._quadDirty = !0
    };
    a.getQuad = function() {
        return this._quad
    };
    a._updateForSetSpriteFrame = function() {};
    a._spriteFrameLoadedCallback = function(a) {
        this.setTextureRect(a.getRect(), a.isRotated(), a.getOriginalSize());
        this.dispatchEvent("load")
    };
    a._textureLoadedCallback = function(a) {
        var c = this._renderCmd;
        if (!this._textureLoaded) {
            this._textureLoaded = !0;
            var d = this._rect;
            d ? cc._rectEqualToZero(d) && (d.width = a.width, d.height = a.height) : d = cc.rect(0, 0, a.width, a.height);
            this.texture = a;
            this.setTextureRect(d, this._rectRotated);
            this.setBatchNode(this._batchNode);
            c._quadDirty = !0;
            this.dispatchEvent("load")
        }
    };
    a._setTextureCoords = function(a, c) {
        void 0 === c && (c = !0);
        c && (a = cc.rectPointsToPixels(a));
        var d = this._node,
            e = d._batchNode ? d.textureAtlas.texture : d._texture;
        if (e) {
            var f = e.pixelsWidth,
                g = e.pixelsHeight,
                h, k, m = this._quad;
            d._rectRotated ? (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * a.x + 1) / (2 * f), f = e + (2 * a.height - 2) / (2 * f), h = (2 * a.y + 1) / (2 * g), g = h + (2 * a.width - 2) / (2 * g)) : (e = a.x / f, f = (a.x + a.height) / f, h = a.y / g, g = (a.y + a.width) / g), d._flippedX && (k = h, h = g, g = k), d._flippedY && (k = e, e = f, f = k), m.bl.texCoords.u = e, m.bl.texCoords.v = h, m.br.texCoords.u = e, m.br.texCoords.v = g, m.tl.texCoords.u = f, m.tl.texCoords.v = h, m.tr.texCoords.u = f, m.tr.texCoords.v = g) : (cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (e = (2 * a.x + 1) / (2 * f), f = e + (2 * a.width - 2) / (2 * f), h = (2 * a.y + 1) / (2 * g), g =
                h + (2 * a.height - 2) / (2 * g)) : (e = a.x / f, f = (a.x + a.width) / f, h = a.y / g, g = (a.y + a.height) / g), d._flippedX && (k = e, e = f, f = k), d._flippedY && (k = h, h = g, g = k), m.bl.texCoords.u = e, m.bl.texCoords.v = g, m.br.texCoords.u = f, m.br.texCoords.v = g, m.tl.texCoords.u = e, m.tl.texCoords.v = h, m.tr.texCoords.u = f, m.tr.texCoords.v = h);
            this._quadDirty = !0
        }
    };
    a.transform = function(a, c) {
        cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, c);
        this._dirty = !0
    };
    a._setColorDirty = function() {};
    a._updateColor = function() {
        var a = this._displayedColor,
            c = this._displayedOpacity,
            d = this._node,
            a = {
                r: a.r,
                g: a.g,
                b: a.b,
                a: c
            };
        d._opacityModifyRGB && (a.r *= c / 255, a.g *= c / 255, a.b *= c / 255);
        c = this._quad;
        c.bl.colors = a;
        c.br.colors = a;
        c.tl.colors = a;
        c.tr.colors = a;
        d._batchNode && (d.atlasIndex !== cc.Sprite.INDEX_NOT_INITIALIZED ? d.textureAtlas.updateQuad(c, d.atlasIndex) : this._dirty = !0);
        this._quadDirty = !0
    };
    a._updateBlendFunc = function() {
        if (this._batchNode) cc.log(cc._LogInfos.Sprite__updateBlendFunc);
        else {
            var a = this._node;
            a._texture && a._texture.hasPremultipliedAlpha() ? (a._blendFunc.src = cc.BLEND_SRC, a._blendFunc.dst =
                cc.BLEND_DST, a.opacityModifyRGB = !0) : (a._blendFunc.src = cc.SRC_ALPHA, a._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA, a.opacityModifyRGB = !1)
        }
    };
    a._setTexture = function(a) {
        var c = this._node;
        if (c._batchNode) {
            if (c._batchNode.texture !== a) {
                cc.log(cc._LogInfos.Sprite_setTexture);
                return
            }
        } else c._texture !== a && (c._textureLoaded = a ? a._textureLoaded : !1, c._texture = a, this._updateBlendFunc());
        this._shaderProgram = a ? cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR) : cc.shaderCache.programForKey(cc.SHADER_POSITION_COLOR)
    };
    a.updateTransform = function() {
        var a = this._node;
        if (this._dirty) {
            var c = this._quad,
                d = a._parent;
            if (!a._visible || d && d !== a._batchNode && d._shouldBeHidden) c.br.vertices = c.tl.vertices = c.tr.vertices = c.bl.vertices = {
                x: 0,
                y: 0,
                z: 0
            }, a._shouldBeHidden = !0;
            else {
                a._shouldBeHidden = !1;
                0 !== this._dirtyFlag && (this.updateStatus(), this._dirtyFlag = 0);
                a._transformToBatch = d && d !== a._batchNode ? cc.affineTransformConcat(this.getNodeToParentTransform(), d._transformToBatch) : this.getNodeToParentTransform();
                var e = a._transformToBatch,
                    f =
                    a._rect,
                    d = a._offsetPosition.x,
                    g = a._offsetPosition.y,
                    h = d + f.width,
                    k = g + f.height,
                    m = e.tx,
                    n = e.ty,
                    p = e.a,
                    s = e.b,
                    r = e.d,
                    u = -e.c,
                    e = d * p - g * u + m,
                    f = d * s + g * r + n,
                    t = h * p - g * u + m,
                    g = h * s + g * r + n,
                    v = h * p - k * u + m,
                    h = h * s + k * r + n,
                    m = d * p - k * u + m,
                    d = d * s + k * r + n,
                    k = a._vertexZ;
                cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (e |= 0, f |= 0, t |= 0, g |= 0, v |= 0, h |= 0, m |= 0, d |= 0);
                c.bl.vertices = {
                    x: e,
                    y: f,
                    z: k
                };
                c.br.vertices = {
                    x: t,
                    y: g,
                    z: k
                };
                c.tl.vertices = {
                    x: m,
                    y: d,
                    z: k
                };
                c.tr.vertices = {
                    x: v,
                    y: h,
                    z: k
                }
            }
            a.textureAtlas.updateQuad(c, a.atlasIndex);
            this._dirty = a._recursiveDirty = !1
        }
        a._hasChildren &&
            a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform)
    };
    a._checkTextureBoundary = function(a, c, d) {
        a && a.url && (d ? (d = c.x + c.height, c = c.y + c.width) : (d = c.x + c.width, c = c.y + c.height), d > a.width && cc.error(cc._LogInfos.RectWidth, a.url), c > a.height && cc.error(cc._LogInfos.RectHeight, a.url))
    };
    a.rendering = function(a) {
        var c = this._node,
            d = c._texture;
        d && !d._textureLoaded || 0 === this._displayedOpacity || (a = a || cc._renderContext, d ? d._textureLoaded && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
                cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst), cc.glBindTexture2DN(0, d), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)) : (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix),
                cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst), cc.glBindTexture2D(null), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_COLOR), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer, a.STATIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.drawArrays(a.TRIANGLE_STRIP, 0, 4)), cc.g_NumberOfDraws++,
            0 === cc.SPRITE_DEBUG_DRAW && !c._showNode) || (cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.current_stack.stack.push(cc.current_stack.top), cc.current_stack.top = this._stackMatrix, 1 === cc.SPRITE_DEBUG_DRAW || c._showNode ? (c = this._quad, c = [cc.p(c.tl.vertices.x, c.tl.vertices.y), cc.p(c.bl.vertices.x, c.bl.vertices.y), cc.p(c.br.vertices.x, c.br.vertices.y), cc.p(c.tr.vertices.x, c.tr.vertices.y)], cc._drawingUtil.drawPoly(c, 4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (d = c.getTextureRect(), c = c.getOffsetPosition(), c = [cc.p(c.x, c.y), cc.p(c.x +
            d.width, c.y), cc.p(c.x + d.width, c.y + d.height), cc.p(c.x, c.y + d.height)], cc._drawingUtil.drawPoly(c, 4, !0)), cc.current_stack.top = cc.current_stack.stack.pop())
    }
})();
cc.SpriteBatchNode = cc.Node.extend({
    _blendFunc: null,
    _descendants: null,
    _className: "SpriteBatchNode",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        this._descendants = [];
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        var c;
        b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY;
        cc.isString(a) ? (c = cc.textureCache.getTextureForKey(a)) || (c = cc.textureCache.addImage(a)) : a instanceof cc.Texture2D && (c = a);
        c && this.initWithTexture(c, b)
    },
    addSpriteWithoutQuad: function(a, b, c) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad_2);
        if (!(a instanceof cc.Sprite)) return cc.log(cc._LogInfos.SpriteBatchNode_addSpriteWithoutQuad), null;
        a.atlasIndex = b;
        var d = 0,
            e, f = this._descendants;
        if (f && 0 < f.length)
            for (d = 0, e = f.length; d < e; d++) {
                var g = f[d];
                if (g && g.atlasIndex >= b) break
            }
        f.splice(d, 0, a);
        cc.Node.prototype.addChild.call(this, a, b, c);
        this.reorderBatch(!1);
        return this
    },
    getTextureAtlas: function() {
        return this._renderCmd.getTextureAtlas()
    },
    setTextureAtlas: function(a) {
        this._renderCmd.getTextureAtlas(a)
    },
    getDescendants: function() {
        return this._descendants
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.getTextureForKey(a);
        c || (c = cc.textureCache.addImage(a));
        return this.initWithTexture(c, b)
    },
    _setNodeDirtyForCache: function() {
        this._renderCmd && this._renderCmd._setNodeDirtyForCache && this._renderCmd._setNodeDirtyForCache()
    },
    init: function(a, b) {
        var c = cc.textureCache.getTextureForKey(a);
        c || (c = cc.textureCache.addImage(a));
        return this.initWithTexture(c, b)
    },
    increaseAtlasCapacity: function() {
        this._renderCmd.increaseAtlasCapacity()
    },
    removeChildAtIndex: function(a,
        b) {
        this.removeChild(this._children[a], b)
    },
    rebuildIndexInOrder: function(a, b) {
        var c = a.children;
        if (c && 0 < c.length)
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && 0 > e.zIndex && (b = this.rebuildIndexInOrder(e, b))
            }!a === this && (a.atlasIndex = b, b++);
        if (c && 0 < c.length)
            for (d = 0; d < c.length; d++)(e = c[d]) && 0 <= e.zIndex && (b = this.rebuildIndexInOrder(e, b));
        return b
    },
    highestAtlasIndexInChild: function(a) {
        var b = a.children;
        return b && 0 !== b.length ? this.highestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    },
    lowestAtlasIndexInChild: function(a) {
        var b =
            a.children;
        return b && 0 !== b.length ? this.lowestAtlasIndexInChild(b[b.length - 1]) : a.atlasIndex
    },
    atlasIndexForChild: function(a, b) {
        var c = a.parent,
            d = c.children,
            e = d.indexOf(a),
            f = null;
        0 < e && e < cc.UINT_MAX && (f = d[e - 1]);
        return c === this ? 0 === e ? 0 : this.highestAtlasIndexInChild(f) + 1 : 0 === e ? 0 > b ? c.atlasIndex : c.atlasIndex + 1 : 0 > f.zIndex && 0 > b || 0 <= f.zIndex && 0 <= b ? this.highestAtlasIndexInChild(f) + 1 : c.atlasIndex + 1
    },
    reorderBatch: function(a) {
        this._reorderChildDirty = a
    },
    setBlendFunc: function(a, b) {
        this._blendFunc = void 0 === b ? a : {
            src: a,
            dst: b
        }
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    reorderChild: function(a, b) {
        cc.assert(a, cc._LogInfos.SpriteBatchNode_reorderChild_2); - 1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_reorderChild) : b !== a.zIndex && cc.Node.prototype.reorderChild.call(this, a, b)
    },
    removeChild: function(a, b) {
        null != a && (-1 === this._children.indexOf(a) ? cc.log(cc._LogInfos.SpriteBatchNode_removeChild) : (this.removeSpriteFromAtlas(a), cc.Node.prototype.removeChild.call(this,
            a, b)))
    },
    updateQuadFromSprite: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite_2);
        a instanceof cc.Sprite ? (this._renderCmd.checkAtlasCapacity(), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform()) : cc.log(cc._LogInfos.CCSpriteBatchNode_updateQuadFromSprite)
    },
    insertQuadFromSprite: function(a, b) {
        cc.assert(a, cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite_2);
        a instanceof cc.Sprite ? (this._renderCmd.insertQuad(a, b), a.batchNode = this, a.atlasIndex = b, a.dirty = !0, a.updateTransform(),
            this._renderCmd.cutting(a, b)) : cc.log(cc._LogInfos.CCSpriteBatchNode_insertQuadFromSprite)
    },
    initWithTexture: function(a, b) {
        this._children.length = 0;
        this._descendants.length = 0;
        b = b || cc.SpriteBatchNode.DEFAULT_CAPACITY;
        this._renderCmd.initWithTexture(a, b);
        return !0
    },
    insertChild: function(a, b) {
        a.batchNode = this;
        a.atlasIndex = b;
        a.dirty = !0;
        this._renderCmd.insertQuad(a, b);
        this._descendants.splice(b, 0, a);
        var c = b + 1,
            d = this._descendants;
        if (d && 0 < d.length)
            for (; c < d.length; c++) d[c].atlasIndex++;
        var d = a.children,
            e, f;
        if (d)
            for (c =
                0, f = d.length || 0; c < f; c++)
                if (e = d[c]) {
                    var g = this.atlasIndexForChild(e, e.zIndex);
                    this.insertChild(e, g)
                }
    },
    appendChild: function(a) {
        this._reorderChildDirty = !0;
        a.batchNode = this;
        a.dirty = !0;
        this._descendants.push(a);
        var b = this._descendants.length - 1;
        a.atlasIndex = b;
        this._renderCmd.insertQuad(a, b);
        a = a.children;
        for (var b = 0, c = a.length || 0; b < c; b++) this.appendChild(a[b])
    },
    removeSpriteFromAtlas: function(a) {
        this._renderCmd.removeQuadAtIndex(a.atlasIndex);
        a.batchNode = null;
        var b = this._descendants,
            c = b.indexOf(a);
        if (-1 !==
            c) {
            b.splice(c, 1);
            for (var d = b.length; c < d; ++c) b[c].atlasIndex--
        }
        if (a = a.children)
            for (b = 0, c = a.length || 0; b < c; b++) a[b] && this.removeSpriteFromAtlas(a[b])
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    setTexture: function(a) {
        this._renderCmd.setTexture(a)
    },
    addChild: function(a, b, c) {
        cc.assert(null != a, cc._LogInfos.CCSpriteBatchNode_addChild_3);
        this._renderCmd.isValidChild(a) && (b = null == b ? a.zIndex : b, c = null == c ? a.tag : c, cc.Node.prototype.addChild.call(this, a, b, c), this.appendChild(a))
    },
    removeAllChildren: function(a) {
        var b =
            this._descendants;
        if (b && 0 < b.length)
            for (var c = 0, d = b.length; c < d; c++) b[c] && (b[c].batchNode = null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this._descendants.length = 0;
        this._renderCmd.removeAllQuads()
    },
    sortAllChildren: function() {
        if (this._reorderChildDirty) {
            var a = this._children,
                b, c = 0,
                d = a.length,
                e;
            for (b = 1; b < d; b++) {
                var f = a[b],
                    c = b - 1;
                for (e = a[c]; 0 <= c && (f._localZOrder < e._localZOrder || f._localZOrder === e._localZOrder && f.arrivalOrder < e.arrivalOrder);) a[c + 1] = e, c -= 1, e = a[c];
                a[c + 1] = f
            }
            0 < a.length && (this._arrayMakeObjectsPerformSelector(a,
                cc.Node._stateCallbackType.sortAllChildren), this._renderCmd.updateChildrenAtlasIndex(a));
            this._reorderChildDirty = !1
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.SpriteBatchNode.CanvasRenderCmd(this) : new cc.SpriteBatchNode.WebGLRenderCmd(this)
    }
});
_p = cc.SpriteBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "textureAtlas", _p.getTextureAtlas, _p.setTextureAtlas);
cc.defineGetterSetter(_p, "descendants", _p.getDescendants);
cc.SpriteBatchNode.DEFAULT_CAPACITY = 29;
cc.SpriteBatchNode.create = function(a, b) {
    return new cc.SpriteBatchNode(a, b)
};
cc.SpriteBatchNode.createWithTexture = cc.SpriteBatchNode.create;
(function() {
    cc.SpriteBatchNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._textureToRender = this._texture = null
    };
    var a = cc.SpriteBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.SpriteBatchNode.CanvasRenderCmd;
    a.checkAtlasCapacity = function() {};
    a.isValidChild = function(a) {
        return a instanceof cc.Sprite ? !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1)
    };
    a.initWithTexture = function(a, c) {
        this._textureToRender = this._texture = a
    };
    a.insertQuad =
        function(a, c) {};
    a.increaseAtlasCapacity = function() {};
    a.removeQuadAtIndex = function() {};
    a.removeAllQuads = function() {};
    a.getTexture = function() {
        return this._texture
    };
    a.setTexture = function(a) {
        this._texture = a;
        for (var c = this._node._children, d = 0; d < c.length; d++) c[d].setTexture(a)
    };
    a.updateChildrenAtlasIndex = function(a) {
        for (var c = this._node._descendants.length = 0, d = a.length; c < d; c++) this._updateAtlasIndex(a[c])
    };
    a._updateAtlasIndex = function(a) {
        var c = this._node._descendants,
            d = a.children,
            e, f = d.length;
        for (e = 0; e <
            f; e++)
            if (0 > d[e]._localZOrder) c.push(d[e]);
            else break;
        for (c.push(a); e < f; e++) c.push(d[e])
    };
    a.getTextureAtlas = function() {};
    a.setTextureAtlas = function(a) {};
    a.cutting = function(a, c) {
        this._node._children.splice(c, 0, a)
    }
})();
(function() {
    cc.SpriteBatchNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._textureAtlas = null
    };
    var a = cc.SpriteBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.SpriteBatchNode.WebGLRenderCmd;
    a.isValidChild = function(a) {
        return a instanceof cc.Sprite ? a.texture != this.getTexture() ? (cc.log(cc._LogInfos.Sprite_addChild_5), !1) : !0 : (cc.log(cc._LogInfos.Sprite_addChild_4), !1)
    };
    a.rendering = function() {
        var a = this._node;
        0 !== this._textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), a._arrayMakeObjectsPerformSelector(a._children, cc.Node._stateCallbackType.updateTransform), cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst), this._textureAtlas.drawQuads())
    };
    a.visit = function(a) {
        var c = this._node;
        if (c._visible) {
            c._parent && c._parent._renderCmd && (this._curLevel = c._parent._renderCmd._curLevel + 1);
            var d = cc.current_stack;
            d.stack.push(d.top);
            this._dirtyFlag &
                cc.Node._dirtyFlags.transformDirty || this.transform(a);
            this.updateStatus(a);
            d.top = this._stackMatrix;
            c.sortAllChildren();
            cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0;
            d.top = d.stack.pop()
        }
    };
    a.checkAtlasCapacity = function(a) {
        for (var c = this._textureAtlas; a >= c.capacity || c.capacity === c.totalQuads;) this.increaseAtlasCapacity()
    };
    a.increaseAtlasCapacity = function() {
        var a = this._textureAtlas.capacity,
            c = Math.floor(4 * (a + 1) / 3);
        cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity, a, c);
        this._textureAtlas.resizeCapacity(c) ||
            cc.log(cc._LogInfos.SpriteBatchNode_increaseAtlasCapacity_2)
    };
    a.initWithTexture = function(a, c) {
        this._textureAtlas = new cc.TextureAtlas;
        this._textureAtlas.initWithTexture(a, c);
        this._updateBlendFunc();
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    };
    a.insertQuad = function(a, c) {
        var d = this._textureAtlas;
        d.totalQuads >= d.capacity && this.increaseAtlasCapacity();
        d.insertQuad(a.quad, c)
    };
    a.removeQuadAtIndex = function(a) {
        this._textureAtlas.removeQuadAtIndex(a)
    };
    a.getTexture = function() {
        return this._textureAtlas.texture
    };
    a.setTexture = function(a) {
        this._textureAtlas.setTexture(a);
        a && this._updateBlendFunc()
    };
    a.removeAllQuads = function() {
        this._textureAtlas.removeAllQuads()
    };
    a._swap = function(a, c) {
        var d = this._node._descendants,
            e = this._textureAtlas,
            f = e.quads,
            g = d[a],
            h = cc.V3F_C4B_T2F_QuadCopy(f[a]);
        d[c].atlasIndex = a;
        d[a] = d[c];
        e.updateQuad(f[c], a);
        d[c] = g;
        e.updateQuad(h, c)
    };
    a._updateAtlasIndex = function(a, c) {
        var d = 0,
            e = a.children;
        e && (d = e.length);
        var f = 0;
        if (0 === d) f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f !== c && this._swap(f,
            c), c++;
        else {
            f = !0;
            0 <= e[0].zIndex && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f !== c && this._swap(f, c), c++, f = !1);
            for (d = 0; d < e.length; d++) {
                var g = e[d];
                f && 0 <= g.zIndex && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f !== c && this._swap(f, c), c++, f = !1);
                c = this._updateAtlasIndex(g, c)
            }
            f && (f = a.atlasIndex, a.atlasIndex = c, a.arrivalOrder = 0, f !== c && this._swap(f, c), c++)
        }
        return c
    };
    a.updateChildrenAtlasIndex = function(a) {
        for (var c = 0, d = 0; d < a.length; d++) c = this._updateAtlasIndex(a[d], c)
    };
    a._updateBlendFunc = function() {
        if (!this._textureAtlas.texture.hasPremultipliedAlpha()) {
            var a =
                this._node._blendFunc;
            a.src = cc.SRC_ALPHA;
            a.dst = cc.ONE_MINUS_SRC_ALPHA
        }
    };
    a.getTextureAtlas = function() {
        return this._textureAtlas
    };
    a.setTextureAtlas = function(a) {
        a !== this._textureAtlas && (this._textureAtlas = a)
    };
    a.cutting = function() {}
})();
cc.BakeSprite = cc.Sprite.extend({
    _cacheCanvas: null,
    _cacheContext: null,
    ctor: function() {
        cc.Sprite.prototype.ctor.call(this);
        var a = document.createElement("canvas");
        a.width = a.height = 10;
        this._cacheCanvas = a;
        this._cacheContext = new cc.CanvasContextWrapper(a.getContext("2d"));
        var b = new cc.Texture2D;
        b.initWithElement(a);
        b.handleLoadedTexture();
        this.setTexture(b)
    },
    getCacheContext: function() {
        return this._cacheContext
    },
    getCacheCanvas: function() {
        return this._cacheCanvas
    },
    resetCanvasSize: function(a, b) {
        var c = this._cacheCanvas,
            d = this._cacheContext,
            e = d._context.strokeStyle,
            f = d._context.fillStyle;
        void 0 === b && (b = a.height, a = a.width);
        c.width = a;
        c.height = b;
        e !== d._context.strokeStyle && (d._context.strokeStyle = e);
        f !== d._context.fillStyle && (d._context.fillStyle = f);
        this.getTexture().handleLoadedTexture();
        this.setTextureRect(cc.rect(0, 0, a, b), !1, null, !1)
    }
});
cc.AnimationFrame = cc.Class.extend({
    _spriteFrame: null,
    _delayPerUnit: 0,
    _userInfo: null,
    ctor: function(a, b, c) {
        this._spriteFrame = a || null;
        this._delayPerUnit = b || 0;
        this._userInfo = c || null
    },
    clone: function() {
        var a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    copyWithZone: function(a) {
        return cc.clone(this)
    },
    copy: function(a) {
        a = new cc.AnimationFrame;
        a.initWithSpriteFrame(this._spriteFrame.clone(), this._delayPerUnit, this._userInfo);
        return a
    },
    initWithSpriteFrame: function(a,
        b, c) {
        this._spriteFrame = a;
        this._delayPerUnit = b;
        this._userInfo = c;
        return !0
    },
    getSpriteFrame: function() {
        return this._spriteFrame
    },
    setSpriteFrame: function(a) {
        this._spriteFrame = a
    },
    getDelayUnits: function() {
        return this._delayPerUnit
    },
    setDelayUnits: function(a) {
        this._delayPerUnit = a
    },
    getUserInfo: function() {
        return this._userInfo
    },
    setUserInfo: function(a) {
        this._userInfo = a
    }
});
cc.AnimationFrame.create = function(a, b, c) {
    return new cc.AnimationFrame(a, b, c)
};
cc.Animation = cc.Class.extend({
    _frames: null,
    _loops: 0,
    _restoreOriginalFrame: !1,
    _duration: 0,
    _delayPerUnit: 0,
    _totalDelayUnits: 0,
    ctor: function(a, b, c) {
        this._frames = [];
        if (void 0 === a) this.initWithSpriteFrames(null, 0);
        else {
            var d = a[0];
            d && (d instanceof cc.SpriteFrame ? this.initWithSpriteFrames(a, b, c) : d instanceof cc.AnimationFrame && this.initWithAnimationFrames(a, b, c))
        }
    },
    getFrames: function() {
        return this._frames
    },
    setFrames: function(a) {
        this._frames = a
    },
    addSpriteFrame: function(a) {
        var b = new cc.AnimationFrame;
        b.initWithSpriteFrame(a,
            1, null);
        this._frames.push(b);
        this._totalDelayUnits++
    },
    addSpriteFrameWithFile: function(a) {
        a = cc.textureCache.addImage(a);
        var b = cc.rect(0, 0, 0, 0);
        b.width = a.width;
        b.height = a.height;
        a = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(a)
    },
    addSpriteFrameWithTexture: function(a, b) {
        var c = new cc.SpriteFrame(a, b);
        this.addSpriteFrame(c)
    },
    initWithAnimationFrames: function(a, b, c) {
        cc.arrayVerifyType(a, cc.AnimationFrame);
        this._delayPerUnit = b;
        this._loops = void 0 === c ? 1 : c;
        this._totalDelayUnits = 0;
        b = this._frames;
        for (c = b.length =
            0; c < a.length; c++) {
            var d = a[c];
            b.push(d);
            this._totalDelayUnits += d.getDelayUnits()
        }
        return !0
    },
    clone: function() {
        var a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    copyWithZone: function(a) {
        a = new cc.Animation;
        a.initWithAnimationFrames(this._copyFrames(), this._delayPerUnit, this._loops);
        a.setRestoreOriginalFrame(this._restoreOriginalFrame);
        return a
    },
    _copyFrames: function() {
        for (var a = [], b = 0; b < this._frames.length; b++) a.push(this._frames[b].clone());
        return a
    },
    copy: function(a) {
        return this.copyWithZone(null)
    },
    getLoops: function() {
        return this._loops
    },
    setLoops: function(a) {
        this._loops = a
    },
    setRestoreOriginalFrame: function(a) {
        this._restoreOriginalFrame = a
    },
    getRestoreOriginalFrame: function() {
        return this._restoreOriginalFrame
    },
    getDuration: function() {
        return this._totalDelayUnits * this._delayPerUnit
    },
    getDelayPerUnit: function() {
        return this._delayPerUnit
    },
    setDelayPerUnit: function(a) {
        this._delayPerUnit = a
    },
    getTotalDelayUnits: function() {
        return this._totalDelayUnits
    },
    initWithSpriteFrames: function(a, b, c) {
        cc.arrayVerifyType(a, cc.SpriteFrame);
        this._loops = void 0 === c ? 1 : c;
        this._delayPerUnit = b || 0;
        this._totalDelayUnits = 0;
        b = this._frames;
        b.length = 0;
        if (a) {
            for (c = 0; c < a.length; c++) {
                var d = a[c],
                    e = new cc.AnimationFrame;
                e.initWithSpriteFrame(d, 1, null);
                b.push(e)
            }
            this._totalDelayUnits += a.length
        }
        return !0
    },
    retain: function() {},
    release: function() {}
});
cc.Animation.create = function(a, b, c) {
    return new cc.Animation(a, b, c)
};
cc.Animation.createWithAnimationFrames = cc.Animation.create;
cc.animationCache = {
    _animations: {},
    addAnimation: function(a, b) {
        this._animations[b] = a
    },
    removeAnimation: function(a) {
        a && this._animations[a] && delete this._animations[a]
    },
    getAnimation: function(a) {
        return this._animations[a] ? this._animations[a] : null
    },
    _addAnimationsWithDictionary: function(a, b) {
        var c = a.animations;
        if (c) {
            var d = 1,
                e = a.properties;
            if (e)
                for (var d = null != e.format ? parseInt(e.format) : d, e = e.spritesheets, f = cc.spriteFrameCache, g = cc.path, h = 0; h < e.length; h++) f.addSpriteFrames(g.changeBasename(b, e[h]));
            switch (d) {
                case 1:
                    this._parseVersion1(c);
                    break;
                case 2:
                    this._parseVersion2(c);
                    break;
                default:
                    cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary_2)
            }
        } else cc.log(cc._LogInfos.animationCache__addAnimationsWithDictionary)
    },
    addAnimations: function(a) {
        cc.assert(a, cc._LogInfos.animationCache_addAnimations_2);
        var b = cc.loader.getRes(a);
        b ? this._addAnimationsWithDictionary(b, a) : cc.log(cc._LogInfos.animationCache_addAnimations)
    },
    _parseVersion1: function(a) {
        var b = cc.spriteFrameCache,
            c;
        for (c in a) {
            var d = a[c],
                e = d.frames,
                d = parseFloat(d.delay) ||
                0,
                f = null;
            if (e) {
                for (var f = [], g = 0; g < e.length; g++) {
                    var h = b.getSpriteFrame(e[g]);
                    if (h) {
                        var k = new cc.AnimationFrame;
                        k.initWithSpriteFrame(h, 1, null);
                        f.push(k)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion1_2, c, e[g])
                }
                0 === f.length ? cc.log(cc._LogInfos.animationCache__parseVersion1_3, c) : (f.length !== e.length && cc.log(cc._LogInfos.animationCache__parseVersion1_4, c), f = new cc.Animation(f, d, 1), cc.animationCache.addAnimation(f, c))
            } else cc.log(cc._LogInfos.animationCache__parseVersion1, c)
        }
    },
    _parseVersion2: function(a) {
        var b =
            cc.spriteFrameCache,
            c;
        for (c in a) {
            var d = a[c],
                e = d.loop,
                f = parseInt(d.loops),
                e = e ? cc.REPEAT_FOREVER : isNaN(f) ? 1 : f,
                f = d.restoreOriginalFrame && !0 == d.restoreOriginalFrame ? !0 : !1,
                g = d.frames;
            if (g) {
                for (var h = [], k = 0; k < g.length; k++) {
                    var m = g[k],
                        n = m.spriteframe,
                        p = b.getSpriteFrame(n);
                    if (p) {
                        var n = parseFloat(m.delayUnits) || 0,
                            m = m.notification,
                            s = new cc.AnimationFrame;
                        s.initWithSpriteFrame(p, n, m);
                        h.push(s)
                    } else cc.log(cc._LogInfos.animationCache__parseVersion2_2, c, n)
                }
                d = parseFloat(d.delayPerUnit) || 0;
                g = new cc.Animation;
                g.initWithAnimationFrames(h,
                    d, e);
                g.setRestoreOriginalFrame(f);
                cc.animationCache.addAnimation(g, c)
            } else cc.log(cc._LogInfos.animationCache__parseVersion2, c)
        }
    },
    _clear: function() {
        this._animations = {}
    }
};
cc.SpriteFrame = cc.Class.extend({
    _offset: null,
    _originalSize: null,
    _rectInPixels: null,
    _rotated: !1,
    _rect: null,
    _offsetInPixels: null,
    _originalSizeInPixels: null,
    _texture: null,
    _textureFilename: "",
    _textureLoaded: !1,
    ctor: function(a, b, c, d, e) {
        this._offset = cc.p(0, 0);
        this._offsetInPixels = cc.p(0, 0);
        this._originalSize = cc.size(0, 0);
        this._rotated = !1;
        this._originalSizeInPixels = cc.size(0, 0);
        this._textureFilename = "";
        this._texture = null;
        this._textureLoaded = !1;
        void 0 !== a && void 0 !== b && (void 0 === c || void 0 === d || void 0 === e ?
            this.initWithTexture(a, b) : this.initWithTexture(a, b, c, d, e))
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    getRectInPixels: function() {
        var a = this._rectInPixels;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRectInPixels: function(a) {
        this._rectInPixels || (this._rectInPixels = cc.rect(0, 0, 0, 0));
        this._rectInPixels.x = a.x;
        this._rectInPixels.y = a.y;
        this._rectInPixels.width = a.width;
        this._rectInPixels.height = a.height;
        this._rect = cc.rectPixelsToPoints(a)
    },
    isRotated: function() {
        return this._rotated
    },
    setRotated: function(a) {
        this._rotated = a
    },
    getRect: function() {
        var a = this._rect;
        return cc.rect(a.x, a.y, a.width, a.height)
    },
    setRect: function(a) {
        this._rect || (this._rect = cc.rect(0, 0, 0, 0));
        this._rect.x = a.x;
        this._rect.y = a.y;
        this._rect.width = a.width;
        this._rect.height = a.height;
        this._rectInPixels = cc.rectPointsToPixels(this._rect)
    },
    getOffsetInPixels: function() {
        return cc.p(this._offsetInPixels)
    },
    setOffsetInPixels: function(a) {
        this._offsetInPixels.x = a.x;
        this._offsetInPixels.y =
            a.y;
        cc._pointPixelsToPointsOut(this._offsetInPixels, this._offset)
    },
    getOriginalSizeInPixels: function() {
        return cc.size(this._originalSizeInPixels)
    },
    setOriginalSizeInPixels: function(a) {
        this._originalSizeInPixels.width = a.width;
        this._originalSizeInPixels.height = a.height
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    setOriginalSize: function(a) {
        this._originalSize.width = a.width;
        this._originalSize.height = a.height
    },
    getTexture: function() {
        if (this._texture) return this._texture;
        if ("" !== this._textureFilename) {
            var a =
                cc.textureCache.addImage(this._textureFilename);
            a && (this._textureLoaded = a.isLoaded());
            return a
        }
        return null
    },
    setTexture: function(a) {
        if (this._texture !== a) {
            var b = a.isLoaded();
            this._textureLoaded = b;
            this._texture = a;
            b || a.addEventListener("load", function(a) {
                this._textureLoaded = !0;
                if (this._rotated && cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                    var b = a.getHtmlElementObj(),
                        b = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(b, this.getRect()),
                        e = new cc.Texture2D;
                    e.initWithElement(b);
                    e.handleLoadedTexture();
                    this.setTexture(e);
                    b = this.getRect();
                    this.setRect(cc.rect(0, 0, b.width, b.height))
                }
                b = this._rect;
                0 === b.width && 0 === b.height && (b = a.width, a = a.height, this._rect.width = b, this._rect.height = a, this._rectInPixels = cc.rectPointsToPixels(this._rect), this._originalSizeInPixels.width = this._rectInPixels.width, this._originalSizeInPixels.height = this._rectInPixels.height, this._originalSize.width = b, this._originalSize.height = a);
                this.dispatchEvent("load")
            }, this)
        }
    },
    getOffset: function() {
        return cc.p(this._offset)
    },
    setOffset: function(a) {
        this._offset.x =
            a.x;
        this._offset.y = a.y
    },
    clone: function() {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copyWithZone: function() {
        var a = new cc.SpriteFrame;
        a.initWithTexture(this._textureFilename, this._rectInPixels, this._rotated, this._offsetInPixels, this._originalSizeInPixels);
        a.setTexture(this._texture);
        return a
    },
    copy: function() {
        return this.copyWithZone()
    },
    initWithTexture: function(a,
        b, c, d, e) {
        2 === arguments.length && (b = cc.rectPointsToPixels(b));
        d = d || cc.p(0, 0);
        e = e || b;
        c = c || !1;
        cc.isString(a) ? (this._texture = null, this._textureFilename = a) : a instanceof cc.Texture2D && this.setTexture(a);
        a = this.getTexture();
        this._rectInPixels = b;
        b = this._rect = cc.rectPixelsToPoints(b);
        if (a && a.url && a.isLoaded()) {
            var f, g;
            c ? (f = b.x + b.height, g = b.y + b.width) : (f = b.x + b.width, g = b.y + b.height);
            f > a.getPixelsWide() && cc.error(cc._LogInfos.RectWidth, a.url);
            g > a.getPixelsHigh() && cc.error(cc._LogInfos.RectHeight, a.url)
        }
        this._offsetInPixels.x =
            d.x;
        this._offsetInPixels.y = d.y;
        cc._pointPixelsToPointsOut(d, this._offset);
        this._originalSizeInPixels.width = e.width;
        this._originalSizeInPixels.height = e.height;
        cc._sizePixelsToPointsOut(e, this._originalSize);
        this._rotated = c;
        return !0
    }
});
cc.EventHelper.prototype.apply(cc.SpriteFrame.prototype);
cc.SpriteFrame.create = function(a, b, c, d, e) {
    return new cc.SpriteFrame(a, b, c, d, e)
};
cc.SpriteFrame.createWithTexture = cc.SpriteFrame.create;
cc.SpriteFrame._frameWithTextureForCanvas = function(a, b, c, d, e) {
    var f = new cc.SpriteFrame;
    f._texture = a;
    f._rectInPixels = b;
    f._rect = cc.rectPixelsToPoints(b);
    f._offsetInPixels.x = d.x;
    f._offsetInPixels.y = d.y;
    cc._pointPixelsToPointsOut(f._offsetInPixels, f._offset);
    f._originalSizeInPixels.width = e.width;
    f._originalSizeInPixels.height = e.height;
    cc._sizePixelsToPointsOut(f._originalSizeInPixels, f._originalSize);
    f._rotated = c;
    return f
};
cc.spriteFrameCache = {
    _CCNS_REG1: /^\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*$/,
    _CCNS_REG2: /^\s*\{\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*,\s*\{\s*([\-]?\d+[.]?\d*)\s*,\s*([\-]?\d+[.]?\d*)\s*\}\s*\}\s*$/,
    _spriteFrames: {},
    _spriteFramesAliases: {},
    _frameConfigCache: {},
    _rectFromString: function(a) {
        return (a = this._CCNS_REG2.exec(a)) ? cc.rect(parseFloat(a[1]), parseFloat(a[2]), parseFloat(a[3]), parseFloat(a[4])) : cc.rect(0, 0, 0, 0)
    },
    _pointFromString: function(a) {
        return (a = this._CCNS_REG1.exec(a)) ?
            cc.p(parseFloat(a[1]), parseFloat(a[2])) : cc.p(0, 0)
    },
    _sizeFromString: function(a) {
        return (a = this._CCNS_REG1.exec(a)) ? cc.size(parseFloat(a[1]), parseFloat(a[2])) : cc.size(0, 0)
    },
    _getFrameConfig: function(a) {
        var b = cc.loader.getRes(a);
        cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2, a);
        cc.loader.release(a);
        if (b._inited) return this._frameConfigCache[a] = b;
        this._frameConfigCache[a] = this._parseFrameConfig(b);
        return this._frameConfigCache[a]
    },
    _getFrameConfigByJsonObject: function(a, b) {
        cc.assert(b, cc._LogInfos.spriteFrameCache__getFrameConfig_2,
            a);
        this._frameConfigCache[a] = this._parseFrameConfig(b);
        return this._frameConfigCache[a]
    },
    _parseFrameConfig: function(a) {
        var b = a.frames,
            c = a.metadata || a.meta;
        a = {};
        var d = {},
            e = 0;
        c && (e = c.format, e = 1 >= e.length ? parseInt(e) : e, d.image = c.textureFileName || c.textureFileName || c.image);
        for (var f in b) {
            var g = b[f];
            if (g) {
                c = {};
                if (0 == e) {
                    c.rect = cc.rect(g.x, g.y, g.width, g.height);
                    c.rotated = !1;
                    c.offset = cc.p(g.offsetX, g.offsetY);
                    var h = g.originalWidth,
                        g = g.originalHeight;
                    h && g || cc.log(cc._LogInfos.spriteFrameCache__getFrameConfig);
                    h = Math.abs(h);
                    g = Math.abs(g);
                    c.size = cc.size(h, g)
                } else if (1 == e || 2 == e) c.rect = this._rectFromString(g.frame), c.rotated = g.rotated || !1, c.offset = this._pointFromString(g.offset), c.size = this._sizeFromString(g.sourceSize);
                else if (3 == e) {
                    var h = this._sizeFromString(g.spriteSize),
                        k = this._rectFromString(g.textureRect);
                    h && (k = cc.rect(k.x, k.y, h.width, h.height));
                    c.rect = k;
                    c.rotated = g.textureRotated || !1;
                    c.offset = this._pointFromString(g.spriteOffset);
                    c.size = this._sizeFromString(g.spriteSourceSize);
                    c.aliases = g.aliases
                } else h =
                    g.frame, k = g.sourceSize, f = g.filename || f, c.rect = cc.rect(h.x, h.y, h.w, h.h), c.rotated = g.rotated || !1, c.offset = cc.p(0, 0), c.size = cc.size(k.w, k.h);
                a[f] = c
            }
        }
        return {
            _inited: !0,
            frames: a,
            meta: d
        }
    },
    _addSpriteFramesByObject: function(a, b, c) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        b && b.frames && (b = this._frameConfigCache[a] || this._getFrameConfigByJsonObject(a, b), this._createSpriteFrames(a, b, c))
    },
    _createSpriteFrames: function(a, b, c) {
        var d = b.frames;
        b = b.meta;
        c ? c instanceof cc.Texture2D || (cc.isString(c) ?
            c = cc.textureCache.addImage(c) : cc.assert(0, cc._LogInfos.spriteFrameCache_addSpriteFrames_3)) : (c = cc.path.changeBasename(a, b.image || ".png"), c = cc.textureCache.addImage(c));
        a = this._spriteFramesAliases;
        b = this._spriteFrames;
        for (var e in d) {
            var f = d[e],
                g = b[e];
            if (!g) {
                g = new cc.SpriteFrame(c, f.rect, f.rotated, f.offset, f.size);
                if (f = f.aliases)
                    for (var h = 0, k = f.length; h < k; h++) {
                        var m = f[h];
                        a[m] && cc.log(cc._LogInfos.spriteFrameCache_addSpriteFrames, m);
                        a[m] = e
                    }
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && g.isRotated() &&
                    g.getTexture().isLoaded() && (f = g.getTexture().getHtmlElementObj(), f = cc.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(f, g.getRectInPixels()), h = new cc.Texture2D, h.initWithElement(f), h.handleLoadedTexture(), g.setTexture(h), f = g._rect, g.setRect(cc.rect(0, 0, f.width, f.height)));
                b[e] = g
            }
        }
    },
    addSpriteFrames: function(a, b) {
        cc.assert(a, cc._LogInfos.spriteFrameCache_addSpriteFrames_2);
        var c = this._frameConfigCache[a] || cc.loader.getRes(a);
        c && c.frames && (c = this._frameConfigCache[a] || this._getFrameConfig(a), this._createSpriteFrames(a,
            c, b))
    },
    _checkConflict: function(a) {
        a = a.frames;
        for (var b in a) this._spriteFrames[b] && cc.log(cc._LogInfos.spriteFrameCache__checkConflict, b)
    },
    addSpriteFrame: function(a, b) {
        this._spriteFrames[b] = a
    },
    removeSpriteFrames: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {}
    },
    removeSpriteFrameByName: function(a) {
        a && (this._spriteFramesAliases[a] && delete this._spriteFramesAliases[a], this._spriteFrames[a] && delete this._spriteFrames[a])
    },
    removeSpriteFramesFromFile: function(a) {
        var b = this._spriteFrames,
            c =
            this._spriteFramesAliases;
        if (a = this._frameConfigCache[a]) {
            a = a.frames;
            for (var d in a)
                if (b[d]) {
                    delete b[d];
                    for (var e in c) c[e] === d && delete c[e]
                }
        }
    },
    removeSpriteFramesFromTexture: function(a) {
        var b = this._spriteFrames,
            c = this._spriteFramesAliases,
            d;
        for (d in b) {
            var e = b[d];
            if (e && e.getTexture() === a) {
                delete b[d];
                for (var f in c) c[f] === d && delete c[f]
            }
        }
    },
    getSpriteFrame: function(a) {
        var b = this._spriteFrames[a];
        if (!b) {
            var c = this._spriteFramesAliases[a];
            c && ((b = this._spriteFrames[c.toString()]) || delete this._spriteFramesAliases[a])
        }
        return b
    },
    _clear: function() {
        this._spriteFrames = {};
        this._spriteFramesAliases = {};
        this._frameConfigCache = {}
    }
};
cc.configuration = {
    ERROR: 0,
    STRING: 1,
    INT: 2,
    DOUBLE: 3,
    BOOLEAN: 4,
    _maxTextureSize: 0,
    _maxModelviewStackDepth: 0,
    _supportsPVRTC: !1,
    _supportsNPOT: !1,
    _supportsBGRA8888: !1,
    _supportsDiscardFramebuffer: !1,
    _supportsShareableVAO: !1,
    _maxSamplesAllowed: 0,
    _maxTextureUnits: 0,
    _GlExtensions: "",
    _valueDict: {},
    _inited: !1,
    _init: function() {
        var a = this._valueDict;
        a["cocos2d.x.version"] = cc.ENGINE_VERSION;
        a["cocos2d.x.compiled_with_profiler"] = !1;
        a["cocos2d.x.compiled_with_gl_state_cache"] = cc.ENABLE_GL_STATE_CACHE;
        this._inited = !0
    },
    getMaxTextureSize: function() {
        return this._maxTextureSize
    },
    getMaxModelviewStackDepth: function() {
        return this._maxModelviewStackDepth
    },
    getMaxTextureUnits: function() {
        return this._maxTextureUnits
    },
    supportsNPOT: function() {
        return this._supportsNPOT
    },
    supportsPVRTC: function() {
        return this._supportsPVRTC
    },
    supportsETC: function() {
        return !1
    },
    supportsS3TC: function() {
        return !1
    },
    supportsATITC: function() {
        return !1
    },
    supportsBGRA8888: function() {
        return this._supportsBGRA8888
    },
    supportsDiscardFramebuffer: function() {
        return this._supportsDiscardFramebuffer
    },
    supportsShareableVAO: function() {
        return this._supportsShareableVAO
    },
    checkForGLExtension: function(a) {
        return -1 < this._GlExtensions.indexOf(a)
    },
    getValue: function(a, b) {
        this._inited || this._init();
        var c = this._valueDict;
        return c[a] ? c[a] : b
    },
    setValue: function(a, b) {
        this._valueDict[a] = b
    },
    dumpInfo: function() {
        0 === cc.ENABLE_GL_STATE_CACHE && (cc.log(""), cc.log(cc._LogInfos.configuration_dumpInfo), cc.log(""))
    },
    gatherGPUInfo: function() {
        if (cc._renderType !== cc.game.RENDER_TYPE_CANVAS) {
            this._inited || this._init();
            var a =
                cc._renderContext,
                b = this._valueDict;
            b["gl.vendor"] = a.getParameter(a.VENDOR);
            b["gl.renderer"] = a.getParameter(a.RENDERER);
            b["gl.version"] = a.getParameter(a.VERSION);
            this._GlExtensions = "";
            for (var c = a.getSupportedExtensions(), d = 0; d < c.length; d++) this._GlExtensions += c[d] + " ";
            this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
            b["gl.max_texture_size"] = this._maxTextureSize;
            this._maxTextureUnits = a.getParameter(a.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            b["gl.max_texture_units"] = this._maxTextureUnits;
            this._supportsPVRTC =
                this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
            b["gl.supports_PVRTC"] = this._supportsPVRTC;
            this._supportsNPOT = !1;
            b["gl.supports_NPOT"] = this._supportsNPOT;
            this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
            b["gl.supports_BGRA8888"] = this._supportsBGRA8888;
            this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
            b["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
            this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
            b["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
            cc.checkGLErrorDebug()
        }
    },
    loadConfigFile: function(a) {
        this._inited || this._init();
        var b = cc.loader.getRes(a);
        if (!b) throw Error("Please load the resource first : " + a);
        cc.assert(b, cc._LogInfos.configuration_loadConfigFile_2, a);
        if (b = b.data)
            for (var c in b) this._valueDict[c] = b[c];
        else cc.log(cc._LogInfos.configuration_loadConfigFile, a)
    }
};
cc.g_NumberOfDraws = 0;
cc.GLToClipTransform = function(a) {
    cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
    var b = new cc.math.Matrix4;
    cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
    a.multiply(b)
};
cc.Director = cc.Class.extend({
    _landscape: !1,
    _nextDeltaTimeZero: !1,
    _paused: !1,
    _purgeDirectorInNextLoop: !1,
    _sendCleanupToScene: !1,
    _animationInterval: 0,
    _oldAnimationInterval: 0,
    _projection: 0,
    _contentScaleFactor: 1,
    _deltaTime: 0,
    _winSizeInPoints: null,
    _lastUpdate: null,
    _nextScene: null,
    _notificationNode: null,
    _openGLView: null,
    _scenesStack: null,
    _projectionDelegate: null,
    _runningScene: null,
    _totalFrames: 0,
    _secondsPerFrame: 0,
    _dirtyRegion: null,
    _scheduler: null,
    _actionManager: null,
    _eventProjectionChanged: null,
    _eventAfterUpdate: null,
    _eventAfterVisit: null,
    _eventAfterDraw: null,
    _bPortrait: !1,
    _runDRSizeWidth: 0,
    _runDRSizeHeight: 0,
    ctor: function() {
        var a = this;
        a._lastUpdate = Date.now();
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
            a._lastUpdate = Date.now()
        })
    },
    init: function() {
        this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
        this._scenesStack = [];
        this._projection = cc.Director.PROJECTION_DEFAULT;
        this._projectionDelegate = null;
        this._totalFrames = 0;
        this._lastUpdate = Date.now();
        this._purgeDirectorInNextLoop = this._paused = !1;
        this._winSizeInPoints = cc.size(0, 0);
        this._openGLView = null;
        this._contentScaleFactor = 1;
        this._scheduler = new cc.Scheduler;
        cc.ActionManager ? (this._actionManager = new cc.ActionManager, this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, !1)) : this._actionManager = null;
        this._eventAfterUpdate = new cc.EventCustom(cc.Director.EVENT_AFTER_UPDATE);
        this._eventAfterUpdate.setUserData(this);
        this._eventAfterVisit = new cc.EventCustom(cc.Director.EVENT_AFTER_VISIT);
        this._eventAfterVisit.setUserData(this);
        this._eventAfterDraw = new cc.EventCustom(cc.Director.EVENT_AFTER_DRAW);
        this._eventAfterDraw.setUserData(this);
        this._eventProjectionChanged = new cc.EventCustom(cc.Director.EVENT_PROJECTION_CHANGED);
        this._eventProjectionChanged.setUserData(this);
        var a = this;
        cc.view.setResizeCallback(function() {
            a.refreshPortrait()
        });
        return !0
    },
    refreshPortrait: function() {
        if (cc.sys.isMobile && void 0 != this._runningScene && null != this._runningScene) {
            var a = cc.view.getFrameSize();
            (this._bPortrait = a.height >= a.width) ? (this._runDRSizeWidth >
                this._runDRSizeHeight ? this._runningScene.setPosition(-280, 280) : this._runningScene.setPosition(280, 280), this._runningScene.setRotation(90), cc.view.setDesignResolutionSize(720, 1280, cc.ResolutionPolicy.SHOW_ALL)) : (this._runningScene.setPosition(0, 0), this._runningScene.setRotation(0), cc.view.setDesignResolutionSize(1280, 720, cc.ResolutionPolicy.SHOW_ALL))
        }
    },
    calculateDeltaTime: function() {
        var a = Date.now();
        this._nextDeltaTimeZero ? (this._deltaTime = 0, this._nextDeltaTimeZero = !1) : this._deltaTime = (a - this._lastUpdate) /
            1E3;
        !cc.game.bhide && 0 < cc.game.config[cc.game.CONFIG_KEY.debugMode] && 0.2 < this._deltaTime && (this._deltaTime = 1 / 60);
        this._lastUpdate = a
    },
    convertToGL: null,
    convertToUI: null,
    drawScene: function() {
        var a = cc.renderer;
        this.calculateDeltaTime();
        this._paused || (this._scheduler.update(this._deltaTime), cc.eventManager.dispatchEvent(this._eventAfterUpdate));
        a.clear();
        this._nextScene && this.setNextScene();
        this._beforeVisitScene && this._beforeVisitScene();
        this._runningScene && (!0 === a.childrenOrderDirty ? (cc.renderer.clearRenderCommands(),
            this._runningScene._renderCmd._curLevel = 0, this._runningScene.visit(), a.resetFlag()) : !0 === a.transformDirty() && a.transform());
        this._notificationNode && this._notificationNode.visit();
        cc.eventManager.dispatchEvent(this._eventAfterVisit);
        cc.g_NumberOfDraws = 0;
        this._afterVisitScene && this._afterVisitScene();
        a.rendering(cc._renderContext);
        this._totalFrames++;
        cc.eventManager.dispatchEvent(this._eventAfterDraw);
        this._calculateMPF()
    },
    _beforeVisitScene: null,
    _afterVisitScene: null,
    end: function() {
        this._purgeDirectorInNextLoop = !0
    },
    getContentScaleFactor: function() {
        return this._contentScaleFactor
    },
    getNotificationNode: function() {
        return this._notificationNode
    },
    getWinSize: function() {
        return cc.size(this._winSizeInPoints)
    },
    getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor)
    },
    getVisibleSize: null,
    getVisibleOrigin: null,
    getZEye: null,
    pause: function() {
        this._paused || (this._oldAnimationInterval = this._animationInterval, this.setAnimationInterval(0.25),
            this._paused = !0)
    },
    popScene: function() {
        cc.assert(this._runningScene, cc._LogInfos.Director_popScene);
        this._scenesStack.pop();
        var a = this._scenesStack.length;
        0 === a ? this.end() : (this._sendCleanupToScene = !0, this._nextScene = this._scenesStack[a - 1])
    },
    purgeCachedData: function() {
        cc.animationCache._clear();
        cc.spriteFrameCache._clear();
        cc.textureCache._clear()
    },
    purgeDirector: function() {
        this.getScheduler().unscheduleAll();
        cc.eventManager && cc.eventManager.setEnabled(!1);
        this._runningScene && (this._runningScene.onExitTransitionDidStart(),
            this._runningScene.onExit(), this._runningScene.cleanup());
        this._nextScene = this._runningScene = null;
        this._scenesStack.length = 0;
        this.stopAnimation();
        this.purgeCachedData();
        cc.checkGLErrorDebug()
    },
    pushScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        this._sendCleanupToScene = !1;
        this._scenesStack.push(a);
        this._nextScene = a
    },
    runScene: function(a) {
        cc.assert(a, cc._LogInfos.Director_pushScene);
        if (this._runningScene) {
            var b = this._scenesStack.length;
            0 === b ? (this._sendCleanupToScene = !0, this._scenesStack[b] =
                a) : (this._sendCleanupToScene = !0, this._scenesStack[b - 1] = a);
            this._nextScene = a
        } else this.pushScene(a), this.startAnimation()
    },
    resume: function() {
        this._paused && (this.setAnimationInterval(this._oldAnimationInterval), (this._lastUpdate = Date.now()) || cc.log(cc._LogInfos.Director_resume), this._paused = !1, this._deltaTime = 0)
    },
    setContentScaleFactor: function(a) {
        a !== this._contentScaleFactor && (this._contentScaleFactor = a)
    },
    setDepthTest: null,
    setClearColor: null,
    setDefaultValues: function() {},
    setNextDeltaTimeZero: function(a) {
        this._nextDeltaTimeZero =
            a
    },
    setNextScene: function() {
        var a = !1,
            b = !1;
        cc.TransitionScene && (a = this._runningScene ? this._runningScene instanceof cc.TransitionScene : !1, b = this._nextScene ? this._nextScene instanceof cc.TransitionScene : !1);
        if (!b) {
            if (b = this._runningScene) b.onExitTransitionDidStart(), b.onExit();
            this._sendCleanupToScene && b && b.cleanup()
        }
        this._runningScene = this._nextScene;
        cc.renderer.childrenOrderDirty = !0;
        this._nextScene = null;
        a || null === this._runningScene || (this._runningScene.onEnter(), this._runningScene.onEnterTransitionDidFinish());
        a = cc.view.getDesignResolutionSize();
        this._runDRSizeWidth = a.width;
        this._runDRSizeHeight = a.height;
        this.refreshPortrait()
    },
    setNotificationNode: function(a) {
        cc.renderer.childrenOrderDirty = !0;
        this._notificationNode && (this._notificationNode.onExitTransitionDidStart(), this._notificationNode.onExit(), this._notificationNode.cleanup());
        if (this._notificationNode = a) this._notificationNode.onEnter(), this._notificationNode.onEnterTransitionDidFinish()
    },
    getDelegate: function() {
        return this._projectionDelegate
    },
    setDelegate: function(a) {
        this._projectionDelegate =
            a
    },
    setOpenGLView: null,
    setProjection: null,
    setViewport: null,
    getOpenGLView: null,
    getProjection: null,
    setAlphaBlending: null,
    isSendCleanupToScene: function() {
        return this._sendCleanupToScene
    },
    getRunningScene: function() {
        return this._runningScene
    },
    getAnimationInterval: function() {
        return this._animationInterval
    },
    isDisplayStats: function() {
        return cc.profiler ? cc.profiler.isShowingStats() : !1
    },
    setDisplayStats: function(a) {
        cc.profiler && (a ? cc.profiler.showStats() : cc.profiler.hideStats())
    },
    getSecondsPerFrame: function() {
        return this._secondsPerFrame
    },
    isNextDeltaTimeZero: function() {
        return this._nextDeltaTimeZero
    },
    isPaused: function() {
        return this._paused
    },
    getTotalFrames: function() {
        return this._totalFrames
    },
    popToRootScene: function() {
        this.popToSceneStackLevel(1)
    },
    popToSceneStackLevel: function(a) {
        cc.assert(this._runningScene, cc._LogInfos.Director_popToSceneStackLevel_2);
        var b = this._scenesStack,
            c = b.length;
        if (0 === c) this.end();
        else if (!(a > c)) {
            for (; c > a;) {
                var d = b.pop();
                d.running && (d.onExitTransitionDidStart(), d.onExit());
                d.cleanup();
                c--
            }
            this._nextScene =
                b[b.length - 1];
            this._sendCleanupToScene = !1
        }
    },
    getScheduler: function() {
        return this._scheduler
    },
    setScheduler: function(a) {
        this._scheduler !== a && (this._scheduler = a)
    },
    getActionManager: function() {
        return this._actionManager
    },
    setActionManager: function(a) {
        this._actionManager !== a && (this._actionManager = a)
    },
    getDeltaTime: function() {
        return this._deltaTime
    },
    _calculateMPF: function() {
        this._secondsPerFrame = (Date.now() - this._lastUpdate) / 1E3
    }
});
cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
cc.DisplayLinkDirector = cc.Director.extend({
    invalid: !1,
    startAnimation: function() {
        this._nextDeltaTimeZero = !0;
        this.invalid = !1
    },
    mainLoop: function() {
        this._purgeDirectorInNextLoop ? (this._purgeDirectorInNextLoop = !1, this.purgeDirector()) : this.invalid || this.drawScene()
    },
    stopAnimation: function() {
        this.invalid = !0
    },
    setAnimationInterval: function(a) {
        this._animationInterval = a;
        this.invalid || (this.stopAnimation(), this.startAnimation())
    }
});
cc.Director.sharedDirector = null;
cc.Director.firstUseDirector = !0;
cc.Director._getInstance = function() {
    cc.Director.firstUseDirector && (cc.Director.firstUseDirector = !1, cc.Director.sharedDirector = new cc.DisplayLinkDirector, cc.Director.sharedDirector.init());
    return cc.Director.sharedDirector
};
cc.defaultFPS = 60;
cc.Director.PROJECTION_2D = 0;
cc.Director.PROJECTION_3D = 1;
cc.Director.PROJECTION_CUSTOM = 3;
cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_3D;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        var a = cc.Director.prototype;
        a.getProjection = function(a) {
            return this._projection
        };
        a.setProjection = function(a) {
            this._projection = a;
            cc.eventManager.dispatchEvent(this._eventProjectionChanged)
        };
        a.setDepthTest = function() {};
        a.setClearColor = function(a) {
            cc.renderer._clearColor = a;
            cc.renderer._clearFillStyle = "rgb(" + a.r + "," + a.g + "," + a.b + ")"
        };
        a.setOpenGLView = function(a) {
            this._winSizeInPoints.width =
                cc._canvas.width;
            this._winSizeInPoints.height = cc._canvas.height;
            this._openGLView = a || cc.view;
            cc.eventManager && cc.eventManager.setEnabled(!0)
        };
        a.getVisibleSize = function() {
            return this.getWinSize()
        };
        a.getVisibleOrigin = function() {
            return cc.p(0, 0)
        }
    } else cc.Director._fpsImage = new Image, cc.Director._fpsImage.addEventListener("load", function() {
        cc.Director._fpsImageLoaded = !0
    }), cc._fpsImage && (cc.Director._fpsImage.src = cc._fpsImage)
});
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.DirectorDelegate = cc.Class.extend({
            updateProjection: function() {}
        });
        var a = cc.Director.prototype,
            b = function(a) {
                if (a && a._renderCmd) {
                    a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
                    var d = a._children;
                    for (a = 0; a < d.length; a++) b(d[a])
                }
            };
        cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function() {
            for (var a = cc.director._scenesStack, d = 0; d < a.length; d++) b(a[d])
        });
        a.setProjection = function(a) {
            var b = this._winSizeInPoints;
            this.setViewport();
            var e = this._openGLView,
                f = e._viewPortRect.x / e._scaleX,
                g = e._viewPortRect.y / e._scaleY;
            switch (a) {
                case cc.Director.PROJECTION_2D:
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                    cc.kmGLLoadIdentity();
                    e = cc.math.Matrix4.createOrthographicProjection(-f, b.width - f, -g, b.height - g, -1024, 1024);
                    cc.kmGLMultMatrix(e);
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.kmGLLoadIdentity();
                    break;
                case cc.Director.PROJECTION_3D:
                    var h = this.getZEye(),
                        k = new cc.math.Matrix4,
                        e = new cc.math.Matrix4;
                    cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
                    cc.kmGLLoadIdentity();
                    k = cc.math.Matrix4.createPerspectiveProjection(60, b.width / b.height, 0.1, 2 * h);
                    cc.kmGLMultMatrix(k);
                    cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
                    cc.kmGLLoadIdentity();
                    h = new cc.math.Vec3(-f + b.width / 2, -g + b.height / 2, h);
                    b = new cc.math.Vec3(-f + b.width / 2, -g + b.height / 2, 0);
                    f = new cc.math.Vec3(0, 1, 0);
                    e.lookAt(h, b, f);
                    cc.kmGLMultMatrix(e);
                    break;
                case cc.Director.PROJECTION_CUSTOM:
                    this._projectionDelegate && this._projectionDelegate.updateProjection();
                    break;
                default:
                    cc.log(cc._LogInfos.Director_setProjection)
            }
            this._projection = a;
            cc.eventManager.dispatchEvent(this._eventProjectionChanged);
            cc.setProjectionMatrixDirty();
            cc.renderer.childrenOrderDirty = !0
        };
        a.setDepthTest = function(a) {
            cc.renderer.setDepthTest(a)
        };
        a.setClearColor = function(a) {
            cc.renderer._clearColor = a
        };
        a.setOpenGLView = function(a) {
            this._winSizeInPoints.width = cc._canvas.width;
            this._winSizeInPoints.height = cc._canvas.height;
            this._openGLView = a || cc.view;
            a = cc.configuration;
            a.gatherGPUInfo();
            a.dumpInfo();
            this.setGLDefaultValues();
            cc.eventManager && cc.eventManager.setEnabled(!0)
        };
        a._clear = function() {
            var a = cc._renderContext;
            a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
        };
        a._beforeVisitScene = function() {
            cc.kmGLPushMatrix()
        };
        a._afterVisitScene = function() {
            cc.kmGLPopMatrix()
        };
        a.convertToGL = function(a) {
            var b = new cc.math.Matrix4;
            cc.GLToClipTransform(b);
            var e = b.inverse(),
                b = b.mat[14] / b.mat[15],
                f = this._openGLView.getDesignResolutionSize();
            a = new cc.math.Vec3(2 * a.x / f.width - 1, 1 - 2 * a.y / f.height, b);
            a.transformCoord(e);
            return cc.p(a.x, a.y)
        };
        a.convertToUI = function(a) {
            var b = new cc.math.Matrix4;
            cc.GLToClipTransform(b);
            a = new cc.math.Vec3(a.x, a.y, 0);
            a.transformCoord(b);
            b = this._openGLView.getDesignResolutionSize();
            return cc.p(b.width * (0.5 * a.x + 0.5), b.height * (0.5 * -a.y + 0.5))
        };
        a.getVisibleSize = function() {
            return this._openGLView.getVisibleSize()
        };
        a.getVisibleOrigin = function() {
            return this._openGLView.getVisibleOrigin()
        };
        a.getZEye = function() {
            return this._winSizeInPoints.height / 1.1566
        };
        a.setViewport = function() {
            var a = this._openGLView;
            if (a) {
                var b = this._winSizeInPoints;
                a.setViewPortInPoints(-a._viewPortRect.x / a._scaleX, -a._viewPortRect.y / a._scaleY, b.width, b.height)
            }
        };
        a.getOpenGLView = function() {
            return this._openGLView
        };
        a.getProjection = function() {
            return this._projection
        };
        a.setAlphaBlending = function(a) {
            a ? cc.glBlendFunc(cc.BLEND_SRC, cc.BLEND_DST) : cc.glBlendFunc(cc._renderContext.ONE, cc._renderContext.ZERO)
        };
        a.setGLDefaultValues = function() {
            this.setAlphaBlending(!0);
            this.setDepthTest(!1);
            this.setProjection(this._projection);
            cc._renderContext.clearColor(0,
                0, 0, 0)
        }
    }
});
cc.Camera = cc.Class.extend({
    _eyeX: null,
    _eyeY: null,
    _eyeZ: null,
    _centerX: null,
    _centerY: null,
    _centerZ: null,
    _upX: null,
    _upY: null,
    _upZ: null,
    _dirty: !1,
    _lookupMatrix: null,
    ctor: function() {
        this._lookupMatrix = new cc.math.Matrix4;
        this.restore()
    },
    description: function() {
        return "\x3cCCCamera | center \x3d(" + this._centerX + "," + this._centerY + "," + this._centerZ + ")\x3e"
    },
    setDirty: function(a) {
        this._dirty = a
    },
    isDirty: function() {
        return this._dirty
    },
    restore: function() {
        this._eyeX = this._eyeY = 0;
        this._eyeZ = cc.Camera.getZEye();
        this._upX =
            this._centerX = this._centerY = this._centerZ = 0;
        this._upY = 1;
        this._upZ = 0;
        this._lookupMatrix.identity();
        this._dirty = !1
    },
    locate: function() {
        if (this._dirty) {
            var a = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
                b = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ),
                c = new cc.math.Vec3(this._upX, this._upY, this._upZ);
            this._lookupMatrix.lookAt(a, b, c);
            this._dirty = !1
        }
        cc.kmGLMultMatrix(this._lookupMatrix)
    },
    _locateForRenderer: function(a) {
        if (this._dirty) {
            var b = new cc.math.Vec3(this._eyeX, this._eyeY, this._eyeZ),
                c = new cc.math.Vec3(this._centerX, this._centerY, this._centerZ),
                d = new cc.math.Vec3(this._upX, this._upY, this._upZ);
            this._lookupMatrix.lookAt(b, c, d);
            this._dirty = !1
        }
        a.multiply(this._lookupMatrix)
    },
    setEyeXYZ: function(a, b, c) {
        this.setEye(a, b, c)
    },
    setEye: function(a, b, c) {
        this._eyeX = a;
        this._eyeY = b;
        this._eyeZ = c;
        this._dirty = !0
    },
    setCenterXYZ: function(a, b, c) {
        this.setCenter(a, b, c)
    },
    setCenter: function(a, b, c) {
        this._centerX = a;
        this._centerY = b;
        this._centerZ = c;
        this._dirty = !0
    },
    setUpXYZ: function(a, b, c) {
        this.setUp(a, b, c)
    },
    setUp: function(a, b, c) {
        this._upX = a;
        this._upY = b;
        this._upZ = c;
        this._dirty = !0
    },
    getEyeXYZ: function(a, b, c) {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getEye: function() {
        return {
            x: this._eyeX,
            y: this._eyeY,
            z: this._eyeZ
        }
    },
    getCenterXYZ: function(a, b, c) {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getCenter: function() {
        return {
            x: this._centerX,
            y: this._centerY,
            z: this._centerZ
        }
    },
    getUpXYZ: function(a, b, c) {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    getUp: function() {
        return {
            x: this._upX,
            y: this._upY,
            z: this._upZ
        }
    },
    _DISALLOW_COPY_AND_ASSIGN: function(a) {}
});
cc.Camera.getZEye = function() {
    return cc.FLT_EPSILON
};
cc.PRIORITY_NON_SYSTEM = cc.PRIORITY_SYSTEM + 1;
cc.ListEntry = function(a, b, c, d, e, f, g) {
    this.prev = a;
    this.next = b;
    this.callback = c;
    this.target = d;
    this.priority = e;
    this.paused = f;
    this.markedForDeletion = g
};
cc.HashUpdateEntry = function(a, b, c, d, e) {
    this.list = a;
    this.entry = b;
    this.target = c;
    this.callback = d;
    this.hh = e
};
cc.HashTimerEntry = cc.hashSelectorEntry = function(a, b, c, d, e, f, g) {
    this.timers = a;
    this.target = b;
    this.timerIndex = c;
    this.currentTimer = d;
    this.currentTimerSalvaged = e;
    this.paused = f;
    this.hh = g
};
cc.Timer = cc.Class.extend({
    _scheduler: null,
    _elapsed: 0,
    _runForever: !1,
    _useDelay: !1,
    _timesExecuted: 0,
    _repeat: 0,
    _delay: 0,
    _interval: 0,
    getInterval: function() {
        return this._interval
    },
    setInterval: function(a) {
        this._interval = a
    },
    setupTimerWithInterval: function(a, b, c) {
        this._elapsed = -1;
        this._interval = a;
        this._delay = c;
        this._useDelay = 0 < this._delay;
        this._repeat = b;
        this._runForever = this._repeat === cc.REPEAT_FOREVER
    },
    trigger: function() {
        return 0
    },
    cancel: function() {
        return 0
    },
    ctor: function() {
        this._scheduler = null;
        this._elapsed = -1;
        this._useDelay = this._runForever = !1;
        this._interval = this._delay = this._repeat = this._timesExecuted = 0
    },
    update: function(a) {
        -1 === this._elapsed ? this._timesExecuted = this._elapsed = 0 : (this._elapsed += a, this._runForever && !this._useDelay ? this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0) : (this._useDelay ? this._elapsed >= this._delay && (this.trigger(), this._elapsed -= this._delay, this._timesExecuted += 1, this._useDelay = !1) : this._elapsed >= this._interval && (this.trigger(), this._elapsed = 0, this._timesExecuted +=
            1), !this._runForever && this._timesExecuted > this._repeat && this.cancel()))
    }
});
cc.TimerTargetSelector = cc.Timer.extend({
    _target: null,
    _selector: null,
    ctor: function() {
        this._selector = this._target = null
    },
    initWithSelector: function(a, b, c, d, e, f) {
        this._scheduler = a;
        this._target = c;
        this._selector = b;
        this.setupTimerWithInterval(d, e, f);
        return !0
    },
    getSelector: function() {
        return this._selector
    },
    trigger: function() {
        this._target && this._selector && this._target.call(this._selector, this._elapsed)
    },
    cancel: function() {
        this._scheduler.unschedule(this._selector, this._target)
    }
});
cc.TimerTargetCallback = cc.Timer.extend({
    _target: null,
    _callback: null,
    _key: null,
    ctor: function() {
        this._callback = this._target = null
    },
    initWithCallback: function(a, b, c, d, e, f, g) {
        this._scheduler = a;
        this._target = c;
        this._callback = b;
        this._key = d;
        this.setupTimerWithInterval(e, f, g);
        return !0
    },
    getCallback: function() {
        return this._callback
    },
    getKey: function() {
        return this._key
    },
    trigger: function() {
        this._callback && this._callback.call(this._target, this._elapsed)
    },
    cancel: function() {
        this._scheduler.unschedule(this._callback,
            this._target)
    }
});
cc.Scheduler = cc.Class.extend({
    _timeScale: 1,
    _updatesNegList: null,
    _updates0List: null,
    _updatesPosList: null,
    _hashForTimers: null,
    _arrayForTimers: null,
    _hashForUpdates: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _updateHashLocked: !1,
    ctor: function() {
        this._timeScale = 1;
        this._updatesNegList = [];
        this._updates0List = [];
        this._updatesPosList = [];
        this._hashForUpdates = {};
        this._hashForTimers = {};
        this._currentTarget = null;
        this._updateHashLocked = this._currentTargetSalvaged = !1;
        this._arrayForTimers = []
    },
    _schedulePerFrame: function(a,
        b, c, d) {
        var e = this._hashForUpdates[b.__instanceId];
        if (e && e.entry)
            if (e.entry.priority !== c) {
                if (this._updateHashLocked) {
                    cc.log("warning: you CANNOT change update priority in scheduled function");
                    e.entry.markedForDeletion = !1;
                    e.entry.paused = d;
                    return
                }
                this.unscheduleUpdate(b)
            } else {
                e.entry.markedForDeletion = !1;
                e.entry.paused = d;
                return
            }
        0 === c ? this._appendIn(this._updates0List, a, b, d) : 0 > c ? this._priorityIn(this._updatesNegList, a, b, c, d) : this._priorityIn(this._updatesPosList, a, b, c, d)
    },
    _removeHashElement: function(a) {
        delete this._hashForTimers[a.target.__instanceId];
        cc.arrayRemoveObject(this._arrayForTimers, a);
        a.Timer = null;
        a.target = null
    },
    _removeUpdateFromHash: function(a) {
        if (a = this._hashForUpdates[a.target.__instanceId]) cc.arrayRemoveObject(a.list, a.entry), delete this._hashForUpdates[a.target.__instanceId], a.entry = null, a.target = null
    },
    _priorityIn: function(a, b, c, d, e) {
        b = new cc.ListEntry(null, null, b, c, d, e, !1);
        if (a) {
            e = a.length - 1;
            for (var f = 0; f <= e && !(d < a[f].priority); f++);
            a.splice(f, 0, b)
        } else a = [], a.push(b);
        this._hashForUpdates[c.__instanceId] = new cc.HashUpdateEntry(a,
            b, c, null);
        return a
    },
    _appendIn: function(a, b, c, d) {
        b = new cc.ListEntry(null, null, b, c, 0, d, !1);
        a.push(b);
        this._hashForUpdates[c.__instanceId] = new cc.HashUpdateEntry(a, b, c, null, null)
    },
    setTimeScale: function(a) {
        this._timeScale = a
    },
    getTimeScale: function() {
        return this._timeScale
    },
    update: function(a) {
        this._updateHashLocked = !0;
        1 !== this._timeScale && (a *= this._timeScale);
        var b, c, d, e;
        b = 0;
        c = this._updatesNegList;
        for (d = c.length; b < d; b++) e = c[b], e.paused || e.markedForDeletion || e.callback(a);
        b = 0;
        c = this._updates0List;
        for (d =
            c.length; b < d; b++) e = c[b], e.paused || e.markedForDeletion || e.callback(a);
        b = 0;
        c = this._updatesPosList;
        for (d = c.length; b < d; b++) e = c[b], e.paused || e.markedForDeletion || e.callback(a);
        d = this._arrayForTimers;
        for (b = 0; b < d.length; b++) {
            this._currentTarget = c = d[b];
            this._currentTargetSalvaged = !1;
            if (!c.paused)
                for (c.timerIndex = 0; c.timerIndex < c.timers.length; ++c.timerIndex) c.currentTimer = c.timers[c.timerIndex], c.currentTimerSalvaged = !1, c.currentTimer.update(a), c.currentTimer = null;
            this._currentTargetSalvaged && 0 === this._currentTarget.timers.length &&
                this._removeHashElement(this._currentTarget)
        }
        b = 0;
        for (c = this._updatesNegList; b < c.length;) e = c[b], e.markedForDeletion ? this._removeUpdateFromHash(e) : b++;
        b = 0;
        for (c = this._updates0List; b < c.length;) e = c[b], e.markedForDeletion ? this._removeUpdateFromHash(e) : b++;
        b = 0;
        for (c = this._updatesPosList; b < c.length;) e = c[b], e.markedForDeletion ? this._removeUpdateFromHash(e) : b++;
        this._updateHashLocked = !1;
        this._currentTarget = null
    },
    scheduleCallbackForTarget: function(a, b, c, d, e, f) {
        this.schedule(b, a, c, d, e, f, a.__instanceId + "")
    },
    schedule: function(a, b, c, d, e, f, g) {
        var h = !1;
        if ("function" !== typeof a) var k = a,
            h = !0;
        if (!1 === h) {
            if (4 === arguments.length || 5 === arguments.length) g = e, f = d, e = 0, d = cc.REPEAT_FOREVER
        } else 4 === arguments.length && (f = d, d = cc.REPEAT_FOREVER, e = 0);
        void 0 === g && (g = b.__instanceId + "");
        cc.assert(b, cc._LogInfos.Scheduler_scheduleCallbackForTarget_3);
        var m = this._hashForTimers[b.__instanceId];
        m ? cc.assert(m.paused === f, "") : (m = new cc.HashTimerEntry(null, b, 0, null, null, f, null), this._arrayForTimers.push(m), this._hashForTimers[b.__instanceId] =
            m);
        var n, p;
        if (null == m.timers) m.timers = [];
        else if (!1 === h)
            for (p = 0; p < m.timers.length; p++) {
                if (n = m.timers[p], a === n._callback) {
                    cc.log(cc._LogInfos.Scheduler_scheduleCallbackForTarget, n.getInterval().toFixed(4), c.toFixed(4));
                    n._interval = c;
                    return
                }
            } else
                for (p = 0; p < m.timers.length; ++p)
                    if ((n = m.timers[p]) && k === n.getSelector()) {
                        cc.log("CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f", n.getInterval(), c);
                        n.setInterval(c);
                        return
                    }!1 === h ? (n = new cc.TimerTargetCallback, n.initWithCallback(this,
            a, b, g, c, d, e)) : (n = new cc.TimerTargetSelector, n.initWithSelector(this, k, b, c, d, e));
        m.timers.push(n)
    },
    scheduleUpdate: function(a, b, c) {
        this._schedulePerFrame(function(b) {
            a.update(b)
        }, a, b, c)
    },
    _getUnscheduleMark: function(a, b) {
        switch (typeof a) {
            case "number":
            case "string":
                return a === b.getKey();
            case "function":
                return a === b._callback;
            default:
                return a === b.getSelector()
        }
    },
    unschedule: function(a, b) {
        if (b && a) {
            var c = this._hashForTimers[b.__instanceId];
            if (c)
                for (var d = c.timers, e = 0, f = d.length; e < f; e++) {
                    var g = d[e];
                    if (this._getUnscheduleMark(a,
                            g)) {
                        g !== c.currentTimer || c.currentTimerSalvaged || (c.currentTimerSalvaged = !0);
                        d.splice(e, 1);
                        c.timerIndex >= e && c.timerIndex--;
                        0 === d.length && (this._currentTarget === c ? this._currentTargetSalvaged = !0 : this._removeHashElement(c));
                        break
                    }
                }
        }
    },
    unscheduleUpdate: function(a) {
        null != a && (a = this._hashForUpdates[a.__instanceId]) && (this._updateHashLocked ? a.entry.markedForDeletion = !0 : this._removeUpdateFromHash(a.entry))
    },
    unscheduleAllForTarget: function(a) {
        if (null != a) {
            var b = this._hashForTimers[a.__instanceId];
            b && (-1 < b.timers.indexOf(b.currentTimer) &&
                !b.currentTimerSalvaged && (b.currentTimerSalvaged = !0), b.timers.length = 0, this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._removeHashElement(b));
            this.unscheduleUpdate(a)
        }
    },
    unscheduleAll: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllWithMinPriority: function(a) {
        var b, c, d = this._arrayForTimers;
        for (b = d.length - 1; 0 <= b; b--) c = d[b], this.unscheduleAllForTarget(c.target);
        d = 0;
        if (0 > a)
            for (b = 0; b < this._updatesNegList.length;) d = this._updatesNegList.length, (c = this._updatesNegList[b]) &&
                c.priority >= a && this.unscheduleUpdate(c.target), d == this._updatesNegList.length && b++;
        if (0 >= a)
            for (b = 0; b < this._updates0List.length;) d = this._updates0List.length, (c = this._updates0List[b]) && this.unscheduleUpdate(c.target), d == this._updates0List.length && b++;
        for (b = 0; b < this._updatesPosList.length;) d = this._updatesPosList.length, (c = this._updatesPosList[b]) && c.priority >= a && this.unscheduleUpdate(c.target), d == this._updatesPosList.length && b++
    },
    isScheduled: function(a, b) {
        cc.assert(a, "Argument key must not be empty");
        cc.assert(b, "Argument target must be non-nullptr");
        var c = this._hashForUpdates[b.__instanceId];
        if (!c) return !1;
        if (null != c.timers)
            for (var c = c.timers, d = 0; d < c.length; ++d)
                if (a === c[d].getKey()) return !0;
        return !1
    },
    pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    pauseAllTargetsWithMinPriority: function(a) {
        var b = [],
            c, d = this._arrayForTimers,
            e, f;
        e = 0;
        for (f = d.length; e < f; e++)
            if (c = d[e]) c.paused = !0, b.push(c.target);
        if (0 > a)
            for (e = 0; e < this._updatesNegList.length; e++)(c =
                this._updatesNegList[e]) && c.priority >= a && (c.paused = !0, b.push(c.target));
        if (0 >= a)
            for (e = 0; e < this._updates0List.length; e++)
                if (c = this._updates0List[e]) c.paused = !0, b.push(c.target);
        for (e = 0; e < this._updatesPosList.length; e++)(c = this._updatesPosList[e]) && c.priority >= a && (c.paused = !0, b.push(c.target));
        return b
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) this.resumeTarget(a[b])
    },
    pauseTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_pauseTarget);
        var b = this._hashForTimers[a.__instanceId];
        b &&
            (b.paused = !0);
        (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !0)
    },
    resumeTarget: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_resumeTarget);
        var b = this._hashForTimers[a.__instanceId];
        b && (b.paused = !1);
        (a = this._hashForUpdates[a.__instanceId]) && (a.entry.paused = !1)
    },
    isTargetPaused: function(a) {
        cc.assert(a, cc._LogInfos.Scheduler_isTargetPaused);
        var b = this._hashForTimers[a.__instanceId];
        return b ? b.paused : (a = this._hashForUpdates[a.__instanceId]) ? a.entry.paused : !1
    },
    scheduleUpdateForTarget: function(a,
        b, c) {
        this.scheduleUpdate(a, b, c)
    },
    unscheduleCallbackForTarget: function(a, b) {
        this.unschedule(b, a)
    },
    unscheduleUpdateForTarget: function(a) {
        this.unscheduleUpdate(a)
    },
    unscheduleAllCallbacksForTarget: function(a) {
        this.unschedule(a.__instanceId + "", a)
    },
    unscheduleAllCallbacks: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM)
    },
    unscheduleAllCallbacksWithMinPriority: function(a) {
        this.unscheduleAllWithMinPriority(a)
    }
});
cc.Scheduler.PRIORITY_SYSTEM = -2147483648;
cc.PI2 = 2 * Math.PI;
cc.DrawingPrimitiveCanvas = cc.Class.extend({
    _cacheArray: [],
    _renderContext: null,
    ctor: function(a) {
        this._renderContext = a
    },
    drawPoint: function(a, b) {
        b || (b = 1);
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY(),
            d = cc.p(a.x * c, a.y * d),
            e = this._renderContext.getContext();
        e.beginPath();
        e.arc(d.x, -d.y, b * c, 0, 2 * Math.PI, !1);
        e.closePath();
        e.fill()
    },
    drawPoints: function(a, b, c) {
        if (null != a) {
            c || (c = 1);
            b = this._renderContext.getContext();
            var d = cc.view.getScaleX(),
                e = cc.view.getScaleY();
            b.beginPath();
            for (var f = 0, g = a.length; f < g; f++) b.arc(a[f].x *
                d, -a[f].y * e, c * d, 0, 2 * Math.PI, !1);
            b.closePath();
            b.fill()
        }
    },
    drawLine: function(a, b) {
        var c = this._renderContext.getContext(),
            d = cc.view.getScaleX(),
            e = cc.view.getScaleY();
        c.beginPath();
        c.moveTo(a.x * d, -a.y * e);
        c.lineTo(b.x * d, -b.y * e);
        c.closePath();
        c.stroke()
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, c) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x,
            b.y)];
        this.drawSolidPoly(a, 4, c)
    },
    drawPoly: function(a, b, c, d) {
        d = d || !1;
        if (null != a) {
            if (3 > a.length) throw Error("Polygon's point must greater than 2");
            var e = a[0];
            b = this._renderContext.getContext();
            var f = cc.view.getScaleX(),
                g = cc.view.getScaleY();
            b.beginPath();
            b.moveTo(e.x * f, -e.y * g);
            for (var e = 1, h = a.length; e < h; e++) b.lineTo(a[e].x * f, -a[e].y * g);
            c && b.closePath();
            d ? b.fill() : b.stroke()
        }
    },
    drawSolidPoly: function(a, b, c) {
        this.setDrawColor(c.r, c.g, c.b, c.a);
        this.drawPoly(a, b, !0, !0)
    },
    drawCircle: function(a, b, c, d, e) {
        e =
            e || !1;
        d = this._renderContext.getContext();
        var f = cc.view.getScaleX(),
            g = cc.view.getScaleY();
        d.beginPath();
        d.arc(0 | a.x * f, 0 | -(a.y * g), b * f, -c, -(c - 2 * Math.PI), !1);
        e && d.lineTo(0 | a.x * f, 0 | -(a.y * g));
        d.stroke()
    },
    drawQuadBezier: function(a, b, c, d) {
        for (var e = this._cacheArray, f = e.length = 0, g = 0; g < d; g++) {
            var h = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x,
                k = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y;
            e.push(cc.p(h, k));
            f += 1 / d
        }
        e.push(cc.p(c.x, c.y));
        this.drawPoly(e, d + 1, !1, !1)
    },
    drawCubicBezier: function(a, b, c, d, e) {
        for (var f = this._cacheArray,
                g = f.length = 0, h = 0; h < e; h++) {
            var k = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x,
                m = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 - g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y;
            f.push(cc.p(k, m));
            g += 1 / e
        }
        f.push(cc.p(d.x, d.y));
        this.drawPoly(f, e + 1, !1, !1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function(a, b, c) {
        cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
        var d = this._cacheArray;
        d.length = 0;
        for (var e, f, g = 1 / a.length, h = 0; h < c + 1; h++) f = h / c, 1 === f ? (e = a.length - 1,
            f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.CardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e - 0), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d.push(e);
        this.drawPoly(d, c + 1, !1, !1)
    },
    drawImage: function(a, b, c, d, e) {
        var f = arguments.length,
            g = this._renderContext.getContext();
        switch (f) {
            case 2:
                g.drawImage(a, b.x, -(b.y + a.height));
                break;
            case 3:
                g.drawImage(a, b.x, -(b.y + c.height), c.width, c.height);
                break;
            case 5:
                g.drawImage(a, b.x, b.y, c.width, c.height, d.x, -(d.y + e.height), e.width, e.height);
                break;
            default:
                throw Error("Argument must be non-nil");
        }
    },
    drawStar: function(a, b, c) {
        a = a || this._renderContext;
        var d = a.getContext();
        b *= cc.view.getScaleX();
        c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
        a.setFillStyle(c + ",1)");
        var e = b / 10;
        d.beginPath();
        d.moveTo(-b, b);
        d.lineTo(0, e);
        d.lineTo(b, b);
        d.lineTo(e, 0);
        d.lineTo(b, -b);
        d.lineTo(0, -e);
        d.lineTo(-b, -b);
        d.lineTo(-e, 0);
        d.lineTo(-b, b);
        d.closePath();
        d.fill();
        var f = d.createRadialGradient(0, 0, e, 0, 0, b);
        f.addColorStop(0, c + ", 1)");
        f.addColorStop(0.3, c + ", 0.8)");
        f.addColorStop(1,
            c + ", 0.0)");
        a.setFillStyle(f);
        d.beginPath();
        d.arc(0, 0, b - e, 0, cc.PI2, !1);
        d.closePath();
        d.fill()
    },
    drawColorBall: function(a, b, c) {
        a = a || this._renderContext;
        var d = a.getContext();
        b *= cc.view.getScaleX();
        c = "rgba(" + (0 | c.r) + "," + (0 | c.g) + "," + (0 | c.b);
        var e = d.createRadialGradient(0, 0, b / 10, 0, 0, b);
        e.addColorStop(0, c + ", 1)");
        e.addColorStop(0.3, c + ", 0.8)");
        e.addColorStop(0.6, c + ", 0.4)");
        e.addColorStop(1, c + ", 0.0)");
        a.setFillStyle(e);
        d.beginPath();
        d.arc(0, 0, b, 0, cc.PI2, !1);
        d.closePath();
        d.fill()
    },
    fillText: function(a, b,
        c) {
        this._renderContext.getContext().fillText(a, b, -c)
    },
    setDrawColor: function(a, b, c, d) {
        this._renderContext.setFillStyle("rgba(" + a + "," + b + "," + c + "," + d / 255 + ")");
        this._renderContext.setStrokeStyle("rgba(" + a + "," + b + "," + c + "," + d / 255 + ")")
    },
    setPointSize: function(a) {},
    setLineWidth: function(a) {
        this._renderContext.getContext().lineWidth = a * cc.view.getScaleX()
    }
});
cc.DrawingPrimitiveWebGL = cc.Class.extend({
    _renderContext: null,
    _initialized: !1,
    _shader: null,
    _colorLocation: -1,
    _colorArray: null,
    _pointSizeLocation: -1,
    _pointSize: -1,
    ctor: function(a) {
        null == a && (a = cc._renderContext);
        if (!a instanceof WebGLRenderingContext) throw Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
        this._renderContext = a;
        this._colorArray = new Float32Array([1, 1, 1, 1])
    },
    lazy_init: function() {
        this._initialized || (this._shader = cc.shaderCache.programForKey(cc.SHADER_POSITION_UCOLOR),
            this._colorLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_color"), this._pointSizeLocation = this._renderContext.getUniformLocation(this._shader.getProgram(), "u_pointSize"), this._initialized = !0)
    },
    drawInit: function() {
        this._initialized = !1
    },
    drawPoint: function(a) {
        this.lazy_init();
        var b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation,
            this._colorArray);
        this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
        var c = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, c);
        b.bufferData(b.ARRAY_BUFFER, new Float32Array([a.x, a.y]), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.POINTS, 0, 1);
        b.deleteBuffer(c);
        cc.incrementGLDraws(1)
    },
    drawPoints: function(a, b) {
        if (a && 0 !== a.length) {
            this.lazy_init();
            var c = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            c.uniform4fv(this._colorLocation, this._colorArray);
            this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
            var d = c.createBuffer();
            c.bindBuffer(c.ARRAY_BUFFER, d);
            c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray(a), c.STATIC_DRAW);
            c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, c.FLOAT, !1, 0, 0);
            c.drawArrays(c.POINTS, 0, a.length);
            c.deleteBuffer(d);
            cc.incrementGLDraws(1)
        }
    },
    _pointsToTypeArray: function(a) {
        for (var b = new Float32Array(2 *
                a.length), c = 0; c < a.length; c++) b[2 * c] = a[c].x, b[2 * c + 1] = a[c].y;
        return b
    },
    drawLine: function(a, b) {
        this.lazy_init();
        var c = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        c.uniform4fv(this._colorLocation, this._colorArray);
        var d = c.createBuffer();
        c.bindBuffer(c.ARRAY_BUFFER, d);
        c.bufferData(c.ARRAY_BUFFER, this._pointsToTypeArray([a, b]), c.STATIC_DRAW);
        c.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
            2, c.FLOAT, !1, 0, 0);
        c.drawArrays(c.LINES, 0, 2);
        c.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawRect: function(a, b) {
        this.drawLine(cc.p(a.x, a.y), cc.p(b.x, a.y));
        this.drawLine(cc.p(b.x, a.y), cc.p(b.x, b.y));
        this.drawLine(cc.p(b.x, b.y), cc.p(a.x, b.y));
        this.drawLine(cc.p(a.x, b.y), cc.p(a.x, a.y))
    },
    drawSolidRect: function(a, b, c) {
        a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
        this.drawSolidPoly(a, 4, c)
    },
    drawPoly: function(a, b, c) {
        this.lazy_init();
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation, this._colorArray);
        var d = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, d);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        c ? b.drawArrays(b.LINE_LOOP, 0, a.length) : b.drawArrays(b.LINE_STRIP, 0, a.length);
        b.deleteBuffer(d);
        cc.incrementGLDraws(1)
    },
    drawSolidPoly: function(a, b, c) {
        this.lazy_init();
        c && this.setDrawColor(c.r, c.g, c.b, c.a);
        b = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        b.uniform4fv(this._colorLocation, this._colorArray);
        c = b.createBuffer();
        b.bindBuffer(b.ARRAY_BUFFER, c);
        b.bufferData(b.ARRAY_BUFFER, this._pointsToTypeArray(a), b.STATIC_DRAW);
        b.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, b.FLOAT, !1, 0, 0);
        b.drawArrays(b.TRIANGLE_FAN, 0, a.length);
        b.deleteBuffer(c);
        cc.incrementGLDraws(1)
    },
    drawCircle: function(a,
        b, c, d, e) {
        this.lazy_init();
        var f = 1;
        e && f++;
        var g = 2 * Math.PI / d;
        if (e = new Float32Array(2 * (d + 2))) {
            for (var h = 0; h <= d; h++) {
                var k = h * g,
                    m = b * Math.cos(k + c) + a.x,
                    k = b * Math.sin(k + c) + a.y;
                e[2 * h] = m;
                e[2 * h + 1] = k
            }
            e[2 * (d + 1)] = a.x;
            e[2 * (d + 1) + 1] = a.y;
            a = this._renderContext;
            this._shader.use();
            this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
            a.uniform4fv(this._colorLocation, this._colorArray);
            b = a.createBuffer();
            a.bindBuffer(a.ARRAY_BUFFER, b);
            a.bufferData(a.ARRAY_BUFFER,
                e, a.STATIC_DRAW);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
            a.drawArrays(a.LINE_STRIP, 0, d + f);
            a.deleteBuffer(b);
            cc.incrementGLDraws(1)
        }
    },
    drawQuadBezier: function(a, b, c, d) {
        this.lazy_init();
        for (var e = new Float32Array(2 * (d + 1)), f = 0, g = 0; g < d; g++) e[2 * g] = Math.pow(1 - f, 2) * a.x + 2 * (1 - f) * f * b.x + f * f * c.x, e[2 * g + 1] = Math.pow(1 - f, 2) * a.y + 2 * (1 - f) * f * b.y + f * f * c.y, f += 1 / d;
        e[2 * d] = c.x;
        e[2 * d + 1] = c.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, e, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, d + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    drawCubicBezier: function(a, b, c, d, e) {
        this.lazy_init();
        for (var f = new Float32Array(2 * (e + 1)), g = 0, h = 0; h < e; h++) f[2 * h] = Math.pow(1 - g, 3) * a.x + 3 * Math.pow(1 - g, 2) * g * b.x + 3 * (1 - g) * g * g * c.x + g * g * g * d.x, f[2 * h + 1] = Math.pow(1 - g, 3) * a.y + 3 * Math.pow(1 -
            g, 2) * g * b.y + 3 * (1 - g) * g * g * c.y + g * g * g * d.y, g += 1 / e;
        f[2 * e] = d.x;
        f[2 * e + 1] = d.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, f, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, e + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    drawCatmullRom: function(a, b) {
        this.drawCardinalSpline(a, 0.5, b)
    },
    drawCardinalSpline: function(a, b, c) {
        this.lazy_init();
        for (var d = new Float32Array(2 * (c + 1)), e, f, g = 1 / a.length, h = 0; h < c + 1; h++) f = h / c, 1 === f ? (e = a.length - 1, f = 1) : (e = 0 | f / g, f = (f - g * e) / g), e = cc.cardinalSplineAt(cc.getControlPointAt(a, e - 1), cc.getControlPointAt(a, e), cc.getControlPointAt(a, e + 1), cc.getControlPointAt(a, e + 2), b, f), d[2 * h] = e.x, d[2 * h + 1] = e.y;
        a = this._renderContext;
        this._shader.use();
        this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION);
        a.uniform4fv(this._colorLocation, this._colorArray);
        b = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, b);
        a.bufferData(a.ARRAY_BUFFER, d, a.STATIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, 0, 0);
        a.drawArrays(a.LINE_STRIP, 0, c + 1);
        a.deleteBuffer(b);
        cc.incrementGLDraws(1)
    },
    setDrawColor: function(a, b, c, d) {
        this._colorArray[0] = a / 255;
        this._colorArray[1] = b / 255;
        this._colorArray[2] = c / 255;
        this._colorArray[3] = d / 255
    },
    setPointSize: function(a) {
        this._pointSize =
            a * cc.contentScaleFactor()
    },
    setLineWidth: function(a) {
        this._renderContext.lineWidth && this._renderContext.lineWidth(a)
    }
});
cc._tmp.PrototypeLabelTTF = function() {
    var a = cc.LabelTTF.prototype;
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "string", a.getString, a.setString);
    cc.defineGetterSetter(a, "textAlign", a.getHorizontalAlignment, a.setHorizontalAlignment);
    cc.defineGetterSetter(a, "verticalAlign", a.getVerticalAlignment, a.setVerticalAlignment);
    cc.defineGetterSetter(a, "fontSize", a.getFontSize, a.setFontSize);
    cc.defineGetterSetter(a,
        "fontName", a.getFontName, a.setFontName);
    cc.defineGetterSetter(a, "font", a._getFont, a._setFont);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a._setBoundingWidth);
    cc.defineGetterSetter(a, "boundingHeight", a._getBoundingHeight, a._setBoundingHeight);
    cc.defineGetterSetter(a, "fillStyle", a._getFillStyle, a.setFontFillColor);
    cc.defineGetterSetter(a, "strokeStyle", a._getStrokeStyle, a._setStrokeStyle);
    cc.defineGetterSetter(a, "lineWidth", a._getLineWidth, a._setLineWidth);
    cc.defineGetterSetter(a, "shadowOffsetX",
        a._getShadowOffsetX, a._setShadowOffsetX);
    cc.defineGetterSetter(a, "shadowOffsetY", a._getShadowOffsetY, a._setShadowOffsetY);
    cc.defineGetterSetter(a, "shadowOpacity", a._getShadowOpacity, a._setShadowOpacity);
    cc.defineGetterSetter(a, "shadowBlur", a._getShadowBlur, a._setShadowBlur)
};
cc.LabelTTF = cc.Sprite.extend({
    _dimensions: null,
    _hAlignment: cc.TEXT_ALIGNMENT_CENTER,
    _vAlignment: cc.VERTICAL_TEXT_ALIGNMENT_TOP,
    _fontName: null,
    _fontSize: 0,
    _string: "",
    _originalText: null,
    _onCacheCanvasMode: !0,
    _shadowEnabled: !1,
    _shadowOffset: null,
    _shadowOpacity: 0,
    _shadowBlur: 0,
    _shadowColor: null,
    _strokeEnabled: !1,
    _strokeColor: null,
    _strokeSize: 0,
    _textFillColor: null,
    _strokeShadowOffsetX: 0,
    _strokeShadowOffsetY: 0,
    _needUpdateTexture: !1,
    _lineWidths: null,
    _className: "LabelTTF",
    _fontStyle: "normal",
    _fontWeight: "normal",
    _lineHeight: "normal",
    initWithString: function(a, b, c, d, e, f) {
        a = a ? a + "" : "";
        c = c || 16;
        d = d || cc.size(0, 0);
        e = e || cc.TEXT_ALIGNMENT_LEFT;
        f = f || cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._dimensions = cc.size(d.width, d.height);
        this._fontName = b || "Arial";
        this._hAlignment = e;
        this._vAlignment = f;
        this._fontSize = c;
        this._renderCmd._setFontStyle(this._fontName, c, this._fontStyle, this._fontWeight);
        this.string = a;
        this._renderCmd._setColorsString();
        this._renderCmd._updateTexture();
        this._setUpdateTextureDirty();
        return !0
    },
    _setUpdateTextureDirty: function() {
        this._needUpdateTexture = !0;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.textDirty)
    },
    ctor: function(a, b, c, d, e, f) {
        cc.Sprite.prototype.ctor.call(this);
        this._dimensions = cc.size(0, 0);
        this._hAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._vAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP;
        this._opacityModifyRGB = !1;
        this._fontName = "Arial";
        this._shadowEnabled = !1;
        this._shadowOffset = cc.p(0, 0);
        this._shadowBlur = this._shadowOpacity = 0;
        this._strokeEnabled = !1;
        this._strokeColor = cc.color(255,
            255, 255, 255);
        this._strokeSize = 0;
        this._textFillColor = cc.color(255, 255, 255, 255);
        this._strokeShadowOffsetY = this._strokeShadowOffsetX = 0;
        this._needUpdateTexture = !1;
        this._lineWidths = [];
        this._renderCmd._setColorsString();
        this._textureLoaded = !0;
        b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, b) : cc.LabelTTF.prototype.initWithString.call(this, a, b, c, d, e, f)
    },
    init: function() {
        return this.initWithString(" ", this._fontName, this._fontSize)
    },
    description: function() {
        return "\x3ccc.LabelTTF | FontName \x3d" +
            this._fontName + " FontSize \x3d " + this._fontSize.toFixed(1) + "\x3e"
    },
    getLineHeight: function() {
        return !this._lineHeight || this._lineHeight.charAt ? this._renderCmd._getFontClientHeight() : this._lineHeight || this._renderCmd._getFontClientHeight()
    },
    setLineHeight: function(a) {
        this._lineHeight = a
    },
    getString: function() {
        return this._string
    },
    getHorizontalAlignment: function() {
        return this._hAlignment
    },
    getVerticalAlignment: function() {
        return this._vAlignment
    },
    getDimensions: function() {
        return cc.size(this._dimensions)
    },
    getFontSize: function() {
        return this._fontSize
    },
    getFontName: function() {
        return this._fontName
    },
    initWithStringAndTextDefinition: function(a, b) {
        this._updateWithTextDefinition(b, !1);
        this.string = a;
        return !0
    },
    setTextDefinition: function(a) {
        a && this._updateWithTextDefinition(a, !0)
    },
    getTextDefinition: function() {
        return this._prepareTextDefinition(!1)
    },
    enableShadow: function(a, b, c, d) {
        null != a.r && null != a.g && null != a.b && null != a.a ? this._enableShadow(a, b, c) : this._enableShadowNoneColor(a, b, c, d)
    },
    _enableShadowNoneColor: function(a,
        b, c, d) {
        c = c || 0.5;
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        var e = this._shadowOffset;
        if (e && e.x !== a || e._y !== b) e.x = a, e.y = b;
        this._shadowOpacity !== c && (this._shadowOpacity = c);
        this._renderCmd._setColorsString();
        this._shadowBlur !== d && (this._shadowBlur = d);
        this._setUpdateTextureDirty()
    },
    _enableShadow: function(a, b, c) {
        this._shadowColor || (this._shadowColor = cc.color(255, 255, 255, 128));
        this._shadowColor.r = a.r;
        this._shadowColor.g = a.g;
        this._shadowColor.b = a.b;
        this._enableShadowNoneColor(b.width || b.x || 0, b.height ||
            b.y || 0, null != a.a ? a.a / 255 : 0.5, c)
    },
    _getShadowOffsetX: function() {
        return this._shadowOffset.x
    },
    _setShadowOffsetX: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset.x !== a && (this._shadowOffset.x = a, this._setUpdateTextureDirty())
    },
    _getShadowOffsetY: function() {
        return this._shadowOffset._y
    },
    _setShadowOffsetY: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOffset._y !== a && (this._shadowOffset._y = a, this._setUpdateTextureDirty())
    },
    _getShadowOffset: function() {
        return cc.p(this._shadowOffset.x,
            this._shadowOffset.y)
    },
    _setShadowOffset: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        if (this._shadowOffset.x !== a.x || this._shadowOffset.y !== a.y) this._shadowOffset.x = a.x, this._shadowOffset.y = a.y, this._setUpdateTextureDirty()
    },
    _getShadowOpacity: function() {
        return this._shadowOpacity
    },
    _setShadowOpacity: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowOpacity !== a && (this._shadowOpacity = a, this._renderCmd._setColorsString(), this._setUpdateTextureDirty())
    },
    _getShadowBlur: function() {
        return this._shadowBlur
    },
    _setShadowBlur: function(a) {
        !1 === this._shadowEnabled && (this._shadowEnabled = !0);
        this._shadowBlur !== a && (this._shadowBlur = a, this._setUpdateTextureDirty())
    },
    disableShadow: function() {
        this._shadowEnabled && (this._shadowEnabled = !1, this._setUpdateTextureDirty())
    },
    enableStroke: function(a, b) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var c = this._strokeColor;
        if (c.r !== a.r || c.g !== a.g || c.b !== a.b) c.r = a.r, c.g = a.g, c.b = a.b, this._renderCmd._setColorsString();
        this._strokeSize !== b && (this._strokeSize = b || 0);
        this._setUpdateTextureDirty()
    },
    _getStrokeStyle: function() {
        return this._strokeColor
    },
    _setStrokeStyle: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        var b = this._strokeColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._setUpdateTextureDirty()
    },
    _getLineWidth: function() {
        return this._strokeSize
    },
    _setLineWidth: function(a) {
        !1 === this._strokeEnabled && (this._strokeEnabled = !0);
        this._strokeSize !== a && (this._strokeSize = a || 0, this._setUpdateTextureDirty())
    },
    disableStroke: function() {
        this._strokeEnabled &&
            (this._strokeEnabled = !1, this._setUpdateTextureDirty())
    },
    setFontFillColor: function(a) {
        var b = this._textFillColor;
        if (b.r !== a.r || b.g !== a.g || b.b !== a.b) b.r = a.r, b.g = a.g, b.b = a.b, this._renderCmd._setColorsString(), this._needUpdateTexture = !0
    },
    _getFillStyle: function() {
        return this._textFillColor
    },
    _updateWithTextDefinition: function(a, b) {
        a.fontDimensions ? (this._dimensions.width = a.boundingWidth, this._dimensions.height = a.boundingHeight) : (this._dimensions.width = 0, this._dimensions.height = 0);
        this._hAlignment = a.textAlign;
        this._vAlignment = a.verticalAlign;
        this._fontName = a.fontName;
        this._fontSize = a.fontSize || 12;
        this._lineHeight = a.lineHeight ? a.lineHeight : this._fontSize;
        this._renderCmd._setFontStyle(a);
        a.shadowEnabled && this.enableShadow(a.shadowOffsetX, a.shadowOffsetY, a.shadowOpacity, a.shadowBlur);
        a.strokeEnabled && this.enableStroke(a.strokeStyle, a.lineWidth);
        this.setFontFillColor(a.fillStyle);
        b && this._renderCmd._updateTexture();
        var c = cc.Node._dirtyFlags;
        this._renderCmd.setDirtyFlag(c.colorDirty | c.opacityDirty | c.textDirty)
    },
    _prepareTextDefinition: function(a) {
        var b = new cc.FontDefinition;
        a ? (b.fontSize = this._fontSize, b.boundingWidth = cc.contentScaleFactor() * this._dimensions.width, b.boundingHeight = cc.contentScaleFactor() * this._dimensions.height) : (b.fontSize = this._fontSize, b.boundingWidth = this._dimensions.width, b.boundingHeight = this._dimensions.height);
        b.fontName = this._fontName;
        b.textAlign = this._hAlignment;
        b.verticalAlign = this._vAlignment;
        if (this._strokeEnabled) {
            b.strokeEnabled = !0;
            var c = this._strokeColor;
            b.strokeStyle = cc.color(c.r,
                c.g, c.b);
            b.lineWidth = this._strokeSize
        } else b.strokeEnabled = !1;
        this._shadowEnabled ? (b.shadowEnabled = !0, b.shadowBlur = this._shadowBlur, b.shadowOpacity = this._shadowOpacity, b.shadowOffsetX = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.x, b.shadowOffsetY = (a ? cc.contentScaleFactor() : 1) * this._shadowOffset.y) : b._shadowEnabled = !1;
        a = this._textFillColor;
        b.fillStyle = cc.color(a.r, a.g, a.b);
        return b
    },
    setString: function(a) {
        a = String(a);
        this._originalText !== a && (this._originalText = a + "", this._updateString(), this._setUpdateTextureDirty(),
            this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty))
    },
    _updateString: function() {
        this._string && "" !== this._string || this._string === this._originalText || (cc.renderer.childrenOrderDirty = !0);
        this._string = this._originalText
    },
    setHorizontalAlignment: function(a) {
        a !== this._hAlignment && (this._hAlignment = a, this._setUpdateTextureDirty())
    },
    setVerticalAlignment: function(a) {
        a !== this._vAlignment && (this._vAlignment = a, this._setUpdateTextureDirty())
    },
    setDimensions: function(a, b) {
        var c;
        void 0 === b ? (c = a.width,
            b = a.height) : c = a;
        if (c !== this._dimensions.width || b !== this._dimensions.height) this._dimensions.width = c, this._dimensions.height = b, this._updateString(), this._setUpdateTextureDirty()
    },
    _getBoundingWidth: function() {
        return this._dimensions.width
    },
    _setBoundingWidth: function(a) {
        a !== this._dimensions.width && (this._dimensions.width = a, this._updateString(), this._setUpdateTextureDirty())
    },
    _getBoundingHeight: function() {
        return this._dimensions.height
    },
    _setBoundingHeight: function(a) {
        a !== this._dimensions.height && (this._dimensions.height =
            a, this._updateString(), this._setUpdateTextureDirty())
    },
    setFontSize: function(a) {
        this._fontSize !== a && (this._fontSize = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    setFontName: function(a) {
        this._fontName && this._fontName !== a && (this._fontName = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFont: function() {
        return this._renderCmd._getFontStyle()
    },
    _setFont: function(a) {
        if (a = cc.LabelTTF._fontStyleRE.exec(a)) this._fontSize = parseInt(a[1]), this._fontName = a[2], this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty()
    },
    getContentSize: function() {
        this._needUpdateTexture && this._renderCmd._updateTTF();
        return cc.Sprite.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        this._needUpdateTexture && this._renderCmd._updateTTF();
        return cc.Sprite.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        this._needUpdateTexture &&
            this._renderCmd._updateTTF();
        return cc.Sprite.prototype._getHeight.call(this)
    },
    setTextureRect: function(a, b, c) {
        cc.Sprite.prototype.setTextureRect.call(this, a, b, c, !1)
    },
    setDrawMode: function(a) {
        this._onCacheCanvasMode = a
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelTTF.WebGLRenderCmd(this) : this._onCacheCanvasMode ? new cc.LabelTTF.CacheCanvasRenderCmd(this) : new cc.LabelTTF.CanvasRenderCmd(this)
    },
    _setFontStyle: function(a) {
        this._fontStyle !== a && (this._fontStyle =
            a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFontStyle: function() {
        return this._fontStyle
    },
    _setFontWeight: function(a) {
        this._fontWeight !== a && (this._fontWeight = a, this._renderCmd._setFontStyle(this._fontName, this._fontSize, this._fontStyle, this._fontWeight), this._setUpdateTextureDirty())
    },
    _getFontWeight: function() {
        return this._fontWeight
    }
});
cc.assert(cc.isFunction(cc._tmp.PrototypeLabelTTF), cc._LogInfos.MissingFile, "LabelTTFPropertyDefine.js");
cc._tmp.PrototypeLabelTTF();
delete cc._tmp.PrototypeLabelTTF;
cc.LabelTTF._fontStyleRE = /^(\d+)px\s+['"]?([\w\s\d]+)['"]?$/;
cc.LabelTTF.create = function(a, b, c, d, e, f) {
    return new cc.LabelTTF(a, b, c, d, e, f)
};
cc.LabelTTF.createWithFontDefinition = cc.LabelTTF.create;
cc.LabelTTF._SHADER_PROGRAM = cc.USE_LA88_LABELS ? cc.SHADER_POSITION_TEXTURECOLOR : cc.SHADER_POSITION_TEXTUREA8COLOR;
cc.LabelTTF.__labelHeightDiv = document.createElement("div");
cc.LabelTTF.__labelHeightDiv.style.fontFamily = "Arial";
cc.LabelTTF.__labelHeightDiv.style.position = "absolute";
cc.LabelTTF.__labelHeightDiv.style.left = "-100px";
cc.LabelTTF.__labelHeightDiv.style.top = "-100px";
cc.LabelTTF.__labelHeightDiv.style.lineHeight = "normal";
document.body ? document.body.appendChild(cc.LabelTTF.__labelHeightDiv) : window.addEventListener("load", function() {
    this.removeEventListener("load", arguments.callee, !1);
    document.body.appendChild(cc.LabelTTF.__labelHeightDiv)
}, !1);
cc.LabelTTF.__getFontHeightByDiv = function(a, b) {
    if (a instanceof cc.FontDefinition) {
        var c = cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()];
        if (0 < c) return c;
        var d = cc.LabelTTF.__labelHeightDiv;
        d.innerHTML = "ajghl~!";
        d.style.fontFamily = a.fontName;
        d.style.fontSize = a.fontSize + "px";
        d.style.fontStyle = a.fontStyle;
        d.style.fontWeight = a.fontWeight;
        c = d.clientHeight;
        cc.LabelTTF.__fontHeightCache[a._getCanvasFontStr()] = c;
        d.innerHTML = "";
        return c
    }
    c = cc.LabelTTF.__fontHeightCache[a + "." + b];
    if (0 < c) return c;
    d = cc.LabelTTF.__labelHeightDiv;
    d.innerHTML = "ajghl~!";
    d.style.fontFamily = a;
    d.style.fontSize = b + "px";
    c = d.clientHeight;
    cc.LabelTTF.__fontHeightCache[a + "." + b] = c;
    d.innerHTML = "";
    return c
};
cc.LabelTTF.__fontHeightCache = {};
cc.LabelTTF._textAlign = ["left", "center", "right"];
cc.LabelTTF._textBaseline = ["top", "middle", "bottom"];
cc.LabelTTF.wrapInspection = !0;
cc.LabelTTF._wordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)/;
cc.LabelTTF._symbolRex = /^[!,.:;}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/;
cc.LabelTTF._lastWordRex = /([a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+|\S)$/;
cc.LabelTTF._lastEnglish = /[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]+$/;
cc.LabelTTF._firsrEnglish = /^[a-zA-Z0-9\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00e9\u00e8\u00e7\u00e0\u00f9\u00ea\u00e2\u00ee\u00f4\u00fb]/;
(function() {
    cc.LabelTTF.RenderCmd = function() {
        this._fontClientHeight = 18;
        this._fontStyleStr = "";
        this._shadowColorStr = "rgba(128, 128, 128, 0.5)";
        this._strokeColorStr = "";
        this._fillColorStr = "rgba(255,255,255,1)";
        this._labelContext = this._labelCanvas = null;
        this._lineWidths = [];
        this._strings = [];
        this._isMultiLine = !1;
        this._status = [];
        this._renderingIndex = 0
    };
    var a = cc.LabelTTF.RenderCmd.prototype;
    a.constructor = cc.LabelTTF.RenderCmd;
    a._setFontStyle = function(a, c, d, e) {
        a instanceof cc.FontDefinition ? (this._fontStyleStr =
            a._getCanvasFontStr(), this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a)) : (this._fontStyleStr = d + " " + e + " " + c + "px '" + a + "'", this._fontClientHeight = cc.LabelTTF.__getFontHeightByDiv(a, c))
    };
    a._getFontStyle = function() {
        return this._fontStyleStr
    };
    a._getFontClientHeight = function() {
        return this._fontClientHeight
    };
    a._updateColor = function() {
        this._setColorsString();
        this._updateTexture()
    };
    a._setColorsString = function() {
        var a = this._displayedColor,
            c = this._node,
            d = c._shadowColor || this._displayedColor,
            e = c._strokeColor,
            f = c._textFillColor,
            g = a.r / 255,
            h = a.g / 255,
            a = a.b / 255;
        this._shadowColorStr = "rgba(" + (0 | g * d.r) + "," + (0 | h * d.g) + "," + (0 | a * d.b) + "," + c._shadowOpacity + ")";
        this._fillColorStr = "rgba(" + (0 | g * f.r) + "," + (0 | h * f.g) + "," + (0 | a * f.b) + ", 1)";
        this._strokeColorStr = "rgba(" + (0 | g * e.r) + "," + (0 | h * e.g) + "," + (0 | a * e.b) + ", 1)"
    };
    a._updateTTF = function() {
        var a = this._node,
            c = a._dimensions.width,
            d, e, f = this._lineWidths;
        f.length = 0;
        this._isMultiLine = !1;
        this._measureConfig();
        if (0 !== c)
            for (this._strings = a._string.split("\n"), d = 0; d < this._strings.length; d++) this._checkWarp(this._strings,
                d, c);
        else
            for (this._strings = a._string.split("\n"), d = 0, e = this._strings.length; d < e; d++) f.push(this._measure(this._strings[d]));
        1 < this._strings.length && (this._isMultiLine = !0);
        e = d = 0;
        a._strokeEnabled && (d = e = 2 * a._strokeSize);
        if (a._shadowEnabled) {
            var g = a._shadowOffset;
            d += 2 * Math.abs(g.x);
            e += 2 * Math.abs(g.y)
        }
        c = 0 === c ? this._isMultiLine ? cc.size(Math.ceil(Math.max.apply(Math, f) + d), Math.ceil(this._fontClientHeight * this._strings.length + e)) : cc.size(Math.ceil(this._measure(a._string) + d), Math.ceil(this._fontClientHeight +
            e)) : 0 === a._dimensions.height ? this._isMultiLine ? cc.size(Math.ceil(c + d), Math.ceil(a.getLineHeight() * this._strings.length + e)) : cc.size(Math.ceil(c + d), Math.ceil(a.getLineHeight() + e)) : cc.size(Math.ceil(c + d), Math.ceil(a._dimensions.height + e));
        "normal" !== a._getFontStyle() && (c.width = Math.ceil(c.width + 0.3 * a._fontSize));
        a.setContentSize(c);
        a._strokeShadowOffsetX = d;
        a._strokeShadowOffsetY = e;
        a = a._anchorPoint;
        this._anchorPointInPoints.x = 0.5 * d + (c.width - d) * a.x;
        this._anchorPointInPoints.y = 0.5 * e + (c.height - e) * a.y
    };
    a._saveStatus =
        function() {
            var a = this._node,
                c = a._strokeShadowOffsetX,
                d = a._strokeShadowOffsetY,
                e = a._contentSize.height - d,
                f = a._vAlignment,
                g = a._hAlignment,
                h = 0.5 * c,
                d = e + 0.5 * d,
                k = 0,
                m = 0,
                n = [],
                p = a._contentSize.width - c,
                a = a.getLineHeight(),
                c = (a - this._fontClientHeight) / 2,
                k = g === cc.TEXT_ALIGNMENT_RIGHT ? k + p : g === cc.TEXT_ALIGNMENT_CENTER ? k + p / 2 : k + 0;
            if (this._isMultiLine)
                for (g = this._strings.length, f === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? m = a - 2 * c + e - a * g : f === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (m = (a - 2 * c) / 2 + (e - a * g) / 2), f = 0; f < g; f++) n.push(-e +
                    (a * f + c) + m);
            else f !== cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM && (m = f === cc.VERTICAL_TEXT_ALIGNMENT_TOP ? m - e : m - 0.5 * e), n.push(m);
            e = {
                contextTransform: cc.v2f(h, d),
                xOffset: k,
                OffsetYArray: n
            };
            this._status.push(e)
        };
    a._drawTTFInCanvas = function(a) {
        if (a) {
            var c = this._status.pop();
            a.setTransform(1, 0, 0, 1, c.contextTransform.x, c.contextTransform.y);
            this.drawLabels(a, c.xOffset, c.OffsetYArray)
        }
    };
    a._checkWarp = function(a, c, d) {
        var e = a[c],
            f = this._measure(e);
        if (f > d && 1 < e.length) {
            for (var g = d / f * e.length | 0, h = e.substr(g), k = f - this._measure(h),
                    m, n = 0, p = 0; k > d && 100 > p++;) g *= d / k, g |= 0, h = e.substr(g), k = f - this._measure(h);
            for (p = 0; k < d && 100 > p++;) h && (n = (m = cc.LabelTTF._wordRex.exec(h)) ? m[0].length : 1, m = h), g += n, h = e.substr(g), k = f - this._measure(h);
            g -= n;
            0 === g && (g = 1, m = m.substr(1));
            d = e.substr(0, g);
            cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(m || h) && (f = cc.LabelTTF._lastWordRex.exec(d), g -= f ? f[0].length : 0, m = e.substr(g), d = e.substr(0, g));
            cc.LabelTTF._firsrEnglish.test(m) && (f = cc.LabelTTF._lastEnglish.exec(d)) && d !== f[0] && (g -= f[0].length, m = e.substr(g),
                d = e.substr(0, g));
            a[c] = m || h;
            a.splice(c, 0, d)
        }
    };
    a.updateStatus = function() {
        var a = cc.Node._dirtyFlags,
            c = this._dirtyFlag,
            d = c & a.colorDirty,
            e = c & a.opacityDirty;
        d && this._updateDisplayColor();
        e && this._updateDisplayOpacity();
        d || e ? this._updateColor() : c & a.textDirty && this._updateTexture();
        this._dirtyFlag & a.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    };
    a._syncStatus = function(a) {
        var c = cc.Node._dirtyFlags,
            d = this._dirtyFlag,
            e = a ? a._node :
            null;
        e && e._cascadeColorEnabled && a._dirtyFlag & c.colorDirty && (d |= c.colorDirty);
        e && e._cascadeOpacityEnabled && a._dirtyFlag & c.opacityDirty && (d |= c.opacityDirty);
        a && a._dirtyFlag & c.transformDirty && (d |= c.transformDirty);
        var e = d & c.colorDirty,
            f = d & c.opacityDirty;
        this._dirtyFlag = d;
        e && this._syncDisplayColor();
        f && this._syncDisplayOpacity();
        e || f ? this._updateColor() : d & c.textDirty && this._updateTexture();
        (cc._renderType === cc.game.RENDER_TYPE_WEBGL || d & c.transformDirty) && this.transform(a)
    };
    a.drawLabels = function(a, c, d) {
        var e =
            this._node;
        if (e._shadowEnabled) {
            var f = e._shadowOffset;
            a.shadowColor = this._shadowColorStr;
            a.shadowOffsetX = f.x;
            a.shadowOffsetY = -f.y;
            a.shadowBlur = e._shadowBlur
        }
        var f = e._hAlignment,
            g = e._vAlignment,
            h = e._strokeSize;
        a.font !== this._fontStyleStr && (a.font = this._fontStyleStr);
        a.fillStyle = this._fillColorStr;
        if (e = e._strokeEnabled) a.lineWidth = 2 * h, a.strokeStyle = this._strokeColorStr;
        a.textBaseline = cc.LabelTTF._textBaseline[g];
        a.textAlign = cc.LabelTTF._textAlign[f];
        f = this._strings.length;
        for (g = 0; g < f; g++) h = this._strings[g],
            e && a.strokeText(h, c, d[g]), a.fillText(h, c, d[g]);
        cc.g_NumberOfDraws++
    }
})();
(function() {
    cc.LabelTTF.CacheRenderCmd = function(a) {
        cc.LabelTTF.RenderCmd.call(this, a);
        a = this._labelCanvas = document.createElement("canvas");
        a.width = 1;
        a.height = 1;
        this._labelContext = a.getContext("2d")
    };
    cc.LabelTTF.CacheRenderCmd.prototype = Object.create(cc.LabelTTF.RenderCmd.prototype);
    cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CacheRenderCmd.prototype);
    var a = cc.LabelTTF.CacheRenderCmd.prototype;
    a.constructor = cc.LabelTTF.CacheRenderCmd;
    a._updateTexture = function() {
        this._dirtyFlag ^= this._dirtyFlag &
            cc.Node._dirtyFlags.textDirty;
        var a = this._node,
            c = a._contentSize;
        this._updateTTF();
        var d = c.width,
            e = c.height,
            f = this._labelContext,
            g = this._labelCanvas;
        if (!a._texture) {
            var h = new cc.Texture2D;
            h.initWithElement(this._labelCanvas);
            a.setTexture(h)
        }
        if (0 === a._string.length) return g.width = 1, g.height = c.height || 1, a._texture && a._texture.handleLoadedTexture(), a.setTextureRect(cc.rect(0, 0, 1, c.height)), !0;
        f.font = this._fontStyleStr;
        c = g.width === d && g.height === e;
        g.width = d;
        g.height = e;
        c && f.clearRect(0, 0, d, e);
        this._saveStatus();
        this._drawTTFInCanvas(f);
        a._texture && a._texture.handleLoadedTexture();
        a.setTextureRect(cc.rect(0, 0, d, e));
        return !0
    };
    a._measureConfig = function() {
        this._labelContext.font = this._fontStyleStr
    };
    a._measure = function(a) {
        return this._labelContext.measureText(a).width
    }
})();
(function() {
    cc.LabelTTF.CacheCanvasRenderCmd = function(a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        cc.LabelTTF.CacheRenderCmd.call(this)
    };
    var a = cc.LabelTTF.CacheCanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    cc.inject(cc.LabelTTF.CacheRenderCmd.prototype, a);
    a.constructor = cc.LabelTTF.CacheCanvasRenderCmd
})();
(function() {
    cc.LabelTTF.CanvasRenderCmd = function(a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        cc.LabelTTF.RenderCmd.call(this)
    };
    cc.LabelTTF.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    cc.inject(cc.LabelTTF.RenderCmd.prototype, cc.LabelTTF.CanvasRenderCmd.prototype);
    var a = cc.LabelTTF.CanvasRenderCmd.prototype;
    a.constructor = cc.LabelTTF.CanvasRenderCmd;
    a._measureConfig = function() {};
    a._measure = function(a) {
        var c = cc._renderContext.getContext();
        c.font = this._fontStyleStr;
        return c.measureText(a).width
    };
    a._updateTexture = function() {
        this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.textDirty;
        var a = this._node,
            c = a._contentSize;
        this._updateTTF();
        var d = c.width,
            e = c.height;
        if (0 === a._string.length) return a.setTextureRect(cc.rect(0, 0, 1, c.height)), !0;
        this._saveStatus();
        a.setTextureRect(cc.rect(0, 0, d, e));
        return !0
    };
    a.rendering = function(a) {
        var c = cc.view.getScaleX(),
            d = cc.view.getScaleY();
        a = a || cc._renderContext;
        var e = a.getContext();
        if (e) {
            var f = this._node;
            a.computeRealOffsetY();
            if (!(0 >= this._status.length)) {
                var g =
                    this._renderingIndex >= this._status.length ? this._renderingIndex - this._status.length : this._renderingIndex,
                    h = this._status[g];
                this._renderingIndex = g + 1;
                var k = f._offsetPosition.x,
                    g = -f._offsetPosition.y - f._rect.height,
                    m = this._displayedOpacity / 255;
                a.setTransform(this._worldTransform, c, d);
                a.setCompositeOperation(this._blendFuncStr);
                a.setGlobalAlpha(m);
                a.save();
                f._flippedX && (k = -k - f._rect.width, e.scale(-1, 1));
                f._flippedY && (g = f._offsetPosition.y, e.scale(1, -1));
                c = h.xOffset + h.contextTransform.x + k * c;
                f = [];
                k = this._strings.length;
                for (m = 0; m < k; m++) f.push(h.OffsetYArray[m] + h.contextTransform.y + g * d);
                this.drawLabels(e, c, f);
                a.restore()
            }
        }
    }
})();
(function() {
    cc.LabelTTF.WebGLRenderCmd = function(a) {
        cc.Sprite.WebGLRenderCmd.call(this, a);
        cc.LabelTTF.CacheRenderCmd.call(this);
        this.setShaderProgram(cc.shaderCache.programForKey(cc.LabelTTF._SHADER_PROGRAM))
    };
    var a = cc.LabelTTF.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    cc.inject(cc.LabelTTF.CacheRenderCmd.prototype, a);
    a.constructor = cc.LabelTTF.WebGLRenderCmd;
    a._updateColor = function() {
        this._updateTexture();
        cc.Sprite.WebGLRenderCmd.prototype._updateColor.call(this)
    }
})();
cc.HashElement = cc.Class.extend({
    actions: null,
    target: null,
    actionIndex: 0,
    currentAction: null,
    currentActionSalvaged: !1,
    paused: !1,
    hh: null,
    ctor: function() {
        this.actions = [];
        this.target = null;
        this.actionIndex = 0;
        this.currentAction = null;
        this.paused = this.currentActionSalvaged = !1;
        this.hh = null
    }
});
cc.ActionManager = cc.Class.extend({
    _hashTargets: null,
    _arrayTargets: null,
    _currentTarget: null,
    _currentTargetSalvaged: !1,
    _searchElementByTarget: function(a, b) {
        for (var c = 0; c < a.length; c++)
            if (b === a[c].target) return a[c];
        return null
    },
    ctor: function() {
        this._hashTargets = {};
        this._arrayTargets = [];
        this._currentTarget = null;
        this._currentTargetSalvaged = !1;
        this.curTime = this.realTime = Date.now()
    },
    addAction: function(a, b, c) {
        if (!a) throw Error("cc.ActionManager.addAction(): action must be non-null");
        if (!b) throw Error("cc.ActionManager.addAction(): action must be non-null");
        var d = this._hashTargets[b.__instanceId];
        d || (d = new cc.HashElement, d.paused = c, d.target = b, this._hashTargets[b.__instanceId] = d, this._arrayTargets.push(d));
        this._actionAllocWithHashElement(d);
        d.actions.push(a);
        a.startWithTarget(b)
    },
    removeAllActions: function() {
        for (var a = this._arrayTargets, b = 0; b < a.length; b++) {
            var c = a[b];
            c && this.removeAllActionsFromTarget(c.target, !0)
        }
    },
    removeAllActionsFromTarget: function(a, b) {
        if (null != a) {
            var c = this._hashTargets[a.__instanceId];
            c && (-1 === c.actions.indexOf(c.currentAction) ||
                c.currentActionSalvaged || (c.currentActionSalvaged = !0), c.actions.length = 0, this._currentTarget !== c || b ? this._deleteHashElement(c) : this._currentTargetSalvaged = !0)
        }
    },
    removeAction: function(a) {
        if (null != a) {
            var b = a.getOriginalTarget();
            if (b = this._hashTargets[b.__instanceId])
                for (var c = 0; c < b.actions.length; c++) {
                    if (b.actions[c] === a) {
                        b.actions.splice(c, 1);
                        break
                    }
                } else cc.log(cc._LogInfos.ActionManager_removeAction)
        }
    },
    removeActionByTag: function(a, b) {
        a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_addAction);
        cc.assert(b, cc._LogInfos.ActionManager_addAction);
        var c = this._hashTargets[b.__instanceId];
        if (c)
            for (var d = c.actions.length, e = 0; e < d; ++e) {
                var f = c.actions[e];
                if (f && f.getTag() === a && f.getOriginalTarget() === b) {
                    this._removeActionAtIndex(e, c);
                    break
                }
            }
    },
    getActionByTag: function(a, b) {
        a === cc.ACTION_TAG_INVALID && cc.log(cc._LogInfos.ActionManager_getActionByTag);
        var c = this._hashTargets[b.__instanceId];
        if (c) {
            if (null != c.actions)
                for (var d = 0; d < c.actions.length; ++d) {
                    var e = c.actions[d];
                    if (e && e.getTag() === a) return e
                }
            cc.log(cc._LogInfos.ActionManager_getActionByTag_2,
                a)
        }
        return null
    },
    numberOfRunningActionsInTarget: function(a) {
        return (a = this._hashTargets[a.__instanceId]) ? a.actions ? a.actions.length : 0 : 0
    },
    pauseTarget: function(a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !0)
    },
    resumeTarget: function(a) {
        (a = this._hashTargets[a.__instanceId]) && (a.paused = !1)
    },
    pauseAllRunningActions: function() {
        for (var a = [], b = this._arrayTargets, c = 0; c < b.length; c++) {
            var d = b[c];
            d && !d.paused && (d.paused = !0, a.push(d.target))
        }
        return a
    },
    resumeTargets: function(a) {
        if (a)
            for (var b = 0; b < a.length; b++) a[b] &&
                this.resumeTarget(a[b])
    },
    purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdate(this)
    },
    _removeActionAtIndex: function(a, b) {
        b.actions[a] !== b.currentAction || b.currentActionSalvaged || (b.currentActionSalvaged = !0);
        b.actions.splice(a, 1);
        b.actionIndex >= a && b.actionIndex--;
        0 === b.actions.length && (this._currentTarget === b ? this._currentTargetSalvaged = !0 : this._deleteHashElement(b))
    },
    _deleteHashElement: function(a) {
        var b = !1;
        a && (this._hashTargets[a.target.__instanceId] && (delete this._hashTargets[a.target.__instanceId],
            cc.arrayRemoveObject(this._arrayTargets, a), b = !0), a.actions = null, a.target = null);
        return b
    },
    _actionAllocWithHashElement: function(a) {
        null == a.actions && (a.actions = [])
    },
    update: function(a) {
        this.update_time()
    },
    setCurTime: function(a) {
        this.curTime = a
    },
    getCurTime: function() {
        return this.curTime
    },
    getSystemTime: function() {
        return Date.now()
    },
    update_time: function() {
        this.realTime = Date.now();
        if (this.realTime > this.curTime) {
            for (var a = 1E3 * cc.director.getAnimationInterval() + 1; this.realTime - this.curTime >= a;) this.curTime +=
                a, this.runAction();
            this.realTime > this.curTime && (this.curTime = this.realTime, this.runAction())
        }
    },
    runAction: function() {
        for (var a = this._arrayTargets, b, c = 0; c < a.length; c++) {
            b = this._currentTarget = a[c];
            if (!b.paused)
                for (b.actionIndex = 0; b.actionIndex < (b.actions ? b.actions.length : 0); b.actionIndex++)
                    if (b.currentAction = b.actions[b.actionIndex], b.currentAction) {
                        b.currentActionSalvaged = !1;
                        b.currentAction.step_time(this.curTime);
                        if (b.currentActionSalvaged) b.currentAction = null;
                        else if (b.currentAction.isDone()) {
                            b.currentAction.stop();
                            var d = b.currentAction;
                            b.currentAction = null;
                            this.removeAction(d)
                        }
                        b.currentAction = null
                    }
            this._currentTargetSalvaged && 0 === b.actions.length && this._deleteHashElement(b) && c--
        }
    }
});
cc.profiler = function() {
    var a = _showFPS = !1,
        b = _frameRate = _lastSPF = _accumDt = 0;
    _afterVisitListener = _FPSLabel = _SPFLabel = _drawsLabel = null;
    var c = 10,
        d = [0, 10, 20, 30],
        e = [0, 0, 0, 0],
        f = 3,
        g = 0,
        h = 0,
        k = function() {
            _lastSPF = cc.director.getSecondsPerFrame();
            b++;
            _accumDt += cc.director.getDeltaTime();
            if (_accumDt > cc.DIRECTOR_FPS_INTERVAL) {
                _frameRate = b / _accumDt;
                _accumDt = b = 0;
                if (n.onFrameRateChange) {
                    var a = _frameRate,
                        k = i = d.length - 1,
                        m = 0;
                    g++;
                    for (h += a; 0 <= i; i--)
                        if (a >= d[i]) {
                            e[i]++;
                            break
                        }
                    if (g >= c) {
                        m = h / c;
                        for (i = k; 0 < i; i--)
                            if (a = e[i] / c, 0.6 <=
                                a && m >= d[i]) {
                                i != f && (f = i, n.onFrameRateChange && n.onFrameRateChange(m.toFixed(2)));
                                break
                            }
                        h = g = _changeCount = 0;
                        for (i = k; 0 < i; i--) e[i] = 0
                    }
                }
                _showFPS && (_SPFLabel.string = _lastSPF.toFixed(3), _FPSLabel.string = _frameRate.toFixed(1), _drawsLabel.string = (0 | cc.g_NumberOfDraws).toString())
            }
            _showFPS && (_FPSLabel.visit(), _SPFLabel.visit(), _drawsLabel.visit())
        },
        m = function() {
            _FPSLabel._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
            _SPFLabel._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
            _drawsLabel._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
        },
        n = {
            onFrameRateChange: null,
            getSecondsPerFrame: function() {
                return _lastSPF
            },
            getFrameRate: function() {
                return _frameRate
            },
            setProfileDuration: function(a) {
                !isNaN(a) && 0 < a && (c = a / cc.DIRECTOR_FPS_INTERVAL)
            },
            resumeProfiling: function() {
                cc.eventManager.addListener(_afterVisitListener, 1)
            },
            stopProfiling: function() {
                cc.eventManager.removeListener(_afterVisitListener)
            },
            isShowingStats: function() {
                return _showFPS
            },
            showStats: function() {
                a || this.init();
                if (cc.LabelTTF && !_FPSLabel) {
                    var b = 0,
                        b = cc.winSize.width,
                        c = cc.winSize.height,
                        d = cc.DIRECTOR_STATS_POSITION,
                        b = b > c ? 0 | c / 320 * 24 : 0 | b / 320 * 24;
                    _FPSLabel = new cc.LabelTTF("000.0", "Arial", b);
                    _SPFLabel = new cc.LabelTTF("0.000", "Arial", b);
                    _drawsLabel = new cc.LabelTTF("0000", "Arial", b);
                    _drawsLabel.setPosition(_drawsLabel.width / 2 + d.x, 5 * _drawsLabel.height / 2 + d.y);
                    _SPFLabel.setPosition(_SPFLabel.width / 2 + d.x, 3 * _SPFLabel.height / 2 + d.y);
                    _FPSLabel.setPosition(_FPSLabel.width / 2 + d.x, _FPSLabel.height / 2 + d.y)
                }
                _FPSLabel && (_showFPS = !0)
            },
            hideStats: function() {
                _showFPS = !1
            },
            init: function() {
                a || (_afterVisitListener =
                    cc.eventManager.addCustomListener(cc.Director.EVENT_AFTER_VISIT, k), cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, m), a = !0)
            }
        };
    return n
}();
cc.math = cc.math || {};
cc.math.EPSILON = 0.015625;
cc.math.square = function(a) {
    return a * a
};
cc.math.almostEqual = function(a, b) {
    return a + cc.math.EPSILON > b && a - cc.math.EPSILON < b
};
(function(a) {
    a.math.Vec2 = function(a, b) {
        void 0 === b ? (this.x = a.x, this.y = a.y) : (this.x = a || 0, this.y = b || 0)
    };
    var b = a.math.Vec2.prototype;
    b.fill = function(a, b) {
        this.x = a;
        this.y = b
    };
    b.length = function() {
        return Math.sqrt(a.math.square(this.x) + a.math.square(this.y))
    };
    b.lengthSq = function() {
        return a.math.square(this.x) + a.math.square(this.y)
    };
    b.normalize = function() {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        return this
    };
    a.math.Vec2.add = function(a, b, e) {
        a.x = b.x + e.x;
        a.y = b.y + e.y;
        return a
    };
    b.add = function(a) {
        this.x += a.x;
        this.y +=
            a.y;
        return this
    };
    b.dot = function(a) {
        return this.x * a.x + this.y * a.y
    };
    a.math.Vec2.subtract = function(a, b, e) {
        a.x = b.x - e.x;
        a.y = b.y - e.y;
        return a
    };
    b.subtract = function(a) {
        this.x -= a.x;
        this.y -= a.y;
        return this
    };
    b.transform = function(a) {
        var b = this.x,
            e = this.y;
        this.x = b * a.mat[0] + e * a.mat[3] + a.mat[6];
        this.y = b * a.mat[1] + e * a.mat[4] + a.mat[7];
        return this
    };
    a.math.Vec2.scale = function(a, b, e) {
        a.x = b.x * e;
        a.y = b.y * e;
        return a
    };
    b.scale = function(a) {
        this.x *= a;
        this.y *= a;
        return this
    };
    b.equals = function(b) {
        return this.x < b.x + a.math.EPSILON &&
            this.x > b.x - a.math.EPSILON && this.y < b.y + a.math.EPSILON && this.y > b.y - a.math.EPSILON
    }
})(cc);
(function(a) {
    a.kmVec3 = a.math.Vec3 = function(a, b, e) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z) : (this.x = a || 0, this.y = b || 0, this.z = e || 0)
    };
    a.math.vec3 = function(b, d, e) {
        return new a.math.Vec3(b, d, e)
    };
    var b = a.math.Vec3.prototype;
    b.fill = function(a, b, e) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z) : (this.x = a, this.y = b, this.z = e);
        return this
    };
    b.length = function() {
        return Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z))
    };
    b.lengthSq = function() {
        return a.math.square(this.x) + a.math.square(this.y) +
            a.math.square(this.z)
    };
    b.normalize = function() {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    };
    b.cross = function(a) {
        var b = this.x,
            e = this.y,
            f = this.z;
        this.x = e * a.z - f * a.y;
        this.y = f * a.x - b * a.z;
        this.z = b * a.y - e * a.x;
        return this
    };
    b.dot = function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    };
    b.add = function(a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        return this
    };
    b.subtract = function(a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        return this
    };
    b.transform = function(a) {
        var b = this.x,
            e = this.y,
            f = this.z;
        a = a.mat;
        this.x = b *
            a[0] + e * a[4] + f * a[8] + a[12];
        this.y = b * a[1] + e * a[5] + f * a[9] + a[13];
        this.z = b * a[2] + e * a[6] + f * a[10] + a[14];
        return this
    };
    b.transformNormal = function(a) {
        var b = this.x,
            e = this.y,
            f = this.z;
        a = a.mat;
        this.x = b * a[0] + e * a[4] + f * a[8];
        this.y = b * a[1] + e * a[5] + f * a[9];
        this.z = b * a[2] + e * a[6] + f * a[10];
        return this
    };
    b.transformCoord = function(b) {
        var d = new a.math.Vec4(this.x, this.y, this.z, 1);
        d.transform(b);
        this.x = d.x / d.w;
        this.y = d.y / d.w;
        this.z = d.z / d.w;
        return this
    };
    b.scale = function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    };
    b.equals = function(b) {
        var d =
            a.math.EPSILON;
        return this.x < b.x + d && this.x > b.x - d && this.y < b.y + d && this.y > b.y - d && this.z < b.z + d && this.z > b.z - d
    };
    b.inverseTransform = function(b) {
        b = b.mat;
        var d = new a.math.Vec3(this.x - b[12], this.y - b[13], this.z - b[14]);
        this.x = d.x * b[0] + d.y * b[1] + d.z * b[2];
        this.y = d.x * b[4] + d.y * b[5] + d.z * b[6];
        this.z = d.x * b[8] + d.y * b[9] + d.z * b[10];
        return this
    };
    b.inverseTransformNormal = function(a) {
        var b = this.x,
            e = this.y,
            f = this.z;
        a = a.mat;
        this.x = b * a[0] + e * a[1] + f * a[2];
        this.y = b * a[4] + e * a[5] + f * a[6];
        this.z = b * a[8] + e * a[9] + f * a[10];
        return this
    };
    b.assignFrom =
        function(a) {
            if (!a) return this;
            this.x = a.x;
            this.y = a.y;
            this.z = a.z;
            return this
        };
    a.math.Vec3.zero = function(a) {
        a.x = a.y = a.z = 0;
        return a
    };
    b.toTypeArray = function() {
        var a = new Float32Array(3);
        a[0] = this.x;
        a[1] = this.y;
        a[2] = this.z;
        return a
    }
})(cc);
(function(a) {
    a.math.Vec4 = function(a, b, e, f) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a || 0, this.y = b || 0, this.z = e || 0, this.w = f || 0)
    };
    a.kmVec4 = a.math.Vec4;
    var b = a.math.Vec4.prototype;
    b.fill = function(a, b, e, f) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a, this.y = b, this.z = e, this.w = f)
    };
    b.add = function(a) {
        if (!a) return this;
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    };
    b.dot = function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    };
    b.length =
        function() {
            return Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z) + a.math.square(this.w))
        };
    b.lengthSq = function() {
        return a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z) + a.math.square(this.w)
    };
    b.lerp = function(a, b) {
        return this
    };
    b.normalize = function() {
        var a = 1 / this.length();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.scale = function(a) {
        this.normalize();
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.subtract = function(a) {
        this.x -= a.x;
        this.y -=
            a.y;
        this.z -= a.z;
        this.w -= a.w
    };
    b.transform = function(a) {
        var b = this.x,
            e = this.y,
            f = this.z,
            g = this.w;
        a = a.mat;
        this.x = b * a[0] + e * a[4] + f * a[8] + g * a[12];
        this.y = b * a[1] + e * a[5] + f * a[9] + g * a[13];
        this.z = b * a[2] + e * a[6] + f * a[10] + g * a[14];
        this.w = b * a[3] + e * a[7] + f * a[11] + g * a[15];
        return this
    };
    a.math.Vec4.transformArray = function(b, d) {
        for (var e = [], f = 0; f < b.length; f++) {
            var g = new a.math.Vec4(b[f]);
            g.transform(d);
            e.push(g)
        }
        return e
    };
    b.equals = function(b) {
        var d = a.math.EPSILON;
        return this.x < b.x + d && this.x > b.x - d && this.y < b.y + d && this.y > b.y - d &&
            this.z < b.z + d && this.z > b.z - d && this.w < b.w + d && this.w > b.w - d
    };
    b.assignFrom = function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = a.w;
        return this
    };
    b.toTypeArray = function() {
        var a = new Float32Array(4);
        a[0] = this.x;
        a[1] = this.y;
        a[2] = this.z;
        a[3] = this.w;
        return a
    }
})(cc);
(function(a) {
    function b(b, d, e) {
        d = new a.math.Vec2(d);
        d.subtract(b);
        e.x = -d.y;
        e.y = d.x;
        e.normalize()
    }
    a.math.Ray2 = function(b, d) {
        this.start = b || new a.math.Vec2;
        this.dir = d || new a.math.Vec2
    };
    a.math.Ray2.prototype.fill = function(a, b, e, f) {
        this.start.x = a;
        this.start.y = b;
        this.dir.x = e;
        this.dir.y = f
    };
    a.math.Ray2.prototype.intersectLineSegment = function(b, d, e) {
        var f = this.start.x,
            g = this.start.y,
            h = this.start.x + this.dir.x,
            k = this.start.y + this.dir.y,
            m = b.x,
            n = b.y,
            p = d.x,
            s = d.y,
            r = (s - n) * (h - f) - (p - m) * (k - g);
        if (r > -a.math.EPSILON &&
            r < a.math.EPSILON) return !1;
        n = ((p - m) * (g - n) - (s - n) * (f - m)) / r;
        m = f + n * (h - f);
        n = g + n * (k - g);
        if (m < Math.min(b.x, d.x) - a.math.EPSILON || m > Math.max(b.x, d.x) + a.math.EPSILON || n < Math.min(b.y, d.y) - a.math.EPSILON || n > Math.max(b.y, d.y) + a.math.EPSILON || m < Math.min(f, h) - a.math.EPSILON || m > Math.max(f, h) + a.math.EPSILON || n < Math.min(g, k) - a.math.EPSILON || n > Math.max(g, k) + a.math.EPSILON) return !1;
        e.x = m;
        e.y = n;
        return !0
    };
    a.math.Ray2.prototype.intersectTriangle = function(c, d, e, f, g) {
        var h = new a.math.Vec2,
            k = new a.math.Vec2,
            m = new a.math.Vec2,
            n = 1E4,
            p = !1,
            s;
        this.intersectLineSegment(c, d, h) && (p = !0, s = h.subtract(this.start).length(), s < n && (k.x = h.x, k.y = h.y, n = s, b(c, d, m)));
        this.intersectLineSegment(d, e, h) && (p = !0, s = h.subtract(this.start).length(), s < n && (k.x = h.x, k.y = h.y, n = s, b(d, e, m)));
        this.intersectLineSegment(e, c, h) && (p = !0, s = h.subtract(this.start).length(), s < n && (k.x = h.x, k.y = h.y, b(e, c, m)));
        p && (f.x = k.x, f.y = k.y, g && (g.x = m.x, g.y = m.y));
        return p
    }
})(cc);
window.Uint16Array = window.Uint16Array || window.Array;
window.Float32Array = window.Float32Array || window.Array;
(function(a) {
    a.math.Matrix3 = function(a) {
        this.mat = a && a.mat ? new Float32Array(a.mat) : new Float32Array(9)
    };
    a.kmMat3 = a.math.Matrix3;
    var b = a.math.Matrix3.prototype;
    b.fill = function(a) {
        var b = this.mat;
        a = a.mat;
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        b[4] = a[4];
        b[5] = a[5];
        b[6] = a[6];
        b[7] = a[7];
        b[8] = a[8];
        return this
    };
    b.adjugate = function() {
        var a = this.mat,
            b = a[0],
            c = a[1],
            g = a[2],
            h = a[3],
            k = a[4],
            m = a[5],
            n = a[6],
            p = a[7],
            s = a[8];
        a[0] = k * s - m * p;
        a[1] = g * p - c * s;
        a[2] = c * m - g * k;
        a[3] = m * n - h * s;
        a[4] = b * s - g * n;
        a[5] = g * h - b * m;
        a[6] = h * p - k * n;
        a[8] = b *
            k - c * h;
        return this
    };
    b.identity = function() {
        var a = this.mat;
        a[1] = a[2] = a[3] = a[5] = a[6] = a[7] = 0;
        a[0] = a[4] = a[8] = 1;
        return this
    };
    var c = new a.math.Matrix3;
    b.inverse = function(a) {
        if (0 === a) return this;
        c.assignFrom(this);
        a = 1 / a;
        this.adjugate();
        this.multiplyScalar(a);
        return this
    };
    b.isIdentity = function() {
        var a = this.mat;
        return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 1 === a[4] && 0 === a[5] && 0 === a[6] && 0 === a[7] && 1 === a[8]
    };
    b.transpose = function() {
        var a = this.mat,
            b = a[1],
            c = a[2],
            g = a[5],
            h = a[6],
            k = a[7];
        a[1] = a[3];
        a[2] = h;
        a[3] = b;
        a[5] =
            k;
        a[6] = c;
        a[7] = g;
        return this
    };
    b.determinant = function() {
        var a = this.mat,
            b = a[0] * a[4] * a[8] + a[1] * a[5] * a[6] + a[2] * a[3] * a[7];
        return b -= a[2] * a[4] * a[6] + a[0] * a[5] * a[7] + a[1] * a[3] * a[8]
    };
    b.multiply = function(a) {
        var b = this.mat,
            c = a.mat;
        a = b[0];
        var g = b[1],
            h = b[2],
            k = b[3],
            m = b[4],
            n = b[5],
            p = b[6],
            s = b[7],
            r = b[8],
            u = c[0],
            t = c[1],
            v = c[2],
            w = c[3],
            A = c[4],
            C = c[5],
            E = c[6],
            x = c[7],
            c = c[8];
        b[0] = a * u + k * t + p * v;
        b[1] = g * u + m * t + s * v;
        b[2] = h * u + n * t + r * v;
        b[3] = h * u + n * t + r * v;
        b[4] = g * w + m * A + s * C;
        b[5] = h * w + n * A + r * C;
        b[6] = a * E + k * x + p * c;
        b[7] = g * E + m * x + s * c;
        b[8] = h * E + n * x + r * c;
        return this
    };
    b.multiplyScalar = function(a) {
        var b = this.mat;
        b[0] *= a;
        b[1] *= a;
        b[2] *= a;
        b[3] *= a;
        b[4] *= a;
        b[5] *= a;
        b[6] *= a;
        b[7] *= a;
        b[8] *= a;
        return this
    };
    a.math.Matrix3.rotationAxisAngle = function(b, c) {
        var f = Math.cos(c),
            g = Math.sin(c),
            h = new a.math.Matrix3,
            k = h.mat;
        k[0] = f + b.x * b.x * (1 - f);
        k[1] = b.z * g + b.y * b.x * (1 - f);
        k[2] = -b.y * g + b.z * b.x * (1 - f);
        k[3] = -b.z * g + b.x * b.y * (1 - f);
        k[4] = f + b.y * b.y * (1 - f);
        k[5] = b.x * g + b.z * b.y * (1 - f);
        k[6] = b.y * g + b.x * b.z * (1 - f);
        k[7] = -b.x * g + b.y * b.z * (1 - f);
        k[8] = f + b.z * b.z * (1 - f);
        return h
    };
    b.assignFrom = function(b) {
        if (this ===
            b) return a.log("cc.math.Matrix3.assign(): current matrix equals matIn"), this;
        var c = this.mat;
        b = b.mat;
        c[0] = b[0];
        c[1] = b[1];
        c[2] = b[2];
        c[3] = b[3];
        c[4] = b[4];
        c[5] = b[5];
        c[6] = b[6];
        c[7] = b[7];
        c[8] = b[8];
        return this
    };
    b.equals = function(b) {
        if (this === b) return !0;
        var c = a.math.EPSILON,
            f = this.mat;
        b = b.mat;
        for (var g = 0; 9 > g; ++g)
            if (!(f[g] + c > b[g] && f[g] - c < b[g])) return !1;
        return !0
    };
    a.math.Matrix3.createByRotationX = function(b) {
        var c = new a.math.Matrix3,
            f = c.mat;
        f[0] = 1;
        f[1] = 0;
        f[2] = 0;
        f[3] = 0;
        f[4] = Math.cos(b);
        f[5] = Math.sin(b);
        f[6] = 0;
        f[7] = -Math.sin(b);
        f[8] = Math.cos(b);
        return c
    };
    a.math.Matrix3.createByRotationY = function(b) {
        var c = new a.math.Matrix3,
            f = c.mat;
        f[0] = Math.cos(b);
        f[1] = 0;
        f[2] = -Math.sin(b);
        f[3] = 0;
        f[4] = 1;
        f[5] = 0;
        f[6] = Math.sin(b);
        f[7] = 0;
        f[8] = Math.cos(b);
        return c
    };
    a.math.Matrix3.createByRotationZ = function(b) {
        var c = new a.math.Matrix3,
            f = c.mat;
        f[0] = Math.cos(b);
        f[1] = -Math.sin(b);
        f[2] = 0;
        f[3] = Math.sin(b);
        f[4] = Math.cos(b);
        f[5] = 0;
        f[6] = 0;
        f[7] = 0;
        f[8] = 1;
        return c
    };
    a.math.Matrix3.createByRotation = function(b) {
        var c = new a.math.Matrix3,
            f = c.mat;
        f[0] = Math.cos(b);
        f[1] = Math.sin(b);
        f[2] = 0;
        f[3] = -Math.sin(b);
        f[4] = Math.cos(b);
        f[5] = 0;
        f[6] = 0;
        f[7] = 0;
        f[8] = 1;
        return c
    };
    a.math.Matrix3.createByScale = function(b, c) {
        var f = new a.math.Matrix3;
        f.identity();
        f.mat[0] = b;
        f.mat[4] = c;
        return f
    };
    a.math.Matrix3.createByTranslation = function(b, c) {
        var f = new a.math.Matrix3;
        f.identity();
        f.mat[6] = b;
        f.mat[7] = c;
        return f
    };
    a.math.Matrix3.createByQuaternion = function(b) {
        if (!b) return null;
        var c = new a.math.Matrix3,
            f = c.mat;
        f[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
        f[1] = 2 * (b.x * b.y - b.w * b.z);
        f[2] = 2 *
            (b.x * b.z + b.w * b.y);
        f[3] = 2 * (b.x * b.y + b.w * b.z);
        f[4] = 1 - 2 * (b.x * b.x + b.z * b.z);
        f[5] = 2 * (b.y * b.z - b.w * b.x);
        f[6] = 2 * (b.x * b.z - b.w * b.y);
        f[7] = 2 * (b.y * b.z + b.w * b.x);
        f[8] = 1 - 2 * (b.x * b.x + b.y * b.y);
        return c
    };
    b.rotationToAxisAngle = function() {
        return a.math.Quaternion.rotationMatrix(this).toAxisAndAngle()
    }
})(cc);
(function(a) {
    a.math.Matrix4 = function(a) {
        this.mat = a && a.mat ? new Float32Array(a.mat) : new Float32Array(16)
    };
    a.kmMat4 = a.math.Matrix4;
    var b = a.math.Matrix4.prototype;
    b.fill = function(a) {
        for (var b = this.mat, c = 0; 16 > c; c++) b[c] = a[c];
        return this
    };
    a.kmMat4Identity = function(a) {
        var b = a.mat;
        b[1] = b[2] = b[3] = b[4] = b[6] = b[7] = b[8] = b[9] = b[11] = b[12] = b[13] = b[14] = 0;
        b[0] = b[5] = b[10] = b[15] = 1;
        return a
    };
    b.identity = function() {
        var a = this.mat;
        a[1] = a[2] = a[3] = a[4] = a[6] = a[7] = a[8] = a[9] = a[11] = a[12] = a[13] = a[14] = 0;
        a[0] = a[5] = a[10] = a[15] = 1;
        return this
    };
    b.get = function(a, b) {
        return this.mat[a + 4 * b]
    };
    b.set = function(a, b, c) {
        this.mat[a + 4 * b] = c
    };
    b.swap = function(a, b, c, d) {
        var k = this.mat,
            m = k[a + 4 * b];
        k[a + 4 * b] = k[c + 4 * d];
        k[c + 4 * d] = m
    };
    a.math.Matrix4._gaussj = function(a, b) {
        var c, d = 0,
            k = 0,
            m, n, p, s, r = [0, 0, 0, 0],
            u = [0, 0, 0, 0],
            t = [0, 0, 0, 0];
        for (c = 0; 4 > c; c++) {
            for (m = s = 0; 4 > m; m++)
                if (1 !== t[m])
                    for (n = 0; 4 > n; n++) 0 === t[n] && (p = Math.abs(a.get(m, n)), p >= s && (s = p, k = m, d = n));
            ++t[d];
            if (k !== d) {
                for (m = 0; 4 > m; m++) a.swap(k, m, d, m);
                for (m = 0; 4 > m; m++) b.swap(k, m, d, m)
            }
            u[c] = k;
            r[c] = d;
            if (0 === a.get(d,
                    d)) return !1;
            n = 1 / a.get(d, d);
            a.set(d, d, 1);
            for (m = 0; 4 > m; m++) a.set(d, m, a.get(d, m) * n);
            for (m = 0; 4 > m; m++) b.set(d, m, b.get(d, m) * n);
            for (n = 0; 4 > n; n++)
                if (n !== d) {
                    p = a.get(n, d);
                    a.set(n, d, 0);
                    for (m = 0; 4 > m; m++) a.set(n, m, a.get(n, m) - a.get(d, m) * p);
                    for (m = 0; 4 > m; m++) b.set(n, m, a.get(n, m) - b.get(d, m) * p)
                }
        }
        for (m = 3; 0 <= m; m--)
            if (u[m] !== r[m])
                for (n = 0; 4 > n; n++) a.swap(n, u[m], n, r[m]);
        return !0
    };
    var c = (new a.math.Matrix4).identity();
    a.kmMat4Inverse = function(b, d) {
        var g = new a.math.Matrix4(d),
            h = new a.math.Matrix4(c);
        if (!1 === a.math.Matrix4._gaussj(g,
                h)) return null;
        b.assignFrom(g);
        return b
    };
    b.inverse = function() {
        var b = new a.math.Matrix4(this),
            d = new a.math.Matrix4(c);
        return !1 === a.math.Matrix4._gaussj(b, d) ? null : b
    };
    b.isIdentity = function() {
        var a = this.mat;
        return 1 === a[0] && 0 === a[1] && 0 === a[2] && 0 === a[3] && 0 === a[4] && 1 === a[5] && 0 === a[6] && 0 === a[7] && 0 === a[8] && 0 === a[9] && 1 === a[10] && 0 === a[11] && 0 === a[12] && 0 === a[13] && 0 === a[14] && 1 === a[15]
    };
    b.transpose = function() {
        var a = this.mat,
            b = a[1],
            c = a[2],
            d = a[3],
            k = a[6],
            m = a[7],
            n = a[8],
            p = a[9],
            s = a[11],
            r = a[12],
            u = a[13],
            t = a[14];
        a[1] = a[4];
        a[2] = n;
        a[3] = r;
        a[4] = b;
        a[6] = p;
        a[7] = u;
        a[8] = c;
        a[9] = k;
        a[11] = t;
        a[12] = d;
        a[13] = m;
        a[14] = s;
        return this
    };
    a.kmMat4Multiply = function(a, b, c) {
        var d = a.mat,
            k = b.mat,
            m = c.mat;
        c = k[0];
        b = k[1];
        var n = k[2],
            p = k[3],
            s = k[4],
            r = k[5],
            u = k[6],
            t = k[7],
            v = k[8],
            w = k[9],
            A = k[10],
            C = k[11],
            E = k[12],
            x = k[13],
            B = k[14],
            k = k[15],
            z = m[0],
            D = m[1],
            G = m[2],
            F = m[3],
            y = m[4],
            J = m[5],
            K = m[6],
            H = m[7],
            L = m[8],
            I = m[9],
            N = m[10],
            M = m[11],
            O = m[12],
            P = m[13],
            Q = m[14],
            m = m[15];
        d[0] = z * c + D * s + G * v + F * E;
        d[1] = z * b + D * r + G * w + F * x;
        d[2] = z * n + D * u + G * A + F * B;
        d[3] = z * p + D * t + G * C + F * k;
        d[4] = y * c + J * s + K * v + H * E;
        d[5] =
            y * b + J * r + K * w + H * x;
        d[6] = y * n + J * u + K * A + H * B;
        d[7] = y * p + J * t + K * C + H * k;
        d[8] = L * c + I * s + N * v + M * E;
        d[9] = L * b + I * r + N * w + M * x;
        d[10] = L * n + I * u + N * A + M * B;
        d[11] = L * p + I * t + N * C + M * k;
        d[12] = O * c + P * s + Q * v + m * E;
        d[13] = O * b + P * r + Q * w + m * x;
        d[14] = O * n + P * u + Q * A + m * B;
        d[15] = O * p + P * t + Q * C + m * k;
        return a
    };
    b.multiply = function(a) {
        var b = this.mat,
            c = a.mat;
        a = b[0];
        var d = b[1],
            k = b[2],
            m = b[3],
            n = b[4],
            p = b[5],
            s = b[6],
            r = b[7],
            u = b[8],
            t = b[9],
            v = b[10],
            w = b[11],
            A = b[12],
            C = b[13],
            E = b[14],
            x = b[15],
            B = c[0],
            z = c[1],
            D = c[2],
            G = c[3],
            F = c[4],
            y = c[5],
            J = c[6],
            K = c[7],
            H = c[8],
            L = c[9],
            I = c[10],
            N = c[11],
            M = c[12],
            O = c[13],
            P = c[14],
            c = c[15];
        b[0] = B * a + z * n + D * u + G * A;
        b[1] = B * d + z * p + D * t + G * C;
        b[2] = B * k + z * s + D * v + G * E;
        b[3] = B * m + z * r + D * w + G * x;
        b[4] = F * a + y * n + J * u + K * A;
        b[5] = F * d + y * p + J * t + K * C;
        b[6] = F * k + y * s + J * v + K * E;
        b[7] = F * m + y * r + J * w + K * x;
        b[8] = H * a + L * n + I * u + N * A;
        b[9] = H * d + L * p + I * t + N * C;
        b[10] = H * k + L * s + I * v + N * E;
        b[11] = H * m + L * r + I * w + N * x;
        b[12] = M * a + O * n + P * u + c * A;
        b[13] = M * d + O * p + P * t + c * C;
        b[14] = M * k + O * s + P * v + c * E;
        b[15] = M * m + O * r + P * w + c * x;
        return this
    };
    a.getMat4MultiplyValue = function(a, b) {
        var c = a.mat,
            d = b.mat,
            k = new Float32Array(16);
        k[0] = c[0] * d[0] + c[4] * d[1] + c[8] * d[2] + c[12] * d[3];
        k[1] = c[1] * d[0] + c[5] * d[1] + c[9] * d[2] + c[13] * d[3];
        k[2] = c[2] * d[0] + c[6] * d[1] + c[10] * d[2] + c[14] * d[3];
        k[3] = c[3] * d[0] + c[7] * d[1] + c[11] * d[2] + c[15] * d[3];
        k[4] = c[0] * d[4] + c[4] * d[5] + c[8] * d[6] + c[12] * d[7];
        k[5] = c[1] * d[4] + c[5] * d[5] + c[9] * d[6] + c[13] * d[7];
        k[6] = c[2] * d[4] + c[6] * d[5] + c[10] * d[6] + c[14] * d[7];
        k[7] = c[3] * d[4] + c[7] * d[5] + c[11] * d[6] + c[15] * d[7];
        k[8] = c[0] * d[8] + c[4] * d[9] + c[8] * d[10] + c[12] * d[11];
        k[9] = c[1] * d[8] + c[5] * d[9] + c[9] * d[10] + c[13] * d[11];
        k[10] = c[2] * d[8] + c[6] * d[9] + c[10] * d[10] + c[14] * d[11];
        k[11] = c[3] * d[8] + c[7] * d[9] + c[11] *
            d[10] + c[15] * d[11];
        k[12] = c[0] * d[12] + c[4] * d[13] + c[8] * d[14] + c[12] * d[15];
        k[13] = c[1] * d[12] + c[5] * d[13] + c[9] * d[14] + c[13] * d[15];
        k[14] = c[2] * d[12] + c[6] * d[13] + c[10] * d[14] + c[14] * d[15];
        k[15] = c[3] * d[12] + c[7] * d[13] + c[11] * d[14] + c[15] * d[15];
        return k
    };
    a.kmMat4Assign = function(b, c) {
        if (b === c) return a.log("cc.kmMat4Assign(): pOut equals pIn"), b;
        var d = b.mat,
            h = c.mat;
        d[0] = h[0];
        d[1] = h[1];
        d[2] = h[2];
        d[3] = h[3];
        d[4] = h[4];
        d[5] = h[5];
        d[6] = h[6];
        d[7] = h[7];
        d[8] = h[8];
        d[9] = h[9];
        d[10] = h[10];
        d[11] = h[11];
        d[12] = h[12];
        d[13] = h[13];
        d[14] = h[14];
        d[15] = h[15];
        return b
    };
    b.assignFrom = function(b) {
        if (this === b) return a.log("cc.mat.Matrix4.assignFrom(): mat4 equals current matrix"), this;
        var c = this.mat;
        b = b.mat;
        c[0] = b[0];
        c[1] = b[1];
        c[2] = b[2];
        c[3] = b[3];
        c[4] = b[4];
        c[5] = b[5];
        c[6] = b[6];
        c[7] = b[7];
        c[8] = b[8];
        c[9] = b[9];
        c[10] = b[10];
        c[11] = b[11];
        c[12] = b[12];
        c[13] = b[13];
        c[14] = b[14];
        c[15] = b[15];
        return this
    };
    b.equals = function(b) {
        if (this === b) return a.log("cc.kmMat4AreEqual(): pMat1 and pMat2 are same object."), !0;
        var c = this.mat;
        b = b.mat;
        for (var d = a.math.EPSILON, h = 0; 16 >
            h; h++)
            if (!(c[h] + d > b[h] && c[h] - d < b[h])) return !1;
        return !0
    };
    a.math.Matrix4.createByRotationX = function(b, c) {
        c = c || new a.math.Matrix4;
        var d = c.mat;
        d[0] = 1;
        d[3] = d[2] = d[1] = 0;
        d[4] = 0;
        d[5] = Math.cos(b);
        d[6] = Math.sin(b);
        d[7] = 0;
        d[8] = 0;
        d[9] = -Math.sin(b);
        d[10] = Math.cos(b);
        d[11] = 0;
        d[14] = d[13] = d[12] = 0;
        d[15] = 1;
        return c
    };
    a.math.Matrix4.createByRotationY = function(b, c) {
        c = c || new a.math.Matrix4;
        var d = c.mat;
        d[0] = Math.cos(b);
        d[1] = 0;
        d[2] = -Math.sin(b);
        d[3] = 0;
        d[7] = d[6] = d[4] = 0;
        d[5] = 1;
        d[8] = Math.sin(b);
        d[9] = 0;
        d[10] = Math.cos(b);
        d[11] =
            0;
        d[14] = d[13] = d[12] = 0;
        d[15] = 1;
        return c
    };
    a.math.Matrix4.createByRotationZ = function(b, c) {
        c = c || new a.math.Matrix4;
        var d = c.mat;
        d[0] = Math.cos(b);
        d[1] = Math.sin(b);
        d[3] = d[2] = 0;
        d[4] = -Math.sin(b);
        d[5] = Math.cos(b);
        d[7] = d[6] = 0;
        d[11] = d[9] = d[8] = 0;
        d[10] = 1;
        d[14] = d[13] = d[12] = 0;
        d[15] = 1;
        return c
    };
    a.math.Matrix4.createByPitchYawRoll = function(b, c, d, h) {
        h = h || new a.math.Matrix4;
        var k = Math.cos(b);
        b = Math.sin(b);
        var m = Math.cos(c);
        c = Math.sin(c);
        var n = Math.cos(d);
        d = Math.sin(d);
        var p = b * c,
            s = k * c,
            r = h.mat;
        r[0] = m * n;
        r[4] = m * d;
        r[8] = -c;
        r[1] = p * n - k * d;
        r[5] = p * d + k * n;
        r[9] = b * m;
        r[2] = s * n + b * d;
        r[6] = s * d - b * n;
        r[10] = k * m;
        r[3] = r[7] = r[11] = 0;
        r[15] = 1;
        return h
    };
    a.math.Matrix4.createByQuaternion = function(b, c) {
        c = c || new a.math.Matrix4;
        var d = c.mat;
        d[0] = 1 - 2 * (b.y * b.y + b.z * b.z);
        d[1] = 2 * (b.x * b.y + b.z * b.w);
        d[2] = 2 * (b.x * b.z - b.y * b.w);
        d[3] = 0;
        d[4] = 2 * (b.x * b.y - b.z * b.w);
        d[5] = 1 - 2 * (b.x * b.x + b.z * b.z);
        d[6] = 2 * (b.z * b.y + b.x * b.w);
        d[7] = 0;
        d[8] = 2 * (b.x * b.z + b.y * b.w);
        d[9] = 2 * (b.y * b.z - b.x * b.w);
        d[10] = 1 - 2 * (b.x * b.x + b.y * b.y);
        d[11] = 0;
        d[14] = d[13] = d[12] = 0;
        d[15] = 1;
        return c
    };
    a.math.Matrix4.createByRotationTranslation =
        function(b, c, d) {
            d = d || new a.math.Matrix4;
            var h = d.mat;
            b = b.mat;
            h[0] = b[0];
            h[1] = b[1];
            h[2] = b[2];
            h[3] = 0;
            h[4] = b[3];
            h[5] = b[4];
            h[6] = b[5];
            h[7] = 0;
            h[8] = b[6];
            h[9] = b[7];
            h[10] = b[8];
            h[11] = 0;
            h[12] = c.x;
            h[13] = c.y;
            h[14] = c.z;
            h[15] = 1;
            return d
        };
    a.math.Matrix4.createByScale = function(b, c, d, h) {
        h = h || new a.math.Matrix4;
        var k = h.mat;
        k[0] = b;
        k[5] = c;
        k[10] = d;
        k[15] = 1;
        k[1] = k[2] = k[3] = k[4] = k[6] = k[7] = k[8] = k[9] = k[11] = k[12] = k[13] = k[14] = 0;
        return h
    };
    a.kmMat4Translation = function(a, b, c, d) {
        a.mat[0] = a.mat[5] = a.mat[10] = a.mat[15] = 1;
        a.mat[1] = a.mat[2] =
            a.mat[3] = a.mat[4] = a.mat[6] = a.mat[7] = a.mat[8] = a.mat[9] = a.mat[11] = 0;
        a.mat[12] = b;
        a.mat[13] = c;
        a.mat[14] = d;
        return a
    };
    a.math.Matrix4.createByTranslation = function(b, c, d, h) {
        h = h || new a.math.Matrix4;
        h.identity();
        h.mat[12] = b;
        h.mat[13] = c;
        h.mat[14] = d;
        return h
    };
    b.getUpVec3 = function() {
        var b = this.mat;
        return (new a.math.Vec3(b[4], b[5], b[6])).normalize()
    };
    b.getRightVec3 = function() {
        var b = this.mat;
        return (new a.math.Vec3(b[0], b[1], b[2])).normalize()
    };
    b.getForwardVec3 = function() {
        var b = this.mat;
        return (new a.math.Vec3(b[8],
            b[9], b[10])).normalize()
    };
    a.kmMat4PerspectiveProjection = function(b, c, d, h, k) {
        var m = a.degreesToRadians(c / 2);
        c = k - h;
        var n = Math.sin(m);
        if (0 === c || 0 === n || 0 === d) return null;
        m = Math.cos(m) / n;
        b.identity();
        b.mat[0] = m / d;
        b.mat[5] = m;
        b.mat[10] = -(k + h) / c;
        b.mat[11] = -1;
        b.mat[14] = -2 * h * k / c;
        b.mat[15] = 0;
        return b
    };
    a.math.Matrix4.createPerspectiveProjection = function(b, c, d, h) {
        var k = a.degreesToRadians(b / 2);
        b = h - d;
        var m = Math.sin(k);
        if (0 === b || 0 === m || 0 === c) return null;
        var k = Math.cos(k) / m,
            m = new a.math.Matrix4,
            n = m.mat;
        m.identity();
        n[0] = k / c;
        n[5] = k;
        n[10] = -(h + d) / b;
        n[11] = -1;
        n[14] = -2 * d * h / b;
        n[15] = 0;
        return m
    };
    a.kmMat4OrthographicProjection = function(a, b, c, d, k, m, n) {
        a.identity();
        a.mat[0] = 2 / (c - b);
        a.mat[5] = 2 / (k - d);
        a.mat[10] = -2 / (n - m);
        a.mat[12] = -((c + b) / (c - b));
        a.mat[13] = -((k + d) / (k - d));
        a.mat[14] = -((n + m) / (n - m));
        return a
    };
    a.math.Matrix4.createOrthographicProjection = function(b, c, d, h, k, m) {
        var n = new a.math.Matrix4,
            p = n.mat;
        n.identity();
        p[0] = 2 / (c - b);
        p[5] = 2 / (h - d);
        p[10] = -2 / (m - k);
        p[12] = -((c + b) / (c - b));
        p[13] = -((h + d) / (h - d));
        p[14] = -((m + k) / (m - k));
        return n
    };
    a.kmMat4LookAt = function(b, c, d, h) {
        d = new a.math.Vec3(d);
        var k = new a.math.Vec3(h);
        d.subtract(c);
        d.normalize();
        k.normalize();
        h = new a.math.Vec3(d);
        h.cross(k);
        h.normalize();
        k = new a.math.Vec3(h);
        k.cross(d);
        h.normalize();
        b.identity();
        b.mat[0] = h.x;
        b.mat[4] = h.y;
        b.mat[8] = h.z;
        b.mat[1] = k.x;
        b.mat[5] = k.y;
        b.mat[9] = k.z;
        b.mat[2] = -d.x;
        b.mat[6] = -d.y;
        b.mat[10] = -d.z;
        c = a.math.Matrix4.createByTranslation(-c.x, -c.y, -c.z);
        b.multiply(c);
        return b
    };
    var d = new a.math.Matrix4;
    b.lookAt = function(b, c, g) {
        c = new a.math.Vec3(c);
        var h =
            new a.math.Vec3(g);
        g = this.mat;
        c.subtract(b);
        c.normalize();
        h.normalize();
        var k = new a.math.Vec3(c);
        k.cross(h);
        k.normalize();
        h = new a.math.Vec3(k);
        h.cross(c);
        k.normalize();
        this.identity();
        g[0] = k.x;
        g[4] = k.y;
        g[8] = k.z;
        g[1] = h.x;
        g[5] = h.y;
        g[9] = h.z;
        g[2] = -c.x;
        g[6] = -c.y;
        g[10] = -c.z;
        d = a.math.Matrix4.createByTranslation(-b.x, -b.y, -b.z, d);
        this.multiply(d);
        return this
    };
    a.kmMat4RotationAxisAngle = function(b, c, d) {
        var h = Math.cos(d);
        d = Math.sin(d);
        c = new a.math.Vec3(c);
        c.normalize();
        b.mat[0] = h + c.x * c.x * (1 - h);
        b.mat[1] = c.z *
            d + c.y * c.x * (1 - h);
        b.mat[2] = -c.y * d + c.z * c.x * (1 - h);
        b.mat[3] = 0;
        b.mat[4] = -c.z * d + c.x * c.y * (1 - h);
        b.mat[5] = h + c.y * c.y * (1 - h);
        b.mat[6] = c.x * d + c.z * c.y * (1 - h);
        b.mat[7] = 0;
        b.mat[8] = c.y * d + c.x * c.z * (1 - h);
        b.mat[9] = -c.x * d + c.y * c.z * (1 - h);
        b.mat[10] = h + c.z * c.z * (1 - h);
        b.mat[11] = 0;
        b.mat[12] = 0;
        b.mat[13] = 0;
        b.mat[14] = 0;
        b.mat[15] = 1;
        return b
    };
    a.math.Matrix4.createByAxisAndAngle = function(b, c, d) {
        d = d || new a.math.Matrix4;
        var h = this.mat,
            k = Math.cos(c);
        c = Math.sin(c);
        b = new a.math.Vec3(b);
        b.normalize();
        h[0] = k + b.x * b.x * (1 - k);
        h[1] = b.z * c + b.y * b.x *
            (1 - k);
        h[2] = -b.y * c + b.z * b.x * (1 - k);
        h[3] = 0;
        h[4] = -b.z * c + b.x * b.y * (1 - k);
        h[5] = k + b.y * b.y * (1 - k);
        h[6] = b.x * c + b.z * b.y * (1 - k);
        h[7] = 0;
        h[8] = b.y * c + b.x * b.z * (1 - k);
        h[9] = -b.x * c + b.y * b.z * (1 - k);
        h[10] = k + b.z * b.z * (1 - k);
        h[11] = 0;
        h[12] = h[13] = h[14] = 0;
        h[15] = 1;
        return d
    };
    b.extractRotation = function() {
        var b = new a.math.Matrix3,
            c = this.mat,
            d = b.mat;
        d[0] = c[0];
        d[1] = c[1];
        d[2] = c[2];
        d[3] = c[4];
        d[4] = c[5];
        d[5] = c[6];
        d[6] = c[8];
        d[7] = c[9];
        d[8] = c[10];
        return b
    };
    b.extractPlane = function(b) {
        var c = new a.math.Plane,
            d = this.mat;
        switch (b) {
            case a.math.Plane.RIGHT:
                c.a =
                    d[3] - d[0];
                c.b = d[7] - d[4];
                c.c = d[11] - d[8];
                c.d = d[15] - d[12];
                break;
            case a.math.Plane.LEFT:
                c.a = d[3] + d[0];
                c.b = d[7] + d[4];
                c.c = d[11] + d[8];
                c.d = d[15] + d[12];
                break;
            case a.math.Plane.BOTTOM:
                c.a = d[3] + d[1];
                c.b = d[7] + d[5];
                c.c = d[11] + d[9];
                c.d = d[15] + d[13];
                break;
            case a.math.Plane.TOP:
                c.a = d[3] - d[1];
                c.b = d[7] - d[5];
                c.c = d[11] - d[9];
                c.d = d[15] - d[13];
                break;
            case a.math.Plane.FAR:
                c.a = d[3] - d[2];
                c.b = d[7] - d[6];
                c.c = d[11] - d[10];
                c.d = d[15] - d[14];
                break;
            case a.math.Plane.NEAR:
                c.a = d[3] + d[2];
                c.b = d[7] + d[6];
                c.c = d[11] + d[10];
                c.d = d[15] + d[14];
                break;
            default:
                a.log("cc.math.Matrix4.extractPlane: Invalid plane index")
        }
        b = Math.sqrt(c.a * c.a + c.b * c.b + c.c * c.c);
        c.a /= b;
        c.b /= b;
        c.c /= b;
        c.d /= b;
        return c
    };
    b.toAxisAndAngle = function() {
        var b = this.extractRotation();
        return a.math.Quaternion.rotationMatrix(b).toAxisAndAngle()
    }
})(cc);
(function(a) {
    a.math.Plane = function(a, b, e, f) {
        a && void 0 === b ? (this.a = a.a, this.b = a.b, this.c = a.c, this.d = a.d) : (this.a = a || 0, this.b = b || 0, this.c = e || 0, this.d = f || 0)
    };
    a.kmPlane = a.math.Plane;
    var b = a.math.Plane.prototype;
    a.math.Plane.LEFT = 0;
    a.math.Plane.RIGHT = 1;
    a.math.Plane.BOTTOM = 2;
    a.math.Plane.TOP = 3;
    a.math.Plane.NEAR = 4;
    a.math.Plane.FAR = 5;
    a.math.Plane.POINT_INFRONT_OF_PLANE = 0;
    a.math.Plane.POINT_BEHIND_PLANE = 1;
    a.math.Plane.POINT_ON_PLANE = 2;
    b.dot = function(a) {
        return this.a * a.x + this.b * a.y + this.c * a.z + this.d * a.w
    };
    b.dotCoord =
        function(a) {
            return this.a * a.x + this.b * a.y + this.c * a.z + this.d
        };
    b.dotNormal = function(a) {
        return this.a * a.x + this.b * a.y + this.c * a.z
    };
    a.math.Plane.fromPointNormal = function(b, d) {
        return new a.math.Plane(d.x, d.y, d.z, -d.dot(b))
    };
    a.math.Plane.fromPoints = function(b, d, e) {
        d = new a.math.Vec3(d);
        e = new a.math.Vec3(e);
        var f = new a.math.Plane;
        d.subtract(b);
        e.subtract(b);
        d.cross(e);
        d.normalize();
        f.a = d.x;
        f.b = d.y;
        f.c = d.z;
        f.d = d.scale(-1).dot(b);
        return f
    };
    b.normalize = function() {
        var b = new a.math.Vec3(this.a, this.b, this.c),
            d = 1 /
            b.length();
        b.normalize();
        this.a = b.x;
        this.b = b.y;
        this.c = b.z;
        this.d *= d;
        return this
    };
    b.classifyPoint = function(b) {
        b = this.a * b.x + this.b * b.y + this.c * b.z + this.d;
        return 0.001 < b ? a.math.Plane.POINT_INFRONT_OF_PLANE : -0.001 > b ? a.math.Plane.POINT_BEHIND_PLANE : a.math.Plane.POINT_ON_PLANE
    }
})(cc);
(function(a) {
    a.math.Quaternion = function(a, b, e, f) {
        a && void 0 === b ? (this.x = a.x, this.y = a.y, this.z = a.z, this.w = a.w) : (this.x = a || 0, this.y = b || 0, this.z = e || 0, this.w = f || 0)
    };
    a.kmQuaternion = a.math.Quaternion;
    var b = a.math.Quaternion.prototype;
    b.conjugate = function(a) {
        this.x = -a.x;
        this.y = -a.y;
        this.z = -a.z;
        this.w = a.w;
        return this
    };
    b.dot = function(a) {
        return this.w * a.w + this.x * a.x + this.y * a.y + this.z * a.z
    };
    b.exponential = function() {
        return this
    };
    b.identity = function() {
        this.z = this.y = this.x = 0;
        this.w = 1;
        return this
    };
    b.inverse = function() {
        var b =
            this.length();
        if (Math.abs(b) > a.math.EPSILON) return this.w = this.z = this.y = this.x = 0, this;
        this.conjugate(this).scale(1 / b);
        return this
    };
    b.isIdentity = function() {
        return 0 === this.x && 0 === this.y && 0 === this.z && 1 === this.w
    };
    b.length = function() {
        return Math.sqrt(this.lengthSq())
    };
    b.lengthSq = function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    };
    b.multiply = function(a) {
        var b = this.x,
            e = this.y,
            f = this.z,
            g = this.w;
        this.w = g * a.w - b * a.x - e * a.y - f * a.z;
        this.x = g * a.x + b * a.w + e * a.z - f * a.y;
        this.y = g * a.y + e * a.w + f * a.x -
            b * a.z;
        this.z = g * a.z + f * a.w + b * a.y - e * a.x;
        return this
    };
    b.normalize = function() {
        var b = this.length();
        if (Math.abs(b) <= a.math.EPSILON) throw Error("current quaternion is an invalid value");
        this.scale(1 / b);
        return this
    };
    b.rotationAxis = function(a, b) {
        var e = 0.5 * b,
            f = Math.sin(e);
        this.w = Math.cos(e);
        this.x = a.x * f;
        this.y = a.y * f;
        this.z = a.z * f;
        return this
    };
    a.math.Quaternion.rotationMatrix = function(b) {
        if (!b) return null;
        var d, e, f;
        d = [];
        e = b.mat;
        b = 0;
        d[0] = e[0];
        d[1] = e[3];
        d[2] = e[6];
        d[4] = e[1];
        d[5] = e[4];
        d[6] = e[7];
        d[8] = e[2];
        d[9] = e[5];
        d[10] = e[8];
        d[15] = 1;
        var g = d[0];
        b = g[0] + g[5] + g[10] + 1;
        b > a.math.EPSILON ? (b = 2 * Math.sqrt(b), d = (g[9] - g[6]) / b, e = (g[2] - g[8]) / b, f = (g[4] - g[1]) / b, b *= 0.25) : g[0] > g[5] && g[0] > g[10] ? (b = 2 * Math.sqrt(1 + g[0] - g[5] - g[10]), d = 0.25 * b, e = (g[4] + g[1]) / b, f = (g[2] + g[8]) / b, b = (g[9] - g[6]) / b) : g[5] > g[10] ? (b = 2 * Math.sqrt(1 + g[5] - g[0] - g[10]), d = (g[4] + g[1]) / b, e = 0.25 * b, f = (g[9] + g[6]) / b, b = (g[2] - g[8]) / b) : (b = 2 * Math.sqrt(1 + g[10] - g[0] - g[5]), d = (g[2] + g[8]) / b, e = (g[9] + g[6]) / b, f = 0.25 * b, b = (g[4] - g[1]) / b);
        return new a.math.Quaternion(d, e, f, b)
    };
    a.math.Quaternion.rotationYawPitchRoll =
        function(b, d, e) {
            var f, g, h, k, m;
            f = a.degreesToRadians(d) / 2;
            g = a.degreesToRadians(b) / 2;
            h = a.degreesToRadians(e) / 2;
            e = Math.cos(f);
            b = Math.cos(g);
            d = Math.cos(h);
            f = Math.sin(f);
            g = Math.sin(g);
            h = Math.sin(h);
            k = b * d;
            m = g * h;
            var n = new a.math.Quaternion;
            n.w = e * k + f * m;
            n.x = f * k - e * m;
            n.y = e * g * d + f * b * h;
            n.z = e * b * h - f * g * d;
            n.normalize();
            return n
        };
    b.slerp = function(b, d) {
        if (this.x === b.x && this.y === b.y && this.z === b.z && this.w === b.w) return this;
        var e = this.dot(b),
            f = Math.acos(e),
            g = Math.sqrt(1 - a.math.square(e)),
            e = Math.sin(d * f) / g,
            f = Math.sin((1 -
                d) * f) / g,
            g = new a.math.Quaternion(b);
        this.scale(f);
        g.scale(e);
        this.add(g);
        return this
    };
    b.toAxisAndAngle = function() {
        var b, d, e = new a.math.Vec3;
        b = Math.acos(this.w);
        d = Math.sqrt(a.math.square(this.x) + a.math.square(this.y) + a.math.square(this.z));
        d > -a.math.EPSILON && d < a.math.EPSILON || d < 2 * Math.PI + a.math.EPSILON && d > 2 * Math.PI - a.math.EPSILON ? (b = 0, e.x = 0, e.y = 0, e.z = 1) : (b *= 2, e.x = this.x / d, e.y = this.y / d, e.z = this.z / d, e.normalize());
        return {
            axis: e,
            angle: b
        }
    };
    b.scale = function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    };
    b.assignFrom = function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = a.w;
        return this
    };
    b.add = function(a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    };
    a.math.Quaternion.rotationBetweenVec3 = function(b, d, e) {
        var f = new a.math.Vec3(b),
            g = new a.math.Vec3(d);
        f.normalize();
        g.normalize();
        var h = f.dot(g);
        d = new a.math.Quaternion;
        if (1 <= h) return d.identity(), d; - 0.999999 > h ? Math.abs(e.lengthSq()) < a.math.EPSILON ? d.rotationAxis(e, Math.PI) : (f = new a.math.Vec3(1, 0, 0), f.cross(b), Math.abs(f.lengthSq()) < a.math.EPSILON &&
            (f.fill(0, 1, 0), f.cross(b)), f.normalize(), d.rotationAxis(f, Math.PI)) : (b = Math.sqrt(2 * (1 + h)), e = 1 / b, f.cross(g), d.x = f.x * e, d.y = f.y * e, d.z = f.z * e, d.w = 0.5 * b, d.normalize());
        return d
    };
    b.multiplyVec3 = function(b) {
        var d = this.x,
            e = this.y,
            f = this.z,
            g = new a.math.Vec3(b),
            h = new a.math.Vec3(d, e, f),
            d = new a.math.Vec3(d, e, f);
        h.cross(b);
        d.cross(h);
        h.scale(2 * q.w);
        d.scale(2);
        g.add(h);
        g.add(d);
        return g
    }
})(cc);
cc.math.AABB = function(a, b) {
    this.min = a || new cc.math.Vec3;
    this.max = b || new cc.math.Vec3
};
cc.math.AABB.prototype.containsPoint = function(a) {
    return a.x >= this.min.x && a.x <= this.max.x && a.y >= this.min.y && a.y <= this.max.y && a.z >= this.min.z && a.z <= this.max.z
};
cc.math.AABB.containsPoint = function(a, b) {
    return a.x >= b.min.x && a.x <= b.max.x && a.y >= b.min.y && a.y <= b.max.y && a.z >= b.min.z && a.z <= b.max.z
};
cc.math.AABB.prototype.assignFrom = function(a) {
    this.min.assignFrom(a.min);
    this.max.assignFrom(a.max)
};
cc.math.AABB.assign = function(a, b) {
    a.min.assignFrom(b.min);
    a.max.assignFrom(b.max);
    return a
};
(function(a) {
    a.math.Matrix4Stack = function(a, b) {
        this.top = a;
        this.stack = b || []
    };
    a.km_mat4_stack = a.math.Matrix4Stack;
    var b = a.math.Matrix4Stack.prototype;
    b.initialize = function() {
        this.stack.length = 0;
        this.top = null
    };
    a.km_mat4_stack_push = function(b, d) {
        b.stack.push(b.top);
        b.top = new a.math.Matrix4(d)
    };
    a.km_mat4_stack_pop = function(a, b) {
        a.top = a.stack.pop()
    };
    a.km_mat4_stack_release = function(a) {
        a.stack = null;
        a.top = null
    };
    b.push = function(b) {
        b = b || this.top;
        this.stack.push(this.top);
        this.top = new a.math.Matrix4(b)
    };
    b.pop =
        function() {
            this.top = this.stack.pop()
        };
    b.release = function() {
        this._matrixPool = this.top = this.stack = null
    };
    b._getFromPool = function(b) {
        var d = this._matrixPool;
        if (0 === d.length) return new a.math.Matrix4(b);
        d = d.pop();
        d.assignFrom(b);
        return d
    };
    b._putInPool = function(a) {
        this._matrixPool.push(a)
    }
})(cc);
(function(a) {
    a.KM_GL_MODELVIEW = 5888;
    a.KM_GL_PROJECTION = 5889;
    a.KM_GL_TEXTURE = 5890;
    a.modelview_matrix_stack = new a.math.Matrix4Stack;
    a.projection_matrix_stack = new a.math.Matrix4Stack;
    a.texture_matrix_stack = new a.math.Matrix4Stack;
    a.current_stack = null;
    a.lazyInitialize = function() {
        var b = new a.math.Matrix4;
        a.modelview_matrix_stack.initialize();
        a.projection_matrix_stack.initialize();
        a.texture_matrix_stack.initialize();
        a.current_stack = a.modelview_matrix_stack;
        a.initialized = !0;
        b.identity();
        a.modelview_matrix_stack.push(b);
        a.projection_matrix_stack.push(b);
        a.texture_matrix_stack.push(b)
    };
    a.lazyInitialize();
    a.kmGLFreeAll = function() {
        a.modelview_matrix_stack.release();
        a.modelview_matrix_stack = null;
        a.projection_matrix_stack.release();
        a.projection_matrix_stack = null;
        a.texture_matrix_stack.release();
        a.texture_matrix_stack = null;
        a.initialized = !1;
        a.current_stack = null
    };
    a.kmGLPushMatrix = function() {
        a.current_stack.push(a.current_stack.top)
    };
    a.kmGLPushMatrixWitMat4 = function(b) {
        a.current_stack.stack.push(a.current_stack.top);
        b.assignFrom(a.current_stack.top);
        a.current_stack.top = b
    };
    a.kmGLPopMatrix = function() {
        a.current_stack.top = a.current_stack.stack.pop()
    };
    a.kmGLMatrixMode = function(b) {
        switch (b) {
            case a.KM_GL_MODELVIEW:
                a.current_stack = a.modelview_matrix_stack;
                break;
            case a.KM_GL_PROJECTION:
                a.current_stack = a.projection_matrix_stack;
                break;
            case a.KM_GL_TEXTURE:
                a.current_stack = a.texture_matrix_stack;
                break;
            default:
                throw Error("Invalid matrix mode specified");
        }
    };
    a.kmGLLoadIdentity = function() {
        a.current_stack.top.identity()
    };
    a.kmGLLoadMatrix = function(b) {
        a.current_stack.top.assignFrom(b)
    };
    a.kmGLMultMatrix = function(b) {
        a.current_stack.top.multiply(b)
    };
    var b = new a.math.Matrix4;
    a.kmGLTranslatef = function(c, e, f) {
        c = a.math.Matrix4.createByTranslation(c, e, f, b);
        a.current_stack.top.multiply(c)
    };
    var c = new a.math.Vec3;
    a.kmGLRotatef = function(d, e, f, g) {
        c.fill(e, f, g);
        d = a.math.Matrix4.createByAxisAndAngle(c, a.degreesToRadians(d), b);
        a.current_stack.top.multiply(d)
    };
    a.kmGLScalef = function(c, e, f) {
        c = a.math.Matrix4.createByScale(c, e, f, b);
        a.current_stack.top.multiply(c)
    };
    a.kmGLGetMatrix = function(b, c) {
        switch (b) {
            case a.KM_GL_MODELVIEW:
                c.assignFrom(a.modelview_matrix_stack.top);
                break;
            case a.KM_GL_PROJECTION:
                c.assignFrom(a.projection_matrix_stack.top);
                break;
            case a.KM_GL_TEXTURE:
                c.assignFrom(a.texture_matrix_stack.top);
                break;
            default:
                throw Error("Invalid matrix mode specified");
        }
    }
})(cc);
cc.SHADER_POSITION_UCOLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()                              \n{ \n    gl_FragColor \x3d v_fragmentColor;      \n}\n";
cc.SHADER_POSITION_UCOLOR_VERT = "attribute vec4 a_position;\nuniform    vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor; \nvoid main(void)   \n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    gl_PointSize \x3d u_pointSize;          \n    v_fragmentColor \x3d u_color;           \n}";
cc.SHADER_POSITION_COLOR_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvoid main() \n{ \n     gl_FragColor \x3d v_fragmentColor; \n} ";
cc.SHADER_POSITION_COLOR_VERT = "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color;             \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG = "// #extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\t\n{ \n// #if defined GL_OES_standard_derivatives\t\n// gl_FragColor \x3d v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0 - length(v_texcoord)); \n// #else\t\ngl_FragColor \x3d v_color * step(0.0, 1.0 - length(v_texcoord)); \n// #endif \n}";
cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT = "attribute mediump vec4 a_position; \nattribute mediump vec2 a_texcoord; \nattribute mediump vec4 a_color;\t\nvarying mediump vec4 v_color; \nvarying mediump vec2 v_texcoord;\t\nvoid main() \n{ \n     v_color \x3d a_color;//vec4(a_color.rgb * a_color.a, a_color.a); \n     v_texcoord \x3d a_texcoord; \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n}";
cc.SHADER_POSITION_TEXTURE_FRAG = "precision lowp float;   \nvarying vec2 v_texCoord;  \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord);   \n}";
cc.SHADER_POSITION_TEXTURE_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;               \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG = "precision lowp float;  \nuniform vec4 u_color; \nvarying vec2 v_texCoord; \nvoid main() \n{  \n    gl_FragColor \x3d  texture2D(CC_Texture0, v_texCoord) * u_color;    \n}";
cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT = "attribute vec4 a_position;\nattribute vec2 a_texCoord; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_texCoord \x3d a_texCoord;                 \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG = "precision lowp float;  \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor \x3d vec4( v_fragmentColor.rgb,         \n        v_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a   \n    ); \n}";
cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_FRAG = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    gl_FragColor \x3d v_fragmentColor * texture2D(CC_Texture0, v_texCoord); \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_VERT = "attribute vec4 a_position; \nattribute vec2 a_texCoord; \nattribute vec4 a_color;  \nvarying lowp vec4 v_fragmentColor; \nvarying mediump vec2 v_texCoord; \nvoid main() \n{ \n    gl_Position \x3d (CC_PMatrix * CC_MVMatrix) * a_position;  \n    v_fragmentColor \x3d a_color; \n    v_texCoord \x3d a_texCoord; \n}";
cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG = "precision lowp float;   \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord;   \nuniform float CC_alpha_value; \nvoid main() \n{  \n    vec4 texColor \x3d texture2D(CC_Texture0, v_texCoord);  \n    if ( texColor.a \x3c\x3d CC_alpha_value )          \n        discard; \n    gl_FragColor \x3d texColor * v_fragmentColor;  \n}";
cc.SHADEREX_SWITCHMASK_FRAG = "precision lowp float; \nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nuniform sampler2D u_texture;  \nuniform sampler2D   u_mask;   \nvoid main()  \n{  \n    vec4 texColor   \x3d texture2D(u_texture, v_texCoord);  \n    vec4 maskColor  \x3d texture2D(u_mask, v_texCoord); \n    vec4 finalColor \x3d vec4(texColor.r, texColor.g, texColor.b, maskColor.a * texColor.a);        \n    gl_FragColor    \x3d v_fragmentColor * finalColor; \n}";
cc.shaderCache = {
    TYPE_POSITION_TEXTURECOLOR: 0,
    TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
    TYPE_POSITION_COLOR: 2,
    TYPE_POSITION_TEXTURE: 3,
    TYPE_POSITION_TEXTURE_UCOLOR: 4,
    TYPE_POSITION_TEXTURE_A8COLOR: 5,
    TYPE_POSITION_UCOLOR: 6,
    TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
    TYPE_MAX: 8,
    _programs: {},
    _init: function() {
        this.loadDefaultShaders();
        return !0
    },
    _loadDefaultShader: function(a, b) {
        switch (b) {
            case this.TYPE_POSITION_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, cc.SHADER_POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_VERT, cc.SHADER_POSITION_COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            case this.TYPE_POSITION_TEXTURE:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_VERT, cc.SHADER_POSITION_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION,
                    cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_UCOLOR_VERT, cc.SHADER_POSITION_TEXTURE_UCOLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_TEXTURE_A8COLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_A8COLOR_VERT,
                    cc.SHADER_POSITION_TEXTURE_A8COLOR_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                break;
            case this.TYPE_POSITION_UCOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_UCOLOR_VERT, cc.SHADER_POSITION_UCOLOR_FRAG);
                a.addAttribute("aVertex", cc.VERTEX_ATTRIB_POSITION);
                break;
            case this.TYPE_POSITION_LENGTH_TEXTURECOLOR:
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_VERT,
                    cc.SHADER_POSITION_COLOR_LENGTH_TEXTURE_FRAG);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                break;
            default:
                cc.log("cocos2d: cc.shaderCache._loadDefaultShader, error shader type");
                return
        }
        a.link();
        a.updateUniforms()
    },
    loadDefaultShaders: function() {
        var a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURECOLOR] =
            a;
        this._programs.ShaderPositionTextureColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        this._programs[cc.SHADER_POSITION_TEXTURECOLORALPHATEST] = a;
        this._programs.ShaderPositionTextureColorAlphaTest = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        this._programs[cc.SHADER_POSITION_COLOR] = a;
        this._programs.ShaderPositionColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        this._programs[cc.SHADER_POSITION_TEXTURE] =
            a;
        this._programs.ShaderPositionTexture = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        this._programs[cc.SHADER_POSITION_TEXTURE_UCOLOR] = a;
        this._programs.ShaderPositionTextureUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        this._programs[cc.SHADER_POSITION_TEXTUREA8COLOR] = a;
        this._programs.ShaderPositionTextureA8Color = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR);
        this._programs[cc.SHADER_POSITION_UCOLOR] =
            a;
        this._programs.ShaderPositionUColor = a;
        a = new cc.GLProgram;
        this._loadDefaultShader(a, this.TYPE_POSITION_LENGTH_TEXTURECOLOR);
        this._programs[cc.SHADER_POSITION_LENGTHTEXTURECOLOR] = a;
        this._programs.ShaderPositionLengthTextureColor = a
    },
    reloadDefaultShaders: function() {
        var a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURECOLOR_ALPHATEST);
        a = this.programForKey(cc.SHADER_POSITION_COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_COLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE);
        a = this.programForKey(cc.SHADER_POSITION_TEXTURE_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_UCOLOR);
        a = this.programForKey(cc.SHADER_POSITION_TEXTUREA8COLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_TEXTURE_A8COLOR);
        a = this.programForKey(cc.SHADER_POSITION_UCOLOR);
        a.reset();
        this._loadDefaultShader(a, this.TYPE_POSITION_UCOLOR)
    },
    programForKey: function(a) {
        return this._programs[a]
    },
    getProgram: function(a) {
        return this._programs[a]
    },
    addProgram: function(a, b) {
        this._programs[b] = a
    }
};
cc.HashUniformEntry = function(a, b, c) {
    this.value = a;
    this.location = b;
    this.hh = c || {}
};
cc.GLProgram = cc.Class.extend({
    _glContext: null,
    _programObj: null,
    _vertShader: null,
    _fragShader: null,
    _uniforms: null,
    _hashForUniforms: null,
    _usesTime: !1,
    _updateUniformLocation: function(a, b, c) {
        if (null == a) return !1;
        c = !0;
        for (var d = null, e = 0; e < this._hashForUniforms.length; e++) this._hashForUniforms[e].location == a && (d = this._hashForUniforms[e]);
        d ? d.value == b ? c = !1 : d.value = b : (d = new cc.HashUniformEntry, d.location = a, d.value = b, this._hashForUniforms.push(d));
        return c
    },
    _description: function() {
        return "\x3cCCGLProgram \x3d " +
            this.toString() + " | Program \x3d " + this._programObj.toString() + ", VertexShader \x3d " + this._vertShader.toString() + ", FragmentShader \x3d " + this._fragShader.toString() + "\x3e"
    },
    _compileShader: function(a, b, c) {
        if (!c || !a) return !1;
        c = (cc.GLProgram._isHighpSupported() ? "precision highp float;\n" : "precision mediump float;\n") + "uniform mat4 CC_PMatrix;         \nuniform mat4 CC_MVMatrix;        \nuniform mat4 CC_MVPMatrix;       \nuniform vec4 CC_Time;            \nuniform vec4 CC_SinTime;         \nuniform vec4 CC_CosTime;         \nuniform vec4 CC_Random01;        \nuniform sampler2D CC_Texture0;   \n//CC INCLUDES END                \n" +
            c;
        this._glContext.shaderSource(a, c);
        this._glContext.compileShader(a);
        c = this._glContext.getShaderParameter(a, this._glContext.COMPILE_STATUS);
        c || (cc.log("cocos2d: ERROR: Failed to compile shader:\n" + this._glContext.getShaderSource(a)), b === this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog()));
        return !0 === c
    },
    ctor: function(a, b, c) {
        this._uniforms = [];
        this._hashForUniforms = [];
        this._glContext = c || cc._renderContext;
        a && b && this.init(a, b)
    },
    destroyProgram: function() {
        this._hashForUniforms =
            this._uniforms = this._fragShader = this._vertShader = null;
        this._glContext.deleteProgram(this._programObj)
    },
    initWithVertexShaderByteArray: function(a, b) {
        var c = this._glContext;
        this._programObj = c.createProgram();
        this._fragShader = this._vertShader = null;
        a && (this._vertShader = c.createShader(c.VERTEX_SHADER), this._compileShader(this._vertShader, c.VERTEX_SHADER, a) || cc.log("cocos2d: ERROR: Failed to compile vertex shader"));
        b && (this._fragShader = c.createShader(c.FRAGMENT_SHADER), this._compileShader(this._fragShader,
            c.FRAGMENT_SHADER, b) || cc.log("cocos2d: ERROR: Failed to compile fragment shader"));
        this._vertShader && c.attachShader(this._programObj, this._vertShader);
        cc.checkGLErrorDebug();
        this._fragShader && c.attachShader(this._programObj, this._fragShader);
        this._hashForUniforms.length = 0;
        cc.checkGLErrorDebug();
        return !0
    },
    initWithString: function(a, b) {
        return this.initWithVertexShaderByteArray(a, b)
    },
    initWithVertexShaderFilename: function(a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw Error("Please load the resource firset : " +
            a);
        var d = cc.loader.getRes(b);
        if (!d) throw Error("Please load the resource firset : " + b);
        return this.initWithVertexShaderByteArray(c, d)
    },
    init: function(a, b) {
        return this.initWithVertexShaderFilename(a, b)
    },
    addAttribute: function(a, b) {
        this._glContext.bindAttribLocation(this._programObj, b, a)
    },
    link: function() {
        if (!this._programObj) return cc.log("cc.GLProgram.link(): Cannot link invalid program"), !1;
        this._glContext.linkProgram(this._programObj);
        this._vertShader && this._glContext.deleteShader(this._vertShader);
        this._fragShader && this._glContext.deleteShader(this._fragShader);
        this._fragShader = this._vertShader = null;
        return cc.game.config[cc.game.CONFIG_KEY.debugMode] && !this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS) ? (cc.log("cocos2d: ERROR: Failed to link program: " + this._glContext.getProgramInfoLog(this._programObj)), cc.glDeleteProgram(this._programObj), this._programObj = null, !1) : !0
    },
    use: function() {
        cc.glUseProgram(this._programObj)
    },
    updateUniforms: function() {
        this._uniforms[cc.UNIFORM_PMATRIX] =
            this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_PMATRIX_S);
        this._uniforms[cc.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVMATRIX_S);
        this._uniforms[cc.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_MVPMATRIX_S);
        this._uniforms[cc.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_TIME_S);
        this._uniforms[cc.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SINTIME_S);
        this._uniforms[cc.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_COSTIME_S);
        this._usesTime = null != this._uniforms[cc.UNIFORM_TIME] || null != this._uniforms[cc.UNIFORM_SINTIME] || null != this._uniforms[cc.UNIFORM_COSTIME];
        this._uniforms[cc.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_RANDOM01_S);
        this._uniforms[cc.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, cc.UNIFORM_SAMPLER_S);
        this.use();
        this.setUniformLocationWith1i(this._uniforms[cc.UNIFORM_SAMPLER],
            0)
    },
    getUniformLocationForName: function(a) {
        if (!a) throw Error("cc.GLProgram.getUniformLocationForName(): uniform name should be non-null");
        if (!this._programObj) throw Error("cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized");
        return this._glContext.getUniformLocation(this._programObj, a)
    },
    getUniformMVPMatrix: function() {
        return this._uniforms[cc.UNIFORM_MVPMATRIX]
    },
    getUniformSampler: function() {
        return this._uniforms[cc.UNIFORM_SAMPLER]
    },
    setUniformLocationWith1i: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1i(a, b)
    },
    setUniformLocationWith2i: function(a, b, c) {
        this._updateUniformLocation(a, [b, c]) && this._glContext.uniform2i(a, b, c)
    },
    setUniformLocationWith3i: function(a, b, c, d) {
        this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3i(a, b, c, d)
    },
    setUniformLocationWith4i: function(a, b, c, d, e) {
        this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4i(a, b, c, d, e)
    },
    setUniformLocationWith2iv: function(a, b,
        c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform2iv(a, b)
    },
    setUniformLocationWith3iv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform3iv(a, b)
    },
    setUniformLocationWith4iv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4iv(a, b)
    },
    setUniformLocationI32: function(a, b) {
        this.setUniformLocationWith1i(a, b)
    },
    setUniformLocationWith1f: function(a, b) {
        this._updateUniformLocation(a, b) && this._glContext.uniform1f(a, b)
    },
    setUniformLocationWith2f: function(a,
        b, c) {
        this._updateUniformLocation(a, [b, c]) && this._glContext.uniform2f(a, b, c)
    },
    setUniformLocationWith3f: function(a, b, c, d) {
        this._updateUniformLocation(a, [b, c, d]) && this._glContext.uniform3f(a, b, c, d)
    },
    setUniformLocationWith4f: function(a, b, c, d, e) {
        this._updateUniformLocation(a, [b, c, d, e]) && this._glContext.uniform4f(a, b, c, d, e)
    },
    setUniformLocationWith2fv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform2fv(a, b)
    },
    setUniformLocationWith3fv: function(a, b, c) {
        this._updateUniformLocation(a,
            b) && this._glContext.uniform3fv(a, b)
    },
    setUniformLocationWith4fv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniform4fv(a, b)
    },
    setUniformLocationWithMatrix4fv: function(a, b, c) {
        this._updateUniformLocation(a, b) && this._glContext.uniformMatrix4fv(a, !1, b)
    },
    setUniformLocationF32: function() {
        if (!(2 > arguments.length)) switch (arguments.length) {
            case 2:
                this.setUniformLocationWith1f(arguments[0], arguments[1]);
                break;
            case 3:
                this.setUniformLocationWith2f(arguments[0], arguments[1], arguments[2]);
                break;
            case 4:
                this.setUniformLocationWith3f(arguments[0], arguments[1], arguments[2], arguments[3]);
                break;
            case 5:
                this.setUniformLocationWith4f(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4])
        }
    },
    setUniformsForBuiltins: function() {
        var a = new cc.math.Matrix4,
            b = new cc.math.Matrix4,
            c = new cc.math.Matrix4;
        cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, a);
        cc.kmGLGetMatrix(cc.KM_GL_MODELVIEW, b);
        cc.kmMat4Multiply(c, a, b);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], a.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX],
            b.mat, 1);
        this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], c.mat, 1);
        this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 !== this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01],
            Math.random(), Math.random(), Math.random(), Math.random())
    },
    _setUniformsForBuiltinsForRenderer: function(a) {
        if (a && a._renderCmd) {
            var b = new cc.math.Matrix4,
                c = new cc.math.Matrix4;
            cc.kmGLGetMatrix(cc.KM_GL_PROJECTION, b);
            cc.kmMat4Multiply(c, b, a._renderCmd._stackMatrix);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], b.mat, 1);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], a._renderCmd._stackMatrix.mat, 1);
            this.setUniformLocationWithMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX],
                c.mat, 1);
            this._usesTime && (a = cc.director, a = a.getTotalFrames() * a.getAnimationInterval(), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_TIME], a / 10, a, 2 * a, 4 * a), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_SINTIME], a / 8, a / 4, a / 2, Math.sin(a)), this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_COSTIME], a / 8, a / 4, a / 2, Math.cos(a))); - 1 !== this._uniforms[cc.UNIFORM_RANDOM01] && this.setUniformLocationWith4f(this._uniforms[cc.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random())
        }
    },
    setUniformForModelViewProjectionMatrix: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, cc.getMat4MultiplyValue(cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top))
    },
    setUniformForModelViewProjectionMatrixWithMat4: function(a) {
        cc.kmMat4Multiply(a, cc.projection_matrix_stack.top, cc.modelview_matrix_stack.top);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVPMATRIX], !1, a.mat)
    },
    setUniformForModelViewAndProjectionMatrixWithMat4: function() {
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, cc.modelview_matrix_stack.top.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    _setUniformForMVPMatrixWithMat4: function(a) {
        if (!a) throw Error("modelView matrix is undefined.");
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_MVMATRIX], !1, a.mat);
        this._glContext.uniformMatrix4fv(this._uniforms[cc.UNIFORM_PMATRIX], !1, cc.projection_matrix_stack.top.mat)
    },
    vertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getVertexShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    getFragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._vertShader)
    },
    fragmentShaderLog: function() {
        return this._glContext.getShaderInfoLog(this._fragShader)
    },
    programLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    getProgramLog: function() {
        return this._glContext.getProgramInfoLog(this._programObj)
    },
    reset: function() {
        this._fragShader = this._vertShader = null;
        this._uniforms.length =
            0;
        this._glContext.deleteProgram(this._programObj);
        this._programObj = null;
        for (var a = 0; a < this._hashForUniforms.length; a++) this._hashForUniforms[a].value = null, this._hashForUniforms[a] = null;
        this._hashForUniforms.length = 0
    },
    getProgram: function() {
        return this._programObj
    },
    retain: function() {},
    release: function() {}
});
cc.GLProgram.create = function(a, b) {
    return new cc.GLProgram(a, b)
};
cc.GLProgram._highpSupported = null;
cc.GLProgram._isHighpSupported = function() {
    if (null == cc.GLProgram._highpSupported) {
        var a = cc._renderContext,
            a = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
        cc.GLProgram._highpSupported = 0 !== a.precision
    }
    return cc.GLProgram._highpSupported
};
cc.setProgram = function(a, b) {
    a.shaderProgram = b;
    var c = a.children;
    if (c)
        for (var d = 0; d < c.length; d++) cc.setProgram(c[d], b)
};
cc._currentProjectionMatrix = -1;
cc._vertexAttribPosition = !1;
cc._vertexAttribColor = !1;
cc._vertexAttribTexCoords = !1;
cc.ENABLE_GL_STATE_CACHE && (cc.MAX_ACTIVETEXTURE = 16, cc._currentShaderProgram = -1, cc._currentBoundTexture = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1], cc._blendingSource = -1, cc._blendingDest = -1, cc._GLServerState = 0, cc.TEXTURE_ATLAS_USE_VAO && (cc._uVAO = 0));
cc.glInvalidateStateCache = function() {
    cc.kmGLFreeAll();
    cc._currentProjectionMatrix = -1;
    cc._vertexAttribPosition = !1;
    cc._vertexAttribColor = !1;
    cc._vertexAttribTexCoords = !1;
    if (cc.ENABLE_GL_STATE_CACHE) {
        cc._currentShaderProgram = -1;
        for (var a = 0; a < cc.MAX_ACTIVETEXTURE; a++) cc._currentBoundTexture[a] = -1;
        cc._blendingSource = -1;
        cc._blendingDest = -1;
        cc._GLServerState = 0
    }
};
cc.glUseProgram = function(a) {
    a !== cc._currentShaderProgram && (cc._currentShaderProgram = a, cc._renderContext.useProgram(a))
};
cc.ENABLE_GL_STATE_CACHE || (cc.glUseProgram = function(a) {
    cc._renderContext.useProgram(a)
});
cc.glDeleteProgram = function(a) {
    cc.ENABLE_GL_STATE_CACHE && a === cc._currentShaderProgram && (cc._currentShaderProgram = -1);
    gl.deleteProgram(a)
};
cc.glBlendFunc = function(a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) cc._blendingSource = a, cc._blendingDest = b, cc.setBlending(a, b)
};
cc.setBlending = function(a, b) {
    var c = cc._renderContext;
    a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), cc._renderContext.blendFunc(a, b))
};
cc.glBlendFuncForParticle = function(a, b) {
    if (a !== cc._blendingSource || b !== cc._blendingDest) {
        cc._blendingSource = a;
        cc._blendingDest = b;
        var c = cc._renderContext;
        a === c.ONE && b === c.ZERO ? c.disable(c.BLEND) : (c.enable(c.BLEND), c.blendFuncSeparate(c.SRC_ALPHA, b, a, b))
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBlendFunc = cc.setBlending);
cc.glBlendResetToCache = function() {
    var a = cc._renderContext;
    a.blendEquation(a.FUNC_ADD);
    cc.ENABLE_GL_STATE_CACHE ? cc.setBlending(cc._blendingSource, cc._blendingDest) : cc.setBlending(a.BLEND_SRC, a.BLEND_DST)
};
cc.setProjectionMatrixDirty = function() {
    cc._currentProjectionMatrix = -1
};
cc.glEnableVertexAttribs = function(a) {
    var b = cc._renderContext,
        c = a & cc.VERTEX_ATTRIB_FLAG_POSITION;
    c !== cc._vertexAttribPosition && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_POSITION), cc._vertexAttribPosition = c);
    c = a & cc.VERTEX_ATTRIB_FLAG_COLOR;
    c !== cc._vertexAttribColor && (c ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_COLOR), cc._vertexAttribColor = c);
    a &= cc.VERTEX_ATTRIB_FLAG_TEX_COORDS;
    a !== cc._vertexAttribTexCoords &&
        (a ? b.enableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS) : b.disableVertexAttribArray(cc.VERTEX_ATTRIB_TEX_COORDS), cc._vertexAttribTexCoords = a)
};
cc.glBindTexture2D = function(a) {
    cc.glBindTexture2DN(0, a)
};
cc.glBindTexture2DN = function(a, b) {
    if (cc._currentBoundTexture[a] !== b) {
        cc._currentBoundTexture[a] = b;
        var c = cc._renderContext;
        c.activeTexture(c.TEXTURE0 + a);
        b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
    }
};
cc.ENABLE_GL_STATE_CACHE || (cc.glBindTexture2DN = function(a, b) {
    var c = cc._renderContext;
    c.activeTexture(c.TEXTURE0 + a);
    b ? c.bindTexture(c.TEXTURE_2D, b._webTextureObj) : c.bindTexture(c.TEXTURE_2D, null)
});
cc.glDeleteTexture = function(a) {
    cc.glDeleteTextureN(0, a)
};
cc.glDeleteTextureN = function(a, b) {
    cc.ENABLE_GL_STATE_CACHE && b === cc._currentBoundTexture[a] && (cc._currentBoundTexture[a] = -1);
    cc._renderContext.deleteTexture(b)
};
cc.glBindVAO = function(a) {
    cc.TEXTURE_ATLAS_USE_VAO && cc.ENABLE_GL_STATE_CACHE && cc._uVAO !== a && (cc._uVAO = a)
};
cc.glEnable = function(a) {};
cc.IMAGE_FORMAT_JPEG = 0;
cc.IMAGE_FORMAT_PNG = 1;
cc.IMAGE_FORMAT_RAWDATA = 9;
cc.NextPOT = function(a) {
    a -= 1;
    a |= a >> 1;
    a |= a >> 2;
    a |= a >> 4;
    a |= a >> 8;
    return (a | a >> 16) + 1
};
cc.RenderTexture = cc.Node.extend({
    sprite: null,
    clearFlags: 0,
    clearDepthVal: 0,
    autoDraw: !1,
    _texture: null,
    _pixelFormat: 0,
    clearStencilVal: 0,
    _clearColor: null,
    _className: "RenderTexture",
    ctor: function(a, b, c, d) {
        cc.Node.prototype.ctor.call(this);
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
        this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888;
        this._clearColor = new cc.Color(0, 0, 0, 255);
        void 0 !== a && void 0 !== b && (c = c || cc.Texture2D.PIXEL_FORMAT_RGBA8888, this.initWithWidthAndHeight(a, b, c, d || 0));
        this.setAnchorPoint(0,
            0)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.RenderTexture.CanvasRenderCmd(this) : new cc.RenderTexture.WebGLRenderCmd(this)
    },
    cleanup: function() {
        cc.Node.prototype.onExit.call(this);
        this._renderCmd.cleanup()
    },
    getSprite: function() {
        return this.sprite
    },
    setSprite: function(a) {
        this.sprite = a
    },
    setVirtualViewport: function(a, b, c) {
        this._renderCmd.setVirtualViewport(a, b, c)
    },
    initWithWidthAndHeight: function(a, b, c, d) {
        return this._renderCmd.initWithWidthAndHeight(a, b, c, d)
    },
    begin: function() {
        cc.renderer._turnToCacheMode(this.__instanceId);
        this._renderCmd.begin()
    },
    beginWithClear: function(a, b, c, d, e, f) {
        var g = cc._renderContext;
        e = e || g.COLOR_BUFFER_BIT;
        f = f || g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT;
        this._beginWithClear(a, b, c, d, e, f, g.COLOR_BUFFER_BIT | g.DEPTH_BUFFER_BIT | g.STENCIL_BUFFER_BIT)
    },
    _beginWithClear: function(a, b, c, d, e, f, g) {
        this.begin();
        this._renderCmd._beginWithClear(a, b, c, d, e, f, g)
    },
    end: function() {
        this._renderCmd.end()
    },
    clear: function(a, b, c, d) {
        this.beginWithClear(a, b, c,
            d);
        this.end()
    },
    clearRect: function(a, b, c, d) {
        this._renderCmd.clearRect(a, b, c, d)
    },
    clearDepth: function(a) {
        this._renderCmd.clearDepth(a)
    },
    clearStencil: function(a) {
        this._renderCmd.clearStencil(a)
    },
    getClearFlags: function() {
        return this.clearFlags
    },
    setClearFlags: function(a) {
        this.clearFlags = a
    },
    getClearColor: function() {
        return this._clearColor
    },
    setClearColor: function(a) {
        var b = this._clearColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = a.a;
        this._renderCmd.updateClearColor(a)
    },
    getClearDepth: function() {
        return this.clearDepthVal
    },
    setClearDepth: function(a) {
        this.clearDepthVal = a
    },
    getClearStencil: function() {
        return this.clearStencilVal
    },
    setClearStencil: function(a) {
        this.clearStencilVal = a
    },
    isAutoDraw: function() {
        return this.autoDraw
    },
    setAutoDraw: function(a) {
        this.autoDraw = a
    },
    saveToFile: function(a, b) {
        cc.log("saveToFile isn't supported on Cocos2d-Html5")
    },
    newCCImage: function(a) {
        cc.log("saveToFile isn't supported on cocos2d-html5");
        return null
    },
    listenToBackground: function(a) {},
    listenToForeground: function(a) {}
});
_p = cc.RenderTexture.prototype;
cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
cc.RenderTexture.create = function(a, b, c, d) {
    return new cc.RenderTexture(a, b, c, d)
};
(function() {
    cc.RenderTexture.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._clearColorStr = "rgba(255,255,255,1)";
        this._cacheCanvas = document.createElement("canvas");
        this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"))
    };
    var a = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.RenderTexture.CanvasRenderCmd;
    a.cleanup = function() {
        this._cacheCanvas = this._cacheContext = null
    };
    a.clearStencil =
        function(a) {};
    a.setVirtualViewport = function(a, c, d) {};
    a.updateClearColor = function(a) {
        this._clearColorStr = "rgba(" + (0 | a.r) + "," + (0 | a.g) + "," + (0 | a.b) + "," + a.a / 255 + ")"
    };
    a.initWithWidthAndHeight = function(a, c, d, e) {
        d = this._node;
        e = this._cacheCanvas;
        var f = cc.contentScaleFactor();
        e.width = 0 | a * f;
        e.height = 0 | c * f;
        a = new cc.Texture2D;
        a.initWithElement(e);
        a.handleLoadedTexture();
        a = d.sprite = new cc.Sprite(a);
        a.setBlendFunc(cc.ONE, cc.ONE_MINUS_SRC_ALPHA);
        d.autoDraw = !1;
        d.addChild(a);
        return !0
    };
    a.begin = function() {};
    a._beginWithClear =
        function(a, c, d, e, f, g, h) {
            a = a || 0;
            c = c || 0;
            d = d || 0;
            e = isNaN(e) ? 255 : e;
            f = this._cacheContext.getContext();
            g = this._cacheCanvas;
            f.setTransform(1, 0, 0, 1, 0, 0);
            this._cacheContext.setFillStyle("rgba(" + (0 | a) + "," + (0 | c) + "," + (0 | d) + "," + e / 255 + ")");
            f.clearRect(0, 0, g.width, g.height);
            f.fillRect(0, 0, g.width, g.height)
        };
    a.end = function() {
        var a = this._node,
            c = cc.contentScaleFactor();
        cc.renderer._renderingToCacheCanvas(this._cacheContext, a.__instanceId, c, c)
    };
    a.clearRect = function(a, c, d, e) {
        this._cacheContext.clearRect(a, c, d, -e)
    };
    a.clearDepth =
        function(a) {
            cc.log("clearDepth isn't supported on Cocos2d-Html5")
        };
    a.visit = function(a) {
        var c = this._node;
        this._syncStatus(a);
        c.sprite.visit(this);
        this._dirtyFlag = 0
    }
})();
(function() {
    cc.RenderTexture.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._depthRenderBuffer = this._textureCopy = this._oldFBO = this._fBO = null;
        this._rtTextureRect = new cc.Rect;
        this._fullRect = new cc.Rect;
        this._fullViewport = new cc.Rect
    };
    var a = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.RenderTexture.WebGLRenderCmd;
    a.setVirtualViewport = function(a, c, d) {
        this._rtTextureRect.x = a.x;
        this._rtTextureRect.y = a.y;
        this._fullRect = c;
        this._fullViewport = d
    };
    a.rendering = function(a) {
        var c = a || cc._renderContext;
        a = this._node;
        if (a.autoDraw) {
            a.begin();
            var d = a.clearFlags;
            if (d) {
                var e = [0, 0, 0, 0],
                    f = 0,
                    g = 0;
                d & c.COLOR_BUFFER_BIT && (e = c.getParameter(c.COLOR_CLEAR_VALUE), c.clearColor(a._clearColor.r / 255, a._clearColor.g / 255, a._clearColor.b / 255, a._clearColor.a / 255));
                d & c.DEPTH_BUFFER_BIT && (f = c.getParameter(c.DEPTH_CLEAR_VALUE), c.clearDepth(a.clearDepthVal));
                d & c.STENCIL_BUFFER_BIT && (g = c.getParameter(c.STENCIL_CLEAR_VALUE), c.clearStencil(a.clearStencilVal));
                c.clear(d);
                d & c.COLOR_BUFFER_BIT && c.clearColor(e[0], e[1], e[2], e[3]);
                d & c.DEPTH_BUFFER_BIT && c.clearDepth(f);
                d & c.STENCIL_BUFFER_BIT && c.clearStencil(g)
            }
            a.sortAllChildren();
            c = a._children;
            for (d = 0; d < c.length; d++) e = c[d], e !== a.sprite && e._renderCmd.visit(a.sprite._renderCmd);
            a.end()
        }
    };
    a.clearStencil = function(a) {
        var c = cc._renderContext,
            d = c.getParameter(c.STENCIL_CLEAR_VALUE);
        c.clearStencil(a);
        c.clear(c.STENCIL_BUFFER_BIT);
        c.clearStencil(d)
    };
    a.cleanup = function() {
        this._textureCopy = null;
        var a = cc._renderContext;
        a.deleteFramebuffer(this._fBO);
        this._depthRenderBuffer && a.deleteRenderbuffer(this._depthRenderBuffer)
    };
    a.updateClearColor = function(a) {};
    a.initWithWidthAndHeight = function(a, c, d, e) {
        var f = this._node;
        d === cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
        var g = cc._renderContext,
            h = cc.contentScaleFactor();
        this._fullRect = new cc.Rect(0, 0, a, c);
        this._fullViewport = new cc.Rect(0, 0, a, c);
        a = 0 | a * h;
        c = 0 | c * h;
        this._oldFBO =
            g.getParameter(g.FRAMEBUFFER_BINDING);
        var k;
        cc.configuration.supportsNPOT() ? (h = a, k = c) : (h = cc.NextPOT(a), k = cc.NextPOT(c));
        for (var m = new Uint8Array(h * k * 4), n = 0; n < h * k * 4; n++) m[n] = 0;
        this._pixelFormat = d;
        n = f._texture = new cc.Texture2D;
        if (!f._texture) return !1;
        n.initWithData(m, f._pixelFormat, h, k, cc.size(a, c));
        d = g.getParameter(g.RENDERBUFFER_BINDING);
        if (cc.configuration.checkForGLExtension("GL_QCOM")) {
            this._textureCopy = new cc.Texture2D;
            if (!this._textureCopy) return !1;
            this._textureCopy.initWithData(m, f._pixelFormat,
                h, k, cc.size(a, c))
        }
        this._fBO = g.createFramebuffer();
        g.bindFramebuffer(g.FRAMEBUFFER, this._fBO);
        g.framebufferTexture2D(g.FRAMEBUFFER, g.COLOR_ATTACHMENT0, g.TEXTURE_2D, n._webTextureObj, 0);
        0 !== e && (this._depthRenderBuffer = g.createRenderbuffer(), g.bindRenderbuffer(g.RENDERBUFFER, this._depthRenderBuffer), g.renderbufferStorage(g.RENDERBUFFER, e, h, k), e === g.DEPTH_STENCIL ? g.framebufferRenderbuffer(g.FRAMEBUFFER, g.DEPTH_STENCIL_ATTACHMENT, g.RENDERBUFFER, this._depthRenderBuffer) : e === g.STENCIL_INDEX || e === g.STENCIL_INDEX8 ?
            g.framebufferRenderbuffer(g.FRAMEBUFFER, g.STENCIL_ATTACHMENT, g.RENDERBUFFER, this._depthRenderBuffer) : e === g.DEPTH_COMPONENT16 && g.framebufferRenderbuffer(g.FRAMEBUFFER, g.DEPTH_ATTACHMENT, g.RENDERBUFFER, this._depthRenderBuffer));
        g.checkFramebufferStatus(g.FRAMEBUFFER) !== g.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer");
        n.setAliasTexParameters();
        a = f.sprite = new cc.Sprite(n);
        a.scaleY = -1;
        a.setBlendFunc(g.ONE, g.ONE_MINUS_SRC_ALPHA);
        g.bindRenderbuffer(g.RENDERBUFFER, d);
        g.bindFramebuffer(g.FRAMEBUFFER,
            this._oldFBO);
        f.autoDraw = !1;
        f.addChild(a);
        return !0
    };
    a.begin = function() {
        var a = this._node;
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPushMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPushMatrix();
        var c = cc._renderContext,
            d = cc.director;
        d.setProjection(d.getProjection());
        var e = a._texture.getContentSizeInPixels(),
            f = cc.director.getWinSizeInPixels(),
            d = f.width / e.width,
            e = f.height / e.height,
            d = cc.math.Matrix4.createOrthographicProjection(-1 / d, 1 / d, -1 / e, 1 / e, -1, 1);
        cc.kmGLMultMatrix(d);
        d = new cc.Rect(0,
            0, 0, 0);
        d.width = this._fullViewport.width;
        d.height = this._fullViewport.height;
        e = d.height / this._fullRect.height;
        d.x = d.width / this._fullRect.width * (this._fullRect.x - this._rtTextureRect.x);
        d.y = (this._fullRect.y - this._rtTextureRect.y) * e;
        c.viewport(d.x, d.y, d.width, d.height);
        this._oldFBO = c.getParameter(c.FRAMEBUFFER_BINDING);
        c.bindFramebuffer(c.FRAMEBUFFER, this._fBO);
        cc.configuration.checkForGLExtension("GL_QCOM") && (c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, this._textureCopy._webTextureObj,
            0), c.clear(c.COLOR_BUFFER_BIT | c.DEPTH_BUFFER_BIT), c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, a._texture._webTextureObj, 0))
    };
    a._beginWithClear = function(a, c, d, e, f, g, h) {
        a /= 255;
        c /= 255;
        d /= 255;
        e /= 255;
        var k = cc._renderContext,
            m = [0, 0, 0, 0],
            n = 0,
            p = 0;
        h & k.COLOR_BUFFER_BIT && (m = k.getParameter(k.COLOR_CLEAR_VALUE), k.clearColor(a, c, d, e));
        h & k.DEPTH_BUFFER_BIT && (n = k.getParameter(k.DEPTH_CLEAR_VALUE), k.clearDepth(f));
        h & k.STENCIL_BUFFER_BIT && (p = k.getParameter(k.STENCIL_CLEAR_VALUE), k.clearStencil(g));
        k.clear(h);
        h & k.COLOR_BUFFER_BIT && k.clearColor(m[0], m[1], m[2], m[3]);
        h & k.DEPTH_BUFFER_BIT && k.clearDepth(n);
        h & k.STENCIL_BUFFER_BIT && k.clearStencil(p)
    };
    a.end = function() {
        cc.renderer._renderingToBuffer(this._node.__instanceId);
        var a = cc._renderContext,
            c = cc.director;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        c.setViewport();
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLPopMatrix();
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLPopMatrix()
    };
    a.clearRect = function(a, c, d, e) {};
    a.clearDepth = function(a) {
        var c = this._node;
        c.begin();
        var d = cc._renderContext,
            e = d.getParameter(d.DEPTH_CLEAR_VALUE);
        d.clearDepth(a);
        d.clear(d.DEPTH_BUFFER_BIT);
        d.clearDepth(e);
        c.end()
    };
    a.visit = function(a) {
        var c = this._node;
        c._visible && (cc.kmGLPushMatrix(), this._syncStatus(a), cc.renderer.pushRenderCommand(this), c.sprite.visit(this), this._dirtyFlag = 0, cc.kmGLPopMatrix())
    }
})();
cc.LabelAtlas = cc.AtlasNode.extend({
    _string: null,
    _mapStartChar: null,
    _textureLoaded: !1,
    _className: "LabelAtlas",
    ctor: function(a, b, c, d, e) {
        cc.AtlasNode.prototype.ctor.call(this);
        this._renderCmd.setCascade();
        b && cc.LabelAtlas.prototype.initWithString.call(this, a, b, c, d, e)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelAtlas.WebGLRenderCmd(this) : new cc.LabelAtlas.CanvasRenderCmd(this)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a,
        b) {
        this.addEventListener("load", a, b)
    },
    initWithString: function(a, b, c, d, e) {
        var f = a + "",
            g, h;
        if (void 0 === c) {
            c = cc.loader.getRes(b);
            if (1 !== parseInt(c.version, 10)) return cc.log("cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version"), !1;
            b = cc.path.changeBasename(b, c.textureFilename);
            d = cc.contentScaleFactor();
            g = parseInt(c.itemWidth, 10) / d;
            h = parseInt(c.itemHeight, 10) / d;
            c = String.fromCharCode(parseInt(c.firstChar, 10))
        } else g = c || 0, h = d || 0, c = e || " ";
        var k = null,
            k = b instanceof cc.Texture2D ? b : cc.textureCache.addImage(b);
        this._textureLoaded = b = k.isLoaded();
        b || (this._string = f, k.addEventListener("load", function(a) {
            this.initWithTexture(k, g, h, f.length);
            this.string = this._string;
            this.setColor(this._renderCmd._displayedColor);
            this.dispatchEvent("load")
        }, this));
        return this.initWithTexture(k, g, h, f.length) ? (this._mapStartChar = c, this.string = f, !0) : !1
    },
    setColor: function(a) {
        cc.AtlasNode.prototype.setColor.call(this, a);
        this._renderCmd.updateAtlasValues()
    },
    getString: function() {
        return this._string
    },
    addChild: function(a, b, c) {
        this._renderCmd._addChild(a);
        cc.Node.prototype.addChild.call(this, a, b, c)
    },
    updateAtlasValues: function() {
        this._renderCmd.updateAtlasValues()
    },
    setString: function(a) {
        a = String(a);
        var b = a.length;
        this._string = a;
        this.setContentSize(b * this._itemWidth, this._itemHeight);
        this._renderCmd.setString(a);
        this._renderCmd.updateAtlasValues();
        this.quadsToDraw = b
    }
});
(function() {
    var a = cc.LabelAtlas.prototype;
    cc.defineGetterSetter(a, "opacity", a.getOpacity, a.setOpacity);
    cc.defineGetterSetter(a, "color", a.getColor, a.setColor);
    cc.defineGetterSetter(a, "string", a.getString, a.setString)
})();
cc.LabelAtlas.create = function(a, b, c, d, e) {
    return new cc.LabelAtlas(a, b, c, d, e)
};
(function() {
    cc.LabelAtlas.CanvasRenderCmd = function(a) {
        cc.AtlasNode.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = cc.LabelAtlas.CanvasRenderCmd.prototype = Object.create(cc.AtlasNode.CanvasRenderCmd.prototype);
    a.constructor = cc.LabelAtlas.CanvasRenderCmd;
    a.setCascade = function() {
        var a = this._node;
        a._cascadeOpacityEnabled = !0;
        a._cascadeColorEnabled = !1
    };
    a.updateAtlasValues = function() {
        for (var a = this._node, c = a._string || "", d = c.length, e = this._textureToRender, f = a._itemWidth, g = a._itemHeight, h = 0, k = -1; h < d; h++) {
            var m =
                c.charCodeAt(h) - a._mapStartChar.charCodeAt(0),
                n = parseInt(m % a._itemsPerRow, 10),
                m = parseInt(m / a._itemsPerRow, 10);
            if (!(0 > n || 0 > m || (n = cc.rect(n * f, m * g, f, g), m = e._contentSize, 0 > n.x || 0 > n.y || n.x + n.width > m.width || n.y + n.height > m.height))) {
                k++;
                var m = c.charCodeAt(h),
                    p = a.getChildByTag(h);
                p ? 32 === m ? (p.init(), p.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : (p.initWithTexture(e, n), p.visible = !0) : (p = new cc.Sprite, 32 === m ? (p.init(), p.setTextureRect(cc.rect(0, 0, 10, 10), !1, cc.size(0, 0))) : p.initWithTexture(e, n), cc.Node.prototype.addChild.call(a,
                    p, 0, h));
                p.setPosition(k * f + f / 2, g / 2)
            }
        }
        this.updateContentSize(h, k + 1)
    };
    a.updateContentSize = function(a, c) {
        var d = this._node,
            e = d._contentSize;
        a !== c && a * d._itemWidth === e.width && d._itemHeight === e.height && d.setContentSize(c * d._itemWidth, d._itemHeight)
    };
    a.setString = function(a) {
        a = this._node;
        if (a._children) {
            a = a._children;
            for (var c = a.length, d = 0; d < c; d++) {
                var e = a[d];
                e && !e._lateChild && (e.visible = !1)
            }
        }
    };
    a._addChild = function() {
        child._lateChild = !0
    }
})();
(function() {
    cc.LabelAtlas.WebGLRenderCmd = function(a) {
        cc.AtlasNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelAtlas.WebGLRenderCmd.prototype = Object.create(cc.AtlasNode.WebGLRenderCmd.prototype);
    a.constructor = cc.LabelAtlas.WebGLRenderCmd;
    a.setCascade = function() {
        var a = this._node;
        a._cascadeOpacityEnabled = !0;
        a._cascadeColorEnabled = !0
    };
    a.rendering = function(a) {
        cc.AtlasNode.WebGLRenderCmd.prototype.rendering.call(this, a);
        if (cc.LABELATLAS_DEBUG_DRAW) {
            var c = this._node;
            a = c.getContentSize();
            var c = c.getBoundingBoxToWorld(),
                d = c.x,
                e = c.y;
            a.width = c.width;
            a.height = c.height;
            a = [cc.p(d, e), cc.p(d + a.width, e), cc.p(a.width + d, a.height + e), cc.p(d, e + a.height)];
            cc._drawingUtil.drawPoly(a, 4, !0)
        }
    };
    a.updateAtlasValues = function() {
        var a = this._node,
            c = a._string,
            d = c.length,
            e = this._textureAtlas,
            f = e.texture,
            g = f.pixelsWidth,
            f = f.pixelsHeight,
            h = a._itemWidth,
            k = a._itemHeight;
        a._ignoreContentScaleFactor || (h = a._itemWidth * cc.contentScaleFactor(), k = a._itemHeight * cc.contentScaleFactor());
        d > e.getCapacity() && cc.log("cc.LabelAtlas._updateAtlasValues(): Invalid String length");
        for (var m = e.quads, n = this._displayedColor, n = {
                r: n.r,
                g: n.g,
                b: n.b,
                a: a._displayedOpacity
            }, p = a._itemWidth, s = a._itemHeight, r = 0, u = -1; r < d; r++) {
            var t = c.charCodeAt(r) - a._mapStartChar.charCodeAt(0),
                v = t % a._itemsPerRow,
                w = 0 | t / a._itemsPerRow;
            if (!(0 > v || 0 > w || v * p + p > g || w * s + s > f)) {
                u++;
                var A;
                cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? (v = (2 * v * h + 1) / (2 * g), t = v + (2 * h - 2) / (2 * g), w = (2 * w * k + 1) / (2 * f), A = w + (2 * k - 2) / (2 * f)) : (v = v * h / g, t = v + h / g, w = w * k / f, A = w + k / f);
                var C = m[r],
                    E = C.tl,
                    x = C.tr,
                    B = C.bl,
                    C = C.br;
                E.texCoords.u = v;
                E.texCoords.v = w;
                x.texCoords.u = t;
                x.texCoords.v = w;
                B.texCoords.u = v;
                B.texCoords.v = A;
                C.texCoords.u = t;
                C.texCoords.v = A;
                B.vertices.x = u * p;
                B.vertices.y = 0;
                B.vertices.z = 0;
                C.vertices.x = u * p + p;
                C.vertices.y = 0;
                C.vertices.z = 0;
                E.vertices.x = u * p;
                E.vertices.y = a._itemHeight;
                E.vertices.z = 0;
                x.vertices.x = u * p + p;
                x.vertices.y = a._itemHeight;
                x.vertices.z = 0;
                E.colors = n;
                x.colors = n;
                B.colors = n;
                C.colors = n
            }
        }
        this.updateContentSize(r, u + 1);
        0 < d && (e.dirty = !0, a = e.totalQuads, d > a && e.increaseTotalQuadsWith(d - a))
    };
    a.updateContentSize = function(a, c) {
        var d = this._node,
            e = d._contentSize;
        a !== c && a * d._itemWidth === e.width && d._itemHeight === e.height && d.setContentSize(c * d._itemWidth, d._itemHeight)
    };
    a.setString = function(a) {
        a = a.length;
        a > this._textureAtlas.totalQuads && this._textureAtlas.resizeCapacity(a)
    };
    a._addChild = function() {}
})();
cc.LABEL_AUTOMATIC_WIDTH = -1;
cc.LabelBMFont = cc.SpriteBatchNode.extend({
    _opacityModifyRGB: !1,
    _string: "",
    _config: null,
    _fntFile: "",
    _initialString: "",
    _alignment: cc.TEXT_ALIGNMENT_CENTER,
    _width: -1,
    _lineBreakWithoutSpaces: !1,
    _imageOffset: null,
    _reusedChar: null,
    _textureLoaded: !1,
    _className: "LabelBMFont",
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.LabelBMFont.WebGLRenderCmd(this) : new cc.LabelBMFont.CanvasRenderCmd(this)
    },
    _setString: function(a, b) {
        b ? this._initialString = a : this._string = a;
        var c = this._children;
        if (c)
            for (var d = 0; d < c.length; d++) {
                var e = c[d];
                e && e.setVisible(!1)
            }
        this._textureLoaded && (this.createFontChars(), b && this.updateLabel())
    },
    ctor: function(a, b, c, d, e) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._imageOffset = cc.p(0, 0);
        this._reusedChar = [];
        this._cascadeOpacityEnabled = this._cascadeColorEnabled = !0;
        this.initWithString(a, b, c, d, e)
    },
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a;
        if (a = this._children)
            for (var b = 0; b < a.length; b++) {
                var c = a[b];
                c && (c.opacityModifyRGB = this._opacityModifyRGB)
            }
    },
    _changeTextureColor: function() {
        this._renderCmd._changeTextureColor()
    },
    init: function() {
        return this.initWithString(null, null, null, null, null)
    },
    initWithString: function(a, b, c, d, e) {
        a = a || "";
        this._config && cc.log("cc.LabelBMFont.initWithString(): re-init is no longer supported");
        if (b) {
            var f = cc.loader.getRes(b);
            if (!f) return cc.log("cc.LabelBMFont.initWithString(): Impossible to create font. Please check file"), !1;
            this._config = f;
            this._fntFile = b;
            b = cc.textureCache.addImage(f.atlasName);
            (this._textureLoaded = f = b.isLoaded()) || b.addEventListener("load", function(a) {
                this._textureLoaded = !0;
                this.initWithTexture(a, this._initialString.length);
                this.setString(this._initialString, !0);
                this.dispatchEvent("load")
            }, this)
        } else b = new cc.Texture2D, f = new Image, b.initWithElement(f), this._textureLoaded = !1;
        return this.initWithTexture(b, a.length) ? (this._alignment = d || cc.TEXT_ALIGNMENT_LEFT, this._imageOffset = e || cc.p(0, 0), this._width =
            null == c ? -1 : c, this._realOpacity = 255, this._realColor = cc.color(255, 255, 255, 255), this._contentSize.width = 0, this._contentSize.height = 0, this.setAnchorPoint(0.5, 0.5), this._renderCmd._initBatchTexture(), this.setString(a, !0), !0) : !1
    },
    createFontChars: function() {
        var a = this._renderCmd._texture || this.textureAtlas.texture,
            b = 0,
            c = cc.size(0, 0),
            d = 0,
            e = 1,
            f = this._string,
            g = f ? f.length : 0;
        if (0 !== g) {
            var h, k = this._config,
                m = k.kerningDict,
                n = k.commonHeight,
                p = k.fontDefDictionary;
            for (h = 0; h < g - 1; h++) 10 === f.charCodeAt(h) && e++;
            var s =
                n * e,
                e = -(n - n * e),
                r = -1;
            for (h = 0; h < g; h++)
                if (n = f.charCodeAt(h), 0 !== n)
                    if (10 === n) b = 0, e -= k.commonHeight;
                    else {
                        var r = m[r << 16 | n & 65535] || 0,
                            u = p[n];
                        u || (cc.log("cocos2d: LabelBMFont: character not found " + f[h]), u = {
                            rect: {
                                x: 0,
                                y: 0,
                                width: 0,
                                height: 0
                            },
                            xOffset: 0,
                            yOffset: 0,
                            xAdvance: 0
                        });
                        var t = cc.rect(u.rect.x, u.rect.y, u.rect.width, u.rect.height),
                            t = cc.rectPixelsToPoints(t);
                        t.x += this._imageOffset.x;
                        t.y += this._imageOffset.y;
                        var v = this.getChildByTag(h);
                        v ? this._renderCmd._updateCharTexture(v, t, n) : (v = new cc.Sprite, v.initWithTexture(a,
                            t, !1), v._newTextureWhenChangeColor = !0, this.addChild(v, 0, h));
                        v.opacityModifyRGB = this._opacityModifyRGB;
                        this._renderCmd._updateCharColorAndOpacity(v);
                        t = cc.p(b + u.xOffset + 0.5 * u.rect.width + r, e + (k.commonHeight - u.yOffset) - 0.5 * t.height * cc.contentScaleFactor());
                        v.setPosition(cc.pointPixelsToPoints(t));
                        b += u.xAdvance + r;
                        r = n;
                        d < b && (d = b)
                    }
            c.width = u && u.xAdvance < u.rect.width ? d - u.xAdvance + u.rect.width : d;
            c.height = s;
            this.setContentSize(cc.sizePixelsToPoints(c))
        }
    },
    updateString: function(a) {
        var b = this._children;
        if (b)
            for (var c =
                    0, d = b.length; c < d; c++) {
                var e = b[c];
                e && (e.visible = !1)
            }
        this._config && this.createFontChars();
        a || this.updateLabel()
    },
    getString: function() {
        return this._initialString
    },
    setString: function(a, b) {
        a = String(a);
        null == b && (b = !0);
        null != a && cc.isString(a) || (a += "");
        this._initialString = a;
        this._setString(a, b)
    },
    _setStringForSetter: function(a) {
        this.setString(a, !1)
    },
    setCString: function(a) {
        this.setString(a, !0)
    },
    _getCharsWidth: function(a, b) {
        if (0 >= b) return 0;
        var c = this.getChildByTag(a),
            d = this.getChildByTag(a + b);
        return this._getLetterPosXLeft(d) -
            this._getLetterPosXLeft(c)
    },
    _checkWarp: function(a, b, c, d) {
        for (var e = a[b], f = 0, g = 0; g < b; g++) f += a[g].length;
        var f = f + b - d,
            h = this._getCharsWidth(f, a[b].length - 1);
        if (h > c && 1 < e.length) {
            d = c / h * e.length | 0;
            for (var g = e.substr(d), k = h - this._getCharsWidth(f + d, g.length - 1), m, n = 0, p = 0; k > c && 100 > p++;) d *= c / k, d |= 0, g = e.substr(d), k = h - this._getCharsWidth(f + d, g.length - 1);
            for (p = 0; k < c && 100 > p++;) g && (n = (m = cc.LabelTTF._wordRex.exec(g)) ? m[0].length : 1, m = g), this._lineBreakWithoutSpaces && (n = 0), d += n, g = e.substr(d), k = h - this._getCharsWidth(f +
                d, g.length - 1);
            d -= n;
            0 === d && (d = 1, m = m.substr(1));
            c = e.substr(0, d);
            cc.LabelTTF.wrapInspection && cc.LabelTTF._symbolRex.test(m || g) && (n = (f = cc.LabelTTF._lastWordRex.exec(c)) ? f[0].length : 0, this._lineBreakWithoutSpaces && (n = 0), d -= n, m = e.substr(d), c = e.substr(0, d));
            cc.LabelTTF._firsrEnglish.test(m) && (f = cc.LabelTTF._lastEnglish.exec(c)) && c !== f[0] && (n = f[0].length, this._lineBreakWithoutSpaces && (n = 0), d -= n, m = e.substr(d), c = e.substr(0, d));
            a[b] = m || g;
            a.splice(b, 0, c)
        }
    },
    updateLabel: function() {
        this.string = this._initialString;
        var a, b, c;
        if (0 < this._width) {
            var d = this.string.split("\n"),
                e = "",
                f = 0,
                g = 0;
            for (a = 0; a < d.length; a++) g = d.length, this._checkWarp(d, a, this._width * this._scaleX, f), g < d.length && f++, 0 < a && (e += "\n"), e += d[a];
            e += String.fromCharCode(0);
            this._setString(e, !1)
        }
        if (this._alignment !== cc.TEXT_ALIGNMENT_LEFT)
            for (d = a = 0, e = this._string.length, f = [], g = 0; g < e; g++)
                if (10 === this._string[g].charCodeAt(0) || 0 === this._string[g].charCodeAt(0)) {
                    b = 0;
                    var h = f.length;
                    if (0 === h) d++;
                    else if (c = a + h - 1 + d, !(0 > c)) {
                        var k = this.getChildByTag(c);
                        if (null !=
                            k) {
                            b = k.getPositionX() + k._getWidth() / 2;
                            k = 0;
                            switch (this._alignment) {
                                case cc.TEXT_ALIGNMENT_CENTER:
                                    k = this.width / 2 - b / 2;
                                    break;
                                case cc.TEXT_ALIGNMENT_RIGHT:
                                    k = this.width - b
                            }
                            if (0 !== k)
                                for (b = 0; b < h; b++) c = a + b + d, 0 > c || (c = this.getChildByTag(c)) && (c.x += k);
                            a += h;
                            d++;
                            f.length = 0
                        }
                    }
                } else f.push(this._string[a])
    },
    setAlignment: function(a) {
        this._alignment = a;
        this.updateLabel()
    },
    _getAlignment: function() {
        return this._alignment
    },
    setBoundingWidth: function(a) {
        this._width = a;
        this.updateLabel()
    },
    _getBoundingWidth: function() {
        return this._width
    },
    setLineBreakWithoutSpace: function(a) {
        this._lineBreakWithoutSpaces = a;
        this.updateLabel()
    },
    setScale: function(a, b) {
        cc.Node.prototype.setScale.call(this, a, b);
        this.updateLabel()
    },
    setScaleX: function(a) {
        cc.Node.prototype.setScaleX.call(this, a);
        this.updateLabel()
    },
    setScaleY: function(a) {
        cc.Node.prototype.setScaleY.call(this, a);
        this.updateLabel()
    },
    setFntFile: function(a) {
        if (null != a && a !== this._fntFile) {
            var b = cc.loader.getRes(a);
            b ? (this._fntFile = a, this._config = b, a = cc.textureCache.addImage(b.atlasName), this._textureLoaded =
                b = a.isLoaded(), this.texture = a, b ? this.createFontChars() : a.addEventListener("load", function(a) {
                    this._textureLoaded = !0;
                    this.texture = a;
                    this.createFontChars();
                    this._changeTextureColor();
                    this.updateLabel();
                    this.dispatchEvent("load")
                }, this)) : cc.log("cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file")
        }
    },
    getFntFile: function() {
        return this._fntFile
    },
    setTexture: function(a) {
        this._renderCmd.setTexture(a)
    },
    setAnchorPoint: function(a, b) {
        cc.Node.prototype.setAnchorPoint.call(this, a, b);
        this.updateLabel()
    },
    _setAnchorX: function(a) {
        cc.Node.prototype._setAnchorX.call(this, a);
        this.updateLabel()
    },
    _setAnchorY: function(a) {
        cc.Node.prototype._setAnchorY.call(this, a);
        this.updateLabel()
    },
    _atlasNameFromFntFile: function(a) {},
    _kerningAmountForFirst: function(a, b) {
        var c = 0;
        if (this._configuration.kerningDictionary) {
            var d = this._configuration.kerningDictionary[(a << 16 | b & 65535).toString()];
            d && (c = d.amount)
        }
        return c
    },
    _getLetterPosXLeft: function(a) {
        return a.getPositionX() * this._scaleX - a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _getLetterPosXRight: function(a) {
        return a.getPositionX() * this._scaleX + a._getWidth() * this._scaleX * a._getAnchorX()
    },
    _isspace_unicode: function(a) {
        a = a.charCodeAt(0);
        return 9 <= a && 13 >= a || 32 === a || 133 === a || 160 === a || 5760 === a || 8192 <= a && 8202 >= a || 8232 === a || 8233 === a || 8239 === a || 8287 === a || 12288 === a
    },
    _utf8_trim_ws: function(a) {
        var b = a.length;
        if (!(0 >= b) && (b -= 1, this._isspace_unicode(a[b]))) {
            for (var c = b - 1; 0 <= c; --c)
                if (this._isspace_unicode(a[c])) b = c;
                else break;
            this._utf8_trim_from(a, b)
        }
    },
    _utf8_trim_from: function(a, b) {
        var c =
            a.length;
        b >= c || 0 > b || a.splice(b, c)
    }
});
(function() {
    var a = cc.LabelBMFont.prototype;
    cc.EventHelper.prototype.apply(a);
    cc.defineGetterSetter(a, "string", a.getString, a._setStringForSetter);
    cc.defineGetterSetter(a, "boundingWidth", a._getBoundingWidth, a.setBoundingWidth);
    cc.defineGetterSetter(a, "textAlign", a._getAlignment, a.setAlignment)
})();
cc.LabelBMFont.create = function(a, b, c, d, e) {
    return new cc.LabelBMFont(a, b, c, d, e)
};
cc._fntLoader = {
    INFO_EXP: /info [^\n]*(\n|$)/gi,
    COMMON_EXP: /common [^\n]*(\n|$)/gi,
    PAGE_EXP: /page [^\n]*(\n|$)/gi,
    CHAR_EXP: /char [^\n]*(\n|$)/gi,
    KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
    ITEM_EXP: /\w+=[^ \r\n]+/gi,
    INT_EXP: /^[\-]?\d+$/,
    _parseStrToObj: function(a) {
        a = a.match(this.ITEM_EXP);
        var b = {};
        if (a)
            for (var c = 0, d = a.length; c < d; c++) {
                var e = a[c],
                    f = e.indexOf("\x3d"),
                    g = e.substring(0, f),
                    e = e.substring(f + 1);
                e.match(this.INT_EXP) ? e = parseInt(e) : '"' === e[0] && (e = e.substring(1, e.length - 1));
                b[g] = e
            }
        return b
    },
    parseFnt: function(a,
        b) {
        var c = {},
            d = this._parseStrToObj(a.match(this.INFO_EXP)[0]).padding.split(",");
        parseInt(d[0]);
        parseInt(d[1]);
        parseInt(d[2]);
        parseInt(d[3]);
        d = this._parseStrToObj(a.match(this.COMMON_EXP)[0]);
        c.commonHeight = d.lineHeight;
        if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
            var e = cc.configuration.getMaxTextureSize();
            (d.scaleW > e.width || d.scaleH > e.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported")
        }
        1 !== d.pages && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
        d = this._parseStrToObj(a.match(this.PAGE_EXP)[0]);
        0 !== d.id && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
        c.atlasName = cc.path.changeBasename(b, d.file);
        for (var f = a.match(this.CHAR_EXP), g = c.fontDefDictionary = {}, d = 0, e = f.length; d < e; d++) {
            var h = this._parseStrToObj(f[d]);
            g[h.id] = {
                rect: {
                    x: h.x,
                    y: h.y,
                    width: h.width,
                    height: h.height
                },
                xOffset: h.xoffset,
                yOffset: h.yoffset,
                xAdvance: h.xadvance
            }
        }
        f = c.kerningDict = {};
        if (g = a.match(this.KERNING_EXP))
            for (d = 0, e = g.length; d < e; d++) h = this._parseStrToObj(g[d]),
                f[h.first << 16 | h.second & 65535] = h.amount;
        return c
    },
    load: function(a, b, c, d) {
        var e = this;
        cc.loader.loadTxt(a, function(a, c) {
            if (a) return d(a);
            d(null, e.parseFnt(c, b))
        })
    }
};
cc.loader.register(["fnt"], cc._fntLoader);
(function() {
    cc.LabelBMFont.CanvasRenderCmd = function(a) {
        cc.SpriteBatchNode.CanvasRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelBMFont.CanvasRenderCmd.prototype = Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
    a.constructor = cc.LabelBMFont.CanvasRenderCmd;
    a.rendering = function() {
        void 0
    };
    a._updateCharTexture = function(a, c, d) {
        32 === d ? a.setTextureRect(c, !1, cc.size(0, 0)) : (a.setTextureRect(c, !1), a.visible = !0)
    };
    a._updateCharColorAndOpacity = function(a) {
        a._displayedColor = this._displayedColor;
        a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty);
        a._displayedOpacity = this._displayedOpacity;
        a._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    };
    a.setTexture = function(a) {
        for (var c = this._node._children, d = this._displayedColor, e = 0; e < c.length; e++) {
            var f = c[e],
                g = f._renderCmd,
                h = g._displayedColor;
            if (this._texture === g._texture || h.r === d.r && h.g === d.g && h.b === d.b) f.texture = a
        }
        this._texture = a
    };
    a._changeTextureColor = function() {
        var a = this._node,
            c = this._textureToRender,
            d = c.getContentSize(),
            a = a._texture,
            e = a.getHtmlElementObj(),
            f = this._displayedColor,
            g = cc.rect(0, 0, e.width, e.height);
        c && 0 < d.width && e && (this._textureToRender = a._generateColorTexture(f.r, f.g, f.b, g))
    };
    a._updateChildrenDisplayedOpacity = function(a) {
        cc.Node.prototype.updateDisplayedOpacity.call(a, this._displayedOpacity)
    };
    a._updateChildrenDisplayedColor = function(a) {
        cc.Node.prototype.updateDisplayedColor.call(a, this._displayedColor)
    };
    a._initBatchTexture = function() {}
})();
(function() {
    cc.LabelBMFont.WebGLRenderCmd = function(a) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.LabelBMFont.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    a.constructor = cc.LabelBMFont.WebGLRenderCmd;
    a._updateCharTexture = function(a, c, d) {
        a.setTextureRect(c, !1);
        a.visible = !0
    };
    a._changeTextureColor = function() {};
    a._updateChildrenDisplayedOpacity = function(a) {
        a.updateDisplayedOpacity(this._displayedOpacity)
    };
    a._updateChildrenDisplayedColor =
        function(a) {
            a.updateDisplayedColor(this._displayedColor)
        };
    a._initBatchTexture = function() {
        var a = this._node,
            c = a.textureAtlas.texture;
        a._opacityModifyRGB = c.hasPremultipliedAlpha();
        var d = a._reusedChar = new cc.Sprite;
        d.initWithTexture(c, cc.rect(0, 0, 0, 0), !1);
        d.batchNode = a
    };
    a.rendering = function(a) {
        cc.SpriteBatchNode.WebGLRenderCmd.prototype.rendering.call(this, a);
        a = this._node;
        if (cc.LABELBMFONT_DEBUG_DRAW) {
            a = a.getContentSize();
            var c = cc.p(0 | -this._anchorPointInPoints.x, 0 | -this._anchorPointInPoints.y);
            a = [cc.p(c.x,
                c.y), cc.p(c.x + a.width, c.y), cc.p(c.x + a.width, c.y + a.height), cc.p(c.x, c.y + a.height)];
            cc._drawingUtil.setDrawColor(0, 255, 0, 255);
            cc._drawingUtil.drawPoly(a, 4, !0)
        }
    };
    a._updateCharColorAndOpacity = function() {}
})();
cc.MotionStreak = cc.Node.extend({
    texture: null,
    fastMode: !1,
    startingPositionInitialized: !1,
    _blendFunc: null,
    _stroke: 0,
    _fadeDelta: 0,
    _minSeg: 0,
    _maxPoints: 0,
    _nuPoints: 0,
    _previousNuPoints: 0,
    _pointVertexes: null,
    _pointState: null,
    _vertices: null,
    _colorPointer: null,
    _texCoords: null,
    _verticesBuffer: null,
    _colorPointerBuffer: null,
    _texCoordsBuffer: null,
    _className: "MotionStreak",
    ctor: function(a, b, c, d, e) {
        cc.Node.prototype.ctor.call(this);
        this._positionR = cc.p(0, 0);
        this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        this.startingPositionInitialized = this.fastMode = !1;
        this.texture = null;
        this._previousNuPoints = this._nuPoints = this._maxPoints = this._minSeg = this._fadeDelta = this._stroke = 0;
        this._texCoordsBuffer = this._colorPointerBuffer = this._verticesBuffer = this._texCoords = this._colorPointer = this._vertices = this._pointState = this._pointVertexes = null;
        void 0 !== e && this.initWithFade(a, b, c, d, e)
    },
    getTexture: function() {
        return this.texture
    },
    setTexture: function(a) {
        this.texture !== a && (this.texture = a)
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? this._blendFunc = a : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    getOpacity: function() {
        cc.log("cc.MotionStreak.getOpacity has not been supported.");
        return 0
    },
    setOpacity: function(a) {
        cc.log("cc.MotionStreak.setOpacity has not been supported.")
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isFastMode: function() {
        return this.fastMode
    },
    setFastMode: function(a) {
        this.fastMode = a
    },
    isStartingPositionInitialized: function() {
        return this.startingPositionInitialized
    },
    setStartingPositionInitialized: function(a) {
        this.startingPositionInitialized = a
    },
    getStroke: function() {
        return this._stroke
    },
    setStroke: function(a) {
        this._stroke = a
    },
    initWithFade: function(a, b, c, d, e) {
        if (!e) throw Error("cc.MotionStreak.initWithFade(): Invalid filename or texture");
        cc.isString(e) && (e = cc.textureCache.addImage(e));
        cc.Node.prototype.setPosition.call(this, cc.p(0, 0));
        this.anchorY = this.anchorX = 0;
        this.ignoreAnchor = !0;
        this.startingPositionInitialized = !1;
        this.fastMode = !0;
        this._minSeg = -1 === b ? c / 5 : b;
        this._minSeg *=
            this._minSeg;
        this._stroke = c;
        this._fadeDelta = 1 / a;
        this._maxPoints = a = (0 | 60 * a) + 2;
        this._nuPoints = 0;
        this._pointState = new Float32Array(a);
        this._pointVertexes = new Float32Array(2 * a);
        this._vertices = new Float32Array(4 * a);
        this._texCoords = new Float32Array(4 * a);
        this._colorPointer = new Uint8Array(8 * a);
        this._verticesBuffer = gl.createBuffer();
        this._texCoordsBuffer = gl.createBuffer();
        this._colorPointerBuffer = gl.createBuffer();
        this._blendFunc.src = gl.SRC_ALPHA;
        this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
        this.texture = e;
        this.color =
            d;
        this.scheduleUpdate();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW);
        return !0
    },
    tintWithColor: function(a) {
        this.color = a;
        for (var b = this._colorPointer, c = 0, d = 2 * this._nuPoints; c < d; c++) b[4 * c] = a.r, b[4 * c +
            1] = a.g, b[4 * c + 2] = a.b
    },
    reset: function() {
        this._nuPoints = 0
    },
    setPosition: function(a, b) {
        this.startingPositionInitialized = !0;
        void 0 === b ? (this._positionR.x = a.x, this._positionR.y = a.y) : (this._positionR.x = a, this._positionR.y = b)
    },
    getPositionX: function() {
        return this._positionR.x
    },
    setPositionX: function(a) {
        this._positionR.x = a;
        this.startingPositionInitialized || (this.startingPositionInitialized = !0)
    },
    getPositionY: function() {
        return this._positionR.y
    },
    setPositionY: function(a) {
        this._positionR.y = a;
        this.startingPositionInitialized ||
            (this.startingPositionInitialized = !0)
    },
    update: function(a) {
        if (this.startingPositionInitialized) {
            this._renderCmd._updateDisplayColor();
            a *= this._fadeDelta;
            var b, c, d, e, f = 0,
                g = this._nuPoints,
                h = this._pointState,
                k = this._pointVertexes,
                m = this._vertices,
                n = this._colorPointer;
            for (d = 0; d < g; d++) h[d] -= a, 0 >= h[d] ? f++ : (b = d - f, 0 < f ? (h[b] = h[d], k[2 * b] = k[2 * d], k[2 * b + 1] = k[2 * d + 1], e = 2 * d, c = 2 * b, m[2 * c] = m[2 * e], m[2 * c + 1] = m[2 * e + 1], m[2 * (c + 1)] = m[2 * (e + 1)], m[2 * (c + 1) + 1] = m[2 * (e + 1) + 1], e *= 4, c *= 4, n[c + 0] = n[e + 0], n[c + 1] = n[e + 1], n[c + 2] = n[e + 2], n[c +
                4] = n[e + 4], n[c + 5] = n[e + 5], n[c + 6] = n[e + 6]) : c = 8 * b, b = 255 * h[b], n[c + 3] = b, n[c + 7] = b);
            g -= f;
            d = !0;
            g >= this._maxPoints ? d = !1 : 0 < g && (a = cc.pDistanceSQ(cc.p(k[2 * (g - 1)], k[2 * (g - 1) + 1]), this._positionR) < this._minSeg, c = 1 === g ? !1 : cc.pDistanceSQ(cc.p(k[2 * (g - 2)], k[2 * (g - 2) + 1]), this._positionR) < 2 * this._minSeg, a || c) && (d = !1);
            d && (k[2 * g] = this._positionR.x, k[2 * g + 1] = this._positionR.y, h[g] = 1, h = 8 * g, d = this.getDisplayedColor(), n[h] = d.r, n[h + 1] = d.g, n[h + 2] = d.b, n[h + 4] = d.r, n[h + 5] = d.g, n[h + 6] = d.b, n[h + 3] = 255, n[h + 7] = 255, 0 < g && this.fastMode && (1 < g ?
                cc.vertexLineToPolygon(k, this._stroke, this._vertices, g, 1) : cc.vertexLineToPolygon(k, this._stroke, this._vertices, 0, 2)), g++);
            this.fastMode || cc.vertexLineToPolygon(k, this._stroke, this._vertices, 0, g);
            if (g && this._previousNuPoints !== g) {
                k = 1 / g;
                n = this._texCoords;
                for (d = 0; d < g; d++) n[4 * d] = 0, n[4 * d + 1] = k * d, n[2 * (2 * d + 1)] = 1, n[2 * (2 * d + 1) + 1] = k * d;
                this._previousNuPoints = g
            }
            this._nuPoints = g
        }
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.MotionStreak.WebGLRenderCmd(this) : null
    }
});
cc.MotionStreak.create = function(a, b, c, d, e) {
    return new cc.MotionStreak(a, b, c, d, e)
};
cc.MotionStreak.WebGLRenderCmd = function(a) {
    cc.Node.WebGLRenderCmd.call(this, a);
    this._needDraw = !0;
    this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
};
cc.MotionStreak.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
cc.MotionStreak.WebGLRenderCmd.prototype.constructor = cc.Sprite.WebGLRenderCmd;
cc.MotionStreak.WebGLRenderCmd.prototype.rendering = function(a) {
    var b = this._node;
    1 >= b._nuPoints || !b.texture || !b.texture.isLoaded() || (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), cc.glBlendFunc(b._blendFunc.src, b._blendFunc.dst), cc.glBindTexture2D(b.texture), a.bindBuffer(a.ARRAY_BUFFER, b._verticesBuffer), a.bufferData(a.ARRAY_BUFFER, b._vertices, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
        2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._texCoordsBuffer), a.bufferData(a.ARRAY_BUFFER, b._texCoords, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, b._colorPointerBuffer), a.bufferData(a.ARRAY_BUFFER, b._colorPointer, a.DYNAMIC_DRAW), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 0, 0), a.drawArrays(a.TRIANGLE_STRIP, 0, 2 * b._nuPoints), cc.g_NumberOfDraws++)
};
cc.NodeGrid = cc.Node.extend({
    grid: null,
    _target: null,
    _gridRect: null,
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        void 0 === a && (a = cc.rect());
        this._gridRect = a
    },
    getGrid: function() {
        return this.grid
    },
    setGrid: function(a) {
        this.grid = a
    },
    setGridRect: function(a) {
        this._gridRect = a
    },
    getGridRect: function() {
        return this._gridRect
    },
    setTarget: function(a) {
        this._target = a
    },
    _transformForWebGL: function() {
        var a = this._transform4x4,
            b = cc.current_stack.top,
            c = this.getNodeToParentTransform(),
            d = a.mat;
        d[0] = c.a;
        d[4] = c.c;
        d[12] =
            c.tx;
        d[1] = c.b;
        d[5] = c.d;
        d[13] = c.ty;
        d[14] = this._vertexZ;
        b.multiply(a);
        null === this._camera || this.grid && this.grid.isActive() || (b = this._renderCmd._anchorPointInPoints, a = b.x, b = b.y, 0 !== a || 0 !== b ? (cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (a |= 0, b |= 0), cc.kmGLTranslatef(a, b, 0), this._camera.locate(), cc.kmGLTranslatef(-a, -b, 0)) : this._camera.locate())
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new cc.NodeGrid.WebGLRenderCmd(this) : new cc.Node.CanvasRenderCmd(this)
    }
});
_p = cc.NodeGrid.prototype;
cc.defineGetterSetter(_p, "target", null, _p.setTarget);
cc.NodeGrid.create = function() {
    return new cc.NodeGrid
};
(function() {
    cc.NodeGrid.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !1;
        this._gridBeginCommand = new cc.CustomRenderCmd(this, this.onGridBeginDraw);
        this._gridEndCommand = new cc.CustomRenderCmd(this, this.onGridEndDraw)
    };
    var a = cc.NodeGrid.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.NodeGrid.WebGLRenderCmd;
    a.visit = function(a) {
        var c = this._node;
        if (c._visible) {
            a = a || this.getParentRenderCmd();
            c._parent && c._parent._renderCmd && (this._curLevel =
                c._parent._renderCmd._curLevel + 1);
            var d = cc.current_stack;
            d.stack.push(d.top);
            this._syncStatus(a);
            d.top = this._stackMatrix;
            cc.renderer.pushRenderCommand(this._gridBeginCommand);
            c._target && c._target.visit();
            if ((a = c._children) && 0 < a.length) {
                var e = a.length;
                c.sortAllChildren();
                for (c = 0; c < e; c++) {
                    var f = a[c];
                    f && f.visit()
                }
            }
            cc.renderer.pushRenderCommand(this._gridEndCommand);
            this._dirtyFlag = 0;
            d.top = d.stack.pop()
        }
    };
    a.onGridBeginDraw = function() {
        var a = this._node.grid;
        a && a._active && a.beforeDraw()
    };
    a.onGridEndDraw =
        function() {
            var a = this._node.grid;
            a && a._active && a.afterDraw(this._node)
        }
})();
cc.v2fzero = function() {
    return {
        x: 0,
        y: 0
    }
};
cc.v2f = function(a, b) {
    return {
        x: a,
        y: b
    }
};
cc.v2fadd = function(a, b) {
    return cc.v2f(a.x + b.x, a.y + b.y)
};
cc.v2fsub = function(a, b) {
    return cc.v2f(a.x - b.x, a.y - b.y)
};
cc.v2fmult = function(a, b) {
    return cc.v2f(a.x * b, a.y * b)
};
cc.v2fperp = function(a) {
    return cc.v2f(-a.y, a.x)
};
cc.v2fneg = function(a) {
    return cc.v2f(-a.x, -a.y)
};
cc.v2fdot = function(a, b) {
    return a.x * b.x + a.y * b.y
};
cc.v2fforangle = function(a) {
    return cc.v2f(Math.cos(a), Math.sin(a))
};
cc.v2fnormalize = function(a) {
    a = cc.pNormalize(cc.p(a.x, a.y));
    return cc.v2f(a.x, a.y)
};
cc.__v2f = function(a) {
    return cc.v2f(a.x, a.y)
};
cc.__t = function(a) {
    return {
        u: a.x,
        v: a.y
    }
};
cc.DrawNode = cc.Node.extend({
    _buffer: null,
    _blendFunc: null,
    _lineWidth: 1,
    _drawColor: null,
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    setLineWidth: function(a) {
        this._lineWidth = a
    },
    getLineWidth: function() {
        return this._lineWidth
    },
    setDrawColor: function(a) {
        var b = this._drawColor;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        b.a = null == a.a ? 255 : a.a
    },
    getDrawColor: function() {
        return cc.color(this._drawColor.r,
            this._drawColor.g, this._drawColor.b, this._drawColor.a)
    }
});
cc.DrawNode.create = function() {
    return new cc.DrawNode
};
cc.DrawNode.TYPE_DOT = 0;
cc.DrawNode.TYPE_SEGMENT = 1;
cc.DrawNode.TYPE_POLY = 2;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    cc._renderType === cc.game.RENDER_TYPE_CANVAS ? (cc._DrawNodeElement = function(a, b, c, d, e, f, g, h, k) {
        this.type = a;
        this.verts = b || null;
        this.fillColor = c || null;
        this.lineWidth = d || 0;
        this.lineColor = e || null;
        this.lineCap = f || "butt";
        this.isClosePolygon = g || !1;
        this.isFill = h || !1;
        this.isStroke = k || !1
    }, cc.extend(cc.DrawNode.prototype, {
        _className: "DrawNodeCanvas",
        ctor: function() {
            cc.Node.prototype.ctor.call(this);
            var a = this._renderCmd;
            a._buffer = this._buffer = [];
            a._drawColor = this._drawColor = cc.color(255, 255, 255, 255);
            a._blendFunc = this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
            this.init()
        },
        drawRect: function(a, b, c, d, e) {
            d = null == d ? this._lineWidth : d;
            e = e || this.getDrawColor();
            null == e.a && (e.a = 255);
            a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
            b = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            b.verts = a;
            b.lineWidth = d;
            b.lineColor = e;
            b.isClosePolygon = !0;
            b.isStroke = !0;
            b.lineCap = "butt";
            if (b.fillColor = c) null == c.a && (c.a = 255), b.isFill = !0;
            this._buffer.push(b)
        },
        drawCircle: function(a,
            b, c, d, e, f, g) {
            f = f || this._lineWidth;
            g = g || this.getDrawColor();
            null == g.a && (g.a = 255);
            for (var h = 2 * Math.PI / d, k = [], m = 0; m <= d; m++) {
                var n = m * h,
                    p = b * Math.cos(n + c) + a.x,
                    n = b * Math.sin(n + c) + a.y;
                k.push(cc.p(p, n))
            }
            e && k.push(cc.p(a.x, a.y));
            a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            a.verts = k;
            a.lineWidth = f;
            a.lineColor = g;
            a.isClosePolygon = !0;
            a.isStroke = !0;
            this._buffer.push(a)
        },
        drawQuadBezier: function(a, b, c, d, e, f) {
            e = e || this._lineWidth;
            f = f || this.getDrawColor();
            null == f.a && (f.a = 255);
            for (var g = [], h = 0, k = 0; k < d; k++) {
                var m =
                    Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                    n = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
                g.push(cc.p(m, n));
                h += 1 / d
            }
            g.push(cc.p(c.x, c.y));
            a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            a.verts = g;
            a.lineWidth = e;
            a.lineColor = f;
            a.isStroke = !0;
            a.lineCap = "round";
            this._buffer.push(a)
        },
        drawCubicBezier: function(a, b, c, d, e, f, g) {
            f = f || this._lineWidth;
            g = g || this.getDrawColor();
            null == g.a && (g.a = 255);
            for (var h = [], k = 0, m = 0; m < e; m++) {
                var n = Math.pow(1 - k, 3) * a.x + 3 * Math.pow(1 - k, 2) * k * b.x + 3 * (1 - k) * k * k * c.x + k * k * k * d.x,
                    p = Math.pow(1 - k,
                        3) * a.y + 3 * Math.pow(1 - k, 2) * k * b.y + 3 * (1 - k) * k * k * c.y + k * k * k * d.y;
                h.push(cc.p(n, p));
                k += 1 / e
            }
            h.push(cc.p(d.x, d.y));
            a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            a.verts = h;
            a.lineWidth = f;
            a.lineColor = g;
            a.isStroke = !0;
            a.lineCap = "round";
            this._buffer.push(a)
        },
        drawCatmullRom: function(a, b, c, d) {
            this.drawCardinalSpline(a, 0.5, b, c, d)
        },
        drawCardinalSpline: function(a, b, c, d, e) {
            d = d || this._lineWidth;
            e = e || this.getDrawColor();
            null == e.a && (e.a = 255);
            for (var f = [], g, h, k = 1 / a.length, m = 0; m < c + 1; m++) h = m / c, 1 === h ? (g = a.length - 1, h = 1) : (g = 0 |
                h / k, h = (h - k * g) / k), g = cc.cardinalSplineAt(cc.getControlPointAt(a, g - 1), cc.getControlPointAt(a, g - 0), cc.getControlPointAt(a, g + 1), cc.getControlPointAt(a, g + 2), b, h), f.push(g);
            a = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            a.verts = f;
            a.lineWidth = d;
            a.lineColor = e;
            a.isStroke = !0;
            a.lineCap = "round";
            this._buffer.push(a)
        },
        drawDot: function(a, b, c) {
            c = c || this.getDrawColor();
            null == c.a && (c.a = 255);
            var d = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
            d.verts = [a];
            d.lineWidth = b;
            d.fillColor = c;
            this._buffer.push(d)
        },
        drawDots: function(a,
            b, c) {
            if (a && 0 != a.length) {
                c = c || this.getDrawColor();
                null == c.a && (c.a = 255);
                for (var d = 0, e = a.length; d < e; d++) this.drawDot(a[d], b, c)
            }
        },
        drawSegment: function(a, b, c, d) {
            c = c || this._lineWidth;
            d = d || this.getDrawColor();
            null == d.a && (d.a = 255);
            var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            e.verts = [a, b];
            e.lineWidth = 2 * c;
            e.lineColor = d;
            e.isStroke = !0;
            e.lineCap = "round";
            this._buffer.push(e)
        },
        drawPoly_: function(a, b, c, d) {
            c = null == c ? this._lineWidth : c;
            d = d || this.getDrawColor();
            null == d.a && (d.a = 255);
            var e = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
            e.verts = a;
            e.fillColor = b;
            e.lineWidth = c;
            e.lineColor = d;
            e.isClosePolygon = !0;
            e.isStroke = !0;
            e.lineCap = "round";
            b && (e.isFill = !0);
            this._buffer.push(e)
        },
        drawPoly: function(a, b, c, d) {
            for (var e = [], f = 0; f < a.length; f++) e.push(cc.p(a[f].x, a[f].y));
            return this.drawPoly_(e, b, c, d)
        },
        clear: function() {
            this._buffer.length = 0
        },
        _createRenderCmd: function() {
            return new cc.DrawNode.CanvasRenderCmd(this)
        }
    })) : cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.extend(cc.DrawNode.prototype, {
        _bufferCapacity: 0,
        _trianglesArrayBuffer: null,
        _trianglesWebBuffer: null,
        _trianglesReader: null,
        _dirty: !1,
        _className: "DrawNodeWebGL",
        ctor: function() {
            cc.Node.prototype.ctor.call(this);
            this._buffer = [];
            this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
            this._drawColor = cc.color(255, 255, 255, 255);
            this.init()
        },
        init: function() {
            return cc.Node.prototype.init.call(this) ? (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_LENGTHTEXTURECOLOR), this._ensureCapacity(64), this._trianglesWebBuffer = cc._renderContext.createBuffer(),
                this._dirty = !0) : !1
        },
        drawRect: function(a, b, c, d, e) {
            d = null == d ? this._lineWidth : d;
            e = e || this.getDrawColor();
            null == e.a && (e.a = 255);
            a = [a, cc.p(b.x, a.y), b, cc.p(a.x, b.y)];
            null == c ? this._drawSegments(a, d, e, !0) : this.drawPoly(a, c, d, e)
        },
        drawCircle: function(a, b, c, d, e, f, g) {
            f = f || this._lineWidth;
            g = g || this.getDrawColor();
            null == g.a && (g.a = 255);
            var h = 2 * Math.PI / d,
                k = [],
                m;
            for (m = 0; m <= d; m++) {
                var n = m * h,
                    p = b * Math.cos(n + c) + a.x,
                    n = b * Math.sin(n + c) + a.y;
                k.push(cc.p(p, n))
            }
            e && k.push(cc.p(a.x, a.y));
            f *= 0.5;
            m = 0;
            for (a = k.length; m < a - 1; m++) this.drawSegment(k[m],
                k[m + 1], f, g)
        },
        drawQuadBezier: function(a, b, c, d, e, f) {
            e = e || this._lineWidth;
            f = f || this.getDrawColor();
            null == f.a && (f.a = 255);
            for (var g = [], h = 0, k = 0; k < d; k++) {
                var m = Math.pow(1 - h, 2) * a.x + 2 * (1 - h) * h * b.x + h * h * c.x,
                    n = Math.pow(1 - h, 2) * a.y + 2 * (1 - h) * h * b.y + h * h * c.y;
                g.push(cc.p(m, n));
                h += 1 / d
            }
            g.push(cc.p(c.x, c.y));
            this._drawSegments(g, e, f, !1)
        },
        drawCubicBezier: function(a, b, c, d, e, f, g) {
            f = f || this._lineWidth;
            g = g || this.getDrawColor();
            null == g.a && (g.a = 255);
            for (var h = [], k = 0, m = 0; m < e; m++) {
                var n = Math.pow(1 - k, 3) * a.x + 3 * Math.pow(1 - k, 2) * k * b.x +
                    3 * (1 - k) * k * k * c.x + k * k * k * d.x,
                    p = Math.pow(1 - k, 3) * a.y + 3 * Math.pow(1 - k, 2) * k * b.y + 3 * (1 - k) * k * k * c.y + k * k * k * d.y;
                h.push(cc.p(n, p));
                k += 1 / e
            }
            h.push(cc.p(d.x, d.y));
            this._drawSegments(h, f, g, !1)
        },
        drawCatmullRom: function(a, b, c, d) {
            this.drawCardinalSpline(a, 0.5, b, c, d)
        },
        drawCardinalSpline: function(a, b, c, d, e) {
            d = d || this._lineWidth;
            e = e || this.getDrawColor();
            null == e.a && (e.a = 255);
            for (var f = [], g, h, k = 1 / a.length, m = 0; m < c + 1; m++) h = m / c, 1 === h ? (g = a.length - 1, h = 1) : (g = 0 | h / k, h = (h - k * g) / k), g = cc.cardinalSplineAt(cc.getControlPointAt(a, g - 1), cc.getControlPointAt(a,
                g - 0), cc.getControlPointAt(a, g + 1), cc.getControlPointAt(a, g + 2), b, h), f.push(g);
            d *= 0.5;
            a = 0;
            for (b = f.length; a < b - 1; a++) this.drawSegment(f[a], f[a + 1], d, e)
        },
        _render: function() {
            var a = cc._renderContext;
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            a.bindBuffer(a.ARRAY_BUFFER, this._trianglesWebBuffer);
            this._dirty && (a.bufferData(a.ARRAY_BUFFER, this._trianglesArrayBuffer, a.STREAM_DRAW), this._dirty = !1);
            var b = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, b, 0);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, b, 8);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, b, 12);
            a.drawArrays(a.TRIANGLES, 0, 3 * this._buffer.length);
            cc.incrementGLDraws(1)
        },
        _ensureCapacity: function(a) {
            var b = this._buffer;
            if (b.length + a > this._bufferCapacity) {
                var c = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                this._bufferCapacity += Math.max(this._bufferCapacity, a);
                if (null == b || 0 === b.length) this._buffer = [], this._trianglesArrayBuffer = new ArrayBuffer(c * this._bufferCapacity),
                    this._trianglesReader = new Uint8Array(this._trianglesArrayBuffer);
                else {
                    a = [];
                    for (var d = new ArrayBuffer(c * this._bufferCapacity), e = 0; e < b.length; e++) a[e] = new cc.V2F_C4B_T2F_Triangle(b[e].a, b[e].b, b[e].c, d, e * c);
                    this._trianglesReader = new Uint8Array(d);
                    this._trianglesArrayBuffer = d;
                    this._buffer = a
                }
            }
        },
        drawDot: function(a, b, c) {
            c = c || this.getDrawColor();
            null == c.a && (c.a = 255);
            var d = {
                r: 0 | c.r,
                g: 0 | c.g,
                b: 0 | c.b,
                a: 0 | c.a
            };
            c = {
                vertices: {
                    x: a.x - b,
                    y: a.y - b
                },
                colors: d,
                texCoords: {
                    u: -1,
                    v: -1
                }
            };
            var e = {
                    vertices: {
                        x: a.x - b,
                        y: a.y + b
                    },
                    colors: d,
                    texCoords: {
                        u: -1,
                        v: 1
                    }
                },
                f = {
                    vertices: {
                        x: a.x + b,
                        y: a.y + b
                    },
                    colors: d,
                    texCoords: {
                        u: 1,
                        v: 1
                    }
                };
            a = {
                vertices: {
                    x: a.x + b,
                    y: a.y - b
                },
                colors: d,
                texCoords: {
                    u: 1,
                    v: -1
                }
            };
            this._ensureCapacity(6);
            this._buffer.push(new cc.V2F_C4B_T2F_Triangle(c, e, f, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
            this._buffer.push(new cc.V2F_C4B_T2F_Triangle(c, f, a, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
            this._dirty = !0
        },
        drawDots: function(a, b, c) {
            if (a && 0 !==
                a.length) {
                c = c || this.getDrawColor();
                null == c.a && (c.a = 255);
                for (var d = 0, e = a.length; d < e; d++) this.drawDot(a[d], b, c)
            }
        },
        drawSegment: function(a, b, c, d) {
            d = d || this.getDrawColor();
            null == d.a && (d.a = 255);
            c = c || 0.5 * this._lineWidth;
            this._ensureCapacity(18);
            d = {
                r: 0 | d.r,
                g: 0 | d.g,
                b: 0 | d.b,
                a: 0 | d.a
            };
            var e = cc.__v2f(a),
                f = cc.__v2f(b);
            b = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(f, e)));
            a = cc.v2fperp(b);
            var g = cc.v2fmult(b, c),
                h = cc.v2fmult(a, c);
            c = cc.v2fsub(f, cc.v2fadd(g, h));
            var k = cc.v2fadd(f, cc.v2fsub(g, h)),
                m = cc.v2fsub(f, g),
                f = cc.v2fadd(f,
                    g),
                n = cc.v2fsub(e, g),
                p = cc.v2fadd(e, g),
                s = cc.v2fsub(e, cc.v2fsub(g, h)),
                e = cc.v2fadd(e, cc.v2fadd(g, h)),
                g = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                h = this._trianglesArrayBuffer,
                r = this._buffer;
            r.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: c,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(cc.v2fadd(b, a)))
            }, {
                vertices: k,
                colors: d,
                texCoords: cc.__t(cc.v2fsub(b, a))
            }, {
                vertices: m,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(b))
            }, h, r.length * g));
            r.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: f,
                colors: d,
                texCoords: cc.__t(b)
            }, {
                vertices: k,
                colors: d,
                texCoords: cc.__t(cc.v2fsub(b, a))
            }, {
                vertices: m,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(b))
            }, h, r.length * g));
            r.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: f,
                colors: d,
                texCoords: cc.__t(b)
            }, {
                vertices: n,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(b))
            }, {
                vertices: m,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(b))
            }, h, r.length * g));
            r.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: f,
                colors: d,
                texCoords: cc.__t(b)
            }, {
                vertices: n,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(b))
            }, {
                vertices: p,
                colors: d,
                texCoords: cc.__t(b)
            }, h, r.length * g));
            r.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: s,
                colors: d,
                texCoords: cc.__t(cc.v2fsub(a, b))
            }, {
                vertices: n,
                colors: d,
                texCoords: cc.__t(cc.v2fneg(b))
            }, {
                vertices: p,
                colors: d,
                texCoords: cc.__t(b)
            }, h, r.length * g));
            r.push(new cc.V2F_C4B_T2F_Triangle({
                vertices: s,
                colors: d,
                texCoords: cc.__t(cc.v2fsub(a, b))
            }, {
                vertices: e,
                colors: d,
                texCoords: cc.__t(cc.v2fadd(b, a))
            }, {
                vertices: p,
                colors: d,
                texCoords: cc.__t(b)
            }, h, r.length * g));
            this._dirty = !0
        },
        drawPoly: function(a, b, c, d) {
            if (null == b) this._drawSegments(a, c, d, !0);
            else {
                null == b.a && (b.a = 255);
                null == d.a && (d.a = 255);
                c = null == c ? this._lineWidth :
                    c;
                c *= 0.5;
                b = {
                    r: 0 | b.r,
                    g: 0 | b.g,
                    b: 0 | b.b,
                    a: 0 | b.a
                };
                d = {
                    r: 0 | d.r,
                    g: 0 | d.g,
                    b: 0 | d.b,
                    a: 0 | d.a
                };
                var e = [],
                    f, g, h, k, m = a.length;
                for (f = 0; f < m; f++) {
                    g = cc.__v2f(a[(f - 1 + m) % m]);
                    h = cc.__v2f(a[f]);
                    k = cc.__v2f(a[(f + 1) % m]);
                    var n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g)));
                    h = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(k, h)));
                    n = cc.v2fmult(cc.v2fadd(n, h), 1 / (cc.v2fdot(n, h) + 1));
                    e[f] = {
                        offset: n,
                        n: h
                    }
                }
                n = 0 < c;
                this._ensureCapacity(3 * (3 * m - 2));
                var p = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT,
                    s = this._trianglesArrayBuffer,
                    r = this._buffer,
                    u = !1 == n ? 0.5 : 0;
                for (f = 0; f < m - 2; f++) g = cc.v2fsub(cc.__v2f(a[0]), cc.v2fmult(e[0].offset, u)), h = cc.v2fsub(cc.__v2f(a[f + 1]), cc.v2fmult(e[f + 1].offset, u)), k = cc.v2fsub(cc.__v2f(a[f + 2]), cc.v2fmult(e[f + 2].offset, u)), r.push(new cc.V2F_C4B_T2F_Triangle({
                    vertices: g,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: h,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, {
                    vertices: k,
                    colors: b,
                    texCoords: cc.__t(cc.v2fzero())
                }, s, r.length * p));
                for (f = 0; f < m; f++) {
                    u = (f + 1) % m;
                    g = cc.__v2f(a[f]);
                    h = cc.__v2f(a[u]);
                    k = e[f].n;
                    var t = e[f].offset,
                        v = e[u].offset,
                        u =
                        n ? cc.v2fsub(g, cc.v2fmult(t, c)) : cc.v2fsub(g, cc.v2fmult(t, 0.5)),
                        w = n ? cc.v2fsub(h, cc.v2fmult(v, c)) : cc.v2fsub(h, cc.v2fmult(v, 0.5));
                    g = n ? cc.v2fadd(g, cc.v2fmult(t, c)) : cc.v2fadd(g, cc.v2fmult(t, 0.5));
                    h = n ? cc.v2fadd(h, cc.v2fmult(v, c)) : cc.v2fadd(h, cc.v2fmult(v, 0.5));
                    n ? (r.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: u,
                        colors: d,
                        texCoords: cc.__t(cc.v2fneg(k))
                    }, {
                        vertices: w,
                        colors: d,
                        texCoords: cc.__t(cc.v2fneg(k))
                    }, {
                        vertices: h,
                        colors: d,
                        texCoords: cc.__t(k)
                    }, s, r.length * p)), r.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: u,
                        colors: d,
                        texCoords: cc.__t(cc.v2fneg(k))
                    }, {
                        vertices: g,
                        colors: d,
                        texCoords: cc.__t(k)
                    }, {
                        vertices: h,
                        colors: d,
                        texCoords: cc.__t(k)
                    }, s, r.length * p))) : (r.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: u,
                        colors: b,
                        texCoords: cc.__t(cc.v2fzero())
                    }, {
                        vertices: w,
                        colors: b,
                        texCoords: cc.__t(cc.v2fzero())
                    }, {
                        vertices: h,
                        colors: b,
                        texCoords: cc.__t(k)
                    }, s, r.length * p)), r.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: u,
                            colors: b,
                            texCoords: cc.__t(cc.v2fzero())
                        }, {
                            vertices: g,
                            colors: b,
                            texCoords: cc.__t(k)
                        }, {
                            vertices: h,
                            colors: b,
                            texCoords: cc.__t(k)
                        },
                        s, r.length * p)))
                }
                this._dirty = !0
            }
        },
        _drawSegments: function(a, b, c, d) {
            b = null == b ? this._lineWidth : b;
            c = c || this._drawColor;
            null == c.a && (c.a = 255);
            b *= 0.5;
            if (!(0 >= b)) {
                c = {
                    r: 0 | c.r,
                    g: 0 | c.g,
                    b: 0 | c.b,
                    a: 0 | c.a
                };
                var e = [],
                    f, g, h, k, m = a.length;
                for (f = 0; f < m; f++) {
                    g = cc.__v2f(a[(f - 1 + m) % m]);
                    h = cc.__v2f(a[f]);
                    k = cc.__v2f(a[(f + 1) % m]);
                    var n = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(h, g)));
                    h = cc.v2fnormalize(cc.v2fperp(cc.v2fsub(k, h)));
                    k = cc.v2fmult(cc.v2fadd(n, h), 1 / (cc.v2fdot(n, h) + 1));
                    e[f] = {
                        offset: k,
                        n: h
                    }
                }
                this._ensureCapacity(3 * (3 * m - 2));
                k = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                var n = this._trianglesArrayBuffer,
                    p = this._buffer;
                d = d ? m : m - 1;
                for (f = 0; f < d; f++) {
                    var s = (f + 1) % m;
                    g = cc.__v2f(a[f]);
                    h = cc.__v2f(a[s]);
                    var r = e[f].n,
                        u = e[f].offset,
                        t = e[s].offset,
                        s = cc.v2fsub(g, cc.v2fmult(u, b)),
                        v = cc.v2fsub(h, cc.v2fmult(t, b));
                    g = cc.v2fadd(g, cc.v2fmult(u, b));
                    h = cc.v2fadd(h, cc.v2fmult(t, b));
                    p.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: s,
                        colors: c,
                        texCoords: cc.__t(cc.v2fneg(r))
                    }, {
                        vertices: v,
                        colors: c,
                        texCoords: cc.__t(cc.v2fneg(r))
                    }, {
                        vertices: h,
                        colors: c,
                        texCoords: cc.__t(r)
                    }, n, p.length * k));
                    p.push(new cc.V2F_C4B_T2F_Triangle({
                        vertices: s,
                        colors: c,
                        texCoords: cc.__t(cc.v2fneg(r))
                    }, {
                        vertices: g,
                        colors: c,
                        texCoords: cc.__t(r)
                    }, {
                        vertices: h,
                        colors: c,
                        texCoords: cc.__t(r)
                    }, n, p.length * k))
                }
                this._dirty = !0
            }
        },
        clear: function() {
            this._buffer.length = 0;
            this._dirty = !0
        },
        _createRenderCmd: function() {
            return new cc.DrawNode.WebGLRenderCmd(this)
        }
    })
});
(function() {
    cc.DrawNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._blendFunc = this._drawColor = this._buffer = null
    };
    cc.DrawNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    cc.DrawNode.CanvasRenderCmd.prototype.constructor = cc.DrawNode.CanvasRenderCmd;
    cc.extend(cc.DrawNode.CanvasRenderCmd.prototype, {
        rendering: function(a, b, c) {
            a = a || cc._renderContext;
            a.getContext();
            var d = this._node._displayedOpacity / 255;
            if (0 !== d) {
                a.setTransform(this._worldTransform,
                    b, c);
                a.setGlobalAlpha(d);
                this._blendFunc && this._blendFunc.src === cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE && a.setCompositeOperation("lighter");
                for (var d = this._buffer, e = 0, f = d.length; e < f; e++) {
                    var g = d[e];
                    switch (g.type) {
                        case cc.DrawNode.TYPE_DOT:
                            this._drawDot(a, g, b, c);
                            break;
                        case cc.DrawNode.TYPE_SEGMENT:
                            this._drawSegment(a, g, b, c);
                            break;
                        case cc.DrawNode.TYPE_POLY:
                            this._drawPoly(a, g, b, c)
                    }
                }
            }
        },
        _drawDot: function(a, b, c, d) {
            var e = b.fillColor,
                f = b.verts[0];
            b = b.lineWidth;
            var g = a.getContext();
            a.setFillStyle("rgba(" +
                (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")");
            g.beginPath();
            g.arc(f.x * c, -f.y * d, b * c, 0, 2 * Math.PI, !1);
            g.closePath();
            g.fill()
        },
        _drawSegment: function(a, b, c, d) {
            var e = b.lineColor,
                f = b.verts[0],
                g = b.verts[1],
                h = b.lineWidth;
            b = b.lineCap;
            var k = a.getContext();
            a.setStrokeStyle("rgba(" + (0 | e.r) + "," + (0 | e.g) + "," + (0 | e.b) + "," + e.a / 255 + ")");
            k.lineWidth = h * c;
            k.beginPath();
            k.lineCap = b;
            k.moveTo(f.x * c, -f.y * d);
            k.lineTo(g.x * c, -g.y * d);
            k.stroke()
        },
        _drawPoly: function(a, b, c, d) {
            var e = b.verts,
                f = b.lineCap;
            if (null != e) {
                var g = b.fillColor,
                    h = b.lineWidth,
                    k = b.lineColor,
                    m = b.isClosePolygon,
                    n = b.isFill;
                b = b.isStroke;
                var p = a.getContext(),
                    s = e[0];
                p.lineCap = f;
                g && a.setFillStyle("rgba(" + (0 | g.r) + "," + (0 | g.g) + "," + (0 | g.b) + "," + g.a / 255 + ")");
                h && (p.lineWidth = h * c);
                k && a.setStrokeStyle("rgba(" + (0 | k.r) + "," + (0 | k.g) + "," + (0 | k.b) + "," + k.a / 255 + ")");
                p.beginPath();
                p.moveTo(s.x * c, -s.y * d);
                a = 1;
                for (f = e.length; a < f; a++) p.lineTo(e[a].x * c, -e[a].y * d);
                m && p.closePath();
                n && p.fill();
                b && p.stroke()
            }
        }
    })
})();
(function() {
    cc.DrawNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    cc.DrawNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd;
    cc.DrawNode.WebGLRenderCmd.prototype.rendering = function(a) {
        a = this._node;
        cc.glBlendFunc(a._blendFunc.src, a._blendFunc.dst);
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
        a._render()
    }
})();
cc.stencilBits = -1;
cc.ClippingNode = cc.Node.extend({
    alphaThreshold: 0,
    inverted: !1,
    _stencil: null,
    _className: "ClippingNode",
    ctor: function(a) {
        a = a || null;
        cc.Node.prototype.ctor.call(this);
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1;
        this._renderCmd.initStencilBits()
    },
    init: function(a) {
        this._stencil = a;
        this.alphaThreshold = 1;
        this.inverted = !1;
        this._renderCmd.initStencilBits();
        return !0
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this._stencil.onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        this._stencil.onEnterTransitionDidFinish()
    },
    onExitTransitionDidStart: function() {
        this._stencil.onExitTransitionDidStart();
        cc.Node.prototype.onExitTransitionDidStart.call(this)
    },
    onExit: function() {
        this._stencil.onExit();
        cc.Node.prototype.onExit.call(this)
    },
    getAlphaThreshold: function() {
        return this.alphaThreshold
    },
    setAlphaThreshold: function(a) {
        this.alphaThreshold = a
    },
    isInverted: function() {
        return this.inverted
    },
    setInverted: function(a) {
        this.inverted = a
    },
    getStencil: function() {
        return this._stencil
    },
    setStencil: function(a) {
        this._stencil !== a && this._renderCmd.setStencil(a)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this)
    }
});
_p = cc.ClippingNode.prototype;
cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
cc.ClippingNode.create = function(a) {
    return new cc.ClippingNode(a)
};
(function() {
    cc.ClippingNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._clipElemType = this._godhelpme = this._needDraw = !1;
        this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._saveCmdCallback);
        this._rendererClipCmd = new cc.CustomRenderCmd(this, this._clipCmdCallback);
        this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback)
    };
    var a = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ClippingNode.CanvasRenderCmd;
    a.initStencilBits = function() {};
    a.setStencil = function(a) {
        if (null != a)
            if (this._node._stencil = a, a instanceof cc.DrawNode) {
                if (a._buffer)
                    for (var c = 0; c < a._buffer.length; c++) a._buffer[c].isFill = !1, a._buffer[c].isStroke = !1;
                a._renderCmd.rendering = function(c, e, f) {
                    e = e || cc.view.getScaleX();
                    f = f || cc.view.getScaleY();
                    c = (c || cc._renderContext).getContext();
                    var g = this._transform;
                    c.transform(g.a, g.b, g.c, g.d, g.tx * e, -g.ty * f);
                    for (g = 0; g < a._buffer.length; g++) {
                        var h = a._buffer[g].verts,
                            k = h[0];
                        c.moveTo(k.x * e, -k.y * f);
                        for (k = h.length -
                            1; 0 < k; k--) c.lineTo(h[k].x * e, -h[k].y * f)
                    }
                }
            } else a._parent = this._node
    };
    a._saveCmdCallback = function(a, c, d) {
        var e = a || cc._renderContext;
        a = e.getContext();
        this._clipElemType ? (c = cc.ClippingNode.CanvasRenderCmd._getSharedCache(), d = a.canvas, c.width = d.width, c.height = d.height, c.getContext("2d").drawImage(d, 0, 0)) : (e.save(), a.beginPath(), e.setTransform(this._worldTransform, c, d), this._node.inverted && (a.rect(0, 0, a.canvas.width, -a.canvas.height), a.clip()))
    };
    a._setStencilCompositionOperation = function(a) {
        if (a) {
            var c =
                this._node;
            a._renderCmd && a._renderCmd._blendFuncStr && (a._renderCmd._blendFuncStr = c.inverted ? "destination-out" : "destination-in");
            if (a._children) {
                a = a._children;
                for (var c = 0, d = a.length; c < d; c++) this._setStencilCompositionOperation(a[c])
            }
        }
    };
    a._clipCmdCallback = function(a) {
        var c = this._node;
        a = (a || cc._renderContext).getContext();
        this._clipElemType ? this._setStencilCompositionOperation(c._stencil) : a.clip()
    };
    a._restoreCmdCallback = function(a) {
        var c = cc.ClippingNode.CanvasRenderCmd._getSharedCache();
        a = a || cc._renderContext;
        var d = a.getContext();
        this._clipElemType ? (d.save(), d.setTransform(1, 0, 0, 1, 0, 0), d.globalCompositeOperation = "destination-over", d.drawImage(c, 0, 0), d.restore(), this._dirtyFlag = 0) : a.restore()
    };
    a.transform = function(a, c) {
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, a, c);
        var d = this._node;
        d._stencil && d._stencil._renderCmd && d._stencil._renderCmd.transform(this, c)
    };
    a._cangodhelpme = function(a) {
        if (!0 === a || !1 === a) cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme = a;
        return cc.ClippingNode.CanvasRenderCmd.prototype._godhelpme
    };
    a.visit = function(a) {
        var c = this._node;
        if (c._visible) {
            if (a = a || this.getParentRenderCmd()) this._curLevel = a._curLevel + 1;
            this._clipElemType = !(!this._cangodhelpme() && c._stencil instanceof cc.DrawNode);
            if (c._stencil && c._stencil.visible) {
                this._syncStatus(a);
                cc.renderer.pushRenderCommand(this._rendererSaveCmd);
                this._clipElemType ? cc.Node.CanvasRenderCmd.prototype.visit.call(this, a) : c._stencil.visit(this);
                cc.renderer.pushRenderCommand(this._rendererClipCmd);
                if (this._clipElemType) c._stencil.visit(this);
                else {
                    a =
                        c._children;
                    this._cangodhelpme(!0);
                    var d = a.length;
                    if (0 < d)
                        for (c.sortAllChildren(), c = 0; c < d; c++) a[c]._renderCmd.visit(this);
                    this._cangodhelpme(!1)
                }
                cc.renderer.pushRenderCommand(this._rendererRestoreCmd);
                this._dirtyFlag = 0
            } else this.inverted && cc.Node.CanvasRenderCmd.prototype.visit.call(this, a)
        }
    };
    cc.ClippingNode.CanvasRenderCmd._sharedCache = null;
    cc.ClippingNode.CanvasRenderCmd._getSharedCache = function() {
        return cc.ClippingNode.CanvasRenderCmd._sharedCache || (cc.ClippingNode.CanvasRenderCmd._sharedCache =
            document.createElement("canvas"))
    }
})();
(function() {
    cc.ClippingNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !1;
        this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
        this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
        this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
        this._mask_layer_le = this._currentDepthWriteMask = this._currentStencilEnabled = this._currentStencilWriteMask = this._currentStencilPassDepthPass = this._currentStencilPassDepthFail =
            this._currentStencilFail = this._currentStencilValueMask = this._currentStencilRef = this._currentStencilFunc = null
    };
    var a = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ClippingNode.WebGLRenderCmd;
    cc.ClippingNode.WebGLRenderCmd._init_once = null;
    cc.ClippingNode.WebGLRenderCmd._visit_once = null;
    cc.ClippingNode.WebGLRenderCmd._layer = -1;
    a.initStencilBits = function() {
        cc.ClippingNode.WebGLRenderCmd._init_once = !0;
        cc.ClippingNode.WebGLRenderCmd._init_once &&
            (cc.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS), 0 >= cc.stencilBits && cc.log("Stencil buffer is not enabled."), cc.ClippingNode.WebGLRenderCmd._init_once = !1)
    };
    a.transform = function(a, c) {
        var d = this._node;
        cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, c);
        d._stencil && d._stencil._renderCmd.transform(this, c)
    };
    a.visit = function(a) {
        var c = this._node;
        if (c._visible)
            if (c._parent && c._parent._renderCmd && (this._curLevel = c._parent._renderCmd._curLevel + 1), 1 > cc.stencilBits) cc.Node.WebGLRenderCmd.prototype.visit.call(this,
                a);
            else if (c._stencil && c._stencil.visible)
            if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.stencilBits) cc.ClippingNode.WebGLRenderCmd._visit_once = !0, cc.ClippingNode.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its children."), cc.ClippingNode.WebGLRenderCmd._visit_once = !1), cc.Node.WebGLRenderCmd.prototype.visit.call(this, a);
            else {
                cc.renderer.pushRenderCommand(this._beforeVisitCmd);
                var d =
                    cc.current_stack;
                d.stack.push(d.top);
                this._syncStatus(a);
                d.top = this._stackMatrix;
                c._stencil._renderCmd.visit(this);
                cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
                if ((a = c._children) && 0 < a.length) {
                    var e = a.length;
                    c.sortAllChildren();
                    for (c = 0; c < e; c++) a[c]._renderCmd.visit(this)
                }
                cc.renderer.pushRenderCommand(this._afterVisitCmd);
                this._dirtyFlag = 0;
                d.top = d.stack.pop()
            }
        else c.inverted && cc.Node.WebGLRenderCmd.prototype.visit.call(this, a)
    };
    a.setStencil = function(a) {
        var c = this._node;
        c._stencil && (c._stencil._parent =
            null);
        c._stencil = a;
        c._stencil && (c._stencil._parent = c)
    };
    a._drawFullScreenQuadClearStencil = function() {
        var a = cc.projection_matrix_stack;
        a.push();
        a.top.identity();
        var c = cc.modelview_matrix_stack;
        c.push();
        c.top.identity();
        cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
        a.pop();
        c.pop()
    };
    a._onBeforeVisit = function(a) {
        var c = a || cc._renderContext;
        a = this._node;
        cc.ClippingNode.WebGLRenderCmd._layer++;
        var d = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
        this._mask_layer_le = d | d - 1;
        this._currentStencilEnabled =
            c.isEnabled(c.STENCIL_TEST);
        this._currentStencilWriteMask = c.getParameter(c.STENCIL_WRITEMASK);
        this._currentStencilFunc = c.getParameter(c.STENCIL_FUNC);
        this._currentStencilRef = c.getParameter(c.STENCIL_REF);
        this._currentStencilValueMask = c.getParameter(c.STENCIL_VALUE_MASK);
        this._currentStencilFail = c.getParameter(c.STENCIL_FAIL);
        this._currentStencilPassDepthFail = c.getParameter(c.STENCIL_PASS_DEPTH_FAIL);
        this._currentStencilPassDepthPass = c.getParameter(c.STENCIL_PASS_DEPTH_PASS);
        c.enable(c.STENCIL_TEST);
        c.stencilMask(d);
        this._currentDepthWriteMask = c.getParameter(c.DEPTH_WRITEMASK);
        c.depthMask(!1);
        c.stencilFunc(c.NEVER, d, d);
        c.stencilOp(a.inverted ? c.REPLACE : c.ZERO, c.KEEP, c.KEEP);
        this._drawFullScreenQuadClearStencil();
        c.stencilFunc(c.NEVER, d, d);
        c.stencilOp(a.inverted ? c.ZERO : c.REPLACE, c.KEEP, c.KEEP);
        1 > a.alphaThreshold && (d = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST), c = c.getUniformLocation(d.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), cc.glUseProgram(d.getProgram()), d.setUniformLocationWith1f(c,
            a.alphaThreshold), cc.setProgram(a._stencil, d))
    };
    a._onAfterDrawStencil = function(a) {
        a = a || cc._renderContext;
        a.depthMask(this._currentDepthWriteMask);
        a.stencilFunc(a.EQUAL, this._mask_layer_le, this._mask_layer_le);
        a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
    };
    a._onAfterVisit = function(a) {
        a = a || cc._renderContext;
        a.stencilFunc(this._currentStencilFunc, this._currentStencilRef, this._currentStencilValueMask);
        a.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass);
        a.stencilMask(this._currentStencilWriteMask);
        this._currentStencilEnabled || a.disable(a.STENCIL_TEST);
        cc.ClippingNode.WebGLRenderCmd._layer--
    }
})();
cc.GridBase = cc.Class.extend({
    _active: !1,
    _reuseGrid: 0,
    _gridSize: null,
    _gridRect: null,
    _texture: null,
    _step: null,
    _grabber: null,
    _isTextureFlipped: !1,
    _shaderProgram: null,
    _directorProjection: 0,
    _dirty: !1,
    ctor: function(a, b, c, d) {
        cc.sys._checkWebGLRenderMode();
        this._active = !1;
        this._reuseGrid = 0;
        this._gridSize = null;
        this._gridRect = new cc.rect;
        this._texture = null;
        this._step = cc.p(0, 0);
        this._grabber = null;
        this._isTextureFlipped = !1;
        this._shaderProgram = null;
        this._directorProjection = 0;
        this._dirty = !1;
        void 0 !== a && this.initWithSize(a,
            b, c, d)
    },
    isActive: function() {
        return this._active
    },
    setActive: function(a) {
        this._active = a;
        if (!a) {
            a = cc.director;
            var b = a.getProjection();
            a.setProjection(b)
        }
    },
    getReuseGrid: function() {
        return this._reuseGrid
    },
    setReuseGrid: function(a) {
        this._reuseGrid = a
    },
    getGridSize: function() {
        return cc.size(this._gridSize.width, this._gridSize.height)
    },
    setGridSize: function(a) {
        this._gridSize.width = parseInt(a.width);
        this._gridSize.height = parseInt(a.height)
    },
    setGridRect: function(a) {
        this._gridRect = a
    },
    getGridRect: function() {
        return this._gridRect
    },
    getStep: function() {
        return cc.p(this._step.x, this._step.y)
    },
    setStep: function(a) {
        this._step.x = a.x;
        this._step.y = a.y
    },
    isTextureFlipped: function() {
        return this._isTextureFlipped
    },
    setTextureFlipped: function(a) {
        this._isTextureFlipped !== a && (this._isTextureFlipped = a, this.calculateVertexPoints())
    },
    initWithSize: function(a, b, c, d) {
        if (!b) {
            var e = cc.director.getWinSizeInPixels(),
                f = cc.NextPOT(e.width),
                g = cc.NextPOT(e.height),
                h = new Uint8Array(f * g * 4);
            if (!h) return cc.log("cocos2d: CCGrid: not enough memory."), !1;
            b = new cc.Texture2D;
            b.initWithData(h, cc.Texture2D.PIXEL_FORMAT_RGBA8888, f, g, e);
            if (!b) return cc.log("cocos2d: CCGrid: error creating texture"), !1
        }
        this._active = !1;
        this._reuseGrid = 0;
        this._gridSize = a;
        this._texture = b;
        this._isTextureFlipped = c || !1;
        if (void 0 === d || cc._rectEqualToZero(d)) b = this._texture.getContentSize(), d = new cc.rect(0, 0, b.width, b.height);
        this._gridRect = d;
        this._step.x = this._gridRect.width / a.width;
        this._step.y = this._gridRect.height / a.height;
        this._grabber = new cc.Grabber;
        if (!this._grabber) return !1;
        this._grabber.grab(this._texture);
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURE);
        this.calculateVertexPoints();
        return !0
    },
    beforeDraw: function() {
        this._directorProjection = cc.director.getProjection();
        this._grabber.beforeRender(this._texture)
    },
    afterDraw: function(a) {
        this._grabber.afterRender(this._texture);
        if (a && a.getCamera().isDirty()) {
            var b = a.getAnchorPointInPoints(),
                c = a._renderCmd._stackMatrix,
                d = cc.math.Matrix4.createByTranslation(b.x, b.y, 0);
            c.multiply(d);
            a._camera._locateForRenderer(c);
            d = cc.math.Matrix4.createByTranslation(-b.x, -b.y, 0, d);
            c.multiply(d)
        }
        cc.glBindTexture2D(this._texture);
        this.beforeBlit();
        this.blit(a);
        this.afterBlit()
    },
    beforeBlit: function() {},
    afterBlit: function() {},
    blit: function() {
        cc.log("cc.GridBase.blit(): Shall be overridden in subclass.")
    },
    reuse: function() {
        cc.log("cc.GridBase.reuse(): Shall be overridden in subclass.")
    },
    calculateVertexPoints: function() {
        cc.log("cc.GridBase.calculateVertexPoints(): Shall be overridden in subclass.")
    },
    set2DProjection: function() {
        var a = cc.director.getWinSizeInPixels();
        cc._renderContext.viewport(0,
            0, a.width, a.height);
        cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
        cc.kmGLLoadIdentity();
        a = cc.math.Matrix4.createOrthographicProjection(0, a.width, 0, a.height, -1, 1);
        cc.kmGLMultMatrix(a);
        cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
        cc.kmGLLoadIdentity();
        cc.setProjectionMatrixDirty()
    }
});
cc.GridBase.create = function(a, b, c, d) {
    return new cc.GridBase(a, b, c, d)
};
cc.Grid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    _needDepthTestForBlit: !1,
    _oldDepthTestValue: !1,
    _oldDepthWriteValue: !1,
    ctor: function(a, b, c, d) {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
        void 0 !== a && this.initWithSize(a, b, c, d)
    },
    vertex: function(a) {
        return this.getVertex(a)
    },
    getVertex: function(a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.vertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._vertices;
        return new cc.Vertex3F(b[a], b[a + 1], b[a + 2])
    },
    originalVertex: function(a) {
        return this.getOriginalVertex(a)
    },
    getOriginalVertex: function(a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.originalVertex() : Numbers must be integers");
        a = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y);
        var b = this._originalVertices;
        return new cc.Vertex3F(b[a], b[a +
            1], b[a + 2])
    },
    setVertex: function(a, b) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.Grid3D.setVertex() : Numbers must be integers");
        var c = 0 | 3 * (a.x * (this._gridSize.height + 1) + a.y),
            d = this._vertices;
        d[c] = b.x;
        d[c + 1] = b.y;
        d[c + 2] = b.z;
        this._dirty = !0
    },
    beforeBlit: function() {
        if (this._needDepthTestForBlit) {
            var a = cc._renderContext;
            this._oldDepthTestValue = a.isEnabled(a.DEPTH_TEST);
            this._oldDepthWriteValue = a.getParameter(a.DEPTH_WRITEMASK);
            a.enable(a.DEPTH_TEST);
            a.depthMask(!0)
        }
    },
    afterBlit: function() {
        if (this._needDepthTestForBlit) {
            var a =
                cc._renderContext;
            this._oldDepthTestValue ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST);
            a.depthMask(this._oldDepthWriteValue)
        }
    },
    blit: function(a) {
        var b = this._gridSize.width * this._gridSize.height;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(a._renderCmd._stackMatrix);
        a = cc._renderContext;
        var c = this._dirty;
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        c && a.bufferData(a.ARRAY_BUFFER,
            this._vertices, a.DYNAMIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 3, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
        c && a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, 0);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        c && a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        a.drawElements(a.TRIANGLES, 6 * b, a.UNSIGNED_SHORT, 0);
        c && (this._dirty = !1);
        cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var a = this._originalVertices, b = this._vertices, c = 0, d = this._vertices.length; c < d; c++) a[c] = b[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = cc._renderContext,
            b = this._texture.pixelsWidth,
            c = this._texture.pixelsHeight,
            d = this._texture.getContentSizeInPixels().height,
            e = this._gridSize,
            f = (e.width + 1) * (e.height + 1);
        this._vertices = new Float32Array(3 * f);
        this._texCoordinates = new Float32Array(2 * f);
        this._indices = new Uint16Array(e.width * e.height * 6);
        this._verticesBuffer &&
            a.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = a.createBuffer();
        this._texCoordinateBuffer && a.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = a.createBuffer();
        this._indicesBuffer && a.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = a.createBuffer();
        for (var g, h, k = this._indices, m = this._texCoordinates, n = this._isTextureFlipped, p = this._vertices, f = 0; f < e.width; ++f)
            for (g = 0; g < e.height; ++g) {
                var s = g * e.width + f;
                h = f * this._step.x + this._gridRect.x;
                var r = h + this._step.x,
                    u = g * this._step.y +
                    this._gridRect.y,
                    t = u + this._step.y,
                    v = f * (e.height + 1) + g,
                    w = (f + 1) * (e.height + 1) + g,
                    A = (f + 1) * (e.height + 1) + (g + 1),
                    C = f * (e.height + 1) + (g + 1);
                k[6 * s] = v;
                k[6 * s + 1] = w;
                k[6 * s + 2] = C;
                k[6 * s + 3] = w;
                k[6 * s + 4] = A;
                k[6 * s + 5] = C;
                var s = [3 * v, 3 * w, 3 * A, 3 * C],
                    E = [{
                        x: h,
                        y: u,
                        z: 0
                    }, {
                        x: r,
                        y: u,
                        z: 0
                    }, {
                        x: r,
                        y: t,
                        z: 0
                    }, {
                        x: h,
                        y: t,
                        z: 0
                    }],
                    v = [2 * v, 2 * w, 2 * A, 2 * C],
                    r = [cc.p(h, u), cc.p(r, u), cc.p(r, t), cc.p(h, t)];
                for (h = 0; 4 > h; ++h) p[s[h]] = E[h].x, p[s[h] + 1] = E[h].y, p[s[h] + 2] = E[h].z, m[v[h]] = r[h].x / b, m[v[h] + 1] = n ? (d - r[h].y) / c : r[h].y / c
            }
        this._originalVertices = new Float32Array(this._vertices);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        this._dirty = !0
    },
    setNeedDepthTestForBlit: function(a) {
        this._needDepthTestForBlit = a
    },
    getNeedDepthTestForBlit: function() {
        return this._needDepthTestForBlit
    }
});
cc.Grid3D.create = function(a, b, c) {
    return new cc.Grid3D(a, b, c)
};
cc.TiledGrid3D = cc.GridBase.extend({
    _texCoordinates: null,
    _vertices: null,
    _originalVertices: null,
    _indices: null,
    _texCoordinateBuffer: null,
    _verticesBuffer: null,
    _indicesBuffer: null,
    ctor: function(a, b, c, d) {
        cc.GridBase.prototype.ctor.call(this);
        this._indicesBuffer = this._verticesBuffer = this._texCoordinateBuffer = this._indices = this._originalVertices = this._vertices = this._texCoordinates = null;
        void 0 !== a && this.initWithSize(a, b, c, d)
    },
    tile: function(a) {
        return this.getTile(a)
    },
    getTile: function(a) {
        a.x === (0 | a.x) && a.y ===
            (0 | a.y) || cc.log("cc.TiledGrid3D.tile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._vertices;
        return new cc.Quad3(new cc.Vertex3F(b[a], b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    getOriginalTile: function(a) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.TiledGrid3D.originalTile() : Numbers must be integers");
        a = 12 * (this._gridSize.height * a.x + a.y);
        var b = this._originalVertices;
        return new cc.Quad3(new cc.Vertex3F(b[a],
            b[a + 1], b[a + 2]), new cc.Vertex3F(b[a + 3], b[a + 4], b[a + 5]), new cc.Vertex3F(b[a + 6], b[a + 7], b[a + 8]), new cc.Vertex3F(b[a + 9], b[a + 10], b[a + 11]))
    },
    originalTile: function(a) {
        return this.getOriginalTile(a)
    },
    setTile: function(a, b) {
        a.x === (0 | a.x) && a.y === (0 | a.y) || cc.log("cc.TiledGrid3D.setTile() : Numbers must be integers");
        var c = 12 * (this._gridSize.height * a.x + a.y),
            d = this._vertices;
        d[c] = b.bl.x;
        d[c + 1] = b.bl.y;
        d[c + 2] = b.bl.z;
        d[c + 3] = b.br.x;
        d[c + 4] = b.br.y;
        d[c + 5] = b.br.z;
        d[c + 6] = b.tl.x;
        d[c + 7] = b.tl.y;
        d[c + 8] = b.tl.z;
        d[c + 9] = b.tr.x;
        d[c +
            10] = b.tr.y;
        d[c + 11] = b.tr.z;
        this._dirty = !0
    },
    blit: function(a) {
        var b = this._gridSize.width * this._gridSize.height;
        this._shaderProgram.use();
        this._shaderProgram._setUniformForMVPMatrixWithMat4(a._renderCmd._stackMatrix);
        a = cc._renderContext;
        var c = this._dirty;
        cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POSITION | cc.VERTEX_ATTRIB_FLAG_TEX_COORDS);
        a.bindBuffer(a.ARRAY_BUFFER, this._verticesBuffer);
        c && a.bufferData(a.ARRAY_BUFFER, this._vertices, a.DYNAMIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
            3, a.FLOAT, !1, 0, this._vertices);
        a.bindBuffer(a.ARRAY_BUFFER, this._texCoordinateBuffer);
        c && a.bufferData(a.ARRAY_BUFFER, this._texCoordinates, a.DYNAMIC_DRAW);
        a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 0, this._texCoordinates);
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        c && a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices, a.STATIC_DRAW);
        a.drawElements(a.TRIANGLES, 6 * b, a.UNSIGNED_SHORT, 0);
        c && (this._dirty = !1);
        cc.incrementGLDraws(1)
    },
    reuse: function() {
        if (0 < this._reuseGrid) {
            for (var a =
                    this._vertices, b = this._originalVertices, c = 0; c < a.length; c++) b[c] = a[c];
            --this._reuseGrid
        }
    },
    calculateVertexPoints: function() {
        var a = this._texture.pixelsWidth,
            b = this._texture.pixelsHeight,
            c = this._texture.getContentSizeInPixels().height,
            d = this._gridSize,
            e = d.width * d.height;
        this._vertices = new Float32Array(12 * e);
        this._texCoordinates = new Float32Array(8 * e);
        this._indices = new Uint16Array(6 * e);
        var f = cc._renderContext;
        this._verticesBuffer && f.deleteBuffer(this._verticesBuffer);
        this._verticesBuffer = f.createBuffer();
        this._texCoordinateBuffer && f.deleteBuffer(this._texCoordinateBuffer);
        this._texCoordinateBuffer = f.createBuffer();
        this._indicesBuffer && f.deleteBuffer(this._indicesBuffer);
        this._indicesBuffer = f.createBuffer();
        var g, h, k = 0,
            m = this._step,
            n = this._vertices,
            p = this._texCoordinates,
            s = this._isTextureFlipped;
        for (g = 0; g < d.width; g++)
            for (h = 0; h < d.height; h++) {
                var r = g * m.x,
                    u = r + m.x,
                    t = h * m.y,
                    v = t + m.y;
                n[12 * k] = r;
                n[12 * k + 1] = t;
                n[12 * k + 2] = 0;
                n[12 * k + 3] = u;
                n[12 * k + 4] = t;
                n[12 * k + 5] = 0;
                n[12 * k + 6] = r;
                n[12 * k + 7] = v;
                n[12 * k + 8] = 0;
                n[12 * k + 9] = u;
                n[12 *
                    k + 10] = v;
                n[12 * k + 11] = 0;
                var w = t,
                    A = v;
                s && (w = c - t, A = c - v);
                p[8 * k] = r / a;
                p[8 * k + 1] = w / b;
                p[8 * k + 2] = u / a;
                p[8 * k + 3] = w / b;
                p[8 * k + 4] = r / a;
                p[8 * k + 5] = A / b;
                p[8 * k + 6] = u / a;
                p[8 * k + 7] = A / b;
                k++
            }
        a = this._indices;
        for (g = 0; g < e; g++) a[6 * g + 0] = 4 * g + 0, a[6 * g + 1] = 4 * g + 1, a[6 * g + 2] = 4 * g + 2, a[6 * g + 3] = 4 * g + 1, a[6 * g + 4] = 4 * g + 2, a[6 * g + 5] = 4 * g + 3;
        this._originalVertices = new Float32Array(this._vertices);
        f.bindBuffer(f.ARRAY_BUFFER, this._verticesBuffer);
        f.bufferData(f.ARRAY_BUFFER, this._vertices, f.DYNAMIC_DRAW);
        f.bindBuffer(f.ARRAY_BUFFER, this._texCoordinateBuffer);
        f.bufferData(f.ARRAY_BUFFER,
            this._texCoordinates, f.DYNAMIC_DRAW);
        f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, this._indicesBuffer);
        f.bufferData(f.ELEMENT_ARRAY_BUFFER, this._indices, f.DYNAMIC_DRAW);
        this._dirty = !0
    }
});
cc.TiledGrid3D.create = function(a, b, c) {
    return new cc.TiledGrid3D(a, b, c)
};
cc.Grabber = cc.Class.extend({
    _FBO: null,
    _oldFBO: null,
    _oldClearColor: null,
    _gl: null,
    ctor: function() {
        cc.sys._checkWebGLRenderMode();
        this._gl = cc._renderContext;
        this._oldClearColor = [0, 0, 0, 0];
        this._oldFBO = null;
        this._FBO = this._gl.createFramebuffer()
    },
    grab: function(a) {
        var b = this._gl;
        this._oldFBO = b.getParameter(b.FRAMEBUFFER_BINDING);
        b.bindFramebuffer(b.FRAMEBUFFER, this._FBO);
        b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, a._webTextureObj, 0);
        b.checkFramebufferStatus(b.FRAMEBUFFER) !== b.FRAMEBUFFER_COMPLETE &&
            cc.log("Frame Grabber: could not attach texture to frmaebuffer");
        b.bindFramebuffer(b.FRAMEBUFFER, this._oldFBO)
    },
    beforeRender: function(a) {
        a = this._gl;
        this._oldFBO = a.getParameter(a.FRAMEBUFFER_BINDING);
        a.bindFramebuffer(a.FRAMEBUFFER, this._FBO);
        this._oldClearColor = a.getParameter(a.COLOR_CLEAR_VALUE);
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)
    },
    afterRender: function(a) {
        a = this._gl;
        a.bindFramebuffer(a.FRAMEBUFFER, this._oldFBO);
        a.colorMask(!0, !0, !0, !0)
    },
    destroy: function() {
        this._gl.deleteFramebuffer(this._FBO)
    }
});
cc.ACTION_TAG_INVALID = -1;
cc.Action = cc.Class.extend({
    originalTarget: null,
    target: null,
    tag: cc.ACTION_TAG_INVALID,
    ctor: function() {
        this.target = this.originalTarget = null;
        this.tag = cc.ACTION_TAG_INVALID;
        this.curTime = cc.director.getActionManager().getCurTime()
    },
    copy: function() {
        cc.log("copy is deprecated. Please use clone instead.");
        return this.clone()
    },
    clone: function() {
        var a = new cc.Action;
        a.originalTarget = null;
        a.target = null;
        a.tag = this.tag;
        return a
    },
    isDone: function() {
        return !0
    },
    startWithTarget: function(a) {
        this.target = this.originalTarget =
            a
    },
    stop: function() {
        this.target = null
    },
    step: function(a) {
        cc.log("[Action step]. override me")
    },
    step_time: function(a) {
        this.curTime >= a || (this.step((a - this.curTime) / 1E3), this.curTime = a)
    },
    update: function(a) {
        cc.log("[Action update]. override me")
    },
    getTarget: function() {
        return this.target
    },
    setTarget: function(a) {
        this.target = a
    },
    getOriginalTarget: function() {
        return this.originalTarget
    },
    setOriginalTarget: function(a) {
        this.originalTarget = a
    },
    getTag: function() {
        return this.tag
    },
    setTag: function(a) {
        this.tag = a
    },
    retain: function() {},
    release: function() {}
});
cc.action = function() {
    return new cc.Action
};
cc.Action.create = cc.action;
cc.FiniteTimeAction = cc.Action.extend({
    _duration: 0,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._duration = 0
    },
    getDuration: function() {
        return this._duration * (this._timesForRepeat || 1)
    },
    setDuration: function(a) {
        this._duration = a
    },
    reverse: function() {
        cc.log("cocos2d: FiniteTimeAction#reverse: Implement me");
        return null
    },
    clone: function() {
        return new cc.FiniteTimeAction
    }
});
cc.Speed = cc.Action.extend({
    _speed: 0,
    _innerAction: null,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this);
        this._speed = 0;
        this._innerAction = null;
        a && this.initWithAction(a, b)
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a
    },
    initWithAction: function(a, b) {
        if (!a) throw Error("cc.Speed.initWithAction(): action must be non nil");
        this._innerAction = a;
        this._speed = b;
        return !0
    },
    clone: function() {
        var a = new cc.Speed;
        a.initWithAction(this._innerAction.clone(), this._speed);
        return a
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    step: function(a) {
        this._innerAction.step(a * this._speed)
    },
    isDone: function() {
        return this._innerAction.isDone()
    },
    reverse: function() {
        return new cc.Speed(this._innerAction.reverse(), this._speed)
    },
    setInnerAction: function(a) {
        this._innerAction !== a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.speed = function(a, b) {
    return new cc.Speed(a, b)
};
cc.Speed.create = cc.speed;
cc.Follow = cc.Action.extend({
    _followedNode: null,
    _boundarySet: !1,
    _boundaryFullyCovered: !1,
    _halfScreenSize: null,
    _fullScreenSize: null,
    _worldRect: null,
    leftBoundary: 0,
    rightBoundary: 0,
    topBoundary: 0,
    bottomBoundary: 0,
    ctor: function(a, b) {
        cc.Action.prototype.ctor.call(this);
        this._followedNode = null;
        this._boundaryFullyCovered = this._boundarySet = !1;
        this._fullScreenSize = this._halfScreenSize = null;
        this.bottomBoundary = this.topBoundary = this.rightBoundary = this.leftBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
        a && (b ? this.initWithTarget(a,
            b) : this.initWithTarget(a))
    },
    clone: function() {
        var a = new cc.Follow,
            b = this._worldRect,
            b = new cc.Rect(b.x, b.y, b.width, b.height);
        a.initWithTarget(this._followedNode, b);
        return a
    },
    isBoundarySet: function() {
        return this._boundarySet
    },
    setBoudarySet: function(a) {
        this._boundarySet = a
    },
    initWithTarget: function(a, b) {
        if (!a) throw Error("cc.Follow.initWithAction(): followedNode must be non nil");
        b = b || cc.rect(0, 0, 0, 0);
        this._followedNode = a;
        this._worldRect = b;
        this._boundarySet = !cc._rectEqualToZero(b);
        this._boundaryFullyCovered = !1;
        var c = cc.director.getWinSize();
        this._fullScreenSize = cc.p(c.width, c.height);
        this._halfScreenSize = cc.pMult(this._fullScreenSize, 0.5);
        this._boundarySet && (this.leftBoundary = -(b.x + b.width - this._fullScreenSize.x), this.rightBoundary = -b.x, this.topBoundary = -b.y, this.bottomBoundary = -(b.y + b.height - this._fullScreenSize.y), this.rightBoundary < this.leftBoundary && (this.rightBoundary = this.leftBoundary = (this.leftBoundary + this.rightBoundary) / 2), this.topBoundary < this.bottomBoundary && (this.topBoundary = this.bottomBoundary =
            (this.topBoundary + this.bottomBoundary) / 2), this.topBoundary === this.bottomBoundary && this.leftBoundary === this.rightBoundary && (this._boundaryFullyCovered = !0));
        return !0
    },
    step: function(a) {
        a = this._followedNode.x;
        var b = this._followedNode.y;
        a = this._halfScreenSize.x - a;
        b = this._halfScreenSize.y - b;
        this.target._renderCmd._dirtyFlag = 0;
        this._boundarySet ? this._boundaryFullyCovered || this.target.setPosition(cc.clampf(a, this.leftBoundary, this.rightBoundary), cc.clampf(b, this.bottomBoundary, this.topBoundary)) : this.target.setPosition(a,
            b)
    },
    isDone: function() {
        return !this._followedNode.running
    },
    stop: function() {
        this.target = null;
        cc.Action.prototype.stop.call(this)
    }
});
cc.follow = function(a, b) {
    return new cc.Follow(a, b)
};
cc.Follow.create = cc.follow;
cc.ActionInterval = cc.FiniteTimeAction.extend({
    _elapsed: 0,
    _firstTick: !1,
    _easeList: null,
    _timesForRepeat: 1,
    _repeatForever: !1,
    _repeatMethod: !1,
    _speed: 1,
    _speedMethod: !1,
    ctor: function(a) {
        this._timesForRepeat = this._speed = 1;
        this._repeatForever = !1;
        this.MAX_VALUE = 2;
        this._speedMethod = this._repeatMethod = !1;
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.initWithDuration(a)
    },
    getElapsed: function() {
        return this._elapsed
    },
    initWithDuration: function(a) {
        this._duration = 0 === a ? cc.FLT_EPSILON : a;
        this._elapsed =
            0;
        return this._firstTick = !0
    },
    isDone: function() {
        return this._elapsed >= this._duration
    },
    _cloneDecoration: function(a) {
        a._repeatForever = this._repeatForever;
        a._speed = this._speed;
        a._timesForRepeat = this._timesForRepeat;
        a._easeList = this._easeList;
        a._speedMethod = this._speedMethod;
        a._repeatMethod = this._repeatMethod
    },
    _reverseEaseList: function(a) {
        if (this._easeList) {
            a._easeList = [];
            for (var b = 0; b < this._easeList.length; b++) a._easeList.push(this._easeList[b].reverse())
        }
    },
    clone: function() {
        var a = new cc.ActionInterval(this._duration);
        this._cloneDecoration(a);
        return a
    },
    easing: function(a) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var b = 0; b < arguments.length; b++) this._easeList.push(arguments[b]);
        return this
    },
    _computeEaseTime: function(a) {
        var b = this._easeList;
        if (!b || 0 === b.length) return a;
        for (var c = 0, d = b.length; c < d; c++) a = b[c].easing(a);
        return a
    },
    step: function(a) {
        this._firstTick ? (this._firstTick = !1, this._elapsed = 0) : this._elapsed += a;
        a = this._elapsed / (1.192092896E-7 < this._duration ? this._duration : 1.192092896E-7);
        a = 1 > a ?
            a : 1;
        this.update(0 < a ? a : 0);
        this._repeatMethod && 1 < this._timesForRepeat && this.isDone() && (this._repeatForever || this._timesForRepeat--, this.startWithTarget(this.target), this.step(this._elapsed - this._duration))
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this, a);
        this._elapsed = 0;
        this._firstTick = !0
    },
    reverse: function() {
        cc.log("cc.IntervalAction: reverse not implemented.");
        return null
    },
    setAmplitudeRate: function(a) {
        cc.log("cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.")
    },
    getAmplitudeRate: function() {
        cc.log("cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.");
        return 0
    },
    speed: function(a) {
        if (0 >= a) return cc.log("The speed parameter error"), this;
        this._speedMethod = !0;
        this._speed *= a;
        return this
    },
    getSpeed: function() {
        return this._speed
    },
    setSpeed: function(a) {
        this._speed = a;
        return this
    },
    repeat: function(a) {
        a = Math.round(a);
        if (isNaN(a) || 1 > a) return cc.log("The repeat parameter error"), this;
        this._repeatMethod = !0;
        this._timesForRepeat *= a;
        return this
    },
    repeatForever: function() {
        this._repeatMethod = !0;
        this._timesForRepeat = this.MAX_VALUE;
        this._repeatForever = !0;
        return this
    }
});
cc.actionInterval = function(a) {
    return new cc.ActionInterval(a)
};
cc.ActionInterval.create = cc.actionInterval;
cc.Sequence = cc.ActionInterval.extend({
    _actions: null,
    _split: null,
    _last: 0,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._actions = [];
        var b = a instanceof Array ? a : arguments,
            c = b.length - 1;
        0 <= c && null == b[c] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= c) {
            for (var d = b[0], e = 1; e < c; e++) b[e] && (d = cc.Sequence._actionOneTwo(d, b[e]));
            this.initWithTwoActions(d, b[c])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
        this.initWithDuration(a._duration + b._duration);
        this._actions[0] = a;
        this._actions[1] = b;
        return !0
    },
    clone: function() {
        var a = new cc.Sequence;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._split = this._actions[0]._duration / this._duration;
        this._last = -1
    },
    stop: function() {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        var b =
            0,
            c = this._split,
            d = this._actions,
            e = this._last;
        a = this._computeEaseTime(a);
        a < c ? (a = 0 !== c ? a / c : 1, 0 === b && 1 === e && (d[1].update(0), d[1].stop())) : (b = 1, a = 1 === c ? 1 : (a - c) / (1 - c), -1 === e && (d[0].startWithTarget(this.target), d[0].update(1), d[0].stop()), e || (d[0].update(1), d[0].stop()));
        d = d[b];
        e === b && d.isDone() || (e !== b && d.startWithTarget(this.target), a *= d._timesForRepeat, d.update(1 < a ? a % 1 : a), this._last = b)
    },
    reverse: function() {
        var a = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.sequence = function(a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c, d, e, f; b && 0 < b.length;)
        for (d = Array.prototype.shift.call(b), f = d._timesForRepeat || 1, d._repeatMethod = !1, d._timesForRepeat = 1, e = 0, c || (c = d, e = 1), e; e < f; e++) c = cc.Sequence._actionOneTwo(c, d);
    return c
};
cc.Sequence.create = cc.sequence;
cc.Sequence._actionOneTwo = function(a, b) {
    var c = new cc.Sequence;
    c.initWithTwoActions(a, b);
    return c
};
cc.Repeat = cc.ActionInterval.extend({
    _times: 0,
    _total: 0,
    _nextDt: 0,
    _actionInstant: !1,
    _innerAction: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithAction(a, b)
    },
    initWithAction: function(a, b) {
        return this.initWithDuration(a._duration * b) ? (this._times = b, this._innerAction = a, a instanceof cc.ActionInstant && (this._actionInstant = !0, this._times -= 1), this._total = 0, !0) : !1
    },
    clone: function() {
        var a = new cc.Repeat;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone(),
            this._times);
        return a
    },
    startWithTarget: function(a) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._innerAction.startWithTarget(a)
    },
    stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._innerAction,
            c = this._duration,
            d = this._times,
            e = this._nextDt;
        if (a >= e) {
            for (; a > e && this._total < d;) b.update(1), this._total++, b.stop(), b.startWithTarget(this.target),
                this._nextDt = e += b._duration / c;
            1 <= a && this._total < d && this._total++;
            this._actionInstant || (this._total === d ? (b.update(1), b.stop()) : b.update(a - (e - b._duration / c)))
        } else b.update(a * d % 1)
    },
    isDone: function() {
        return this._total === this._times
    },
    reverse: function() {
        var a = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    setInnerAction: function(a) {
        this._innerAction !== a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.repeat = function(a, b) {
    return new cc.Repeat(a, b)
};
cc.Repeat.create = cc.repeat;
cc.RepeatForever = cc.ActionInterval.extend({
    _innerAction: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._innerAction = null;
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw Error("cc.RepeatForever.initWithAction(): action must be non null");
        this._innerAction = a;
        return !0
    },
    clone: function() {
        var a = new cc.RepeatForever;
        this._cloneDecoration(a);
        a.initWithAction(this._innerAction.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._innerAction.startWithTarget(a)
    },
    step: function(a) {
        var b = this._innerAction;
        b.step(a);
        b.isDone() && (b.startWithTarget(this.target), b.step(b.getElapsed() - b._duration))
    },
    isDone: function() {
        return !1
    },
    reverse: function() {
        var a = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    setInnerAction: function(a) {
        this._innerAction !== a && (this._innerAction = a)
    },
    getInnerAction: function() {
        return this._innerAction
    }
});
cc.repeatForever = function(a) {
    return new cc.RepeatForever(a)
};
cc.RepeatForever.create = cc.repeatForever;
cc.Spawn = cc.ActionInterval.extend({
    _one: null,
    _two: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._two = this._one = null;
        var b = a instanceof Array ? a : arguments,
            c = b.length - 1;
        0 <= c && null == b[c] && cc.log("parameters should not be ending with null in Javascript");
        if (0 <= c) {
            for (var d = b[0], e = 1; e < c; e++) b[e] && (d = cc.Spawn._actionOneTwo(d, b[e]));
            this.initWithTwoActions(d, b[c])
        }
    },
    initWithTwoActions: function(a, b) {
        if (!a || !b) throw Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
        var c = !1,
            d = a._duration,
            e = b._duration;
        this.initWithDuration(Math.max(d, e)) && (this._one = a, this._two = b, d > e ? this._two = cc.Sequence._actionOneTwo(b, cc.delayTime(d - e)) : d < e && (this._one = cc.Sequence._actionOneTwo(a, cc.delayTime(e - d))), c = !0);
        return c
    },
    clone: function() {
        var a = new cc.Spawn;
        this._cloneDecoration(a);
        a.initWithTwoActions(this._one.clone(), this._two.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._one.startWithTarget(a);
        this._two.startWithTarget(a)
    },
    stop: function() {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._one && this._one.update(a);
        this._two && this._two.update(a)
    },
    reverse: function() {
        var a = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.spawn = function(a) {
    var b = a instanceof Array ? a : arguments;
    0 < b.length && null == b[b.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    for (var c = b[0], d = 1; d < b.length; d++) null != b[d] && (c = cc.Spawn._actionOneTwo(c, b[d]));
    return c
};
cc.Spawn.create = cc.spawn;
cc.Spawn._actionOneTwo = function(a, b) {
    var c = new cc.Spawn;
    c.initWithTwoActions(a, b);
    return c
};
cc.RotateTo = cc.ActionInterval.extend({
    _dstAngleX: 0,
    _startAngleX: 0,
    _diffAngleX: 0,
    _dstAngleY: 0,
    _startAngleY: 0,
    _diffAngleY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._dstAngleX = b || 0, this._dstAngleY = c || this._dstAngleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._dstAngleX,
            this._dstAngleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.rotationX % 360,
            c = this._dstAngleX - b;
        180 < c && (c -= 360); - 180 > c && (c += 360);
        this._startAngleX = b;
        this._diffAngleX = c;
        this._startAngleY = a.rotationY % 360;
        a = this._dstAngleY - this._startAngleY;
        180 < a && (a -= 360); - 180 > a && (a += 360);
        this._diffAngleY = a
    },
    reverse: function() {
        cc.log("cc.RotateTo.reverse(): it should be overridden in subclass.")
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX =
            this._startAngleX + this._diffAngleX * a, this.target.rotationY = this._startAngleY + this._diffAngleY * a)
    }
});
cc.rotateTo = function(a, b, c) {
    return new cc.RotateTo(a, b, c)
};
cc.RotateTo.create = cc.rotateTo;
cc.RotateBy = cc.ActionInterval.extend({
    _angleX: 0,
    _startAngleX: 0,
    _angleY: 0,
    _startAngleY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._angleX = b || 0, this._angleY = c || this._angleX, !0) : !1
    },
    clone: function() {
        var a = new cc.RotateBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._angleX, this._angleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._startAngleX = a.rotationX;
        this._startAngleY = a.rotationY
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.rotationX = this._startAngleX + this._angleX * a, this.target.rotationY = this._startAngleY + this._angleY * a)
    },
    reverse: function() {
        var a = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.rotateBy = function(a, b, c) {
    return new cc.RotateBy(a, b, c)
};
cc.RotateBy.create = cc.rotateBy;
cc.MoveBy = cc.ActionInterval.extend({
    _positionDelta: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._positionDelta = cc.p(0, 0);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 !== b.x && (c = b.y, b = b.x), this._positionDelta.x = b, this._positionDelta.y = c, !0) : !1
    },
    clone: function() {
        var a =
            new cc.MoveBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._positionDelta);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = this._positionDelta.x * a;
            a *= this._positionDelta.y;
            var c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d =
                    this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                b += c.x;
                a += c.y;
                f.x = b;
                f.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(c.x + b, c.y + a)
        }
    },
    reverse: function() {
        var a = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.moveBy = function(a, b, c) {
    return new cc.MoveBy(a, b, c)
};
cc.MoveBy.create = cc.moveBy;
cc.MoveTo = cc.MoveBy.extend({
    _endPosition: null,
    ctor: function(a, b, c) {
        cc.MoveBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.MoveBy.prototype.initWithDuration.call(this, a, b, c) ? (void 0 !== b.x && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
    },
    clone: function() {
        var a = new cc.MoveTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition);
        return a
    },
    startWithTarget: function(a) {
        cc.MoveBy.prototype.startWithTarget.call(this,
            a);
        this._positionDelta.x = this._endPosition.x - a.getPositionX();
        this._positionDelta.y = this._endPosition.y - a.getPositionY()
    }
});
cc.moveTo = function(a, b, c) {
    return new cc.MoveTo(a, b, c)
};
cc.MoveTo.create = cc.moveTo;
cc.SkewTo = cc.ActionInterval.extend({
    _skewX: 0,
    _skewY: 0,
    _startSkewX: 0,
    _startSkewY: 0,
    _endSkewX: 0,
    _endSkewY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        var d = !1;
        cc.ActionInterval.prototype.initWithDuration.call(this, a) && (this._endSkewX = b, this._endSkewY = c, d = !0);
        return d
    },
    clone: function() {
        var a = new cc.SkewTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startSkewX = a.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        180 < this._deltaX && (this._deltaX -= 360); - 180 > this._deltaX && (this._deltaX += 360);
        this._startSkewY = a.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        180 < this._deltaY && (this._deltaY -= 360); - 180 > this._deltaY && (this._deltaY += 360)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target.skewX = this._startSkewX + this._deltaX * a;
        this.target.skewY =
            this._startSkewY + this._deltaY * a
    }
});
cc.skewTo = function(a, b, c) {
    return new cc.SkewTo(a, b, c)
};
cc.SkewTo.create = cc.skewTo;
cc.SkewBy = cc.SkewTo.extend({
    ctor: function(a, b, c) {
        cc.SkewTo.prototype.ctor.call(this);
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        var d = !1;
        cc.SkewTo.prototype.initWithDuration.call(this, a, b, c) && (this._skewX = b, this._skewY = c, d = !0);
        return d
    },
    clone: function() {
        var a = new cc.SkewBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._skewX, this._skewY);
        return a
    },
    startWithTarget: function(a) {
        cc.SkewTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY
    },
    reverse: function() {
        var a = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.skewBy = function(a, b, c) {
    return new cc.SkewBy(a, b, c)
};
cc.SkewBy.create = cc.skewBy;
cc.JumpBy = cc.ActionInterval.extend({
    _startPosition: null,
    _delta: null,
    _height: 0,
    _jumps: 0,
    _previousPosition: null,
    ctor: function(a, b, c, d, e) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        this._delta = cc.p(0, 0);
        void 0 !== d && this.initWithDuration(a, b, c, d, e)
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (void 0 === e && (e = d, d = c, c = b.y, b = b.x), this._delta.x = b, this._delta.y = c, this._height = d, this._jumps =
            e, !0) : !1
    },
    clone: function() {
        var a = new cc.JumpBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = a * this._jumps % 1,
                b = 4 * this._height * b * (1 - b),
                b = b + this._delta.y *
                a;
            a *= this._delta.x;
            var c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                a += c.x;
                b += c.y;
                f.x = a;
                f.y = b;
                this.target.setPosition(a, b)
            } else this.target.setPosition(c.x + a, c.y + b)
        }
    },
    reverse: function() {
        var a = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.jumpBy = function(a, b, c, d, e) {
    return new cc.JumpBy(a, b, c, d, e)
};
cc.JumpBy.create = cc.jumpBy;
cc.JumpTo = cc.JumpBy.extend({
    _endPosition: null,
    ctor: function(a, b, c, d, e) {
        cc.JumpBy.prototype.ctor.call(this);
        this._endPosition = cc.p(0, 0);
        void 0 !== d && this.initWithDuration(a, b, c, d, e)
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.JumpBy.prototype.initWithDuration.call(this, a, b, c, d, e) ? (void 0 === e && (c = b.y, b = b.x), this._endPosition.x = b, this._endPosition.y = c, !0) : !1
    },
    startWithTarget: function(a) {
        cc.JumpBy.prototype.startWithTarget.call(this, a);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y =
            this._endPosition.y - this._startPosition.y
    },
    clone: function() {
        var a = new cc.JumpTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return a
    }
});
cc.jumpTo = function(a, b, c, d, e) {
    return new cc.JumpTo(a, b, c, d, e)
};
cc.JumpTo.create = cc.jumpTo;
cc.bezierAt = function(a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
};
cc.BezierBy = cc.ActionInterval.extend({
    _config: null,
    _startPosition: null,
    _previousPosition: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._config = [];
        this._startPosition = cc.p(0, 0);
        this._previousPosition = cc.p(0, 0);
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._config = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierBy;
        this._cloneDecoration(a);
        for (var b = [], c = 0; c < this._config.length; c++) {
            var d =
                this._config[c];
            b.push(cc.p(d.x, d.y))
        }
        a.initWithDuration(this._duration, b);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        var b = a.getPositionX();
        a = a.getPositionY();
        this._previousPosition.x = b;
        this._previousPosition.y = a;
        this._startPosition.x = b;
        this._startPosition.y = a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target) {
            var b = this._config,
                c = b[0].y,
                d = b[1].y,
                e = b[2].y,
                b = cc.bezierAt(0, b[0].x, b[1].x, b[2].x, a);
            a = cc.bezierAt(0, c, d, e, a);
            c = this._startPosition;
            if (cc.ENABLE_STACKABLE_ACTIONS) {
                var d = this.target.getPositionX(),
                    e = this.target.getPositionY(),
                    f = this._previousPosition;
                c.x = c.x + d - f.x;
                c.y = c.y + e - f.y;
                b += c.x;
                a += c.y;
                f.x = b;
                f.y = a;
                this.target.setPosition(b, a)
            } else this.target.setPosition(c.x + b, c.y + a)
        }
    },
    reverse: function() {
        var a = this._config,
            a = [cc.pAdd(a[1], cc.pNeg(a[2])), cc.pAdd(a[0], cc.pNeg(a[2])), cc.pNeg(a[2])],
            a = new cc.BezierBy(this._duration, a);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.bezierBy = function(a, b) {
    return new cc.BezierBy(a, b)
};
cc.BezierBy.create = cc.bezierBy;
cc.BezierTo = cc.BezierBy.extend({
    _toConfig: null,
    ctor: function(a, b) {
        cc.BezierBy.prototype.ctor.call(this);
        this._toConfig = [];
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toConfig = b, !0) : !1
    },
    clone: function() {
        var a = new cc.BezierTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toConfig);
        return a
    },
    startWithTarget: function(a) {
        cc.BezierBy.prototype.startWithTarget.call(this, a);
        a = this._startPosition;
        var b =
            this._toConfig,
            c = this._config;
        c[0] = cc.pSub(b[0], a);
        c[1] = cc.pSub(b[1], a);
        c[2] = cc.pSub(b[2], a)
    }
});
cc.bezierTo = function(a, b) {
    return new cc.BezierTo(a, b)
};
cc.BezierTo.create = cc.bezierTo;
cc.ScaleTo = cc.ActionInterval.extend({
    _scaleX: 1,
    _scaleY: 1,
    _startScaleX: 1,
    _startScaleY: 1,
    _endScaleX: 0,
    _endScaleY: 0,
    _deltaX: 0,
    _deltaY: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._endScaleX = b, this._endScaleY = null != c ? c : b, !0) : !1
    },
    clone: function() {
        var a = new cc.ScaleTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX,
            this._endScaleY);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._startScaleX = a.scaleX;
        this._startScaleY = a.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target && (this.target.scaleX = this._startScaleX + this._deltaX * a, this.target.scaleY = this._startScaleY + this._deltaY * a)
    }
});
cc.scaleTo = function(a, b, c) {
    return new cc.ScaleTo(a, b, c)
};
cc.ScaleTo.create = cc.scaleTo;
cc.ScaleBy = cc.ScaleTo.extend({
    startWithTarget: function(a) {
        cc.ScaleTo.prototype.startWithTarget.call(this, a);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY
    },
    reverse: function() {
        var a = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.ScaleBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._endScaleX,
            this._endScaleY);
        return a
    }
});
cc.scaleBy = function(a, b, c) {
    return new cc.ScaleBy(a, b, c)
};
cc.ScaleBy.create = cc.scaleBy;
cc.Blink = cc.ActionInterval.extend({
    _times: 0,
    _originalState: !1,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._times = b, !0) : !1
    },
    clone: function() {
        var a = new cc.Blink;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._times);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        if (this.target && !this.isDone()) {
            var b = 1 / this._times;
            this.target.visible =
                a % b > b / 2
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._originalState = a.visible
    },
    stop: function() {
        this.target.visible = this._originalState;
        cc.ActionInterval.prototype.stop.call(this)
    },
    reverse: function() {
        var a = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.blink = function(a, b) {
    return new cc.Blink(a, b)
};
cc.Blink.create = cc.blink;
cc.FadeTo = cc.ActionInterval.extend({
    _toOpacity: 0,
    _fromOpacity: 0,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._toOpacity = b, !0) : !1
    },
    clone: function() {
        var a = new cc.FadeTo;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = void 0 !== this._fromOpacity ? this._fromOpacity :
            255;
        this.target.opacity = b + (this._toOpacity - b) * a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._fromOpacity = a.opacity
    }
});
cc.fadeTo = function(a, b) {
    return new cc.FadeTo(a, b)
};
cc.FadeTo.create = cc.fadeTo;
cc.FadeIn = cc.FadeTo.extend({
    _reverseAction: null,
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this);
        null == a && (a = 0);
        this.initWithDuration(a, 255)
    },
    reverse: function() {
        var a = new cc.FadeOut;
        a.initWithDuration(this._duration, 0);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.FadeIn;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    },
    startWithTarget: function(a) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, a)
    }
});
cc.fadeIn = function(a) {
    return new cc.FadeIn(a)
};
cc.FadeIn.create = cc.fadeIn;
cc.FadeOut = cc.FadeTo.extend({
    ctor: function(a) {
        cc.FadeTo.prototype.ctor.call(this);
        null == a && (a = 0);
        this.initWithDuration(a, 0)
    },
    reverse: function() {
        var a = new cc.FadeIn;
        a._reverseAction = this;
        a.initWithDuration(this._duration, 255);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.FadeOut;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._toOpacity);
        return a
    }
});
cc.fadeOut = function(a) {
    return new cc.FadeOut(a)
};
cc.FadeOut.create = cc.fadeOut;
cc.TintTo = cc.ActionInterval.extend({
    _to: null,
    _from: null,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = cc.color(b, c, d), !0) : !1
    },
    clone: function() {
        var a = new cc.TintTo;
        this._cloneDecoration(a);
        var b = this._to;
        a.initWithDuration(this._duration, b.r, b.g, b.b);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._from = this.target.color
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b = this._from,
            c = this._to;
        b && this.target.setColor(cc.color(b.r + (c.r - b.r) * a, b.g + (c.g - b.g) * a, b.b + (c.b - b.b) * a))
    }
});
cc.tintTo = function(a, b, c, d) {
    return new cc.TintTo(a, b, c, d)
};
cc.TintTo.create = cc.tintTo;
cc.TintBy = cc.ActionInterval.extend({
    _deltaR: 0,
    _deltaG: 0,
    _deltaB: 0,
    _fromR: 0,
    _fromG: 0,
    _fromB: 0,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._deltaR = b, this._deltaG = c, this._deltaB = d, !0) : !1
    },
    clone: function() {
        var a = new cc.TintBy;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.color;
        this._fromR = a.r;
        this._fromG = a.g;
        this._fromB = a.b
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this.target.color = cc.color(this._fromR + this._deltaR * a, this._fromG + this._deltaG * a, this._fromB + this._deltaB * a)
    },
    reverse: function() {
        var a = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    }
});
cc.tintBy = function(a, b, c, d) {
    return new cc.TintBy(a, b, c, d)
};
cc.TintBy.create = cc.tintBy;
cc.DelayTime = cc.ActionInterval.extend({
    update: function(a) {},
    reverse: function() {
        var a = new cc.DelayTime(this._duration);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    clone: function() {
        var a = new cc.DelayTime;
        this._cloneDecoration(a);
        a.initWithDuration(this._duration);
        return a
    }
});
cc.delayTime = function(a) {
    return new cc.DelayTime(a)
};
cc.DelayTime.create = cc.delayTime;
cc.ReverseTime = cc.ActionInterval.extend({
    _other: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._other = null;
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw Error("cc.ReverseTime.initWithAction(): action must be non null");
        if (a === this._other) throw Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
        return cc.ActionInterval.prototype.initWithDuration.call(this, a._duration) ? (this._other = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ReverseTime;
        this._cloneDecoration(a);
        a.initWithAction(this._other.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._other.startWithTarget(a)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._other && this._other.update(1 - a)
    },
    reverse: function() {
        return this._other.clone()
    },
    stop: function() {
        this._other.stop();
        cc.Action.prototype.stop.call(this)
    }
});
cc.reverseTime = function(a) {
    return new cc.ReverseTime(a)
};
cc.ReverseTime.create = cc.reverseTime;
cc.Animate = cc.ActionInterval.extend({
    _animation: null,
    _nextFrame: 0,
    _origFrame: null,
    _executedLoops: 0,
    _splitTimes: null,
    _currFrameIndex: 0,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._splitTimes = [];
        a && this.initWithAnimation(a)
    },
    getAnimation: function() {
        return this._animation
    },
    setAnimation: function(a) {
        this._animation = a
    },
    getCurrentFrameIndex: function() {
        return this._currFrameIndex
    },
    initWithAnimation: function(a) {
        if (!a) throw Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
        var b = a.getDuration();
        if (this.initWithDuration(b * a.getLoops())) {
            this._nextFrame = 0;
            this.setAnimation(a);
            this._origFrame = null;
            this._executedLoops = 0;
            var c = this._splitTimes,
                d = c.length = 0,
                e = b / a.getTotalDelayUnits();
            a = a.getFrames();
            cc.arrayVerifyType(a, cc.AnimationFrame);
            for (var f = 0; f < a.length; f++) {
                var g = d * e / b,
                    d = d + a[f].getDelayUnits();
                c.push(g)
            }
            return !0
        }
        return !1
    },
    clone: function() {
        var a = new cc.Animate;
        this._cloneDecoration(a);
        a.initWithAnimation(this._animation.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._animation.getRestoreOriginalFrame() && (this._origFrame = a.displayFrame());
        this._executedLoops = this._nextFrame = 0
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        1 > a && (a *= this._animation.getLoops(), (0 | a) > this._executedLoops && (this._nextFrame = 0, this._executedLoops++), a %= 1);
        for (var b = this._animation.getFrames(), c = b.length, d = this._splitTimes, e = this._nextFrame; e < c; e++)
            if (d[e] <= a) _currFrameIndex = e, this.target.setSpriteFrame(b[_currFrameIndex].getSpriteFrame()), this._nextFrame = e + 1;
            else break
    },
    reverse: function() {
        var a =
            this._animation,
            b = a.getFrames(),
            c = [];
        cc.arrayVerifyType(b, cc.AnimationFrame);
        if (0 < b.length)
            for (var d = b.length - 1; 0 <= d; d--) {
                var e = b[d];
                if (!e) break;
                c.push(e.clone())
            }
        b = new cc.Animation(c, a.getDelayPerUnit(), a.getLoops());
        b.setRestoreOriginalFrame(a.getRestoreOriginalFrame());
        a = new cc.Animate(b);
        this._cloneDecoration(a);
        this._reverseEaseList(a);
        return a
    },
    stop: function() {
        this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
        cc.Action.prototype.stop.call(this)
    }
});
cc.animate = function(a) {
    return new cc.Animate(a)
};
cc.Animate.create = cc.animate;
cc.TargetedAction = cc.ActionInterval.extend({
    _action: null,
    _forcedTarget: null,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        b && this.initWithTarget(a, b)
    },
    initWithTarget: function(a, b) {
        return this.initWithDuration(b._duration) ? (this._forcedTarget = a, this._action = b, !0) : !1
    },
    clone: function() {
        var a = new cc.TargetedAction;
        this._cloneDecoration(a);
        a.initWithTarget(this._forcedTarget, this._action.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._action.startWithTarget(this._forcedTarget)
    },
    stop: function() {
        this._action.stop()
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        this._action.update(a)
    },
    getForcedTarget: function() {
        return this._forcedTarget
    },
    setForcedTarget: function(a) {
        this._forcedTarget !== a && (this._forcedTarget = a)
    }
});
cc.targetedAction = function(a, b) {
    return new cc.TargetedAction(a, b)
};
cc.TargetedAction.create = cc.targetedAction;
cc.ActionInstant = cc.FiniteTimeAction.extend({
    isDone: function() {
        return !0
    },
    step: function(a) {
        this.update(1)
    },
    update: function(a) {},
    reverse: function() {
        return this.clone()
    },
    clone: function() {
        return new cc.ActionInstant
    }
});
cc.Show = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !0
    },
    reverse: function() {
        return new cc.Hide
    },
    clone: function() {
        return new cc.Show
    }
});
cc.show = function() {
    return new cc.Show
};
cc.Show.create = cc.show;
cc.Hide = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !1
    },
    reverse: function() {
        return new cc.Show
    },
    clone: function() {
        return new cc.Hide
    }
});
cc.hide = function() {
    return new cc.Hide
};
cc.Hide.create = cc.hide;
cc.ToggleVisibility = cc.ActionInstant.extend({
    update: function(a) {
        this.target.visible = !this.target.visible
    },
    reverse: function() {
        return new cc.ToggleVisibility
    },
    clone: function() {
        return new cc.ToggleVisibility
    }
});
cc.toggleVisibility = function() {
    return new cc.ToggleVisibility
};
cc.ToggleVisibility.create = cc.toggleVisibility;
cc.RemoveSelf = cc.ActionInstant.extend({
    _isNeedCleanUp: !0,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        void 0 !== a && this.init(a)
    },
    update: function(a) {
        this.target.removeFromParent(this._isNeedCleanUp)
    },
    init: function(a) {
        this._isNeedCleanUp = a;
        return !0
    },
    reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    },
    clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp)
    }
});
cc.removeSelf = function(a) {
    return new cc.RemoveSelf(a)
};
cc.RemoveSelf.create = cc.removeSelf;
cc.FlipX = cc.ActionInstant.extend({
    _flippedX: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedX = !1;
        void 0 !== a && this.initWithFlipX(a)
    },
    initWithFlipX: function(a) {
        this._flippedX = a;
        return !0
    },
    update: function(a) {
        this.target.flippedX = this._flippedX
    },
    reverse: function() {
        return new cc.FlipX(!this._flippedX)
    },
    clone: function() {
        var a = new cc.FlipX;
        a.initWithFlipX(this._flippedX);
        return a
    }
});
cc.flipX = function(a) {
    return new cc.FlipX(a)
};
cc.FlipX.create = cc.flipX;
cc.FlipY = cc.ActionInstant.extend({
    _flippedY: !1,
    ctor: function(a) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._flippedY = !1;
        void 0 !== a && this.initWithFlipY(a)
    },
    initWithFlipY: function(a) {
        this._flippedY = a;
        return !0
    },
    update: function(a) {
        this.target.flippedY = this._flippedY
    },
    reverse: function() {
        return new cc.FlipY(!this._flippedY)
    },
    clone: function() {
        var a = new cc.FlipY;
        a.initWithFlipY(this._flippedY);
        return a
    }
});
cc.flipY = function(a) {
    return new cc.FlipY(a)
};
cc.FlipY.create = cc.flipY;
cc.Place = cc.ActionInstant.extend({
    _x: 0,
    _y: 0,
    ctor: function(a, b) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this._y = this._x = 0;
        void 0 !== a && (void 0 !== a.x && (b = a.y, a = a.x), this.initWithPosition(a, b))
    },
    initWithPosition: function(a, b) {
        this._x = a;
        this._y = b;
        return !0
    },
    update: function(a) {
        this.target.setPosition(this._x, this._y)
    },
    clone: function() {
        var a = new cc.Place;
        a.initWithPosition(this._x, this._y);
        return a
    }
});
cc.place = function(a, b) {
    return new cc.Place(a, b)
};
cc.Place.create = cc.place;
cc.CallFunc = cc.ActionInstant.extend({
    _selectorTarget: null,
    _function: null,
    _data: null,
    ctor: function(a, b, c) {
        cc.FiniteTimeAction.prototype.ctor.call(this);
        this.initWithFunction(a, b, c)
    },
    initWithFunction: function(a, b, c) {
        a && (this._function = a);
        b && (this._selectorTarget = b);
        c && (this._data = c);
        return !0
    },
    execute: function() {
        this._function && this._function.call(this._selectorTarget, this.target, this._data)
    },
    update: function(a) {
        this.execute()
    },
    getTargetCallback: function() {
        return this._selectorTarget
    },
    setTargetCallback: function(a) {
        a !==
            this._selectorTarget && (this._selectorTarget && (this._selectorTarget = null), this._selectorTarget = a)
    },
    clone: function() {
        var a = new cc.CallFunc;
        a.initWithFunction(this._function, this._selectorTarget, this._data);
        return a
    }
});
cc.callFunc = function(a, b, c) {
    return new cc.CallFunc(a, b, c)
};
cc.CallFunc.create = cc.callFunc;
cc.ActionCamera = cc.ActionInterval.extend({
    _centerXOrig: 0,
    _centerYOrig: 0,
    _centerZOrig: 0,
    _eyeXOrig: 0,
    _eyeYOrig: 0,
    _eyeZOrig: 0,
    _upXOrig: 0,
    _upYOrig: 0,
    _upZOrig: 0,
    ctor: function() {
        cc.ActionInterval.prototype.ctor.call(this);
        this._upZOrig = this._upYOrig = this._upXOrig = this._eyeZOrig = this._eyeYOrig = this._eyeXOrig = this._centerZOrig = this._centerYOrig = this._centerXOrig = 0
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        a = a.getCamera();
        var b = a.getCenter();
        this._centerXOrig = b.x;
        this._centerYOrig = b.y;
        this._centerZOrig = b.z;
        b = a.getEye();
        this._eyeXOrig = b.x;
        this._eyeYOrig = b.y;
        this._eyeZOrig = b.z;
        a = a.getUp();
        this._upXOrig = a.x;
        this._upYOrig = a.y;
        this._upZOrig = a.z
    },
    clone: function() {
        return new cc.ActionCamera
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    }
});
cc.OrbitCamera = cc.ActionCamera.extend({
    _radius: 0,
    _deltaRadius: 0,
    _angleZ: 0,
    _deltaAngleZ: 0,
    _angleX: 0,
    _deltaAngleX: 0,
    _radZ: 0,
    _radDeltaZ: 0,
    _radX: 0,
    _radDeltaX: 0,
    ctor: function(a, b, c, d, e, f, g) {
        cc.ActionCamera.prototype.ctor.call(this);
        void 0 !== g && this.initWithDuration(a, b, c, d, e, f, g)
    },
    initWithDuration: function(a, b, c, d, e, f, g) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._radius = b, this._deltaRadius = c, this._angleZ = d, this._deltaAngleZ = e, this._angleX = f, this._deltaAngleX = g, this._radDeltaZ =
            cc.degreesToRadians(e), this._radDeltaX = cc.degreesToRadians(g), !0) : !1
    },
    sphericalRadius: function() {
        var a, b;
        b = this.target.getCamera();
        var c = b.getEye();
        a = b.getCenter();
        b = c.x - a.x;
        var d = c.y - a.y;
        a = c.z - a.z;
        var c = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2) + Math.pow(a, 2)),
            e = Math.sqrt(Math.pow(b, 2) + Math.pow(d, 2));
        0 === e && (e = cc.FLT_EPSILON);
        0 === c && (c = cc.FLT_EPSILON);
        a = Math.acos(a / c);
        b = 0 > b ? Math.PI - Math.asin(d / e) : Math.asin(d / e);
        return {
            newRadius: c / cc.Camera.getZEye(),
            zenith: a,
            azimuth: b
        }
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        a = this.sphericalRadius();
        isNaN(this._radius) && (this._radius = a.newRadius);
        isNaN(this._angleZ) && (this._angleZ = cc.radiansToDegrees(a.zenith));
        isNaN(this._angleX) && (this._angleX = cc.radiansToDegrees(a.azimuth));
        this._radZ = cc.degreesToRadians(this._angleZ);
        this._radX = cc.degreesToRadians(this._angleX)
    },
    clone: function() {
        var a = new cc.OrbitCamera;
        a.initWithDuration(this._duration, this._radius, this._deltaRadius, this._angleZ, this._deltaAngleZ, this._angleX, this._deltaAngleX);
        return a
    },
    update: function(a) {
        a =
            this._computeEaseTime(a);
        var b = (this._radius + this._deltaRadius * a) * cc.Camera.getZEye(),
            c = this._radZ + this._radDeltaZ * a,
            d = this._radX + this._radDeltaX * a;
        a = Math.sin(c) * Math.cos(d) * b + this._centerXOrig;
        d = Math.sin(c) * Math.sin(d) * b + this._centerYOrig;
        b = Math.cos(c) * b + this._centerZOrig;
        this.target.getCamera().setEye(a, d, b);
        this.target.setNodeDirty()
    }
});
cc.orbitCamera = function(a, b, c, d, e, f, g) {
    return new cc.OrbitCamera(a, b, c, d, e, f, g)
};
cc.OrbitCamera.create = cc.orbitCamera;
cc.ActionEase = cc.ActionInterval.extend({
    _inner: null,
    ctor: function(a) {
        cc.ActionInterval.prototype.ctor.call(this);
        a && this.initWithAction(a)
    },
    initWithAction: function(a) {
        if (!a) throw Error("cc.ActionEase.initWithAction(): action must be non nil");
        return this.initWithDuration(a.getDuration()) ? (this._inner = a, !0) : !1
    },
    clone: function() {
        var a = new cc.ActionEase;
        a.initWithAction(this._inner.clone());
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._inner.startWithTarget(this.target)
    },
    stop: function() {
        this._inner.stop();
        cc.ActionInterval.prototype.stop.call(this)
    },
    update: function(a) {
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.ActionEase(this._inner.reverse())
    },
    getInnerAction: function() {
        return this._inner
    }
});
cc.actionEase = function(a) {
    return new cc.ActionEase(a)
};
cc.ActionEase.create = cc.actionEase;
cc.EaseRateAction = cc.ActionEase.extend({
    _rate: 0,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this);
        void 0 !== b && this.initWithAction(a, b)
    },
    setRate: function(a) {
        this._rate = a
    },
    getRate: function() {
        return this._rate
    },
    initWithAction: function(a, b) {
        return cc.ActionEase.prototype.initWithAction.call(this, a) ? (this._rate = b, !0) : !1
    },
    clone: function() {
        var a = new cc.EaseRateAction;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function() {
        return new cc.EaseRateAction(this._inner.reverse(),
            1 / this._rate)
    }
});
cc.easeRateAction = function(a, b) {
    return new cc.EaseRateAction(a, b)
};
cc.EaseRateAction.create = cc.easeRateAction;
cc.EaseIn = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, this._rate))
    },
    reverse: function() {
        return new cc.EaseIn(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseIn;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseIn.create = function(a, b) {
    return new cc.EaseIn(a, b)
};
cc.easeIn = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, this._rate)
        },
        reverse: function() {
            return cc.easeIn(1 / this._rate)
        }
    }
};
cc.EaseOut = cc.EaseRateAction.extend({
    update: function(a) {
        this._inner.update(Math.pow(a, 1 / this._rate))
    },
    reverse: function() {
        return new cc.EaseOut(this._inner.reverse(), 1 / this._rate)
    },
    clone: function() {
        var a = new cc.EaseOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    }
});
cc.EaseOut.create = function(a, b) {
    return new cc.EaseOut(a, b)
};
cc.easeOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            return Math.pow(a, 1 / this._rate)
        },
        reverse: function() {
            return cc.easeOut(1 / this._rate)
        }
    }
};
cc.EaseInOut = cc.EaseRateAction.extend({
    update: function(a) {
        a *= 2;
        1 > a ? this._inner.update(0.5 * Math.pow(a, this._rate)) : this._inner.update(1 - 0.5 * Math.pow(2 - a, this._rate))
    },
    clone: function() {
        var a = new cc.EaseInOut;
        a.initWithAction(this._inner.clone(), this._rate);
        return a
    },
    reverse: function() {
        return new cc.EaseInOut(this._inner.reverse(), this._rate)
    }
});
cc.EaseInOut.create = function(a, b) {
    return new cc.EaseInOut(a, b)
};
cc.easeInOut = function(a) {
    return {
        _rate: a,
        easing: function(a) {
            a *= 2;
            return 1 > a ? 0.5 * Math.pow(a, this._rate) : 1 - 0.5 * Math.pow(2 - a, this._rate)
        },
        reverse: function() {
            return cc.easeInOut(this._rate)
        }
    }
};
cc.EaseExponentialIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a ? 0 : Math.pow(2, 10 * (a - 1)))
    },
    reverse: function() {
        return new cc.EaseExponentialOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialIn.create = function(a) {
    return new cc.EaseExponentialIn(a)
};
cc._easeExponentialInObj = {
    easing: function(a) {
        return 0 === a ? 0 : Math.pow(2, 10 * (a - 1))
    },
    reverse: function() {
        return cc._easeExponentialOutObj
    }
};
cc.easeExponentialIn = function() {
    return cc._easeExponentialInObj
};
cc.EaseExponentialOut = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(1 === a ? 1 : -Math.pow(2, -10 * a) + 1)
    },
    reverse: function() {
        return new cc.EaseExponentialIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialOut.create = function(a) {
    return new cc.EaseExponentialOut(a)
};
cc._easeExponentialOutObj = {
    easing: function(a) {
        return 1 === a ? 1 : -Math.pow(2, -10 * a) + 1
    },
    reverse: function() {
        return cc._easeExponentialInObj
    }
};
cc.easeExponentialOut = function() {
    return cc._easeExponentialOutObj
};
cc.EaseExponentialInOut = cc.ActionEase.extend({
    update: function(a) {
        1 !== a && 0 !== a && (a *= 2, a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2));
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseExponentialInOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseExponentialInOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseExponentialInOut.create = function(a) {
    return new cc.EaseExponentialInOut(a)
};
cc._easeExponentialInOutObj = {
    easing: function(a) {
        return 1 !== a && 0 !== a ? (a *= 2, 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)) : a
    },
    reverse: function() {
        return cc._easeExponentialInOutObj
    }
};
cc.easeExponentialInOut = function() {
    return cc._easeExponentialInOutObj
};
cc.EaseSineIn = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1;
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineIn.create = function(a) {
    return new cc.EaseSineIn(a)
};
cc._easeSineInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -1 * Math.cos(a * Math.PI / 2) + 1
    },
    reverse: function() {
        return cc._easeSineOutObj
    }
};
cc.easeSineIn = function() {
    return cc._easeSineInObj
};
cc.EaseSineOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseSineIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseSineOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseSineOut.create = function(a) {
    return new cc.EaseSineOut(a)
};
cc._easeSineOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : Math.sin(a * Math.PI / 2)
    },
    reverse: function() {
        return cc._easeSineInObj
    }
};
cc.easeSineOut = function() {
    return cc._easeSineOutObj
};
cc.EaseSineInOut = cc.ActionEase.extend({
    update: function(a) {
        a = 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1);
        this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseSineInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseSineInOut(this._inner.reverse())
    }
});
cc.EaseSineInOut.create = function(a) {
    return new cc.EaseSineInOut(a)
};
cc._easeSineInOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : -0.5 * (Math.cos(Math.PI * a) - 1)
    },
    reverse: function() {
        return cc._easeSineInOutObj
    }
};
cc.easeSineInOut = function() {
    return cc._easeSineInOutObj
};
cc.EaseElastic = cc.ActionEase.extend({
    _period: 0.3,
    ctor: function(a, b) {
        cc.ActionEase.prototype.ctor.call(this);
        a && this.initWithAction(a, b)
    },
    getPeriod: function() {
        return this._period
    },
    setPeriod: function(a) {
        this._period = a
    },
    initWithAction: function(a, b) {
        cc.ActionEase.prototype.initWithAction.call(this, a);
        this._period = null == b ? 0.3 : b;
        return !0
    },
    reverse: function() {
        cc.log("cc.EaseElastic.reverse(): it should be overridden in subclass.");
        return null
    },
    clone: function() {
        var a = new cc.EaseElastic;
        a.initWithAction(this._inner.clone(),
            this._period);
        return a
    }
});
cc.EaseElastic.create = function(a, b) {
    return new cc.EaseElastic(a, b)
};
cc.EaseElasticIn = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, a -= 1, b = -Math.pow(2, 10 * a) * Math.sin((a - b) * Math.PI * 2 / this._period));
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticIn;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticIn.create = function(a, b) {
    return new cc.EaseElasticIn(a, b)
};
cc._easeElasticInObj = {
    easing: function(a) {
        if (0 === a || 1 === a) return a;
        a -= 1;
        return -Math.pow(2, 10 * a) * Math.sin((a - 0.075) * Math.PI * 2 / 0.3)
    },
    reverse: function() {
        return cc._easeElasticOutObj
    }
};
cc.easeElasticIn = function(a) {
    return a && 0.3 !== a ? {
        _period: a,
        easing: function(a) {
            if (0 === a || 1 === a) return a;
            a -= 1;
            return -Math.pow(2, 10 * a) * Math.sin((a - this._period / 4) * Math.PI * 2 / this._period)
        },
        reverse: function() {
            return cc.easeElasticOut(this._period)
        }
    } : cc._easeElasticInObj
};
cc.EaseElasticOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0;
        0 === a || 1 === a ? b = a : (b = this._period / 4, b = Math.pow(2, -10 * a) * Math.sin((a - b) * Math.PI * 2 / this._period) + 1);
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticIn(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticOut.create = function(a, b) {
    return new cc.EaseElasticOut(a, b)
};
cc._easeElasticOutObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin((a - 0.075) * Math.PI * 2 / 0.3) + 1
    },
    reverse: function() {
        return cc._easeElasticInObj
    }
};
cc.easeElasticOut = function(a) {
    return a && 0.3 !== a ? {
        _period: a,
        easing: function(a) {
            return 0 === a || 1 === a ? a : Math.pow(2, -10 * a) * Math.sin((a - this._period / 4) * Math.PI * 2 / this._period) + 1
        },
        reverse: function() {
            return cc.easeElasticIn(this._period)
        }
    } : cc._easeElasticOutObj
};
cc.EaseElasticInOut = cc.EaseElastic.extend({
    update: function(a) {
        var b = 0,
            b = this._period;
        if (0 === a || 1 === a) b = a;
        else {
            b || (b = this._period = 0.3 * 1.5);
            var c = b / 4;
            a = 2 * a - 1;
            b = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - c) * Math.PI * 2 / b) : Math.pow(2, -10 * a) * Math.sin((a - c) * Math.PI * 2 / b) * 0.5 + 1
        }
        this._inner.update(b)
    },
    reverse: function() {
        return new cc.EaseElasticInOut(this._inner.reverse(), this._period)
    },
    clone: function() {
        var a = new cc.EaseElasticInOut;
        a.initWithAction(this._inner.clone(), this._period);
        return a
    }
});
cc.EaseElasticInOut.create = function(a, b) {
    return new cc.EaseElasticInOut(a, b)
};
cc.easeElasticInOut = function(a) {
    return {
        _period: a || 0.3,
        easing: function(a) {
            var c = 0,
                c = this._period;
            if (0 === a || 1 === a) c = a;
            else {
                c || (c = this._period = 0.3 * 1.5);
                var d = c / 4;
                a = 2 * a - 1;
                c = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - d) * Math.PI * 2 / c) : Math.pow(2, -10 * a) * Math.sin((a - d) * Math.PI * 2 / c) * 0.5 + 1
            }
            return c
        },
        reverse: function() {
            return cc.easeElasticInOut(this._period)
        }
    }
};
cc.EaseBounce = cc.ActionEase.extend({
    bounceTime: function(a) {
        if (a < 1 / 2.75) return 7.5625 * a * a;
        if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
        if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
        a -= 2.625 / 2.75;
        return 7.5625 * a * a + 0.984375
    },
    clone: function() {
        var a = new cc.EaseBounce;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBounce(this._inner.reverse())
    }
});
cc.EaseBounce.create = function(a) {
    return new cc.EaseBounce(a)
};
cc.EaseBounceIn = cc.EaseBounce.extend({
    update: function(a) {
        a = 1 - this.bounceTime(1 - a);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBounceOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceIn.create = function(a) {
    return new cc.EaseBounceIn(a)
};
cc._bounceTime = function(a) {
    if (a < 1 / 2.75) return 7.5625 * a * a;
    if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
cc._easeBounceInObj = {
    easing: function(a) {
        return 1 - cc._bounceTime(1 - a)
    },
    reverse: function() {
        return cc._easeBounceOutObj
    }
};
cc.easeBounceIn = function() {
    return cc._easeBounceInObj
};
cc.EaseBounceOut = cc.EaseBounce.extend({
    update: function(a) {
        a = this.bounceTime(a);
        this._inner.update(a)
    },
    reverse: function() {
        return new cc.EaseBounceIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBounceOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBounceOut.create = function(a) {
    return new cc.EaseBounceOut(a)
};
cc._easeBounceOutObj = {
    easing: function(a) {
        return cc._bounceTime(a)
    },
    reverse: function() {
        return cc._easeBounceInObj
    }
};
cc.easeBounceOut = function() {
    return cc._easeBounceOutObj
};
cc.EaseBounceInOut = cc.EaseBounce.extend({
    update: function(a) {
        var b = 0,
            b = 0.5 > a ? 0.5 * (1 - this.bounceTime(1 - 2 * a)) : 0.5 * this.bounceTime(2 * a - 1) + 0.5;
        this._inner.update(b)
    },
    clone: function() {
        var a = new cc.EaseBounceInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBounceInOut(this._inner.reverse())
    }
});
cc.EaseBounceInOut.create = function(a) {
    return new cc.EaseBounceInOut(a)
};
cc._easeBounceInOutObj = {
    easing: function(a) {
        return a = 0.5 > a ? 0.5 * (1 - cc._bounceTime(1 - 2 * a)) : 0.5 * cc._bounceTime(2 * a - 1) + 0.5
    },
    reverse: function() {
        return cc._easeBounceInOutObj
    }
};
cc.easeBounceInOut = function() {
    return cc._easeBounceInOutObj
};
cc.EaseBackIn = cc.ActionEase.extend({
    update: function(a) {
        this._inner.update(0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158))
    },
    reverse: function() {
        return new cc.EaseBackOut(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackIn;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackIn.create = function(a) {
    return new cc.EaseBackIn(a)
};
cc._easeBackInObj = {
    easing: function(a) {
        return 0 === a || 1 === a ? a : a * a * (2.70158 * a - 1.70158)
    },
    reverse: function() {
        return cc._easeBackOutObj
    }
};
cc.easeBackIn = function() {
    return cc._easeBackInObj
};
cc.EaseBackOut = cc.ActionEase.extend({
    update: function(a) {
        a -= 1;
        this._inner.update(a * a * (2.70158 * a + 1.70158) + 1)
    },
    reverse: function() {
        return new cc.EaseBackIn(this._inner.reverse())
    },
    clone: function() {
        var a = new cc.EaseBackOut;
        a.initWithAction(this._inner.clone());
        return a
    }
});
cc.EaseBackOut.create = function(a) {
    return new cc.EaseBackOut(a)
};
cc._easeBackOutObj = {
    easing: function(a) {
        a -= 1;
        return a * a * (2.70158 * a + 1.70158) + 1
    },
    reverse: function() {
        return cc._easeBackInObj
    }
};
cc.easeBackOut = function() {
    return cc._easeBackOutObj
};
cc.EaseBackInOut = cc.ActionEase.extend({
    update: function(a) {
        a *= 2;
        1 > a ? this._inner.update(a * a * (3.5949095 * a - 2.5949095) / 2) : (a -= 2, this._inner.update(a * a * (3.5949095 * a + 2.5949095) / 2 + 1))
    },
    clone: function() {
        var a = new cc.EaseBackInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseBackInOut(this._inner.reverse())
    }
});
cc.EaseBackInOut.create = function(a) {
    return new cc.EaseBackInOut(a)
};
cc._easeBackInOutObj = {
    easing: function(a) {
        a *= 2;
        if (1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
        a -= 2;
        return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
    },
    reverse: function() {
        return cc._easeBackInOutObj
    }
};
cc.easeBackInOut = function() {
    return cc._easeBackInOutObj
};
cc.EaseBezierAction = cc.ActionEase.extend({
    _p0: null,
    _p1: null,
    _p2: null,
    _p3: null,
    ctor: function(a) {
        cc.ActionEase.prototype.ctor.call(this, a)
    },
    _updateTime: function(a, b, c, d, e) {
        return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
    },
    update: function(a) {
        a = this._updateTime(this._p0, this._p1, this._p2, this._p3, a);
        this._inner.update(a)
    },
    clone: function() {
        var a = new cc.EaseBezierAction;
        a.initWithAction(this._inner.clone());
        a.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
        return a
    },
    reverse: function() {
        var a = new cc.EaseBezierAction(this._inner.reverse());
        a.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
        return a
    },
    setBezierParamer: function(a, b, c, d) {
        this._p0 = a || 0;
        this._p1 = b || 0;
        this._p2 = c || 0;
        this._p3 = d || 0
    }
});
cc.EaseBezierAction.create = function(a) {
    return new cc.EaseBezierAction(a)
};
cc.easeBezierAction = function(a, b, c, d) {
    return {
        easing: function(e) {
            return cc.EaseBezierAction.prototype._updateTime(a, b, c, d, e)
        },
        reverse: function() {
            return cc.easeBezierAction(d, c, b, a)
        }
    }
};
cc.EaseQuadraticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return Math.pow(a, 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionIn(this._inner.reverse())
    }
});
cc.EaseQuadraticActionIn.create = function(a) {
    return new cc.EaseQuadraticActionIn(a)
};
cc._easeQuadraticActionIn = {
    easing: cc.EaseQuadraticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionIn
    }
};
cc.easeQuadraticActionIn = function() {
    return cc._easeQuadraticActionIn
};
cc.EaseQuadraticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -a * (a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionOut;
        a.initWithAction();
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionOut(this._inner.reverse())
    }
});
cc.EaseQuadraticActionOut.create = function(a) {
    return new cc.EaseQuadraticActionOut(a)
};
cc._easeQuadraticActionOut = {
    easing: cc.EaseQuadraticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionOut
    }
};
cc.easeQuadraticActionOut = function() {
    return cc._easeQuadraticActionOut
};
cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        var b = a;
        a *= 2;
        1 > a ? b = a * a * 0.5 : (--a, b = -0.5 * (a * (a - 2) - 1));
        return b
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuadraticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuadraticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuadraticActionInOut.create = function(a) {
    return new cc.EaseQuadraticActionInOut(a)
};
cc._easeQuadraticActionInOut = {
    easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuadraticActionInOut
    }
};
cc.easeQuadraticActionInOut = function() {
    return cc._easeQuadraticActionInOut
};
cc.EaseQuarticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionIn(this._inner.reverse())
    }
});
cc.EaseQuarticActionIn.create = function(a) {
    return new cc.EaseQuarticActionIn(a)
};
cc._easeQuarticActionIn = {
    easing: cc.EaseQuarticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionIn
    }
};
cc.easeQuarticActionIn = function() {
    return cc._easeQuarticActionIn
};
cc.EaseQuarticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return -(a * a * a * a - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionOut(this._inner.reverse())
    }
});
cc.EaseQuarticActionOut.create = function(a) {
    return new cc.EaseQuarticActionOut(a)
};
cc._easeQuarticActionOut = {
    easing: cc.EaseQuarticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionOut
    }
};
cc.easeQuarticActionOut = function() {
    return cc._easeQuarticActionOut
};
cc.EaseQuarticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a * a;
        a -= 2;
        return -0.5 * (a * a * a * a - 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuarticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuarticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuarticActionInOut.create = function(a) {
    return new cc.EaseQuarticActionInOut(a)
};
cc._easeQuarticActionInOut = {
    easing: cc.EaseQuarticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuarticActionInOut
    }
};
cc.easeQuarticActionInOut = function() {
    return cc._easeQuarticActionInOut
};
cc.EaseQuinticActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionIn(this._inner.reverse())
    }
});
cc.EaseQuinticActionIn.create = function(a) {
    return new cc.EaseQuinticActionIn(a)
};
cc._easeQuinticActionIn = {
    easing: cc.EaseQuinticActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionIn
    }
};
cc.easeQuinticActionIn = function() {
    return cc._easeQuinticActionIn
};
cc.EaseQuinticActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return a * a * a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionOut(this._inner.reverse())
    }
});
cc.EaseQuinticActionOut.create = function(a) {
    return new cc.EaseQuinticActionOut(a)
};
cc._easeQuinticActionOut = {
    easing: cc.EaseQuinticActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionOut
    }
};
cc.easeQuinticActionOut = function() {
    return cc._easeQuinticActionOut
};
cc.EaseQuinticActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a * a * a + 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseQuinticActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseQuinticActionInOut(this._inner.reverse())
    }
});
cc.EaseQuinticActionInOut.create = function(a) {
    return new cc.EaseQuinticActionInOut(a)
};
cc._easeQuinticActionInOut = {
    easing: cc.EaseQuinticActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeQuinticActionInOut
    }
};
cc.easeQuinticActionInOut = function() {
    return cc._easeQuinticActionInOut
};
cc.EaseCircleActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return -1 * (Math.sqrt(1 - a * a) - 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionIn(this._inner.reverse())
    }
});
cc.EaseCircleActionIn.create = function(a) {
    return new cc.EaseCircleActionIn(a)
};
cc._easeCircleActionIn = {
    easing: cc.EaseCircleActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionIn
    }
};
cc.easeCircleActionIn = function() {
    return cc._easeCircleActionIn
};
cc.EaseCircleActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return Math.sqrt(1 - a * a)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionOut(this._inner.reverse())
    }
});
cc.EaseCircleActionOut.create = function(a) {
    return new cc.EaseCircleActionOut(a)
};
cc._easeCircleActionOut = {
    easing: cc.EaseCircleActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionOut
    }
};
cc.easeCircleActionOut = function() {
    return cc._easeCircleActionOut
};
cc.EaseCircleActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
        a -= 2;
        return 0.5 * (Math.sqrt(1 - a * a) + 1)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCircleActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCircleActionInOut(this._inner.reverse())
    }
});
cc.EaseCircleActionInOut.create = function(a) {
    return new cc.EaseCircleActionInOut(a)
};
cc._easeCircleActionInOut = {
    easing: cc.EaseCircleActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCircleActionInOut
    }
};
cc.easeCircleActionInOut = function() {
    return cc._easeCircleActionInOut
};
cc.EaseCubicActionIn = cc.ActionEase.extend({
    _updateTime: function(a) {
        return a * a * a
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionIn;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionIn(this._inner.reverse())
    }
});
cc.EaseCubicActionIn.create = function(a) {
    return new cc.EaseCubicActionIn(a)
};
cc._easeCubicActionIn = {
    easing: cc.EaseCubicActionIn.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionIn
    }
};
cc.easeCubicActionIn = function() {
    return cc._easeCubicActionIn
};
cc.EaseCubicActionOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a -= 1;
        return a * a * a + 1
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionOut(this._inner.reverse())
    }
});
cc.EaseCubicActionOut.create = function(a) {
    return new cc.EaseCubicActionOut(a)
};
cc._easeCubicActionOut = {
    easing: cc.EaseCubicActionOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionOut
    }
};
cc.easeCubicActionOut = function() {
    return cc._easeCubicActionOut
};
cc.EaseCubicActionInOut = cc.ActionEase.extend({
    _updateTime: function(a) {
        a *= 2;
        if (1 > a) return 0.5 * a * a * a;
        a -= 2;
        return 0.5 * (a * a * a + 2)
    },
    update: function(a) {
        this._inner.update(this._updateTime(a))
    },
    clone: function() {
        var a = new cc.EaseCubicActionInOut;
        a.initWithAction(this._inner.clone());
        return a
    },
    reverse: function() {
        return new cc.EaseCubicActionInOut(this._inner.reverse())
    }
});
cc.EaseCubicActionInOut.create = function(a) {
    return new cc.EaseCubicActionInOut(a)
};
cc._easeCubicActionInOut = {
    easing: cc.EaseCubicActionInOut.prototype._updateTime,
    reverse: function() {
        return cc._easeCubicActionInOut
    }
};
cc.easeCubicActionInOut = function() {
    return cc._easeCubicActionInOut
};
cc.cardinalSplineAt = function(a, b, c, d, e, f) {
    var g = f * f,
        h = g * f,
        k = (1 - e) / 2;
    e = k * (-h + 2 * g - f);
    var m = k * (-h + g) + (2 * h - 3 * g + 1);
    f = k * (h - 2 * g + f) + (-2 * h + 3 * g);
    g = k * (h - g);
    return cc.p(a.x * e + b.x * m + c.x * f + d.x * g, a.y * e + b.y * m + c.y * f + d.y * g)
};
cc.reverseControlPoints = function(a) {
    for (var b = [], c = a.length - 1; 0 <= c; c--) b.push(cc.p(a[c].x, a[c].y));
    return b
};
cc.cloneControlPoints = function(a) {
    for (var b = [], c = 0; c < a.length; c++) b.push(cc.p(a[c].x, a[c].y));
    return b
};
cc.copyControlPoints = cc.cloneControlPoints;
cc.getControlPointAt = function(a, b) {
    var c = Math.min(a.length - 1, Math.max(b, 0));
    return a[c]
};
cc.reverseControlPointsInline = function(a) {
    for (var b = a.length, c = 0 | b / 2, d = 0; d < c; ++d) {
        var e = a[d];
        a[d] = a[b - d - 1];
        a[b - d - 1] = e
    }
};
cc.CardinalSplineTo = cc.ActionInterval.extend({
    _points: null,
    _deltaT: 0,
    _tension: 0,
    _previousPosition: null,
    _accumulatedDiff: null,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._points = [];
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        if (!b || 0 === b.length) throw Error("Invalid configuration. It must at least have one control point");
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.setPoints(b), this._tension = c, !0) : !1
    },
    clone: function() {
        var a =
            new cc.CardinalSplineTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
        this._accumulatedDiff = cc.p(0, 0)
    },
    update: function(a) {
        a = this._computeEaseTime(a);
        var b, c = this._points;
        if (1 === a) b = c.length - 1, a = 1;
        else {
            var d = this._deltaT;
            b = 0 | a / d;
            a = (a - d * b) / d
        }
        b = cc.cardinalSplineAt(cc.getControlPointAt(c,
            b - 1), cc.getControlPointAt(c, b - 0), cc.getControlPointAt(c, b + 1), cc.getControlPointAt(c, b + 2), this._tension, a);
        cc.ENABLE_STACKABLE_ACTIONS && (c = this.target.getPositionX() - this._previousPosition.x, a = this.target.getPositionY() - this._previousPosition.y, 0 !== c || 0 !== a) && (d = this._accumulatedDiff, c = d.x + c, a = d.y + a, d.x = c, d.y = a, b.x += c, b.y += a);
        this.updatePosition(b)
    },
    reverse: function() {
        var a = cc.reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        this.target.setPosition(a);
        this._previousPosition = a
    },
    getPoints: function() {
        return this._points
    },
    setPoints: function(a) {
        this._points = a
    }
});
cc.cardinalSplineTo = function(a, b, c) {
    return new cc.CardinalSplineTo(a, b, c)
};
cc.CardinalSplineTo.create = cc.cardinalSplineTo;
cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
    _startPosition: null,
    ctor: function(a, b, c) {
        cc.CardinalSplineTo.prototype.ctor.call(this);
        this._startPosition = cc.p(0, 0);
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    startWithTarget: function(a) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, a);
        this._startPosition.x = a.getPositionX();
        this._startPosition.y = a.getPositionY()
    },
    reverse: function() {
        for (var a = this._points.slice(), b, c = a[0], d = 1; d < a.length; ++d) b = a[d], a[d] = cc.pSub(b, c), c = b;
        a = cc.reverseControlPoints(a);
        c = a[a.length - 1];
        a.pop();
        c.x = -c.x;
        c.y = -c.y;
        a.unshift(c);
        for (d = 1; d < a.length; ++d) b = a[d], b.x = -b.x, b.y = -b.y, b.x += c.x, b.y += c.y, c = a[d] = b;
        return cc.cardinalSplineBy(this._duration, a, this._tension)
    },
    updatePosition: function(a) {
        var b = this._startPosition,
            c = a.x + b.x;
        a = a.y + b.y;
        this._previousPosition.x = c;
        this._previousPosition.y = a;
        this.target.setPosition(c, a)
    },
    clone: function() {
        var a = new cc.CardinalSplineBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points), this._tension);
        return a
    }
});
cc.cardinalSplineBy = function(a, b, c) {
    return new cc.CardinalSplineBy(a, b, c)
};
cc.CardinalSplineBy.create = cc.cardinalSplineBy;
cc.CatmullRomTo = cc.CardinalSplineTo.extend({
    ctor: function(a, b) {
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    },
    clone: function() {
        var a = new cc.CatmullRomTo;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomTo = function(a, b) {
    return new cc.CatmullRomTo(a, b)
};
cc.CatmullRomTo.create = cc.catmullRomTo;
cc.CatmullRomBy = cc.CardinalSplineBy.extend({
    ctor: function(a, b) {
        cc.CardinalSplineBy.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, a, b, 0.5)
    },
    clone: function() {
        var a = new cc.CatmullRomBy;
        a.initWithDuration(this._duration, cc.copyControlPoints(this._points));
        return a
    }
});
cc.catmullRomBy = function(a, b) {
    return new cc.CatmullRomBy(a, b)
};
cc.CatmullRomBy.create = cc.catmullRomBy;
cc.ActionTweenDelegate = cc.Class.extend({
    updateTweenAction: function(a, b) {}
});
cc.ActionTween = cc.ActionInterval.extend({
    key: "",
    from: 0,
    to: 0,
    delta: 0,
    ctor: function(a, b, c, d) {
        cc.ActionInterval.prototype.ctor.call(this);
        this.key = "";
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this.key = b, this.to = d, this.from = c, !0) : !1
    },
    startWithTarget: function(a) {
        if (!a || !a.updateTweenAction) throw Error("cc.ActionTween.startWithTarget(): target must be non-null, and target must implement updateTweenAction function");
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this.delta = this.to - this.from
    },
    update: function(a) {
        this.target.updateTweenAction(this.to - this.delta * (1 - a), this.key)
    },
    reverse: function() {
        return new cc.ActionTween(this.duration, this.key, this.to, this.from)
    },
    clone: function() {
        var a = new cc.ActionTween;
        a.initWithDuration(this._duration, this.key, this.from, this.to);
        return a
    }
});
cc.actionTween = function(a, b, c, d) {
    return new cc.ActionTween(a, b, c, d)
};
cc.ActionTween.create = cc.actionTween;
cc.GridAction = cc.ActionInterval.extend({
    _gridSize: null,
    _gridNodeTarget: null,
    ctor: function(a, b) {
        cc.sys._checkWebGLRenderMode();
        cc.ActionInterval.prototype.ctor.call(this);
        this._gridSize = cc.size(0, 0);
        b && this.initWithDuration(a, b)
    },
    _cacheTargetAsGridNode: function(a) {
        this._gridNodeTarget = a
    },
    clone: function() {
        var a = new cc.GridAction,
            b = this._gridSize;
        a.initWithDuration(this._duration, cc.size(b.width, b.height));
        return a
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a);
        cc.renderer.childrenOrderDirty = !0;
        this._cacheTargetAsGridNode(a);
        var b = this.getGrid();
        (a = this._gridNodeTarget.getGrid()) && 0 < a.getReuseGrid() ? (b = a.getGridSize(), a.isActive() && b.width === this._gridSize.width && b.height === this._gridSize.height && a.reuse()) : (a && a.isActive() && a.setActive(!1), this._gridNodeTarget.setGrid(b), this._gridNodeTarget.getGrid().setActive(!0))
    },
    reverse: function() {
        return new cc.ReverseTime(this)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this,
            a) ? (this._gridSize.width = b.width, this._gridSize.height = b.height, !0) : !1
    },
    getGrid: function() {
        cc.log("cc.GridAction.getGrid(): it should be overridden in subclass.")
    }
});
cc.gridAction = function(a, b) {
    return new cc.GridAction(a, b)
};
cc.GridAction.create = cc.gridAction;
cc.Grid3DAction = cc.GridAction.extend({
    getGrid: function() {
        return new cc.Grid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect())
    },
    getGridRect: function() {
        return this._gridNodeTarget.getGridRect()
    },
    vertex: function(a) {
        return this.getVertex(a)
    },
    getVertex: function(a) {
        return this.target.grid.getVertex(a)
    },
    originalVertex: function(a) {
        return this.getOriginalVertex(a)
    },
    getOriginalVertex: function(a) {
        return this.target.grid.originalVertex(a)
    },
    setVertex: function(a, b) {
        this.target.grid.setVertex(a,
            b)
    }
});
cc.grid3DAction = function(a, b) {
    return new cc.Grid3DAction(a, b)
};
cc.Grid3DAction.create = cc.grid3DAction;
cc.TiledGrid3DAction = cc.GridAction.extend({
    tile: function(a) {
        return this.getTile(a)
    },
    getTile: function(a) {
        return this.target.grid.tile(a)
    },
    originalTile: function(a) {
        return this.getOriginalTile(a)
    },
    getOriginalTile: function(a) {
        return this.target.grid.originalTile(a)
    },
    setTile: function(a, b) {
        this.target.grid.setTile(a, b)
    },
    getGrid: function() {
        return new cc.TiledGrid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect())
    }
});
cc.tiledGrid3DAction = function(a, b) {
    return new cc.TiledGrid3DAction(a, b)
};
cc.TiledGrid3DAction.create = cc.tiledGrid3DAction;
cc.StopGrid = cc.ActionInstant.extend({
    startWithTarget: function(a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a);
        cc.renderer.childrenOrderDirty = !0;
        (a = this.target.grid) && a.isActive() && a.setActive(!1)
    }
});
cc.stopGrid = function() {
    return new cc.StopGrid
};
cc.StopGrid.create = cc.stopGrid;
cc.ReuseGrid = cc.ActionInstant.extend({
    _times: null,
    ctor: function(a) {
        cc.ActionInstant.prototype.ctor.call(this);
        void 0 !== a && this.initWithTimes(a)
    },
    initWithTimes: function(a) {
        this._times = a;
        return !0
    },
    startWithTarget: function(a) {
        cc.ActionInstant.prototype.startWithTarget.call(this, a);
        cc.renderer.childrenOrderDirty = !0;
        this.target.grid && this.target.grid.isActive() && this.target.grid.setReuseGrid(this.target.grid.getReuseGrid() + this._times)
    }
});
cc.reuseGrid = function(a) {
    return new cc.ReuseGrid(a)
};
cc.ReuseGrid.create = cc.reuseGrid;
cc.Waves3D = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude =
            d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b = this._gridSize, c = this._amplitude, d = cc.p(0, 0), e = this._amplitudeRate, f = this._waves, g = 0; g < b.width + 1; ++g)
            for (var h = 0; h < b.height + 1; ++h) {
                d.x = g;
                d.y = h;
                var k = this.originalVertex(d);
                k.z += Math.sin(Math.PI * a * f * 2 + 0.01 * (k.y + k.x)) * c * e;
                this.setVertex(d, k)
            }
    }
});
cc.waves3D = function(a, b, c, d) {
    return new cc.Waves3D(a, b, c, d)
};
cc.Waves3D.create = cc.waves3D;
cc.FlipX3D = cc.Grid3DAction.extend({
    ctor: function(a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    initWithDuration: function(a) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, 1))
    },
    initWithSize: function(a, b) {
        return 1 !== a.width || 1 !== a.height ? (cc.log("Grid size must be (1,1)"), !1) : cc.Grid3DAction.prototype.initWithDuration.call(this, b, a)
    },
    update: function(a) {
        var b = Math.PI * a;
        a = Math.sin(b);
        var c = Math.cos(b / 2),
            b = new cc.Vertex3F,
            d = cc.p(0, 0);
        d.x = d.y = 1;
        var e = this.originalVertex(d);
        d.x = d.y = 0;
        var d = this.originalVertex(d),
            f = e.x,
            g = d.x,
            h, k;
        f > g ? (e = cc.p(0, 0), d = cc.p(0, 1), h = cc.p(1, 0), k = cc.p(1, 1)) : (h = cc.p(0, 0), k = cc.p(0, 1), e = cc.p(1, 0), d = cc.p(1, 1), f = g);
        b.x = f - f * c;
        b.z = Math.abs(parseFloat(f * a / 4));
        a = this.originalVertex(e);
        a.x = b.x;
        a.z += b.z;
        this.setVertex(e, a);
        a = this.originalVertex(d);
        a.x = b.x;
        a.z += b.z;
        this.setVertex(d, a);
        a = this.originalVertex(h);
        a.x -= b.x;
        a.z -= b.z;
        this.setVertex(h, a);
        a = this.originalVertex(k);
        a.x -= b.x;
        a.z -= b.z;
        this.setVertex(k,
            a)
    }
});
cc.flipX3D = function(a) {
    return new cc.FlipX3D(a)
};
cc.FlipX3D.create = cc.flipX3D;
cc.FlipY3D = cc.FlipX3D.extend({
    ctor: function(a) {
        void 0 !== a ? cc.GridAction.prototype.ctor.call(this, a, cc.size(1, 1)) : cc.GridAction.prototype.ctor.call(this)
    },
    update: function(a) {
        var b = Math.PI * a;
        a = Math.sin(b);
        var c = Math.cos(b / 2),
            b = new cc.Vertex3F,
            d = cc.p(0, 0);
        d.x = d.y = 1;
        var e = this.originalVertex(d);
        d.x = d.y = 0;
        var d = this.originalVertex(d),
            f = e.y,
            g = d.y,
            h, k;
        f > g ? (e = cc.p(0, 0), d = cc.p(0, 1), h = cc.p(1, 0), k = cc.p(1, 1)) : (d = cc.p(0, 0), e = cc.p(0, 1), k = cc.p(1, 0), h = cc.p(1, 1), f = g);
        b.y = f - f * c;
        b.z = Math.abs(parseFloat(f * a) / 4);
        a = this.originalVertex(e);
        a.y = b.y;
        a.z += b.z;
        this.setVertex(e, a);
        a = this.originalVertex(d);
        a.y -= b.y;
        a.z -= b.z;
        this.setVertex(d, a);
        a = this.originalVertex(h);
        a.y = b.y;
        a.z += b.z;
        this.setVertex(h, a);
        a = this.originalVertex(k);
        a.y -= b.y;
        a.z -= b.z;
        this.setVertex(k, a)
    }
});
cc.flipY3D = function(a) {
    return new cc.FlipY3D(a)
};
cc.FlipY3D.create = cc.flipY3D;
cc.Lens3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _lensEffect: 0,
    _concave: !1,
    _dirty: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getLensEffect: function() {
        return this._lensEffect
    },
    setLensEffect: function(a) {
        this._lensEffect = a
    },
    setConcave: function(a) {
        this._concave = a
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        cc.pointEqualToPoint(a, this._position) || (this._position.x = a.x, this._position.y =
            a.y, this._dirty = !0)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._lensEffect = 0.7, this._dirty = !0) : !1
    },
    update: function(a) {
        if (this._dirty) {
            a = this._gridSize.width;
            for (var b = this._gridSize.height, c = this._radius, d = this._lensEffect, e = cc.p(0, 0), f = cc.p(0, 0), g, h, k, m = 0; m < a + 1; ++m)
                for (var n = 0; n < b + 1; ++n) e.x = m, e.y = n, g = this.originalVertex(e), f.x = this._position.x - g.x, f.y = this._position.y - g.y, h = cc.pLength(f), h < c && (h = c -
                    h, h /= c, 0 === h && (h = 0.001), h = Math.log(h) * d, k = Math.exp(h) * c, h = cc.pLength(f), 0 < h && (f.x /= h, f.y /= h, f.x *= k, f.y *= k, g.z += cc.pLength(f) * d)), this.setVertex(e, g);
            this._dirty = !1
        }
    }
});
cc.lens3D = function(a, b, c, d) {
    return new cc.Lens3D(a, b, c, d)
};
cc.Lens3D.create = cc.lens3D;
cc.Ripple3D = cc.Grid3DAction.extend({
    _position: null,
    _radius: 0,
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d, e, f) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== f && this.initWithDuration(a, b, c, d, e, f)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        this._position.x = a.x;
        this._position.y = a.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._radius = d, this._waves = e, this._amplitude = f, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._radius, f = this._waves, g = this._amplitude, h = this._amplitudeRate, k, m, n = cc.p(0, 0), p = 0; p < b + 1; ++p)
            for (var s = 0; s < c + 1; ++s) {
                d.x = p;
                d.y = s;
                k = this.originalVertex(d);
                n.x =
                    this._position.x - k.x;
                n.y = this._position.y - k.y;
                m = cc.pLength(n);
                if (m < e) {
                    m = e - m;
                    var r = Math.pow(m / e, 2);
                    k.z += Math.sin(a * Math.PI * f * 2 + 0.1 * m) * g * h * r
                }
                this.setVertex(d, k)
            }
    }
});
cc.ripple3D = function(a, b, c, d, e, f) {
    return new cc.Ripple3D(a, b, c, d, e, f)
};
cc.Ripple3D.create = cc.ripple3D;
cc.Shaky3D = cc.Grid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
    },
    update: function(a) {
        a = this._gridSize.width;
        for (var b = this._gridSize.height, c = this._randRange, d = this._shakeZ, e = cc.p(0, 0), f, g = 0; g < a + 1; ++g)
            for (var h = 0; h < b + 1; ++h) e.x = g, e.y = h, f = this.originalVertex(e),
                f.x += cc.rand() % (2 * c) - c, f.y += cc.rand() % (2 * c) - c, d && (f.z += cc.rand() % (2 * c) - c), this.setVertex(e, f)
    }
});
cc.shaky3D = function(a, b, c, d) {
    return new cc.Shaky3D(a, b, c, d)
};
cc.Shaky3D.create = cc.shaky3D;
cc.Liquid = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves = c, this._amplitude =
            d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._waves, f = this._amplitude, g = this._amplitudeRate, h, k = 1; k < b; ++k)
            for (var m = 1; m < c; ++m) d.x = k, d.y = m, h = this.originalVertex(d), h.x += Math.sin(a * Math.PI * e * 2 + 0.01 * h.x) * f * g, h.y += Math.sin(a * Math.PI * e * 2 + 0.01 * h.y) * f * g, this.setVertex(d, h)
    }
});
cc.liquid = function(a, b, c, d) {
    return new cc.Liquid(a, b, c, d)
};
cc.Liquid.create = cc.liquid;
cc.Waves = cc.Grid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    _vertical: !1,
    _horizontal: !1,
    ctor: function(a, b, c, d, e, f) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== f && this.initWithDuration(a, b, c, d, e, f)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d, e, f) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this,
            a, b) ? (this._waves = c, this._amplitude = d, this._amplitudeRate = 1, this._horizontal = e, this._vertical = f, !0) : !1
    },
    update: function(a) {
        for (var b = this._gridSize.width, c = this._gridSize.height, d = cc.p(0, 0), e = this._vertical, f = this._horizontal, g = this._waves, h = this._amplitude, k = this._amplitudeRate, m, n = 0; n < b + 1; ++n)
            for (var p = 0; p < c + 1; ++p) d.x = n, d.y = p, m = this.originalVertex(d), e && (m.x += Math.sin(a * Math.PI * g * 2 + 0.01 * m.y) * h * k), f && (m.y += Math.sin(a * Math.PI * g * 2 + 0.01 * m.x) * h * k), this.setVertex(d, m)
    }
});
cc.waves = function(a, b, c, d, e, f) {
    return new cc.Waves(a, b, c, d, e, f)
};
cc.Waves.create = cc.waves;
cc.Twirl = cc.Grid3DAction.extend({
    _position: null,
    _twirls: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d, e) {
        cc.GridAction.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        void 0 !== e && this.initWithDuration(a, b, c, d, e)
    },
    getPosition: function() {
        return this._position
    },
    setPosition: function(a) {
        this._position.x = a.x;
        this._position.y = a.y
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate =
            a
    },
    initWithDuration: function(a, b, c, d, e) {
        return cc.Grid3DAction.prototype.initWithDuration.call(this, a, b) ? (this.setPosition(c), this._twirls = d, this._amplitude = e, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b = this._position, c = this._gridSize.width, d = this._gridSize.height, e = cc.p(0, 0), f = 0.1 * this._amplitude * this._amplitudeRate, g = this._twirls, h, k, m, n = cc.p(0, 0), p = 0; p < c + 1; ++p)
            for (var s = 0; s < d + 1; ++s) e.x = p, e.y = s, h = this.originalVertex(e), n.x = p - c / 2, n.y = s - d / 2, k = cc.pLength(n) * Math.cos(Math.PI / 2 + a * Math.PI *
                g * 2) * f, m = Math.sin(k) * (h.y - b.y) + Math.cos(k) * (h.x - b.x), k = Math.cos(k) * (h.y - b.y) - Math.sin(k) * (h.x - b.x), h.x = b.x + m, h.y = b.y + k, this.setVertex(e, h)
    }
});
cc.twirl = function(a, b, c, d, e) {
    return new cc.Twirl(a, b, c, d, e)
};
cc.Twirl.create = cc.twirl;
cc.ShakyTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _shakeZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._randRange = c, this._shakeZ = d, !0) : !1
    },
    update: function(a) {
        a = this._gridSize;
        for (var b = this._randRange, c = cc.p(0, 0), d = 0; d < a.width; ++d)
            for (var e = 0; e < a.height; ++e) {
                c.x = d;
                c.y = e;
                var f = this.originalTile(c);
                f.bl.x += cc.rand() % (2 *
                    b) - b;
                f.br.x += cc.rand() % (2 * b) - b;
                f.tl.x += cc.rand() % (2 * b) - b;
                f.tr.x += cc.rand() % (2 * b) - b;
                f.bl.y += cc.rand() % (2 * b) - b;
                f.br.y += cc.rand() % (2 * b) - b;
                f.tl.y += cc.rand() % (2 * b) - b;
                f.tr.y += cc.rand() % (2 * b) - b;
                this._shakeZ && (f.bl.z += cc.rand() % (2 * b) - b, f.br.z += cc.rand() % (2 * b) - b, f.tl.z += cc.rand() % (2 * b) - b, f.tr.z += cc.rand() % (2 * b) - b);
                this.setTile(c, f)
            }
    }
});
cc.shakyTiles3D = function(a, b, c, d) {
    return new cc.ShakyTiles3D(a, b, c, d)
};
cc.ShakyTiles3D.create = cc.shakyTiles3D;
cc.ShatteredTiles3D = cc.TiledGrid3DAction.extend({
    _randRange: 0,
    _once: !1,
    _shatterZ: !1,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._once = !1, this._randRange = c, this._shatterZ = d, !0) : !1
    },
    update: function(a) {
        if (!1 === this._once) {
            a = this._gridSize;
            for (var b = this._randRange, c, d = cc.p(0, 0), e = 0; e < a.width; ++e)
                for (var f = 0; f < a.height; ++f) d.x = e,
                    d.y = f, c = this.originalTile(d), c.bl.x += cc.rand() % (2 * b) - b, c.br.x += cc.rand() % (2 * b) - b, c.tl.x += cc.rand() % (2 * b) - b, c.tr.x += cc.rand() % (2 * b) - b, c.bl.y += cc.rand() % (2 * b) - b, c.br.y += cc.rand() % (2 * b) - b, c.tl.y += cc.rand() % (2 * b) - b, c.tr.y += cc.rand() % (2 * b) - b, this._shatterZ && (c.bl.z += cc.rand() % (2 * b) - b, c.br.z += cc.rand() % (2 * b) - b, c.tl.z += cc.rand() % (2 * b) - b, c.tr.z += cc.rand() % (2 * b) - b), this.setTile(d, c);
            this._once = !0
        }
    }
});
cc.shatteredTiles3D = function(a, b, c, d) {
    return new cc.ShatteredTiles3D(a, b, c, d)
};
cc.ShatteredTiles3D.create = cc.shatteredTiles3D;
cc.Tile = function(a, b, c) {
    this.position = a || cc.p(0, 0);
    this.startPosition = b || cc.p(0, 0);
    this.delta = c || cc.p(0, 0)
};
cc.ShuffleTiles = cc.TiledGrid3DAction.extend({
    _seed: 0,
    _tilesCount: 0,
    _tilesOrder: null,
    _tiles: null,
    ctor: function(a, b, c) {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        this._tiles = [];
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c, this._tilesOrder.length = 0, this._tiles.length = 0, !0) : !1
    },
    shuffle: function(a, b) {
        for (var c = b - 1; 0 <= c; c--) {
            var d = 0 | cc.rand() % (c + 1),
                e = a[c];
            a[c] = a[d];
            a[d] = e
        }
    },
    getDelta: function(a) {
        var b = this._gridSize,
            c = a.width * b.height + a.height;
        return cc.size(this._tilesOrder[c] / b.height - a.width, this._tilesOrder[c] % b.height - a.height)
    },
    placeTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep(),
            e = b.position;
        c.bl.x += e.x * d.x;
        c.bl.y += e.y * d.y;
        c.br.x += e.x * d.x;
        c.br.y += e.y * d.y;
        c.tl.x += e.x * d.x;
        c.tl.y += e.y * d.y;
        c.tr.x += e.x * d.x;
        c.tr.y += e.y * d.y;
        this.setTile(a, c)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        a = this._gridSize;
        this._tilesCount = a.width * a.height;
        for (var b = this._tilesOrder, c = b.length = 0; c < this._tilesCount; ++c) b[c] = c;
        this.shuffle(b, this._tilesCount);
        for (var b = this._tiles, c = b.length = 0, d = cc.size(0, 0), e = 0; e < a.width; ++e)
            for (var f = 0; f < a.height; ++f) b[c] = new cc.Tile, b[c].position = cc.p(e, f), b[c].startPosition = cc.p(e, f), d.width = e, d.height = f, b[c].delta = this.getDelta(d), ++c
    },
    update: function(a) {
        for (var b = 0, c = this._gridSize, d = this._tiles, e, f = cc.p(0, 0), g = 0; g < c.width; ++g)
            for (var h = 0; h < c.height; ++h) f.x = g, f.y = h, e = d[b], e.position.x =
                e.delta.width * a, e.position.y = e.delta.height * a, this.placeTile(f, e), ++b
    }
});
cc.shuffleTiles = function(a, b, c) {
    return new cc.ShuffleTiles(a, b, c)
};
cc.ShuffleTiles.create = cc.shuffleTiles;
cc.FadeOutTRTiles = cc.TiledGrid3DAction.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.width * b,
            d = this._gridSize.height * b;
        return c === this._gridSize.width && d === this._gridSize.height ? 0 : 0 === c + d ? 1 : Math.pow((a.x + a.y) / (c + d), 6)
    },
    turnOnTile: function(a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function(a) {
        this.setTile(a, new cc.Quad3)
    },
    transformTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep();
        c.bl.x += d.x / 2 * (1 - b);
        c.bl.y += d.y / 2 * (1 - b);
        c.br.x -= d.x / 2 * (1 - b);
        c.br.y += d.y / 2 * (1 -
            b);
        c.tl.x += d.x / 2 * (1 - b);
        c.tl.y -= d.y / 2 * (1 - b);
        c.tr.x -= d.x / 2 * (1 - b);
        c.tr.y -= d.y / 2 * (1 - b);
        this.setTile(a, c)
    },
    update: function(a) {
        for (var b = this._gridSize, c = cc.p(0, 0), d, e = 0; e < b.width; ++e)
            for (var f = 0; f < b.height; ++f) c.x = e, c.y = f, d = this.testFunc(c, a), 0 === d ? this.turnOffTile(c) : 1 > d ? this.transformTile(c, d) : this.turnOnTile(c)
    }
});
cc.fadeOutTRTiles = function(a, b) {
    return new cc.FadeOutTRTiles(a, b)
};
cc.FadeOutTRTiles.create = cc.fadeOutTRTiles;
cc.FadeOutBLTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.width * (1 - b),
            d = this._gridSize.height * (1 - b);
        return 0 === c + d ? 0 : 0 === a.x + a.y ? 1 : Math.pow((c + d) / (a.x + a.y), 6)
    }
});
cc.fadeOutBLTiles = function(a, b) {
    return new cc.FadeOutBLTiles(a, b)
};
cc.FadeOutBLTiles.create = cc.fadeOutBLTiles;
cc.FadeOutUpTiles = cc.FadeOutTRTiles.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.height * b;
        return c === this._gridSize.height ? 0 : 0 === c ? 1 : Math.pow(a.y / c, 6)
    },
    transformTile: function(a, b) {
        var c = this.originalTile(a),
            d = this.target.grid.getStep();
        c.bl.y += d.y / 2 * (1 - b);
        c.br.y += d.y / 2 * (1 - b);
        c.tl.y -= d.y / 2 * (1 - b);
        c.tr.y -= d.y / 2 * (1 - b);
        this.setTile(a, c)
    }
});
cc.fadeOutUpTiles = function(a, b) {
    return new cc.FadeOutUpTiles(a, b)
};
cc.FadeOutUpTiles.create = cc.fadeOutUpTiles;
cc.FadeOutDownTiles = cc.FadeOutUpTiles.extend({
    testFunc: function(a, b) {
        var c = this._gridSize.height * (1 - b);
        return 0 === c ? 0 : 0 === a.y ? 1 : Math.pow(c / a.y, 6)
    }
});
cc.fadeOutDownTiles = function(a, b) {
    return new cc.FadeOutDownTiles(a, b)
};
cc.FadeOutDownTiles.create = cc.fadeOutDownTiles;
cc.TurnOffTiles = cc.TiledGrid3DAction.extend({
    _seed: null,
    _tilesCount: 0,
    _tilesOrder: null,
    ctor: function(a, b, c) {
        cc.GridAction.prototype.ctor.call(this);
        this._tilesOrder = [];
        void 0 !== b && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._seed = c || 0, this._tilesOrder.length = 0, !0) : !1
    },
    shuffle: function(a, b) {
        for (var c = b - 1; 0 <= c; c--) {
            var d = 0 | cc.rand() % (c + 1),
                e = a[c];
            a[c] = a[d];
            a[d] = e
        }
    },
    turnOnTile: function(a) {
        this.setTile(a, this.originalTile(a))
    },
    turnOffTile: function(a) {
        this.setTile(a, new cc.Quad3)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._tilesCount = this._gridSize.width * this._gridSize.height;
        a = this._tilesOrder;
        for (var b = a.length = 0; b < this._tilesCount; ++b) a[b] = b;
        this.shuffle(a, this._tilesCount)
    },
    update: function(a) {
        a = 0 | a * this._tilesCount;
        for (var b = this._gridSize, c, d = cc.p(0, 0), e = this._tilesOrder, f = 0; f < this._tilesCount; f++) c = e[f], d.x = 0 | c / b.height, d.y = c % (0 | b.height), f < a ? this.turnOffTile(d) : this.turnOnTile(d)
    }
});
cc.turnOffTiles = function(a, b, c) {
    return new cc.TurnOffTiles(a, b, c)
};
cc.TurnOffTiles.create = cc.turnOffTiles;
cc.WavesTiles3D = cc.TiledGrid3DAction.extend({
    _waves: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._waves =
            c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        for (var b = this._gridSize, c = this._waves, d = this._amplitude, e = this._amplitudeRate, f = cc.p(0, 0), g, h = 0; h < b.width; h++)
            for (var k = 0; k < b.height; k++) f.x = h, f.y = k, g = this.originalTile(f), g.bl.z = Math.sin(a * Math.PI * c * 2 + 0.01 * (g.bl.y + g.bl.x)) * d * e, g.br.z = g.bl.z, g.tl.z = g.bl.z, g.tr.z = g.bl.z, this.setTile(f, g)
    }
});
cc.wavesTiles3D = function(a, b, c, d) {
    return new cc.WavesTiles3D(a, b, c, d)
};
cc.WavesTiles3D.create = cc.wavesTiles3D;
cc.JumpTiles3D = cc.TiledGrid3DAction.extend({
    _jumps: 0,
    _amplitude: 0,
    _amplitudeRate: 0,
    ctor: function(a, b, c, d) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== d && this.initWithDuration(a, b, c, d)
    },
    getAmplitude: function() {
        return this._amplitude
    },
    setAmplitude: function(a) {
        this._amplitude = a
    },
    getAmplitudeRate: function() {
        return this._amplitudeRate
    },
    setAmplitudeRate: function(a) {
        this._amplitudeRate = a
    },
    initWithDuration: function(a, b, c, d) {
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, b) ? (this._jumps =
            c, this._amplitude = d, this._amplitudeRate = 1, !0) : !1
    },
    update: function(a) {
        var b = Math.sin(Math.PI * a * this._jumps * 2) * this._amplitude * this._amplitudeRate;
        a = Math.sin(Math.PI * (a * this._jumps * 2 + 1)) * this._amplitude * this._amplitudeRate;
        for (var c = this._gridSize, d = this.target.grid, e, f = cc.p(0, 0), g = 0; g < c.width; g++)
            for (var h = 0; h < c.height; h++) f.x = g, f.y = h, e = d.originalTile(f), 0 === (g + h) % 2 ? (e.bl.z += b, e.br.z += b, e.tl.z += b, e.tr.z += b) : (e.bl.z += a, e.br.z += a, e.tl.z += a, e.tr.z += a), d.setTile(f, e)
    }
});
cc.jumpTiles3D = function(a, b, c, d) {
    return new cc.JumpTiles3D(a, b, c, d)
};
cc.JumpTiles3D.create = cc.jumpTiles3D;
cc.SplitRows = cc.TiledGrid3DAction.extend({
    _rows: 0,
    _winSize: null,
    ctor: function(a, b) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        this._rows = b;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(1, b))
    },
    update: function(a) {
        for (var b = this._gridSize, c = this._winSize.width, d, e, f = cc.p(0, 0), g = 0; g < b.height; ++g) f.y = g, d = this.originalTile(f), e = 1, 0 === g % 2 && (e = -1), d.bl.x += e * c * a, d.br.x += e * c * a, d.tl.x += e * c * a, d.tr.x += e * c * a, this.setTile(f,
            d)
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._winSize = cc.director.getWinSizeInPixels()
    }
});
cc.splitRows = function(a, b) {
    return new cc.SplitRows(a, b)
};
cc.SplitRows.create = cc.splitRows;
cc.SplitCols = cc.TiledGrid3DAction.extend({
    _cols: 0,
    _winSize: null,
    ctor: function(a, b) {
        cc.GridAction.prototype.ctor.call(this);
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        this._cols = b;
        return cc.TiledGrid3DAction.prototype.initWithDuration.call(this, a, cc.size(b, 1))
    },
    update: function(a) {
        for (var b = this._gridSize.width, c = this._winSize.height, d, e, f = cc.p(0, 0), g = 0; g < b; ++g) f.x = g, d = this.originalTile(f), e = 1, 0 === g % 2 && (e = -1), d.bl.y += e * c * a, d.br.y += e * c * a, d.tl.y += e * c * a, d.tr.y += e * c * a, this.setTile(f,
            d);
        cc.renderer.childrenOrderDirty = !0
    },
    startWithTarget: function(a) {
        cc.TiledGrid3DAction.prototype.startWithTarget.call(this, a);
        this._winSize = cc.director.getWinSizeInPixels()
    }
});
cc.splitCols = function(a, b) {
    return new cc.SplitCols(a, b)
};
cc.SplitCols.create = cc.splitCols;
cc.PageTurn3D = cc.Grid3DAction.extend({
    getGrid: function() {
        var a = new cc.Grid3D(this._gridSize, void 0, void 0, this._gridNodeTarget.getGridRect());
        a.setNeedDepthTestForBlit(!0);
        return a
    },
    clone: function() {
        var a = new cc.PageTurn3D;
        a.initWithDuration(this._duration, this._gridSize);
        return a
    },
    update: function(a) {
        var b = Math.max(0, a - 0.25),
            b = -100 - b * b * 500,
            c = Math.sqrt(a),
            d = 0.5 < c ? Math.PI / 2 * c : Math.PI / 2 * (1 - c);
        a = (2 - a) * Math.PI;
        for (var c = Math.sin(d), d = Math.cos(d), e = this._gridSize, f = cc.p(0, 0), g = 0; g <= e.width; ++g)
            for (var h =
                    0; h <= e.height; ++h) {
                f.x = g;
                f.y = h;
                var k = this.getOriginalVertex(f);
                k.x -= this.getGridRect().x;
                var m = Math.sqrt(k.x * k.x + (k.y - b) * (k.y - b)),
                    n = m * c,
                    p = Math.asin(k.x / m) / c,
                    s = Math.cos(p);
                k.x = p <= Math.PI ? n * Math.sin(p) : 0;
                k.y = m + b - n * (1 - s) * c;
                k.z = n * (1 - s) * d;
                k.x = k.z * Math.sin(a) + k.x * Math.cos(a);
                k.z = k.z * Math.cos(a) - k.x * Math.cos(a);
                k.z /= 7;
                0.5 > k.z && (k.z = 0.5);
                k.x += this.getGridRect().x;
                this.setVertex(f, k)
            }
    }
});
cc.pageTurn3D = function(a, b) {
    return new cc.PageTurn3D(a, b)
};
cc.PageTurn3D.create = cc.pageTurn3D;
cc.ProgressTimer = cc.Node.extend({
    _type: null,
    _percentage: 0,
    _sprite: null,
    _midPoint: null,
    _barChangeRate: null,
    _reverseDirection: !1,
    _className: "ProgressTimer",
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._percentage = 0;
        this._midPoint = cc.p(0, 0);
        this._barChangeRate = cc.p(0, 0);
        this._reverseDirection = !1;
        this._sprite = null;
        a && this.initWithSprite(a)
    },
    getMidpoint: function() {
        return cc.p(this._midPoint.x, this._midPoint.y)
    },
    setMidpoint: function(a) {
        this._midPoint = cc.pClamp(a,
            cc.p(0, 0), cc.p(1, 1))
    },
    getBarChangeRate: function() {
        return cc.p(this._barChangeRate.x, this._barChangeRate.y)
    },
    setBarChangeRate: function(a) {
        this._barChangeRate = cc.pClamp(a, cc.p(0, 0), cc.p(1, 1))
    },
    getType: function() {
        return this._type
    },
    getPercentage: function() {
        return this._percentage
    },
    getSprite: function() {
        return this._sprite
    },
    setPercentage: function(a) {
        this._percentage !== a && (this._percentage = cc.clampf(a, 0, 100), this._renderCmd._updateProgress())
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    isReverseDirection: function() {
        return this._reverseDirection
    },
    setColor: function(a) {
        this._sprite.color = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.colorDirty)
    },
    setOpacity: function(a) {
        this._sprite.opacity = a;
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.opacityDirty)
    },
    getColor: function() {
        return this._sprite.color
    },
    getOpacity: function() {
        return this._sprite.opacity
    },
    setReverseProgress: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.releaseData())
    },
    setSprite: function(a) {
        this._sprite !==
            a && ((this._sprite = a) ? this.setContentSize(a.width, a.height) : this.setContentSize(0, 0), this._renderCmd.releaseData())
    },
    setType: function(a) {
        a !== this._type && (this._type = a, this._renderCmd.releaseData())
    },
    setReverseDirection: function(a) {
        this._reverseDirection !== a && (this._reverseDirection = a, this._renderCmd.releaseData())
    },
    initWithSprite: function(a) {
        this.percentage = 0;
        this.setAnchorPoint(0.5, 0.5);
        this._type = cc.ProgressTimer.TYPE_RADIAL;
        this._reverseDirection = !1;
        this.midPoint = cc.p(0.5, 0.5);
        this.barChangeRate =
            cc.p(1, 1);
        this.setSprite(a);
        this._renderCmd.initCmd();
        return !0
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ProgressTimer.CanvasRenderCmd(this) : new cc.ProgressTimer.WebGLRenderCmd(this)
    }
});
_p = cc.ProgressTimer.prototype;
cc.defineGetterSetter(_p, "midPoint", _p.getMidpoint, _p.setMidpoint);
cc.defineGetterSetter(_p, "barChangeRate", _p.getBarChangeRate, _p.setBarChangeRate);
cc.defineGetterSetter(_p, "type", _p.getType, _p.setType);
cc.defineGetterSetter(_p, "percentage", _p.getPercentage, _p.setPercentage);
cc.defineGetterSetter(_p, "sprite", _p.getSprite, _p.setSprite);
cc.defineGetterSetter(_p, "reverseDir", _p.isReverseDirection, _p.setReverseDirection);
cc.ProgressTimer.create = function(a) {
    return new cc.ProgressTimer(a)
};
cc.ProgressTimer.TEXTURE_COORDS_COUNT = 4;
cc.ProgressTimer.TEXTURE_COORDS = 75;
cc.ProgressTimer.TYPE_RADIAL = 0;
cc.ProgressTimer.TYPE_BAR = 1;
cc.ProgressTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(a, b) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0;
        void 0 !== b && this.initWithDuration(a, b)
    },
    initWithDuration: function(a, b) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = b, !0) : !1
    },
    clone: function() {
        var a = new cc.ProgressTo;
        a.initWithDuration(this._duration, this._to);
        return a
    },
    reverse: function() {
        cc.log("cc.ProgressTo.reverse(): reverse hasn't been supported.");
        return null
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this,
            a);
        this._from = a.percentage
    },
    update: function(a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.progressTo = function(a, b) {
    return new cc.ProgressTo(a, b)
};
cc.ProgressTo.create = cc.progressTo;
cc.ProgressFromTo = cc.ActionInterval.extend({
    _to: 0,
    _from: 0,
    ctor: function(a, b, c) {
        cc.ActionInterval.prototype.ctor.call(this);
        this._from = this._to = 0;
        void 0 !== c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        return cc.ActionInterval.prototype.initWithDuration.call(this, a) ? (this._to = c, this._from = b, !0) : !1
    },
    clone: function() {
        var a = new cc.ProgressFromTo;
        a.initWithDuration(this._duration, this._from, this._to);
        return a
    },
    reverse: function() {
        return cc.progressFromTo(this._duration, this._to, this._from)
    },
    startWithTarget: function(a) {
        cc.ActionInterval.prototype.startWithTarget.call(this, a)
    },
    update: function(a) {
        this.target instanceof cc.ProgressTimer && (this.target.percentage = this._from + (this._to - this._from) * a)
    }
});
cc.progressFromTo = function(a, b, c) {
    return new cc.ProgressFromTo(a, b, c)
};
cc.ProgressFromTo.create = cc.progressFromTo;
(function() {
    cc.ProgressTimer.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._PI180 = Math.PI / 180;
        this._barRect = cc.rect(0, 0, 0, 0);
        this._origin = cc.p(0, 0);
        this._radius = 0;
        this._endAngle = this._startAngle = 270;
        this._counterClockWise = !1
    };
    var a = cc.ProgressTimer.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ProgressTimer.CanvasRenderCmd;
    a.rendering = function(a, c, d) {
        a = a || cc._renderContext;
        var e = a.getContext(),
            f = this._node,
            g = f._sprite,
            h = g._renderCmd._textureCoord,
            k = g._renderCmd._displayedOpacity / 255;
        if (0 !== h.width && 0 !== h.height && g._texture && h.validRect && 0 !== k) {
            a.setTransform(this._worldTransform, c, d);
            a.setCompositeOperation(g._blendFuncStr);
            a.setGlobalAlpha(k);
            var m = g._rect,
                n = g._offsetPosition,
                k = n.x,
                p = -n.y - m.height,
                s = m.width,
                m = m.height;
            a.save();
            g._flippedX && (k = -k - s, e.scale(-1, 1));
            g._flippedY && (p = n.y, e.scale(1, -1));
            f._type === cc.ProgressTimer.TYPE_BAR ? (f = this._barRect, e.beginPath(), e.rect(f.x * c, f.y * d, f.width * c, f.height * d), e.clip(),
                e.closePath()) : f._type === cc.ProgressTimer.TYPE_RADIAL && (f = this._origin.x * c, n = this._origin.y * d, e.beginPath(), e.arc(f, n, this._radius * d, this._PI180 * this._startAngle, this._PI180 * this._endAngle, this._counterClockWise), e.lineTo(f, n), e.clip(), e.closePath());
            f = g._texture.getHtmlElementObj();
            g._renderCmd._colorized ? e.drawImage(f, 0, 0, h.width, h.height, k * c, p * d, s * c, m * d) : e.drawImage(f, h.renderX, h.renderY, h.width, h.height, k * c, p * d, s * c, m * d);
            a.restore();
            cc.g_NumberOfDraws++
        }
    };
    a.releaseData = function() {};
    a.initCmd = function() {};
    a._updateProgress = function() {
        var a = this._node,
            c = a._sprite,
            d = c.width,
            e = c.height,
            f = a._midPoint;
        if (a._type === cc.ProgressTimer.TYPE_RADIAL) {
            this._radius = Math.round(Math.sqrt(d * d + e * e));
            var g, h = !1,
                k = this._origin;
            k.x = d * f.x;
            k.y = -e * f.y;
            a._reverseDirection ? (g = 270, f = 270 - 3.6 * a._percentage) : (f = -90, g = -90 + 3.6 * a._percentage);
            c._flippedX && (k.x -= 2 * d * a._midPoint.x, f = -f - 180, g = -g - 180, h = !h);
            c._flippedY && (k.y += 2 * e * a._midPoint.y, h = !h, f = -f, g = -g);
            this._startAngle = f;
            this._endAngle = g;
            this._counterClockWise = h
        } else h = a._barChangeRate,
            k = a._percentage / 100, a = this._barRect, h = cc.size(d * (1 - h.x), e * (1 - h.y)), k = cc.size((d - h.width) * k, (e - h.height) * k), h = cc.size(h.width + k.width, h.height + k.height), g = cc.p(d * f.x, e * f.y), k = g.x - h.width / 2, 0.5 < f.x && h.width / 2 >= d - g.x && (k = d - h.width), d = g.y - h.height / 2, 0.5 < f.y && h.height / 2 >= e - g.y && (d = e - h.height), a.x = 0, e = 1, c._flippedX && (a.x -= h.width, e = -1), 0 < k && (a.x += k * e), a.y = 0, e = 1, c._flippedY && (a.y += h.height, e = -1), 0 < d && (a.y -= d * e), a.width = h.width, a.height = -h.height
    };
    a._updateColor = function() {};
    a._syncStatus = function(a) {
        var c =
            this._node;
        if (c._sprite) {
            var d = cc.Node._dirtyFlags,
                e = this._dirtyFlag,
                f = a ? a._node : null;
            f && f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty && (e |= d.colorDirty);
            f && f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty && (e |= d.opacityDirty);
            a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
            this._dirtyFlag = e;
            var c = c._sprite._renderCmd,
                g = c._dirtyFlag,
                f = g & d.colorDirty,
                g = g & d.opacityDirty;
            f && c._syncDisplayColor();
            g && c._syncDisplayOpacity();
            (f || g) && c._updateColor();
            e & d.transformDirty && this.transform(a)
        }
    };
    a.updateStatus = function() {
        var a = this._node;
        if (a._sprite) {
            var c = cc.Node._dirtyFlags,
                d = this._dirtyFlag,
                a = a._sprite._renderCmd,
                e = a._dirtyFlag,
                f = e & c.colorDirty,
                e = e & c.opacityDirty;
            f && a._updateDisplayColor();
            e && a._updateDisplayOpacity();
            (f || e) && a._updateColor();
            d & c.transformDirty && this.transform(this.getParentRenderCmd(), !0);
            this._dirtyFlag = 0
        }
    }
})();
(function() {
    cc.ProgressTimer.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._vertexWebGLBuffer = cc._renderContext.createBuffer();
        this._vertexDataCount = 0;
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataDirty = !1
    };
    var a = cc.ProgressTimer.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ProgressTimer.WebGLRenderCmd;
    a.rendering = function(a) {
        var c = this._node;
        a = a || cc._renderContext;
        if (this._vertexData && c._sprite) {
            this._shaderProgram.use();
            this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix);
            var d = c._sprite._blendFunc;
            cc.glBlendFunc(d.src, d.dst);
            cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX);
            cc.glBindTexture2D(c._sprite.texture);
            a.bindBuffer(a.ARRAY_BUFFER, this._vertexWebGLBuffer);
            this._vertexDataDirty && (a.bufferData(a.ARRAY_BUFFER, this._vertexArrayBuffer, a.DYNAMIC_DRAW), this._vertexDataDirty = !1);
            d = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION, 2, a.FLOAT, !1, d, 0);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR,
                4, a.UNSIGNED_BYTE, !0, d, 8);
            a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, d, 12);
            c._type === cc.ProgressTimer.TYPE_RADIAL ? a.drawArrays(a.TRIANGLE_FAN, 0, this._vertexDataCount) : c._type === cc.ProgressTimer.TYPE_BAR && (c._reverseDirection ? (a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount / 2), a.drawArrays(a.TRIANGLE_STRIP, 4, this._vertexDataCount / 2), cc.g_NumberOfDraws++) : a.drawArrays(a.TRIANGLE_STRIP, 0, this._vertexDataCount));
            cc.g_NumberOfDraws++
        }
    };
    a._syncStatus = function(a) {
        var c = this._node;
        if (c._sprite) {
            var d = cc.Node._dirtyFlags,
                e = this._dirtyFlag,
                f = a ? a._node : null;
            f && f._cascadeColorEnabled && a._dirtyFlag & d.colorDirty && (e |= d.colorDirty);
            f && f._cascadeOpacityEnabled && a._dirtyFlag & d.opacityDirty && (e |= d.opacityDirty);
            a && a._dirtyFlag & d.transformDirty && (e |= d.transformDirty);
            this._dirtyFlag = e;
            c = c._sprite._renderCmd;
            f = c._dirtyFlag;
            e = f & d.colorDirty;
            d = f & d.opacityDirty;
            e && c._syncDisplayColor();
            d && c._syncDisplayOpacity();
            if (e || d) c._updateColor(), this._updateColor();
            this.transform(a);
            c._dirtyFlag =
                0
        }
    };
    a.updateStatus = function() {
        var a = this._node;
        if (a._sprite) {
            var c = cc.Node._dirtyFlags,
                d = this._dirtyFlag,
                a = a._sprite._renderCmd,
                e = a._dirtyFlag,
                f = e & c.colorDirty,
                e = e & c.opacityDirty;
            f && (a._updateDisplayColor(), this._dirtyFlag ^= this._dirtyFlag & c.colorDirty);
            e && (a._updateDisplayOpacity(), this._dirtyFlag ^= this._dirtyFlag & c.opacityDirty);
            if (f || e) a._updateColor(), this._updateColor();
            d & c.transformDirty && this.transform(this.getParentRenderCmd(), !0)
        }
    };
    a.releaseData = function() {
        this._vertexData && (this._vertexArrayBuffer =
            this._vertexData = null, this._vertexDataCount = 0)
    };
    a.initCmd = function() {
        this._vertexArrayBuffer = this._vertexData = null;
        this._vertexDataCount = 0;
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    };
    a._updateProgress = function() {
        var a = this._node._type;
        a === cc.ProgressTimer.TYPE_RADIAL ? this._updateRadial() : a === cc.ProgressTimer.TYPE_BAR && this._updateBar();
        this._vertexDataDirty = !0
    };
    a._updateBar = function() {
        var a = this._node;
        if (a._sprite) {
            var c, d = a._percentage / 100;
            c = a._barChangeRate;
            c = cc.pMult(cc.p(1 - c.x + d * c.x, 1 - c.y + d * c.y), 0.5);
            d = cc.pSub(a._midPoint, c);
            a = cc.pAdd(a._midPoint, c);
            0 > d.x && (a.x += -d.x, d.x = 0);
            1 < a.x && (d.x -= a.x - 1, a.x = 1);
            0 > d.y && (a.y += -d.y, d.y = 0);
            1 < a.y && (d.y -= a.y - 1, a.y = 1);
            if (this._reverseDirection) {
                if (!this._vertexData) {
                    this._vertexDataCount = 8;
                    var e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                    this._vertexArrayBuffer = new ArrayBuffer(8 * e);
                    var f = [];
                    for (c = 0; 8 > c; c++) f[c] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, c * e);
                    f[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(0,
                        1));
                    f[0].vertices = this._vertexFromAlphaPoint(cc.p(0, 1));
                    f[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(0, 0));
                    f[1].vertices = this._vertexFromAlphaPoint(cc.p(0, 0));
                    f[6].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 1));
                    f[6].vertices = this._vertexFromAlphaPoint(cc.p(1, 1));
                    f[7].texCoords = this._textureCoordFromAlphaPoint(cc.p(1, 0));
                    f[7].vertices = this._vertexFromAlphaPoint(cc.p(1, 0));
                    this._vertexData = f
                }
                c = this._vertexData;
                c[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, a.y));
                c[2].vertices =
                    this._vertexFromAlphaPoint(cc.p(d.x, a.y));
                c[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, d.y));
                c[3].vertices = this._vertexFromAlphaPoint(cc.p(d.x, d.y));
                c[4].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, a.y));
                c[4].vertices = this._vertexFromAlphaPoint(cc.p(a.x, a.y));
                c[5].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, d.y));
                c[5].vertices = this._vertexFromAlphaPoint(cc.p(a.x, d.y))
            } else {
                if (!this._vertexData)
                    for (this._vertexDataCount = 4, e = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT, this._vertexArrayBuffer =
                        new ArrayBuffer(4 * e), this._vertexData = [], c = 0; 4 > c; c++) this._vertexData[c] = new cc.V2F_C4B_T2F(null, null, null, this._vertexArrayBuffer, c * e);
                c = this._vertexData;
                c[0].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, a.y));
                c[0].vertices = this._vertexFromAlphaPoint(cc.p(d.x, a.y));
                c[1].texCoords = this._textureCoordFromAlphaPoint(cc.p(d.x, d.y));
                c[1].vertices = this._vertexFromAlphaPoint(cc.p(d.x, d.y));
                c[2].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, a.y));
                c[2].vertices = this._vertexFromAlphaPoint(cc.p(a.x,
                    a.y));
                c[3].texCoords = this._textureCoordFromAlphaPoint(cc.p(a.x, d.y));
                c[3].vertices = this._vertexFromAlphaPoint(cc.p(a.x, d.y))
            }
            this._updateColor()
        }
    };
    a._updateRadial = function() {
        var a = this._node;
        if (a._sprite) {
            var c, d = a._midPoint;
            c = a._percentage / 100;
            var e = 2 * cc.PI * (a._reverseDirection ? c : 1 - c),
                a = cc.p(d.x, 1),
                f = cc.pRotateByAngle(a, d, e),
                e = 0;
            if (0 === c) f = a, e = 0;
            else if (1 === c) f = a, e = 4;
            else {
                var g = cc.FLT_MAX,
                    h = cc.ProgressTimer.TEXTURE_COORDS_COUNT;
                for (c = 0; c <= h; ++c) {
                    var k = (c + (h - 1)) % h,
                        m = this._boundaryTexCoord(c % h),
                        k =
                        this._boundaryTexCoord(k);
                    0 === c ? k = cc.pLerp(m, k, 1 - d.x) : 4 === c && (m = cc.pLerp(m, k, 1 - d.x));
                    var n = cc.p(0, 0);
                    cc.pLineIntersect(m, k, d, f, n) && (0 !== c && 4 !== c || 0 <= n.x && 1 >= n.x) && 0 <= n.y && n.y < g && (g = n.y, e = c)
                }
                f = cc.pAdd(d, cc.pMult(cc.pSub(f, d), g))
            }
            g = !0;
            this._vertexDataCount !== e + 3 && (g = !1, this._vertexArrayBuffer = this._vertexData = null, this._vertexDataCount = 0);
            if (!this._vertexData) {
                h = this._vertexDataCount = e + 3;
                m = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                this._vertexArrayBuffer = new ArrayBuffer(h * m);
                k = [];
                for (c = 0; c < h; c++) k[c] = new cc.V2F_C4B_T2F(null,
                    null, null, this._vertexArrayBuffer, c * m);
                this._vertexData = k;
                if (!this._vertexData) {
                    cc.log("cc.ProgressTimer._updateRadial() : Not enough memory");
                    return
                }
            }
            this._updateColor();
            h = this._vertexData;
            if (!g)
                for (h[0].texCoords = this._textureCoordFromAlphaPoint(d), h[0].vertices = this._vertexFromAlphaPoint(d), h[1].texCoords = this._textureCoordFromAlphaPoint(a), h[1].vertices = this._vertexFromAlphaPoint(a), c = 0; c < e; c++) d = this._boundaryTexCoord(c), h[c + 2].texCoords = this._textureCoordFromAlphaPoint(d), h[c + 2].vertices = this._vertexFromAlphaPoint(d);
            h[this._vertexDataCount - 1].texCoords = this._textureCoordFromAlphaPoint(f);
            h[this._vertexDataCount - 1].vertices = this._vertexFromAlphaPoint(f)
        }
    };
    a._boundaryTexCoord = function(a) {
        if (a < cc.ProgressTimer.TEXTURE_COORDS_COUNT) {
            var c = cc.ProgressTimer.TEXTURE_COORDS;
            return this._node._reverseDirection ? cc.p(c >> 7 - (a << 1) & 1, c >> 7 - ((a << 1) + 1) & 1) : cc.p(c >> (a << 1) + 1 & 1, c >> (a << 1) & 1)
        }
        return cc.p(0, 0)
    };
    a._textureCoordFromAlphaPoint = function(a) {
        var c = this._node._sprite;
        if (!c) return {
            u: 0,
            v: 0
        };
        var d = c.quad,
            e = cc.p(d.bl.texCoords.u,
                d.bl.texCoords.v),
            d = cc.p(d.tr.texCoords.u, d.tr.texCoords.v);
        c.textureRectRotated && (c = a.x, a.x = a.y, a.y = c);
        return {
            u: e.x * (1 - a.x) + d.x * a.x,
            v: e.y * (1 - a.y) + d.y * a.y
        }
    };
    a._vertexFromAlphaPoint = function(a) {
        var c = this._node._sprite;
        if (!c) return {
            x: 0,
            y: 0
        };
        var d = c.quad,
            c = cc.p(d.bl.vertices.x, d.bl.vertices.y),
            d = cc.p(d.tr.vertices.x, d.tr.vertices.y);
        return {
            x: c.x * (1 - a.x) + d.x * a.x,
            y: c.y * (1 - a.y) + d.y * a.y
        }
    };
    a._updateColor = function() {
        var a = this._node;
        if (a._sprite && this._vertexData) {
            for (var a = a._sprite.quad.tl.colors, c = this._vertexData,
                    d = 0, e = this._vertexDataCount; d < e; ++d) c[d].colors = a;
            this._vertexDataDirty = !0
        }
    }
})();
cc.SCENE_FADE = 4208917214;
cc.TRANSITION_ORIENTATION_LEFT_OVER = 0;
cc.TRANSITION_ORIENTATION_RIGHT_OVER = 1;
cc.TRANSITION_ORIENTATION_UP_OVER = 0;
cc.TRANSITION_ORIENTATION_DOWN_OVER = 1;
cc.TransitionScene = cc.Scene.extend({
    _inScene: null,
    _outScene: null,
    _duration: null,
    _isInSceneOnTop: !1,
    _isSendCleanupToScene: !1,
    _className: "TransitionScene",
    ctor: function(a, b) {
        cc.Scene.prototype.ctor.call(this);
        void 0 !== a && void 0 !== b && this.initWithDuration(a, b)
    },
    _setNewScene: function(a) {
        this.unschedule(this._setNewScene);
        a = cc.director;
        this._isSendCleanupToScene = a.isSendCleanupToScene();
        a.runScene(this._inScene);
        cc.eventManager.setEnabled(!0);
        this._outScene.visible = !0
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    visit: function() {
        this._isInSceneOnTop ? (this._outScene.visit(), this._inScene.visit()) : (this._inScene.visit(), this._outScene.visit());
        cc.Node.prototype.visit.call(this)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        cc.eventManager.setEnabled(!1);
        this._outScene.onExitTransitionDidStart();
        this._inScene.onEnter()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        cc.eventManager.setEnabled(!0);
        this._outScene.onExit();
        this._inScene.onEnterTransitionDidFinish()
    },
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this);
        this._isSendCleanupToScene && this._outScene.cleanup()
    },
    initWithDuration: function(a, b) {
        if (!b) throw Error("cc.TransitionScene.initWithDuration(): Argument scene must be non-nil");
        if (this.init()) {
            this._duration = a;
            this.attr({
                x: 0,
                y: 0,
                anchorX: 0,
                anchorY: 0
            });
            this._inScene = b;
            this._outScene = cc.director.getRunningScene();
            this._outScene || (this._outScene = new cc.Scene, this._outScene.init());
            if (this._inScene === this._outScene) throw Error("cc.TransitionScene.initWithDuration(): Incoming scene must be different from the outgoing scene");
            this._sceneOrder();
            return !0
        }
        return !1
    },
    finish: function() {
        this._inScene.attr({
            visible: !0,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._inScene.getCamera().restore();
        this._outScene.attr({
            visible: !1,
            x: 0,
            y: 0,
            scale: 1,
            rotation: 0
        });
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && this._outScene.getCamera().restore();
        this.schedule(this._setNewScene, 0)
    },
    hideOutShowIn: function() {
        this._inScene.visible = !0;
        this._outScene.visible = !1
    }
});
cc.TransitionScene.create = function(a, b) {
    return new cc.TransitionScene(a, b)
};
cc.TransitionSceneOriented = cc.TransitionScene.extend({
    _orientation: 0,
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        void 0 != c && this.initWithDuration(a, b, c)
    },
    initWithDuration: function(a, b, c) {
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._orientation = c);
        return !0
    }
});
cc.TransitionSceneOriented.create = function(a, b, c) {
    return new cc.TransitionSceneOriented(a, b, c)
};
cc.TransitionRotoZoom = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.001,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 0.5,
            anchorY: 0.5
        });
        var a = cc.sequence(cc.spawn(cc.scaleBy(this._duration / 2, 0.001), cc.rotateBy(this._duration / 2, 720)), cc.delayTime(this._duration / 2));
        this._outScene.runAction(a);
        this._inScene.runAction(cc.sequence(a.reverse(),
            cc.callFunc(this.finish, this)))
    }
});
cc.TransitionRotoZoom.create = function(a, b) {
    return new cc.TransitionRotoZoom(a, b)
};
cc.TransitionJumpZoom = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize();
        this._inScene.attr({
            scale: 0.5,
            x: a.width,
            y: 0,
            anchorX: 0.5,
            anchorY: 0.5
        });
        this._outScene.anchorX = 0.5;
        this._outScene.anchorY = 0.5;
        var b = cc.jumpBy(this._duration / 4, cc.p(-a.width, 0), a.width / 4, 2),
            c = cc.scaleTo(this._duration / 4, 1),
            a = cc.scaleTo(this._duration / 4, 0.5),
            a = cc.sequence(a,
                b),
            b = cc.sequence(b, c),
            c = cc.delayTime(this._duration / 2);
        this._outScene.runAction(a);
        this._inScene.runAction(cc.sequence(c, b, cc.callFunc(this.finish, this)))
    }
});
cc.TransitionJumpZoom.create = function(a, b) {
    return new cc.TransitionJumpZoom(a, b)
};
cc.TransitionMoveInL = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action();
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)))
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width, 0)
    },
    action: function() {
        return cc.moveTo(this._duration, cc.p(0, 0))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseOut(a,
            2)
    }
});
cc.TransitionMoveInL.create = function(a, b) {
    return new cc.TransitionMoveInL(a, b)
};
cc.TransitionMoveInR = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width, 0)
    }
});
cc.TransitionMoveInR.create = function(a, b) {
    return new cc.TransitionMoveInR(a, b)
};
cc.TransitionMoveInT = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInT.create = function(a, b) {
    return new cc.TransitionMoveInT(a, b)
};
cc.TransitionMoveInB = cc.TransitionMoveInL.extend({
    ctor: function(a, b) {
        cc.TransitionMoveInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    initScenes: function() {
        this._inScene.setPosition(0, -cc.director.getWinSize().height)
    }
});
cc.TransitionMoveInB.create = function(a, b) {
    return new cc.TransitionMoveInB(a, b)
};
cc.ADJUST_FACTOR = 0.5;
cc.TransitionSlideInL = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this.initScenes();
        var a = this.action(),
            b = this.action(),
            a = cc.sequence(this.easeActionWithAction(a), cc.callFunc(this.finish, this)),
            b = this.easeActionWithAction(b);
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    },
    initScenes: function() {
        this._inScene.setPosition(-cc.director.getWinSize().width +
            cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseInOut(a, 2)
    }
});
cc.TransitionSlideInL.create = function(a, b) {
    return new cc.TransitionSlideInL(a, b)
};
cc.TransitionSlideInR = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(cc.director.getWinSize().width - cc.ADJUST_FACTOR, 0)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(-(cc.director.getWinSize().width - cc.ADJUST_FACTOR), 0))
    }
});
cc.TransitionSlideInR.create = function(a, b) {
    return new cc.TransitionSlideInR(a, b)
};
cc.TransitionSlideInB = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    initScenes: function() {
        this._inScene.setPosition(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR))
    }
});
cc.TransitionSlideInB.create = function(a, b) {
    return new cc.TransitionSlideInB(a, b)
};
cc.TransitionSlideInT = cc.TransitionSlideInL.extend({
    ctor: function(a, b) {
        cc.TransitionSlideInL.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !0
    },
    initScenes: function() {
        this._inScene.setPosition(0, cc.director.getWinSize().height - cc.ADJUST_FACTOR)
    },
    action: function() {
        return cc.moveBy(this._duration, cc.p(0, -(cc.director.getWinSize().height - cc.ADJUST_FACTOR)))
    }
});
cc.TransitionSlideInT.create = function(a, b) {
    return new cc.TransitionSlideInT(a, b)
};
cc.TransitionShrinkGrow = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._inScene.attr({
            scale: 0.001,
            anchorX: 2 / 3,
            anchorY: 0.5
        });
        this._outScene.attr({
            scale: 1,
            anchorX: 1 / 3,
            anchorY: 0.5
        });
        var a = cc.scaleTo(this._duration, 0.01),
            b = cc.scaleTo(this._duration, 1);
        this._inScene.runAction(cc.sequence(this.easeActionWithAction(b), cc.callFunc(this.finish, this)));
        this._outScene.runAction(this.easeActionWithAction(a))
    },
    easeActionWithAction: function(a) {
        return new cc.EaseOut(a, 2)
    }
});
cc.TransitionShrinkGrow.create = function(a, b) {
    return new cc.TransitionShrinkGrow(a, b)
};
cc.TransitionFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0,
            c, a, 0, 0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipX.create = function(a, b, c) {
    return new cc.TransitionFlipX(a, b, c)
};
cc.TransitionFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration / 2, 1, 0, c, a, 90,
            0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipY.create = function(a, b, c) {
    return new cc.TransitionFlipY(a, b, c)
};
cc.TransitionFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.show(), cc.orbitCamera(this._duration /
            2, 1, 0, c, a, -45, 0), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionFlipAngular.create = function(a, b, c) {
    return new cc.TransitionFlipAngular(a, b, c)
};
cc.TransitionZoomFlipX = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2,
            1, 0, c, a, 0, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 0, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipX.create = function(a, b, c) {
    return new cc.TransitionZoomFlipX(a, b, c)
};
cc.TransitionZoomFlipY = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_UP_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_UP_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, c,
            a, 90, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 90, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipY.create = function(a, b, c) {
    return new cc.TransitionZoomFlipY(a, b, c)
};
cc.TransitionZoomFlipAngular = cc.TransitionSceneOriented.extend({
    ctor: function(a, b, c) {
        cc.TransitionSceneOriented.prototype.ctor.call(this);
        null == c && (c = cc.TRANSITION_ORIENTATION_RIGHT_OVER);
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a, b;
        this._inScene.visible = !1;
        var c;
        this._orientation === cc.TRANSITION_ORIENTATION_RIGHT_OVER ? (a = 90, c = 270, b = 90) : (a = -90, c = 90, b = -90);
        a = cc.sequence(cc.delayTime(this._duration / 2), cc.spawn(cc.orbitCamera(this._duration /
            2, 1, 0, c, a, -45, 0), cc.scaleTo(this._duration / 2, 1), cc.show()), cc.show(), cc.callFunc(this.finish, this));
        b = cc.sequence(cc.spawn(cc.orbitCamera(this._duration / 2, 1, 0, 0, b, 45, 0), cc.scaleTo(this._duration / 2, 0.5)), cc.hide(), cc.delayTime(this._duration / 2));
        this._inScene.scale = 0.5;
        this._inScene.runAction(a);
        this._outScene.runAction(b)
    }
});
cc.TransitionZoomFlipAngular.create = function(a, b, c) {
    return new cc.TransitionZoomFlipAngular(a, b, c)
};
cc.TransitionFade = cc.TransitionScene.extend({
    _color: null,
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._color = cc.color();
        b && this.initWithDuration(a, b, c)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = new cc.LayerColor(this._color);
        this._inScene.visible = !1;
        this.addChild(a, 2, cc.SCENE_FADE);
        var a = this.getChildByTag(cc.SCENE_FADE),
            b = cc.sequence(cc.fadeIn(this._duration / 2), cc.callFunc(this.hideOutShowIn, this), cc.fadeOut(this._duration / 2), cc.callFunc(this.finish,
                this));
        a.runAction(b)
    },
    onExit: function() {
        cc.TransitionScene.prototype.onExit.call(this);
        this.removeChildByTag(cc.SCENE_FADE, !1)
    },
    initWithDuration: function(a, b, c) {
        c = c || cc.color.BLACK;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b) && (this._color.r = c.r, this._color.g = c.g, this._color.b = c.b, this._color.a = 0);
        return !0
    }
});
cc.TransitionFade.create = function(a, b, c) {
    return new cc.TransitionFade(a, b, c)
};
cc.TransitionCrossFade = cc.TransitionScene.extend({
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.color(0, 0, 0, 0),
            b = cc.director.getWinSize(),
            a = new cc.LayerColor(a),
            c = new cc.RenderTexture(b.width, b.height);
        c.sprite.anchorX = 0.5;
        c.sprite.anchorY = 0.5;
        c.attr({
            x: b.width / 2,
            y: b.height / 2,
            anchorX: 0.5,
            anchorY: 0.5
        });
        c.begin();
        this._inScene.visit();
        c.end();
        var d = new cc.RenderTexture(b.width,
            b.height);
        d.setPosition(b.width / 2, b.height / 2);
        d.sprite.anchorX = d.anchorX = 0.5;
        d.sprite.anchorY = d.anchorY = 0.5;
        d.begin();
        this._outScene.visit();
        d.end();
        c.sprite.setBlendFunc(cc.ONE, cc.ONE);
        d.sprite.setBlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
        a.addChild(c);
        a.addChild(d);
        c.sprite.opacity = 255;
        d.sprite.opacity = 255;
        b = cc.sequence(cc.fadeTo(this._duration, 0), cc.callFunc(this.hideOutShowIn, this), cc.callFunc(this.finish, this));
        d.sprite.runAction(b);
        this.addChild(a, 2, cc.SCENE_FADE)
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_FADE, !1);
        cc.TransitionScene.prototype.onExit.call(this)
    },
    visit: function() {
        cc.Node.prototype.visit.call(this)
    },
    draw: function() {}
});
cc.TransitionCrossFade.create = function(a, b) {
    return new cc.TransitionCrossFade(a, b)
};
cc.TransitionTurnOffTiles = cc.TransitionScene.extend({
    _gridProxy: null,
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = cc.director.getWinSize(),
            a = cc.turnOffTiles(this._duration, cc.size(0 | a.width / a.height * 12, 12)),
            a = this.easeActionWithAction(a);
        this._gridProxy.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    visit: function() {
        this._inScene.visit();
        this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return a
    }
});
cc.TransitionTurnOffTiles.create = function(a, b) {
    return new cc.TransitionTurnOffTiles(a, b)
};
cc.TransitionSplitCols = cc.TransitionScene.extend({
    _gridProxy: null,
    _switchTargetToInscene: function() {
        this._gridProxy.setTarget(this._inScene)
    },
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = this.action(),
            a = cc.sequence(a, cc.callFunc(this._switchTargetToInscene, this), a.reverse());
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(a),
            cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    onExit: function() {
        this._gridProxy.setTarget(null);
        this._gridProxy.onExit();
        cc.TransitionScene.prototype.onExit.call(this)
    },
    visit: function() {
        this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return new cc.EaseInOut(a, 3)
    },
    action: function() {
        return cc.splitCols(this._duration / 2, 3)
    }
});
cc.TransitionSplitCols.create = function(a, b) {
    return new cc.TransitionSplitCols(a, b)
};
cc.TransitionSplitRows = cc.TransitionSplitCols.extend({
    ctor: function(a, b) {
        cc.TransitionSplitCols.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    action: function() {
        return cc.splitRows(this._duration / 2, 3)
    }
});
cc.TransitionSplitRows.create = function(a, b) {
    return new cc.TransitionSplitRows(a, b)
};
cc.TransitionFadeTR = cc.TransitionScene.extend({
    _gridProxy: null,
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        b && this.initWithDuration(a, b)
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._gridProxy.setTarget(this._outScene);
        this._gridProxy.onEnter();
        var a = cc.director.getWinSize(),
            a = this.actionWithSize(cc.size(0 | a.width / a.height * 12, 12));
        this._gridProxy.runAction(cc.sequence(this.easeActionWithAction(a),
            cc.callFunc(this.finish, this), cc.stopGrid()))
    },
    visit: function() {
        this._inScene.visit();
        this._gridProxy.visit()
    },
    easeActionWithAction: function(a) {
        return a
    },
    actionWithSize: function(a) {
        return cc.fadeOutTRTiles(this._duration, a)
    }
});
cc.TransitionFadeTR.create = function(a, b) {
    return new cc.TransitionFadeTR(a, b)
};
cc.TransitionFadeBL = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return cc.fadeOutBLTiles(this._duration, a)
    }
});
cc.TransitionFadeBL.create = function(a, b) {
    return new cc.TransitionFadeBL(a, b)
};
cc.TransitionFadeUp = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return new cc.FadeOutUpTiles(this._duration, a)
    }
});
cc.TransitionFadeUp.create = function(a, b) {
    return new cc.TransitionFadeUp(a, b)
};
cc.TransitionFadeDown = cc.TransitionFadeTR.extend({
    ctor: function(a, b) {
        cc.TransitionFadeTR.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    actionWithSize: function(a) {
        return cc.fadeOutDownTiles(this._duration, a)
    }
});
cc.TransitionFadeDown.create = function(a, b) {
    return new cc.TransitionFadeDown(a, b)
};
cc.SCENE_RADIAL = 49153;
cc.TransitionProgress = cc.TransitionScene.extend({
    _to: 0,
    _from: 0,
    _sceneToBeModified: null,
    _className: "TransitionProgress",
    ctor: function(a, b) {
        cc.TransitionScene.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _setAttrs: function(a, b, c) {
        a.attr({
            x: b,
            y: c,
            anchorX: 0.5,
            anchorY: 0.5
        })
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        this._setupTransition();
        var a = cc.director.getWinSize(),
            b = new cc.RenderTexture(a.width, a.height);
        b.sprite.anchorX = 0.5;
        b.sprite.anchorY = 0.5;
        this._setAttrs(b,
            a.width / 2, a.height / 2);
        b.clear(0, 0, 0, 1);
        b.begin();
        this._sceneToBeModified.visit();
        b.end();
        this._sceneToBeModified === this._outScene && this.hideOutShowIn();
        a = this._progressTimerNodeWithRenderTexture(b);
        b = cc.sequence(cc.progressFromTo(this._duration, this._from, this._to), cc.callFunc(this.finish, this));
        a.runAction(b);
        this.addChild(a, 2, cc.SCENE_RADIAL)
    },
    onExit: function() {
        this.removeChildByTag(cc.SCENE_RADIAL, !0);
        cc.TransitionScene.prototype.onExit.call(this)
    },
    _setupTransition: function() {
        this._sceneToBeModified =
            this._outScene;
        this._from = 100;
        this._to = 0
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        cc.log("cc.TransitionProgress._progressTimerNodeWithRenderTexture(): should be overridden in subclass");
        return null
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    }
});
cc.TransitionProgress.create = function(a, b) {
    return new cc.TransitionProgress(a, b)
};
cc.TransitionProgressRadialCCW = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_RADIAL;
        a.reverseDir = !1;
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCCW.create = function(a, b) {
    return new cc.TransitionProgressRadialCCW(a, b)
};
cc.TransitionProgressRadialCW = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_RADIAL;
        a.reverseDir = !0;
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressRadialCW.create = function(a, b) {
    var c = new cc.TransitionProgressRadialCW;
    return null !== c && c.initWithDuration(a, b) ? c : new cc.TransitionProgressRadialCW(a, b)
};
cc.TransitionProgressHorizontal = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(1, 0);
        a.barChangeRate = cc.p(1, 0);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressHorizontal.create = function(a, b) {
    return new cc.TransitionProgressHorizontal(a, b)
};
cc.TransitionProgressVertical = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0, 0);
        a.barChangeRate = cc.p(0, 1);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressVertical.create = function(a, b) {
    return new cc.TransitionProgressVertical(a, b)
};
cc.TransitionProgressInOut = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 0;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = !1
    },
    _setupTransition: function() {
        this._sceneToBeModified = this._inScene;
        this._from = 0;
        this._to = 100
    }
});
cc.TransitionProgressInOut.create = function(a, b) {
    return new cc.TransitionProgressInOut(a, b)
};
cc.TransitionProgressOutIn = cc.TransitionProgress.extend({
    ctor: function(a, b) {
        cc.TransitionProgress.prototype.ctor.call(this);
        b && this.initWithDuration(a, b)
    },
    _progressTimerNodeWithRenderTexture: function(a) {
        var b = cc.director.getWinSize();
        a = new cc.ProgressTimer(a.sprite);
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (a.sprite.flippedY = !0);
        a.type = cc.ProgressTimer.TYPE_BAR;
        a.midPoint = cc.p(0.5, 0.5);
        a.barChangeRate = cc.p(1, 1);
        a.percentage = 100;
        this._setAttrs(a, b.width / 2, b.height / 2);
        return a
    }
});
cc.TransitionProgressOutIn.create = function(a, b) {
    return new cc.TransitionProgressOutIn(a, b)
};
cc.TransitionPageTurn = cc.TransitionScene.extend({
    ctor: function(a, b, c) {
        cc.TransitionScene.prototype.ctor.call(this);
        this._gridProxy = new cc.NodeGrid;
        this.initWithDuration(a, b, c)
    },
    _back: !0,
    _gridProxy: null,
    _className: "TransitionPageTurn",
    initWithDuration: function(a, b, c) {
        this._back = c;
        cc.TransitionScene.prototype.initWithDuration.call(this, a, b);
        return !0
    },
    actionWithSize: function(a) {
        return this._back ? cc.reverseTime(cc.pageTurn3D(this._duration, a)) : cc.pageTurn3D(this._duration, a)
    },
    onEnter: function() {
        cc.TransitionScene.prototype.onEnter.call(this);
        var a = cc.director.getWinSize(),
            b;
        a.width > a.height ? (a = 16, b = 12) : (a = 12, b = 16);
        a = this.actionWithSize(cc.size(a, b));
        b = this._gridProxy;
        this._back ? (b.setTarget(this._inScene), b.onEnter(), this._inScene.visible = !1, b.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid())), this._inScene.runAction(cc.show())) : (b.setTarget(this._outScene), b.onEnter(), b.runAction(cc.sequence(a, cc.callFunc(this.finish, this), cc.stopGrid())))
    },
    visit: function() {
        this._back ? this._outScene.visit() : this._inScene.visit();
        this._gridProxy.visit()
    },
    _sceneOrder: function() {
        this._isInSceneOnTop = this._back
    }
});
cc.TransitionPageTurn.create = function(a, b, c) {
    return new cc.TransitionPageTurn(a, b, c)
};
cc.Codec = {
    name: "Jacob__Codec"
};
cc.unzip = function() {
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments)
};
cc.unzipBase64 = function() {
    var a = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
    return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, [a])
};
cc.unzipBase64AsArray = function(a, b) {
    b = b || 1;
    var c = this.unzipBase64(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++)
        for (d[e] = 0, f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f;
    return d
};
cc.unzipAsArray = function(a, b) {
    b = b || 1;
    var c = this.unzip(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++)
        for (d[e] = 0, f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f;
    return d
};
cc.StringToArray = function(a) {
    a = a.split(",");
    var b = [],
        c;
    for (c = 0; c < a.length; c++) b.push(parseInt(a[c]));
    return b
};
cc.Codec.Base64 = {
    name: "Jacob__Codec__Base64"
};
cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d";
cc.Codec.Base64.decode = function(a) {
    var b = [],
        c, d, e, f, g, h = 0;
    for (a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""); h < a.length;) c = this._keyStr.indexOf(a.charAt(h++)), d = this._keyStr.indexOf(a.charAt(h++)), f = this._keyStr.indexOf(a.charAt(h++)), g = this._keyStr.indexOf(a.charAt(h++)), c = c << 2 | d >> 4, d = (d & 15) << 4 | f >> 2, e = (f & 3) << 6 | g, b.push(String.fromCharCode(c)), 64 !== f && b.push(String.fromCharCode(d)), 64 !== g && b.push(String.fromCharCode(e));
    return b = b.join("")
};
cc.Codec.Base64.decodeAsArray = function(a, b) {
    var c = this.decode(a),
        d = [],
        e, f, g;
    e = 0;
    for (g = c.length / b; e < g; e++)
        for (d[e] = 0, f = b - 1; 0 <= f; --f) d[e] += c.charCodeAt(e * b + f) << 8 * f;
    return d
};
cc.uint8ArrayToUint32Array = function(a) {
    if (0 !== a.length % 4) return null;
    for (var b = a.length / 4, c = window.Uint32Array ? new Uint32Array(b) : [], d = 0; d < b; d++) {
        var e = 4 * d;
        c[d] = a[e] + 256 * a[e + 1] + 65536 * a[e + 2] + 16777216 * a[e + 3]
    }
    return c
};
cc.Codec.GZip = function(a) {
    this.data = a;
    this.debug = !1;
    this.gpflags = void 0;
    this.files = 0;
    this.unzipped = [];
    this.buf32k = Array(32768);
    this.bIdx = 0;
    this.modeZIP = !1;
    this.bytepos = 0;
    this.bb = 1;
    this.bits = 0;
    this.nameBuf = [];
    this.fileout = void 0;
    this.literalTree = Array(cc.Codec.GZip.LITERALS);
    this.distanceTree = Array(32);
    this.treepos = 0;
    this.Places = null;
    this.len = 0;
    this.fpos = Array(17);
    this.fpos[0] = 0;
    this.fmax = this.flens = void 0
};
cc.Codec.GZip.gunzip = function(a) {
    return (new cc.Codec.GZip(a)).gunzip()[0][0]
};
cc.Codec.GZip.HufNode = function() {
    this.b1 = this.b0 = 0;
    this.jump = null;
    this.jumppos = -1
};
cc.Codec.GZip.LITERALS = 288;
cc.Codec.GZip.NAMEMAX = 256;
cc.Codec.GZip.bitReverse = [0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161,
    97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255
];
cc.Codec.GZip.cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
cc.Codec.GZip.cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99];
cc.Codec.GZip.cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
cc.Codec.GZip.cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
cc.Codec.GZip.border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
cc.Codec.GZip.prototype.gunzip = function() {
    this.outputArr = [];
    this.nextFile();
    return this.unzipped
};
cc.Codec.GZip.prototype.readByte = function() {
    this.bits += 8;
    return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1
};
cc.Codec.GZip.prototype.byteAlign = function() {
    this.bb = 1
};
cc.Codec.GZip.prototype.readBit = function() {
    var a;
    this.bits++;
    a = this.bb & 1;
    this.bb >>= 1;
    0 === this.bb && (this.bb = this.readByte(), a = this.bb & 1, this.bb = this.bb >> 1 | 128);
    return a
};
cc.Codec.GZip.prototype.readBits = function(a) {
    for (var b = 0, c = a; c--;) b = b << 1 | this.readBit();
    a && (b = cc.Codec.GZip.bitReverse[b] >> 8 - a);
    return b
};
cc.Codec.GZip.prototype.flushBuffer = function() {
    this.bIdx = 0
};
cc.Codec.GZip.prototype.addBuffer = function(a) {
    this.buf32k[this.bIdx++] = a;
    this.outputArr.push(String.fromCharCode(a));
    32768 === this.bIdx && (this.bIdx = 0)
};
cc.Codec.GZip.prototype.IsPat = function() {
    for (;;) {
        if (this.fpos[this.len] >= this.fmax) return -1;
        if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++
    }
};
cc.Codec.GZip.prototype.Rec = function() {
    var a = this.Places[this.treepos],
        b;
    if (17 === this.len) return -1;
    this.treepos++;
    this.len++;
    b = this.IsPat();
    if (0 <= b) a.b0 = b;
    else if (a.b0 = 32768, this.Rec()) return -1;
    b = this.IsPat();
    if (0 <= b) a.b1 = b, a.jump = null;
    else if (a.b1 = 32768, a.jump = this.Places[this.treepos], a.jumppos = this.treepos, this.Rec()) return -1;
    this.len--;
    return 0
};
cc.Codec.GZip.prototype.CreateTree = function(a, b, c, d) {
    this.Places = a;
    this.treepos = 0;
    this.flens = c;
    this.fmax = b;
    for (a = 0; 17 > a; a++) this.fpos[a] = 0;
    this.len = 0;
    return this.Rec() ? -1 : 0
};
cc.Codec.GZip.prototype.DecodeValue = function(a) {
    for (var b, c, d = 0, e = a[d];;)
        if (b = this.readBit()) {
            if (!(e.b1 & 32768)) return e.b1;
            e = e.jump;
            b = a.length;
            for (c = 0; c < b; c++)
                if (a[c] === e) {
                    d = c;
                    break
                }
        } else {
            if (!(e.b0 & 32768)) return e.b0;
            d++;
            e = a[d]
        }
    return -1
};
cc.Codec.GZip.prototype.DeflateLoop = function() {
    var a, b, c, d, e;
    do
        if (a = this.readBit(), c = this.readBits(2), 0 === c)
            for (this.byteAlign(), c = this.readByte(), c |= this.readByte() << 8, b = this.readByte(), b |= this.readByte() << 8, (c ^ ~b) & 65535 && document.write("BlockLen checksum mismatch\n"); c--;) b = this.readByte(), this.addBuffer(b);
        else if (1 === c)
        for (;;)
            if (c = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1, 23 < c ? (c = c << 1 | this.readBit(), 199 < c ? (c -= 128, c = c << 1 | this.readBit()) : (c -= 48, 143 < c && (c += 136))) : c += 256, 256 > c) this.addBuffer(c);
            else if (256 === c) break;
    else {
        var f;
        c -= 257;
        e = this.readBits(cc.Codec.GZip.cplext[c]) + cc.Codec.GZip.cplens[c];
        c = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
        8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]);
        f += cc.Codec.GZip.cpdist[c];
        for (c = 0; c < e; c++) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
    } else if (2 === c) {
        var g = Array(320);
        b = 257 + this.readBits(5);
        f = 1 + this.readBits(5);
        d = 4 + this.readBits(4);
        for (c = 0; 19 > c; c++) g[c] =
            0;
        for (c = 0; c < d; c++) g[cc.Codec.GZip.border[c]] = this.readBits(3);
        e = this.distanceTree.length;
        for (d = 0; d < e; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.distanceTree, 19, g, 0)) return this.flushBuffer(), 1;
        e = b + f;
        d = 0;
        for (var h = -1; d < e;)
            if (h++, c = this.DecodeValue(this.distanceTree), 16 > c) g[d++] = c;
            else if (16 === c) {
            var k;
            c = 3 + this.readBits(2);
            if (d + c > e) return this.flushBuffer(), 1;
            for (k = d ? g[d - 1] : 0; c--;) g[d++] = k
        } else {
            c = 17 === c ? 3 + this.readBits(3) : 11 + this.readBits(7);
            if (d + c > e) return this.flushBuffer(),
                1;
            for (; c--;) g[d++] = 0
        }
        e = this.literalTree.length;
        for (d = 0; d < e; d++) this.literalTree[d] = new cc.Codec.GZip.HufNode;
        if (this.CreateTree(this.literalTree, b, g, 0)) return this.flushBuffer(), 1;
        e = this.literalTree.length;
        for (d = 0; d < e; d++) this.distanceTree[d] = new cc.Codec.GZip.HufNode;
        c = [];
        for (d = b; d < g.length; d++) c[d - b] = g[d];
        if (this.CreateTree(this.distanceTree, f, c, 0)) return this.flushBuffer(), 1;
        for (;;)
            if (c = this.DecodeValue(this.literalTree), 256 <= c) {
                c -= 256;
                if (0 === c) break;
                c--;
                e = this.readBits(cc.Codec.GZip.cplext[c]) +
                    cc.Codec.GZip.cplens[c];
                c = this.DecodeValue(this.distanceTree);
                8 < cc.Codec.GZip.cpdext[c] ? (f = this.readBits(8), f |= this.readBits(cc.Codec.GZip.cpdext[c] - 8) << 8) : f = this.readBits(cc.Codec.GZip.cpdext[c]);
                for (f += cc.Codec.GZip.cpdist[c]; e--;) b = this.buf32k[this.bIdx - f & 32767], this.addBuffer(b)
            } else this.addBuffer(c)
    }
    while (!a);
    this.flushBuffer();
    this.byteAlign();
    return 0
};
cc.Codec.GZip.prototype.unzipFile = function(a) {
    var b;
    this.gunzip();
    for (b = 0; b < this.unzipped.length; b++)
        if (this.unzipped[b][1] === a) return this.unzipped[b][0]
};
cc.Codec.GZip.prototype.nextFile = function() {
    this.outputArr = [];
    this.modeZIP = !1;
    var a = [];
    a[0] = this.readByte();
    a[1] = this.readByte();
    120 === a[0] && 218 === a[1] && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), "geonext.gxt"], this.files++);
    31 === a[0] && 139 === a[1] && (this.skipdir(), this.unzipped[this.files] = [this.outputArr.join(""), "file"], this.files++);
    if (80 === a[0] && 75 === a[1] && (this.modeZIP = !0, a[2] = this.readByte(), a[3] = this.readByte(), 3 === a[2] && 4 === a[3])) {
        a[0] = this.readByte();
        a[1] = this.readByte();
        this.gpflags = this.readByte();
        this.gpflags |= this.readByte() << 8;
        a = this.readByte();
        a |= this.readByte() << 8;
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        this.readByte();
        var b = this.readByte(),
            b = b | this.readByte() << 8,
            c = this.readByte(),
            c = c | this.readByte() << 8,
            d = 0;
        for (this.nameBuf = []; b--;) {
            var e = this.readByte();
            "/" === e | ":" === e ? d = 0 : d < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[d++] = String.fromCharCode(e))
        }
        this.fileout ||
            (this.fileout = this.nameBuf);
        for (var d = 0; d < c;) this.readByte(), d++;
        8 === a && (this.DeflateLoop(), this.unzipped[this.files] = [this.outputArr.join(""), this.nameBuf.join("")], this.files++);
        this.skipdir()
    }
};
cc.Codec.GZip.prototype.skipdir = function() {
    var a = [],
        b;
    this.gpflags & 8 && (a[0] = this.readByte(), a[1] = this.readByte(), a[2] = this.readByte(), a[3] = this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte(), this.readByte());
    this.modeZIP && this.nextFile();
    a[0] = this.readByte();
    if (8 !== a[0]) return 0;
    this.gpflags = this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    if (this.gpflags & 4)
        for (a[0] =
            this.readByte(), a[2] = this.readByte(), this.len = a[0] + 256 * a[1], a = 0; a < this.len; a++) this.readByte();
    if (this.gpflags & 8)
        for (a = 0, this.nameBuf = []; b = this.readByte();) {
            if ("7" === b || ":" === b) a = 0;
            a < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[a++] = b)
        }
    if (this.gpflags & 16)
        for (; this.readByte(););
    this.gpflags & 2 && (this.readByte(), this.readByte());
    this.DeflateLoop();
    this.readByte();
    this.readByte();
    this.readByte();
    this.readByte();
    this.modeZIP && this.nextFile()
};
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {
    function a(a) {
        throw a;
    }

    function b(a, b) {
        var c = a.split("."),
            d = E;
        c[0] in d || !d.execScript || d.execScript("var " + c[0]);
        for (var e; c.length && (e = c.shift());) c.length || b === A ? d = d[e] ? d[e] : d[e] = {} : d[e] = b
    }

    function c(a) {
        if ("string" === typeof a) {
            a = a.split("");
            var b, c;
            b = 0;
            for (c = a.length; b < c; b++) a[b] = (a[b].charCodeAt(0) & 255) >>> 0
        }
        b = 1;
        c = 0;
        for (var d = a.length, e, f = 0; 0 < d;) {
            e = 1024 < d ? 1024 : d;
            d -= e;
            do b += a[f++], c += b; while (--e);
            b %= 65521;
            c %= 65521
        }
        return (c << 16 | b) >>> 0
    }

    function d(b, c) {
        this.index = "number" === typeof c ? c : 0;
        this.i = 0;
        this.buffer = b instanceof(x ? Uint8Array : Array) ? b : new(x ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && a(Error("invalid index"));
        this.buffer.length <= this.index && this.f()
    }

    function e(a) {
        this.buffer = new(x ? Uint16Array : Array)(2 * a);
        this.length = 0
    }

    function f(a) {
        var b = a.length,
            c = 0,
            d = Number.POSITIVE_INFINITY,
            e, f, g, h, k, m, n, r, p;
        for (r = 0; r < b; ++r) a[r] > c && (c = a[r]), a[r] < d && (d = a[r]);
        e = 1 << c;
        f = new(x ? Uint32Array : Array)(e);
        g = 1;
        h = 0;
        for (k = 2; g <= c;) {
            for (r = 0; r < b; ++r)
                if (a[r] === g) {
                    m = 0;
                    n = h;
                    for (p = 0; p < g; ++p) m =
                        m << 1 | n & 1, n >>= 1;
                    for (p = m; p < e; p += k) f[p] = g << 16 | r;
                    ++h
                }++g;
            h <<= 1;
            k <<= 1
        }
        return [f, c, d]
    }

    function g(a, b) {
        this.h = J;
        this.w = 0;
        this.input = a;
        this.b = 0;
        b && (b.lazy && (this.w = b.lazy), "number" === typeof b.compressionType && (this.h = b.compressionType), b.outputBuffer && (this.a = x && b.outputBuffer instanceof Array ? new Uint8Array(b.outputBuffer) : b.outputBuffer), "number" === typeof b.outputIndex && (this.b = b.outputIndex));
        this.a || (this.a = new(x ? Uint8Array : Array)(32768))
    }

    function h(a, b) {
        this.length = a;
        this.G = b
    }

    function k() {
        var b = H;
        switch (C) {
            case 3 ===
            b:
                return [257, b - 3, 0];
            case 4 === b:
                return [258, b - 4, 0];
            case 5 === b:
                return [259, b - 5, 0];
            case 6 === b:
                return [260, b - 6, 0];
            case 7 === b:
                return [261, b - 7, 0];
            case 8 === b:
                return [262, b - 8, 0];
            case 9 === b:
                return [263, b - 9, 0];
            case 10 === b:
                return [264, b - 10, 0];
            case 12 >= b:
                return [265, b - 11, 1];
            case 14 >= b:
                return [266, b - 13, 1];
            case 16 >= b:
                return [267, b - 15, 1];
            case 18 >= b:
                return [268, b - 17, 1];
            case 22 >= b:
                return [269, b - 19, 2];
            case 26 >= b:
                return [270, b - 23, 2];
            case 30 >= b:
                return [271, b - 27, 2];
            case 34 >= b:
                return [272, b - 31, 2];
            case 42 >= b:
                return [273, b - 35, 3];
            case 50 >=
            b:
                return [274, b - 43, 3];
            case 58 >= b:
                return [275, b - 51, 3];
            case 66 >= b:
                return [276, b - 59, 3];
            case 82 >= b:
                return [277, b - 67, 4];
            case 98 >= b:
                return [278, b - 83, 4];
            case 114 >= b:
                return [279, b - 99, 4];
            case 130 >= b:
                return [280, b - 115, 4];
            case 162 >= b:
                return [281, b - 131, 5];
            case 194 >= b:
                return [282, b - 163, 5];
            case 226 >= b:
                return [283, b - 195, 5];
            case 257 >= b:
                return [284, b - 227, 5];
            case 258 === b:
                return [285, b - 258, 0];
            default:
                a("invalid length: " + b)
        }
    }

    function m(b, c) {
        function d(b, c) {
            var e = b.G,
                f = [],
                g = 0,
                h;
            h = L[b.length];
            f[g++] = h & 65535;
            f[g++] = h >> 16 & 255;
            f[g++] =
                h >> 24;
            var k;
            switch (C) {
                case 1 === e:
                    k = [0, e - 1, 0];
                    break;
                case 2 === e:
                    k = [1, e - 2, 0];
                    break;
                case 3 === e:
                    k = [2, e - 3, 0];
                    break;
                case 4 === e:
                    k = [3, e - 4, 0];
                    break;
                case 6 >= e:
                    k = [4, e - 5, 1];
                    break;
                case 8 >= e:
                    k = [5, e - 7, 1];
                    break;
                case 12 >= e:
                    k = [6, e - 9, 2];
                    break;
                case 16 >= e:
                    k = [7, e - 13, 2];
                    break;
                case 24 >= e:
                    k = [8, e - 17, 3];
                    break;
                case 32 >= e:
                    k = [9, e - 25, 3];
                    break;
                case 48 >= e:
                    k = [10, e - 33, 4];
                    break;
                case 64 >= e:
                    k = [11, e - 49, 4];
                    break;
                case 96 >= e:
                    k = [12, e - 65, 5];
                    break;
                case 128 >= e:
                    k = [13, e - 97, 5];
                    break;
                case 192 >= e:
                    k = [14, e - 129, 6];
                    break;
                case 256 >= e:
                    k = [15, e - 193, 6];
                    break;
                case 384 >= e:
                    k = [16, e - 257, 7];
                    break;
                case 512 >= e:
                    k = [17, e - 385, 7];
                    break;
                case 768 >= e:
                    k = [18, e - 513, 8];
                    break;
                case 1024 >= e:
                    k = [19, e - 769, 8];
                    break;
                case 1536 >= e:
                    k = [20, e - 1025, 9];
                    break;
                case 2048 >= e:
                    k = [21, e - 1537, 9];
                    break;
                case 3072 >= e:
                    k = [22, e - 2049, 10];
                    break;
                case 4096 >= e:
                    k = [23, e - 3073, 10];
                    break;
                case 6144 >= e:
                    k = [24, e - 4097, 11];
                    break;
                case 8192 >= e:
                    k = [25, e - 6145, 11];
                    break;
                case 12288 >= e:
                    k = [26, e - 8193, 12];
                    break;
                case 16384 >= e:
                    k = [27, e - 12289, 12];
                    break;
                case 24576 >= e:
                    k = [28, e - 16385, 13];
                    break;
                case 32768 >= e:
                    k = [29, e - 24577, 13];
                    break;
                default:
                    a("invalid distance")
            }
            h =
                k;
            f[g++] = h[0];
            f[g++] = h[1];
            f[g++] = h[2];
            e = 0;
            for (g = f.length; e < g; ++e) p[t++] = f[e];
            u[f[0]]++;
            v[f[3]]++;
            s = b.length + c - 1;
            r = null
        }
        var e, f, g, k, m, n = {},
            r, p = x ? new Uint16Array(2 * c.length) : [],
            t = 0,
            s = 0,
            u = new(x ? Uint32Array : Array)(286),
            v = new(x ? Uint32Array : Array)(30),
            w = b.w,
            E;
        if (!x) {
            for (g = 0; 285 >= g;) u[g++] = 0;
            for (g = 0; 29 >= g;) v[g++] = 0
        }
        u[256] = 1;
        e = 0;
        for (f = c.length; e < f; ++e) {
            g = m = 0;
            for (k = 3; g < k && e + g !== f; ++g) m = m << 8 | c[e + g];
            n[m] === A && (n[m] = []);
            g = n[m];
            if (!(0 < s--)) {
                for (; 0 < g.length && 32768 < e - g[0];) g.shift();
                if (e + 3 >= f) {
                    r && d(r, -1);
                    g = 0;
                    for (k = f - e; g < k; ++g) E = c[e + g], p[t++] = E, ++u[E];
                    break
                }
                if (0 < g.length) {
                    m = k = A;
                    var z = 0,
                        B = A,
                        y = A,
                        D = B = A,
                        G = c.length,
                        y = 0,
                        D = g.length;
                    a: for (; y < D; y++) {
                        k = g[D - y - 1];
                        B = 3;
                        if (3 < z) {
                            for (B = z; 3 < B; B--)
                                if (c[k + B - 1] !== c[e + B - 1]) continue a;
                            B = z
                        }
                        for (; 258 > B && e + B < G && c[k + B] === c[e + B];) ++B;
                        B > z && (m = k, z = B);
                        if (258 === B) break
                    }
                    k = new h(z, e - m);
                    r ? r.length < k.length ? (E = c[e - 1], p[t++] = E, ++u[E], d(k, 0)) : d(r, -1) : k.length < w ? r = k : d(k, 0)
                } else r ? d(r, -1) : (E = c[e], p[t++] = E, ++u[E])
            }
            g.push(e)
        }
        p[t++] = 256;
        u[256]++;
        b.L = u;
        b.K = v;
        return x ? p.subarray(0, t) : p
    }

    function n(a,
        b) {
        function c(a) {
            var b = p[a][t[a]];
            b === n ? (c(a + 1), c(a + 1)) : --r[b];
            ++t[a]
        }
        var d = a.length,
            f = new e(572),
            g = new(x ? Uint8Array : Array)(d),
            h, k, m;
        if (!x)
            for (k = 0; k < d; k++) g[k] = 0;
        for (k = 0; k < d; ++k) 0 < a[k] && f.push(k, a[k]);
        d = Array(f.length / 2);
        h = new(x ? Uint32Array : Array)(f.length / 2);
        if (1 === d.length) return g[f.pop().index] = 1, g;
        k = 0;
        for (m = f.length / 2; k < m; ++k) d[k] = f.pop(), h[k] = d[k].value;
        var n = h.length;
        k = new(x ? Uint16Array : Array)(b);
        var f = new(x ? Uint8Array : Array)(b),
            r = new(x ? Uint8Array : Array)(n);
        m = Array(b);
        var p = Array(b),
            t =
            Array(b),
            s = (1 << b) - n,
            u = 1 << b - 1,
            v, w, A;
        k[b - 1] = n;
        for (v = 0; v < b; ++v) s < u ? f[v] = 0 : (f[v] = 1, s -= u), s <<= 1, k[b - 2 - v] = (k[b - 1 - v] / 2 | 0) + n;
        k[0] = f[0];
        m[0] = Array(k[0]);
        p[0] = Array(k[0]);
        for (v = 1; v < b; ++v) k[v] > 2 * k[v - 1] + f[v] && (k[v] = 2 * k[v - 1] + f[v]), m[v] = Array(k[v]), p[v] = Array(k[v]);
        for (s = 0; s < n; ++s) r[s] = b;
        for (u = 0; u < k[b - 1]; ++u) m[b - 1][u] = h[u], p[b - 1][u] = u;
        for (s = 0; s < b; ++s) t[s] = 0;
        1 === f[b - 1] && (--r[0], ++t[b - 1]);
        for (v = b - 2; 0 <= v; --v) {
            w = s = 0;
            A = t[v + 1];
            for (u = 0; u < k[v]; u++) w = m[v + 1][A] + m[v + 1][A + 1], w > h[s] ? (m[v][u] = w, p[v][u] = n, A += 2) : (m[v][u] = h[s],
                p[v][u] = s, ++s);
            t[v] = 0;
            1 === f[v] && c(v)
        }
        h = r;
        k = 0;
        for (m = d.length; k < m; ++k) g[d[k].index] = h[k];
        return g
    }

    function p(b) {
        var c = new(x ? Uint16Array : Array)(b.length),
            d = [],
            e = [],
            f = 0,
            g, h, k;
        g = 0;
        for (h = b.length; g < h; g++) d[b[g]] = (d[b[g]] | 0) + 1;
        g = 1;
        for (h = 16; g <= h; g++) e[g] = f, f += d[g] | 0, f > 1 << g && a("overcommitted"), f <<= 1;
        65536 > f && a("undercommitted");
        g = 0;
        for (h = b.length; g < h; g++)
            for (f = e[b[g]], e[b[g]] += 1, d = c[g] = 0, k = b[g]; d < k; d++) c[g] = c[g] << 1 | f & 1, f >>>= 1;
        return c
    }

    function s(a, b) {
        this.input = a;
        this.a = new(x ? Uint8Array : Array)(32768);
        this.h =
            I.j;
        var c = {},
            d;
        !b && (b = {}) || "number" !== typeof b.compressionType || (this.h = b.compressionType);
        for (d in b) c[d] = b[d];
        c.outputBuffer = this.a;
        this.z = new g(this.input, c)
    }

    function r(b, c) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = x ? new Uint8Array(b) : b;
        this.s = !1;
        this.m = M;
        this.B = !1;
        if (c || !(c = {})) c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize);
        switch (this.m) {
            case N:
                this.b = 32768;
                this.a = new(x ? Uint8Array : Array)(32768 +
                    this.l + 258);
                break;
            case M:
                this.b = 0;
                this.a = new(x ? Uint8Array : Array)(this.l);
                this.f = this.J;
                this.t = this.H;
                this.o = this.I;
                break;
            default:
                a(Error("invalid inflate mode"))
        }
    }

    function u(b, c) {
        for (var d = b.g, e = b.e, f = b.input, g = b.c, h; e < c;) h = f[g++], h === A && a(Error("input buffer is broken")), d |= h << e, e += 8;
        b.g = d >>> c;
        b.e = e - c;
        b.c = g;
        return d & (1 << c) - 1
    }

    function t(b, c) {
        for (var d = b.g, e = b.e, f = b.input, g = b.c, h = c[0], k = c[1], m; e < k;) m = f[g++], m === A && a(Error("input buffer is broken")), d |= m << e, e += 8;
        f = h[d & (1 << k) - 1];
        h = f >>> 16;
        b.g = d >> h;
        b.e =
            e - h;
        b.c = g;
        return f & 65535
    }

    function v(a) {
        function b(a, c, d) {
            var e, f, g, h;
            for (h = 0; h < a;) switch (e = t(this, c), e) {
                case 16:
                    for (g = 3 + u(this, 2); g--;) d[h++] = f;
                    break;
                case 17:
                    for (g = 3 + u(this, 3); g--;) d[h++] = 0;
                    f = 0;
                    break;
                case 18:
                    for (g = 11 + u(this, 7); g--;) d[h++] = 0;
                    f = 0;
                    break;
                default:
                    f = d[h++] = e
            }
            return d
        }
        var c = u(a, 5) + 257,
            d = u(a, 5) + 1,
            e = u(a, 4) + 4,
            g = new(x ? Uint8Array : Array)(O.length),
            h;
        for (h = 0; h < e; ++h) g[O[h]] = u(a, 3);
        e = f(g);
        g = new(x ? Uint8Array : Array)(c);
        h = new(x ? Uint8Array : Array)(d);
        a.o(f(b.call(a, c, e, g)), f(b.call(a, d, e, h)))
    }

    function w(b,
        c) {
        var d, e;
        this.input = b;
        this.c = 0;
        if (c || !(c = {})) c.index && (this.c = c.index), c.verify && (this.M = c.verify);
        d = b[this.c++];
        e = b[this.c++];
        switch (d & 15) {
            case R:
                this.method = R;
                break;
            default:
                a(Error("unsupported compression method"))
        }
        0 !== ((d << 8) + e) % 31 && a(Error("invalid fcheck flag:" + ((d << 8) + e) % 31));
        e & 32 && a(Error("fdict flag is not supported"));
        this.A = new r(b, {
            index: this.c,
            bufferSize: c.bufferSize,
            bufferType: c.bufferType,
            resize: c.resize
        })
    }
    var A = void 0,
        C = !0,
        E = this,
        x = "undefined" !== typeof Uint8Array && "undefined" !==
        typeof Uint16Array && "undefined" !== typeof Uint32Array;
    d.prototype.f = function() {
        var a = this.buffer,
            b, c = a.length,
            d = new(x ? Uint8Array : Array)(c << 1);
        if (x) d.set(a);
        else
            for (b = 0; b < c; ++b) d[b] = a[b];
        return this.buffer = d
    };
    d.prototype.d = function(a, b, c) {
        var d = this.buffer,
            e = this.index,
            f = this.i,
            g = d[e];
        c && 1 < b && (a = 8 < b ? (y[a & 255] << 24 | y[a >>> 8 & 255] << 16 | y[a >>> 16 & 255] << 8 | y[a >>> 24 & 255]) >> 32 - b : y[a] >> 8 - b);
        if (8 > b + f) g = g << b | a, f += b;
        else
            for (c = 0; c < b; ++c) g = g << 1 | a >> b - c - 1 & 1, 8 === ++f && (f = 0, d[e++] = y[g], g = 0, e === d.length && (d = this.f()));
        d[e] = g;
        this.buffer = d;
        this.i = f;
        this.index = e
    };
    d.prototype.finish = function() {
        var a = this.buffer,
            b = this.index,
            c;
        0 < this.i && (a[b] <<= 8 - this.i, a[b] = y[a[b]], b++);
        x ? c = a.subarray(0, b) : (a.length = b, c = a);
        return c
    };
    var B = new(x ? Uint8Array : Array)(256),
        z;
    for (z = 0; 256 > z; ++z) {
        for (var D = z, G = D, F = 7, D = D >>> 1; D; D >>>= 1) G <<= 1, G |= D & 1, --F;
        B[z] = (G << F & 255) >>> 0
    }
    var y = B,
        B = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049,
            498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275,
            3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277,
            2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143,
            2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112,
            2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746,
            711928724, 3020668471, 3272380065, 1510334235, 755167117
        ];
    x && new Uint32Array(B);
    e.prototype.getParent = function(a) {
        return 2 * ((a - 2) / 4 | 0)
    };
    e.prototype.push = function(a, b) {
        var c, d, e = this.buffer,
            f;
        c = this.length;
        e[this.length++] = b;
        for (e[this.length++] = a; 0 < c;)
            if (d = this.getParent(c), e[c] > e[d]) f = e[c], e[c] = e[d], e[d] = f, f = e[c + 1], e[c + 1] = e[d + 1], e[d + 1] = f, c = d;
            else break;
        return this.length
    };
    e.prototype.pop = function() {
        var a, b, c = this.buffer,
            d, e, f;
        b = c[0];
        a = c[1];
        this.length -= 2;
        c[0] = c[this.length];
        c[1] = c[this.length + 1];
        for (f =
            0;;) {
            e = 2 * f + 2;
            if (e >= this.length) break;
            e + 2 < this.length && c[e + 2] > c[e] && (e += 2);
            if (c[e] > c[f]) d = c[f], c[f] = c[e], c[e] = d, d = c[f + 1], c[f + 1] = c[e + 1], c[e + 1] = d;
            else break;
            f = e
        }
        return {
            index: a,
            value: b,
            length: this.length
        }
    };
    var J = 2,
        B = {
            NONE: 0,
            r: 1,
            j: J,
            N: 3
        },
        K = [];
    for (z = 0; 288 > z; z++) switch (C) {
        case 143 >= z:
            K.push([z + 48, 8]);
            break;
        case 255 >= z:
            K.push([z - 144 + 400, 9]);
            break;
        case 279 >= z:
            K.push([z - 256 + 0, 7]);
            break;
        case 287 >= z:
            K.push([z - 280 + 192, 8]);
            break;
        default:
            a("invalid literal: " + z)
    }
    g.prototype.n = function() {
        var b, c, e, f, g = this.input;
        switch (this.h) {
            case 0:
                e = 0;
                for (f = g.length; e < f;) {
                    c = x ? g.subarray(e, e + 65535) : g.slice(e, e + 65535);
                    e += c.length;
                    var h = e === f,
                        k = A,
                        r = k = A,
                        r = k = A,
                        t = this.a,
                        v = this.b;
                    if (x) {
                        for (t = new Uint8Array(this.a.buffer); t.length <= v + c.length + 5;) t = new Uint8Array(t.length << 1);
                        t.set(this.a)
                    }
                    k = h ? 1 : 0;
                    t[v++] = k | 0;
                    k = c.length;
                    r = ~k + 65536 & 65535;
                    t[v++] = k & 255;
                    t[v++] = k >>> 8 & 255;
                    t[v++] = r & 255;
                    t[v++] = r >>> 8 & 255;
                    if (x) t.set(c, v), v += c.length, t = t.subarray(0, v);
                    else {
                        k = 0;
                        for (r = c.length; k < r; ++k) t[v++] = c[k];
                        t.length = v
                    }
                    this.b = v;
                    this.a = t
                }
                break;
            case 1:
                e =
                    new d(new Uint8Array(this.a.buffer), this.b);
                e.d(1, 1, C);
                e.d(1, 2, C);
                g = m(this, g);
                c = 0;
                for (h = g.length; c < h; c++)
                    if (f = g[c], d.prototype.d.apply(e, K[f]), 256 < f) e.d(g[++c], g[++c], C), e.d(g[++c], 5), e.d(g[++c], g[++c], C);
                    else if (256 === f) break;
                this.a = e.finish();
                this.b = this.a.length;
                break;
            case J:
                f = new d(new Uint8Array(this.a), this.b);
                var s, u, w, E = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                    B, z, k = Array(19),
                    y, t = J;
                f.d(1, 1, C);
                f.d(t, 2, C);
                g = m(this, g);
                r = n(this.L, 15);
                B = p(r);
                t = n(this.K, 7);
                v = p(t);
                for (s = 286; 257 < s && 0 === r[s -
                        1]; s--);
                for (u = 30; 1 < u && 0 === t[u - 1]; u--);
                var D = s,
                    G = u;
                b = new(x ? Uint32Array : Array)(D + G);
                var F = new(x ? Uint32Array : Array)(316),
                    I, H;
                z = new(x ? Uint8Array : Array)(19);
                for (y = w = 0; y < D; y++) b[w++] = r[y];
                for (y = 0; y < G; y++) b[w++] = t[y];
                if (!x)
                    for (y = 0, G = z.length; y < G; ++y) z[y] = 0;
                y = I = 0;
                for (G = b.length; y < G; y += w) {
                    for (w = 1; y + w < G && b[y + w] === b[y]; ++w);
                    D = w;
                    if (0 === b[y])
                        if (3 > D)
                            for (; 0 < D--;) F[I++] = 0, z[0]++;
                        else
                            for (; 0 < D;) H = 138 > D ? D : 138, H > D - 3 && H < D && (H = D - 3), 10 >= H ? (F[I++] = 17, F[I++] = H - 3, z[17]++) : (F[I++] = 18, F[I++] = H - 11, z[18]++), D -= H;
                    else if (F[I++] =
                        b[y], z[b[y]]++, D--, 3 > D)
                        for (; 0 < D--;) F[I++] = b[y], z[b[y]]++;
                    else
                        for (; 0 < D;) H = 6 > D ? D : 6, H > D - 3 && H < D && (H = D - 3), F[I++] = 16, F[I++] = H - 3, z[16]++, D -= H
                }
                b = x ? F.subarray(0, I) : F.slice(0, I);
                z = n(z, 7);
                for (y = 0; 19 > y; y++) k[y] = z[E[y]];
                for (w = 19; 4 < w && 0 === k[w - 1]; w--);
                E = p(z);
                f.d(s - 257, 5, C);
                f.d(u - 1, 5, C);
                f.d(w - 4, 4, C);
                for (y = 0; y < w; y++) f.d(k[y], 3, C);
                y = 0;
                for (k = b.length; y < k; y++)
                    if (c = b[y], f.d(E[c], z[c], C), 16 <= c) {
                        y++;
                        switch (c) {
                            case 16:
                                h = 2;
                                break;
                            case 17:
                                h = 3;
                                break;
                            case 18:
                                h = 7;
                                break;
                            default:
                                a("invalid code: " + c)
                        }
                        f.d(b[y], h, C)
                    }
                h = [B, r];
                v = [v,
                    t
                ];
                c = h[0];
                h = h[1];
                t = v[0];
                B = v[1];
                v = 0;
                for (k = g.length; v < k; ++v)
                    if (e = g[v], f.d(c[e], h[e], C), 256 < e) f.d(g[++v], g[++v], C), r = g[++v], f.d(t[r], B[r], C), f.d(g[++v], g[++v], C);
                    else if (256 === e) break;
                this.a = f.finish();
                this.b = this.a.length;
                break;
            default:
                a("invalid compression type")
        }
        return this.a
    };
    z = [];
    var H;
    for (H = 3; 258 >= H; H++) D = k(), z[H] = D[2] << 24 | D[1] << 16 | D[0];
    var L = x ? new Uint32Array(z) : z,
        I = B;
    s.prototype.n = function() {
        var b, d, e, f, g = 0;
        f = this.a;
        b = R;
        switch (b) {
            case R:
                d = Math.LOG2E * Math.log(32768) - 8;
                break;
            default:
                a(Error("invalid compression method"))
        }
        d =
            d << 4 | b;
        f[g++] = d;
        switch (b) {
            case R:
                switch (this.h) {
                    case I.NONE:
                        e = 0;
                        break;
                    case I.r:
                        e = 1;
                        break;
                    case I.j:
                        e = 2;
                        break;
                    default:
                        a(Error("unsupported compression type"))
                }
                break;
            default:
                a(Error("invalid compression method"))
        }
        b = e << 6 | 0;
        f[g++] = b | 31 - (256 * d + b) % 31;
        b = c(this.input);
        this.z.b = g;
        f = this.z.n();
        g = f.length;
        x && (f = new Uint8Array(f.buffer), f.length <= g + 4 && (this.a = new Uint8Array(f.length + 4), this.a.set(f), f = this.a), f = f.subarray(0, g + 4));
        f[g++] = b >> 24 & 255;
        f[g++] = b >> 16 & 255;
        f[g++] = b >> 8 & 255;
        f[g++] = b & 255;
        return f
    };
    b("Zlib.Deflate",
        s);
    b("Zlib.Deflate.compress", function(a, b) {
        return (new s(a, b)).n()
    });
    b("Zlib.Deflate.CompressionType", I);
    b("Zlib.Deflate.CompressionType.NONE", I.NONE);
    b("Zlib.Deflate.CompressionType.FIXED", I.r);
    b("Zlib.Deflate.CompressionType.DYNAMIC", I.j);
    var N = 0,
        M = 1,
        B = {
            D: N,
            C: M
        };
    r.prototype.p = function() {
        for (; !this.s;) {
            var b = u(this, 3);
            b & 1 && (this.s = C);
            b >>>= 1;
            switch (b) {
                case 0:
                    var b = this.input,
                        c = this.c,
                        d = this.a,
                        e = this.b,
                        f = A,
                        g = A,
                        h = A,
                        k = d.length,
                        f = A;
                    this.e = this.g = 0;
                    f = b[c++];
                    f === A && a(Error("invalid uncompressed block header: LEN (first byte)"));
                    g = f;
                    f = b[c++];
                    f === A && a(Error("invalid uncompressed block header: LEN (second byte)"));
                    g |= f << 8;
                    f = b[c++];
                    f === A && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                    h = f;
                    f = b[c++];
                    f === A && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                    h |= f << 8;
                    g === ~h && a(Error("invalid uncompressed block header: length verify"));
                    c + g > b.length && a(Error("input buffer is broken"));
                    switch (this.m) {
                        case N:
                            for (; e + g > d.length;) {
                                f = k - e;
                                g -= f;
                                if (x) d.set(b.subarray(c, c + f), e), e += f, c += f;
                                else
                                    for (; f--;) d[e++] =
                                        b[c++];
                                this.b = e;
                                d = this.f();
                                e = this.b
                            }
                            break;
                        case M:
                            for (; e + g > d.length;) d = this.f({
                                v: 2
                            });
                            break;
                        default:
                            a(Error("invalid inflate mode"))
                    }
                    if (x) d.set(b.subarray(c, c + g), e), e += g, c += g;
                    else
                        for (; g--;) d[e++] = b[c++];
                    this.c = c;
                    this.b = e;
                    this.a = d;
                    break;
                case 1:
                    this.o(U, V);
                    break;
                case 2:
                    v(this);
                    break;
                default:
                    a(Error("unknown BTYPE: " + b))
            }
        }
        return this.t()
    };
    z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var O = x ? new Uint16Array(z) : z;
    z = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227,
        258, 258, 258
    ];
    var P = x ? new Uint16Array(z) : z;
    z = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var Q = x ? new Uint8Array(z) : z;
    z = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var T = x ? new Uint16Array(z) : z;
    z = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var S = x ? new Uint8Array(z) : z;
    z = new(x ? Uint8Array : Array)(288);
    D = 0;
    for (G = z.length; D < G; ++D) z[D] = 143 >= D ? 8 : 255 >= D ? 9 : 279 >= D ? 7 : 8;
    var U = f(z);
    z = new(x ? Uint8Array :
        Array)(30);
    D = 0;
    for (G = z.length; D < G; ++D) z[D] = 5;
    var V = f(z);
    r.prototype.o = function(a, b) {
        var c = this.a,
            d = this.b;
        this.u = a;
        for (var e = c.length - 258, f, g, h; 256 !== (f = t(this, a));)
            if (256 > f) d >= e && (this.b = d, c = this.f(), d = this.b), c[d++] = f;
            else
                for (f -= 257, h = P[f], 0 < Q[f] && (h += u(this, Q[f])), f = t(this, b), g = T[f], 0 < S[f] && (g += u(this, S[f])), d >= e && (this.b = d, c = this.f(), d = this.b); h--;) c[d] = c[d++ - g];
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = d
    };
    r.prototype.I = function(a, b) {
        var c = this.a,
            d = this.b;
        this.u = a;
        for (var e = c.length, f, g, h; 256 !==
            (f = t(this, a));)
            if (256 > f) d >= e && (c = this.f(), e = c.length), c[d++] = f;
            else
                for (f -= 257, h = P[f], 0 < Q[f] && (h += u(this, Q[f])), f = t(this, b), g = T[f], 0 < S[f] && (g += u(this, S[f])), d + h > e && (c = this.f(), e = c.length); h--;) c[d] = c[d++ - g];
        for (; 8 <= this.e;) this.e -= 8, this.c--;
        this.b = d
    };
    r.prototype.f = function() {
        var a = new(x ? Uint8Array : Array)(this.b - 32768),
            b = this.b - 32768,
            c, d, e = this.a;
        if (x) a.set(e.subarray(32768, a.length));
        else
            for (c = 0, d = a.length; c < d; ++c) a[c] = e[c + 32768];
        this.k.push(a);
        this.q += a.length;
        if (x) e.set(e.subarray(b, b + 32768));
        else
            for (c = 0; 32768 > c; ++c) e[c] = e[b + c];
        this.b = 32768;
        return e
    };
    r.prototype.J = function(a) {
        var b, c = this.input.length / this.c + 1 | 0,
            d, e, f, g = this.input,
            h = this.a;
        a && ("number" === typeof a.v && (c = a.v), "number" === typeof a.F && (c += a.F));
        2 > c ? (d = (g.length - this.c) / this.u[2], f = d / 2 * 258 | 0, e = f < h.length ? h.length + f : h.length << 1) : e = h.length * c;
        x ? (b = new Uint8Array(e), b.set(h)) : b = h;
        return this.a = b
    };
    r.prototype.t = function() {
        var a = 0,
            b = this.a,
            c = this.k,
            d, e = new(x ? Uint8Array : Array)(this.q + (this.b - 32768)),
            f, g, h, k;
        if (0 === c.length) return x ?
            this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        f = 0;
        for (g = c.length; f < g; ++f)
            for (d = c[f], h = 0, k = d.length; h < k; ++h) e[a++] = d[h];
        f = 32768;
        for (g = this.b; f < g; ++f) e[a++] = b[f];
        this.k = [];
        return this.buffer = e
    };
    r.prototype.H = function() {
        var a, b = this.b;
        x ? this.B ? (a = new Uint8Array(b), a.set(this.a.subarray(0, b))) : a = this.a.subarray(0, b) : (this.a.length > b && (this.a.length = b), a = this.a);
        return this.buffer = a
    };
    w.prototype.p = function() {
        var b = this.input,
            d, e;
        d = this.A.p();
        this.c = this.A.c;
        this.M && (e = (b[this.c++] << 24 | b[this.c++] <<
            16 | b[this.c++] << 8 | b[this.c++]) >>> 0, e !== c(d) && a(Error("invalid adler-32 checksum")));
        return d
    };
    b("Zlib.Inflate", w);
    b("Zlib.Inflate.BufferType", B);
    B.ADAPTIVE = B.C;
    B.BLOCK = B.D;
    b("Zlib.Inflate.prototype.decompress", w.prototype.p);
    B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    x && new Uint16Array(B);
    B = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    x && new Uint16Array(B);
    B = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    x && new Uint8Array(B);
    B = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    x && new Uint16Array(B);
    B = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    x && new Uint8Array(B);
    B = new(x ? Uint8Array : Array)(288);
    z = 0;
    for (D = B.length; z < D; ++z) B[z] = 143 >= z ? 8 : 255 >= z ? 9 : 279 >= z ? 7 : 8;
    f(B);
    B = new(x ? Uint8Array : Array)(30);
    z = 0;
    for (D = B.length; z < D; ++z) B[z] = 5;
    f(B);
    var R = 8
}).call(this);
_p = window;
_p = _p.Zlib = _p.Zlib;
_p.Deflate = _p.Deflate;
_p.Deflate.compress = _p.Deflate.compress;
_p.Inflate = _p.Inflate;
_p.Inflate.BufferType = _p.Inflate.BufferType;
_p.Inflate.prototype.decompress = _p.Inflate.prototype.decompress;
cc.PNGReader = cc.Class.extend({
    ctor: function(a) {
        var b, c, d, e;
        this.data = a;
        this.pos = 8;
        this.palette = [];
        this.imgData = [];
        this.transparency = {};
        this.animation = null;
        this.text = {};
        for (d = null;;) {
            b = this.readUInt32();
            e = a = void 0;
            e = [];
            for (a = 0; 4 > a; ++a) e.push(String.fromCharCode(this.data[this.pos++]));
            a = e.join("");
            switch (a) {
                case "IHDR":
                    this.width = this.readUInt32();
                    this.height = this.readUInt32();
                    this.bits = this.data[this.pos++];
                    this.colorType = this.data[this.pos++];
                    this.compressionMethod = this.data[this.pos++];
                    this.filterMethod =
                        this.data[this.pos++];
                    this.interlaceMethod = this.data[this.pos++];
                    break;
                case "acTL":
                    this.animation = {
                        numFrames: this.readUInt32(),
                        numPlays: this.readUInt32() || Infinity,
                        frames: []
                    };
                    break;
                case "PLTE":
                    this.palette = this.read(b);
                    break;
                case "fcTL":
                    d && this.animation.frames.push(d);
                    this.pos += 4;
                    d = {
                        width: this.readUInt32(),
                        height: this.readUInt32(),
                        xOffset: this.readUInt32(),
                        yOffset: this.readUInt32()
                    };
                    a = this.readUInt16();
                    b = this.readUInt16() || 100;
                    d.delay = 1E3 * a / b;
                    d.disposeOp = this.data[this.pos++];
                    d.blendOp = this.data[this.pos++];
                    d.data = [];
                    break;
                case "IDAT":
                case "fdAT":
                    "fdAT" === a && (this.pos += 4, b -= 4);
                    a = (null != d ? d.data : void 0) || this.imgData;
                    for (e = 0; 0 <= b ? e < b : e > b; 0 <= b ? ++e : --e) a.push(this.data[this.pos++]);
                    break;
                case "tRNS":
                    this.transparency = {};
                    switch (this.colorType) {
                        case 3:
                            this.transparency.indexed = this.read(b);
                            b = 255 - this.transparency.indexed.length;
                            if (0 < b)
                                for (a = 0; 0 <= b ? a < b : a > b; 0 <= b ? ++a : --a) this.transparency.indexed.push(255);
                            break;
                        case 0:
                            this.transparency.grayscale = this.read(b)[0];
                            break;
                        case 2:
                            this.transparency.rgb = this.read(b)
                    }
                    break;
                case "tEXt":
                    e = this.read(b);
                    b = e.indexOf(0);
                    a = String.fromCharCode.apply(String, e.slice(0, b));
                    this.text[a] = String.fromCharCode.apply(String, e.slice(b + 1));
                    break;
                case "IEND":
                    d && this.animation.frames.push(d);
                    a: {
                        switch (this.colorType) {
                            case 0:
                            case 3:
                            case 4:
                                d = 1;
                                break a;
                            case 2:
                            case 6:
                                d = 3;
                                break a
                        }
                        d = void 0
                    }
                    this.colors = d;
                    this.hasAlphaChannel = 4 === (c = this.colorType) || 6 === c;
                    c = this.colors + (this.hasAlphaChannel ? 1 : 0);
                    this.pixelBitlength = this.bits * c;
                    a: {
                        switch (this.colors) {
                            case 1:
                                c = "DeviceGray";
                                break a;
                            case 3:
                                c = "DeviceRGB";
                                break a
                        }
                        c = void 0
                    }
                    this.colorSpace = c;
                    Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
                    return;
                default:
                    this.pos += b
            }
            this.pos += 4;
            if (this.pos > this.data.length) throw Error("Incomplete or corrupt PNG file");
        }
    },
    read: function(a) {
        var b, c;
        c = [];
        for (b = 0; 0 <= a ? b < a : b > a; 0 <= a ? ++b : --b) c.push(this.data[this.pos++]);
        return c
    },
    readUInt32: function() {
        var a, b, c, d;
        a = this.data[this.pos++] << 24;
        b = this.data[this.pos++] << 16;
        c = this.data[this.pos++] << 8;
        d = this.data[this.pos++];
        return a | b | c | d
    },
    readUInt16: function() {
        var a,
            b;
        a = this.data[this.pos++] << 8;
        b = this.data[this.pos++];
        return a | b
    },
    decodePixels: function(a) {
        var b, c, d, e, f, g, h, k, m, n, p, s, r, u, t;
        null == a && (a = this.imgData);
        if (0 === a.length) return new Uint8Array(0);
        a = (new Zlib.Inflate(a, {
            index: 0,
            verify: !1
        })).decompress();
        k = this.pixelBitlength / 8;
        s = k * this.width;
        m = new Uint8Array(s * this.height);
        g = a.length;
        for (c = n = p = 0; n < g;) {
            switch (a[n++]) {
                case 0:
                    for (b = 0; b < s; b += 1) m[c++] = a[n++];
                    break;
                case 1:
                    for (e = r = 0; r < s; e = r += 1) b = a[n++], f = e < k ? 0 : m[c - k], m[c++] = (b + f) % 256;
                    break;
                case 2:
                    for (e = f = 0; f <
                        s; e = f += 1) b = a[n++], d = (e - e % k) / k, r = p && m[(p - 1) * s + d * k + e % k], m[c++] = (r + b) % 256;
                    break;
                case 3:
                    for (e = t = 0; t < s; e = t += 1) b = a[n++], d = (e - e % k) / k, f = e < k ? 0 : m[c - k], r = p && m[(p - 1) * s + d * k + e % k], m[c++] = (b + Math.floor((f + r) / 2)) % 256;
                    break;
                case 4:
                    for (e = t = 0; t < s; e = t += 1) b = a[n++], d = (e - e % k) / k, f = e < k ? 0 : m[c - k], 0 === p ? r = u = 0 : (r = m[(p - 1) * s + d * k + e % k], u = d && m[(p - 1) * s + (d - 1) * k + e % k]), h = f + r - u, e = Math.abs(h - f), d = Math.abs(h - r), h = Math.abs(h - u), f = e <= d && e <= h ? f : d <= h ? r : u, m[c++] = (b + f) % 256;
                    break;
                default:
                    throw Error("Invalid filter algorithm: " + a[n - 1]);
            }
            p++
        }
        return m
    },
    copyToImageData: function(a, b) {
        var c, d, e, f, g, h, k, m;
        d = this.colors;
        m = null;
        c = this.hasAlphaChannel;
        this.palette.length && (m = null != (e = this._decodedPalette) ? e : this._decodedPalette = this.decodePalette(), d = 4, c = !0);
        e = a.data || a;
        k = e.length;
        g = m || b;
        f = h = 0;
        if (1 === d)
            for (; f < k;) d = m ? 4 * b[f / 4] : h, h = g[d++], e[f++] = h, e[f++] = h, e[f++] = h, e[f++] = c ? g[d++] : 255, h = d;
        else
            for (; f < k;) d = m ? 4 * b[f / 4] : h, e[f++] = g[d++], e[f++] = g[d++], e[f++] = g[d++], e[f++] = c ? g[d++] : 255, h = d
    },
    decodePalette: function() {
        var a, b, c, d, e, f, g, h, k;
        c = this.palette;
        f = this.transparency.indexed || [];
        e = new Uint8Array((f.length || 0) + c.length);
        b = g = a = d = 0;
        for (h = c.length; g < h; b = g += 3) e[d++] = c[b], e[d++] = c[b + 1], e[d++] = c[b + 2], e[d++] = null != (k = f[a++]) ? k : 255;
        return e
    },
    render: function(a) {
        var b;
        a.width = this.width;
        a.height = this.height;
        a = a.getContext("2d");
        b = a.createImageData(this.width, this.height);
        this.copyToImageData(b, this.decodePixels());
        return a.putImageData(b, 0, 0)
    }
});
cc.tiffReader = {
    _littleEndian: !1,
    _tiffData: null,
    _fileDirectories: [],
    getUint8: function(a) {
        return this._tiffData[a]
    },
    getUint16: function(a) {
        return this._littleEndian ? this._tiffData[a + 1] << 8 | this._tiffData[a] : this._tiffData[a] << 8 | this._tiffData[a + 1]
    },
    getUint32: function(a) {
        var b = this._tiffData;
        return this._littleEndian ? b[a + 3] << 24 | b[a + 2] << 16 | b[a + 1] << 8 | b[a] : b[a] << 24 | b[a + 1] << 16 | b[a + 2] << 8 | b[a + 3]
    },
    checkLittleEndian: function() {
        var a = this.getUint16(0);
        if (18761 === a) this.littleEndian = !0;
        else if (19789 === a) this.littleEndian = !1;
        else throw console.log(a), TypeError("Invalid byte order value.");
        return this.littleEndian
    },
    hasTowel: function() {
        if (42 !== this.getUint16(2)) throw RangeError("You forgot your towel!");
        return !0
    },
    getFieldTypeName: function(a) {
        var b = this.fieldTypeNames;
        return a in b ? b[a] : null
    },
    getFieldTagName: function(a) {
        var b = this.fieldTagNames;
        if (a in b) return b[a];
        console.log("Unknown Field Tag:", a);
        return "Tag" + a
    },
    getFieldTypeLength: function(a) {
        return -1 !== ["BYTE", "ASCII", "SBYTE", "UNDEFINED"].indexOf(a) ? 1 : -1 !== ["SHORT",
            "SSHORT"
        ].indexOf(a) ? 2 : -1 !== ["LONG", "SLONG", "FLOAT"].indexOf(a) ? 4 : -1 !== ["RATIONAL", "SRATIONAL", "DOUBLE"].indexOf(a) ? 8 : null
    },
    getFieldValues: function(a, b, c, d) {
        a = [];
        var e = this.getFieldTypeLength(b);
        if (4 >= e * c) !1 === this.littleEndian ? a.push(d >>> 8 * (4 - e)) : a.push(d);
        else
            for (var f = 0; f < c; f++) {
                var g = e * f;
                8 <= e ? -1 !== ["RATIONAL", "SRATIONAL"].indexOf(b) ? (a.push(this.getUint32(d + g)), a.push(this.getUint32(d + g + 4))) : cc.log("Can't handle this field type or size") : a.push(this.getBytes(e, d + g))
            }
        "ASCII" === b && a.forEach(function(a,
            b, c) {
            c[b] = String.fromCharCode(a)
        });
        return a
    },
    getBytes: function(a, b) {
        if (0 >= a) cc.log("No bytes requested");
        else {
            if (1 >= a) return this.getUint8(b);
            if (2 >= a) return this.getUint16(b);
            if (3 >= a) return this.getUint32(b) >>> 8;
            if (4 >= a) return this.getUint32(b);
            cc.log("Too many bytes requested")
        }
    },
    getBits: function(a, b, c) {
        c = c || 0;
        b += Math.floor(c / 8);
        var d = c + a;
        a = 32 - a;
        var e, f;
        0 >= d ? console.log("No bits requested") : 8 >= d ? (e = 24 + c, f = this.getUint8(b)) : 16 >= d ? (e = 16 + c, f = this.getUint16(b)) : 32 >= d ? (e = c, f = this.getUint32(b)) : console.log("Too many bits requested");
        return {
            bits: f << e >>> a,
            byteOffset: b + Math.floor(d / 8),
            bitOffset: d % 8
        }
    },
    parseFileDirectory: function(a) {
        var b = this.getUint16(a),
            c = [];
        a += 2;
        for (var d = 0; d < b; a += 12, d++) {
            var e = this.getUint16(a),
                f = this.getUint16(a + 2),
                g = this.getUint32(a + 4),
                h = this.getUint32(a + 8),
                e = this.getFieldTagName(e),
                f = this.getFieldTypeName(f),
                g = this.getFieldValues(e, f, g, h);
            c[e] = {
                type: f,
                values: g
            }
        }
        this._fileDirectories.push(c);
        b = this.getUint32(a);
        0 !== b && this.parseFileDirectory(b)
    },
    clampColorSample: function(a, b) {
        var c = Math.pow(2, 8 - b);
        return Math.floor(a *
            c + (c - 1))
    },
    parseTIFF: function(a, b) {
        b = b || document.createElement("canvas");
        this._tiffData = a;
        this.canvas = b;
        this.checkLittleEndian();
        if (this.hasTowel()) {
            var c = this.getUint32(4);
            this._fileDirectories.length = 0;
            this.parseFileDirectory(c);
            var d = this._fileDirectories[0],
                c = d.ImageWidth.values[0],
                e = d.ImageLength.values[0];
            this.canvas.width = c;
            this.canvas.height = e;
            var f = [],
                g = d.Compression ? d.Compression.values[0] : 1,
                h = d.SamplesPerPixel.values[0],
                k = [],
                m = 0,
                n = !1;
            d.BitsPerSample.values.forEach(function(a, b, c) {
                k[b] = {
                    bitsPerSample: a,
                    hasBytesPerSample: !1,
                    bytesPerSample: void 0
                };
                0 === a % 8 && (k[b].hasBytesPerSample = !0, k[b].bytesPerSample = a / 8);
                m += a
            }, this);
            if (0 === m % 8) var n = !0,
                p = m / 8;
            var s = d.StripOffsets.values,
                r = s.length;
            if (d.StripByteCounts) var u = d.StripByteCounts.values;
            else if (cc.log("Missing StripByteCounts!"), 1 === r) u = [Math.ceil(c * e * m / 8)];
            else throw Error("Cannot recover from missing StripByteCounts");
            for (var t = 0; t < r; t++) {
                var v = s[t];
                f[t] = [];
                for (var w = u[t], A = 0, C = 0, E = 1, x = !0, B = [], z = 0, D = 0, G = 0; A < w; A += E) switch (g) {
                    case 1:
                        E = 0;
                        for (B = []; E < h; E++)
                            if (k[E].hasBytesPerSample) B.push(this.getBytes(k[E].bytesPerSample,
                                v + A + k[E].bytesPerSample * E));
                            else {
                                var F = this.getBits(k[E].bitsPerSample, v + A, C);
                                B.push(F.bits);
                                A = F.byteOffset - v;
                                C = F.bitOffset;
                                throw RangeError("Cannot handle sub-byte bits per sample");
                            }
                        f[t].push(B);
                        if (n) E = p;
                        else throw E = 0, RangeError("Cannot handle sub-byte bits per pixel");
                        break;
                    case 32773:
                        if (x) {
                            var x = !1,
                                y = 1,
                                J = 1,
                                E = this.getInt8(v + A);
                            0 <= E && 127 >= E ? y = E + 1 : -127 <= E && -1 >= E ? J = -E + 1 : x = !0
                        } else {
                            for (var K = this.getUint8(v + A), E = 0; E < J; E++) {
                                if (k[D].hasBytesPerSample) G = G << 8 * z | K, z++, z === k[D].bytesPerSample && (B.push(G),
                                    G = z = 0, D++);
                                else throw RangeError("Cannot handle sub-byte bits per sample");
                                D === h && (f[t].push(B), B = [], D = 0)
                            }
                            y--;
                            0 === y && (x = !0)
                        }
                        E = 1
                }
            }
            if (b.getContext) {
                p = this.canvas.getContext("2d");
                p.fillStyle = "rgba(255, 255, 255, 0)";
                t = d.RowsPerStrip ? d.RowsPerStrip.values[0] : e;
                v = f.length;
                e %= t;
                e = 0 === e ? t : e;
                A = t;
                g = 0;
                B = d.PhotometricInterpretation.values[0];
                y = [];
                J = 0;
                d.ExtraSamples && (y = d.ExtraSamples.values, J = y.length);
                if (d.ColorMap) var F = d.ColorMap.values,
                    H = Math.pow(2, k[0].bitsPerSample);
                for (t = 0; t < v; t++) {
                    t + 1 === v && (A = e);
                    d =
                        f[t].length;
                    g *= t;
                    for (n = h = 0; h < A, n < d; h++)
                        for (s = 0; s < c; s++, n++) {
                            u = f[t][n];
                            x = C = w = 0;
                            r = 1;
                            if (0 < J)
                                for (w = 0; w < J; w++)
                                    if (1 === y[w] || 2 === y[w]) {
                                        r = u[3 + w] / 256;
                                        break
                                    }
                            switch (B) {
                                case 0:
                                    if (k[0].hasBytesPerSample) var L = Math.pow(16, 2 * k[0].bytesPerSample);
                                    u.forEach(function(a, b, c) {
                                        c[b] = L - a
                                    });
                                case 1:
                                    w = C = x = this.clampColorSample(u[0], k[0].bitsPerSample);
                                    break;
                                case 2:
                                    w = this.clampColorSample(u[0], k[0].bitsPerSample);
                                    C = this.clampColorSample(u[1], k[1].bitsPerSample);
                                    x = this.clampColorSample(u[2], k[2].bitsPerSample);
                                    break;
                                case 3:
                                    if (void 0 ===
                                        F) throw Error("Palette image missing color map");
                                    u = u[0];
                                    w = this.clampColorSample(F[u], 16);
                                    C = this.clampColorSample(F[H + u], 16);
                                    x = this.clampColorSample(F[2 * H + u], 16);
                                    break;
                                default:
                                    throw RangeError("Unknown Photometric Interpretation:", B);
                            }
                            p.fillStyle = "rgba(" + w + ", " + C + ", " + x + ", " + r + ")";
                            p.fillRect(s, g + h, 1, 1)
                        }
                    g = A
                }
            }
            return this.canvas
        }
    },
    fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
    },
    fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
    }
};
cc.Particle = function(a, b, c, d, e, f, g, h, k, m, n, p) {
    this.pos = a ? a : cc.p(0, 0);
    this.startPos = b ? b : cc.p(0, 0);
    this.color = c ? c : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    this.deltaColor = d ? d : {
        r: 0,
        g: 0,
        b: 0,
        a: 255
    };
    this.size = e || 0;
    this.deltaSize = f || 0;
    this.rotation = g || 0;
    this.deltaRotation = h || 0;
    this.timeToLive = k || 0;
    this.atlasIndex = m || 0;
    this.modeA = n ? n : new cc.Particle.ModeA;
    this.modeB = p ? p : new cc.Particle.ModeB;
    this.isChangeColor = !1;
    this.drawPos = cc.p(0, 0)
};
cc.Particle.ModeA = function(a, b, c) {
    this.dir = a ? a : cc.p(0, 0);
    this.radialAccel = b || 0;
    this.tangentialAccel = c || 0
};
cc.Particle.ModeB = function(a, b, c, d) {
    this.angle = a || 0;
    this.degreesPerSecond = b || 0;
    this.radius = c || 0;
    this.deltaRadius = d || 0
};
cc.Particle.TemporaryPoints = [cc.p(), cc.p(), cc.p(), cc.p()];
cc.ParticleSystem = cc.Node.extend({
    _className: "ParticleSystem",
    _plistFile: "",
    _elapsed: 0,
    _dontTint: !1,
    modeA: null,
    modeB: null,
    _pointZeroForParticle: cc.p(0, 0),
    _particles: null,
    _emitCounter: 0,
    _particleIdx: 0,
    _batchNode: null,
    atlasIndex: 0,
    _transformSystemDirty: !1,
    _allocatedParticles: 0,
    _isActive: !1,
    particleCount: 0,
    duration: 0,
    _sourcePosition: null,
    _posVar: null,
    life: 0,
    lifeVar: 0,
    angle: 0,
    angleVar: 0,
    startSize: 0,
    startSizeVar: 0,
    endSize: 0,
    endSizeVar: 0,
    _startColor: null,
    _startColorVar: null,
    _endColor: null,
    _endColorVar: null,
    startSpin: 0,
    startSpinVar: 0,
    endSpin: 0,
    endSpinVar: 0,
    emissionRate: 0,
    _totalParticles: 0,
    _texture: null,
    _blendFunc: null,
    _opacityModifyRGB: !1,
    positionType: null,
    autoRemoveOnFinish: !1,
    emitterMode: 0,
    _textureLoaded: null,
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this.modeA = new cc.ParticleSystem.ModeA;
        this.modeB = new cc.ParticleSystem.ModeB;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        this._particles = [];
        this._sourcePosition = cc.p(0, 0);
        this._posVar = cc.p(0,
            0);
        this._startColor = cc.color(255, 255, 255, 255);
        this._startColorVar = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._endColorVar = cc.color(255, 255, 255, 255);
        this._plistFile = "";
        this._elapsed = 0;
        this._dontTint = !1;
        this._pointZeroForParticle = cc.p(0, 0);
        this._particleIdx = this._emitCounter = 0;
        this._batchNode = null;
        this.atlasIndex = 0;
        this._transformSystemDirty = !1;
        this._allocatedParticles = 0;
        this._isActive = !1;
        this._totalParticles = this.emissionRate = this.endSpinVar = this.endSpin = this.startSpinVar =
            this.startSpin = this.endSizeVar = this.endSize = this.startSizeVar = this.startSize = this.angleVar = this.angle = this.lifeVar = this.life = this.duration = this.particleCount = 0;
        this._texture = null;
        this._opacityModifyRGB = !1;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.autoRemoveOnFinish = !1;
        this._textureLoaded = !0;
        !a || cc.isNumber(a) ? (a = a || 100, this.setDrawMode(cc.ParticleSystem.TEXTURE_MODE), this.initWithTotalParticles(a)) : cc.isString(a) ? this.initWithFile(a) : cc.isObject(a) && this.initWithDictionary(a, "")
    },
    _createRenderCmd: function() {
        return cc._renderType ===
            cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleSystem.CanvasRenderCmd(this) : new cc.ParticleSystem.WebGLRenderCmd(this)
    },
    ignoreColor: function(a) {
        this._dontTint = a
    },
    initTexCoordsWithRect: function(a) {
        this._renderCmd.initTexCoordsWithRect(a)
    },
    getBatchNode: function() {
        return this._batchNode
    },
    setBatchNode: function(a) {
        this._renderCmd.setBatchNode(a)
    },
    getAtlasIndex: function() {
        return this.atlasIndex
    },
    setAtlasIndex: function(a) {
        this.atlasIndex = a
    },
    getDrawMode: function() {
        return this._renderCmd.getDrawMode()
    },
    setDrawMode: function(a) {
        this._renderCmd.setDrawMode(a)
    },
    getShapeType: function() {
        return this._renderCmd.getShapeType()
    },
    setShapeType: function(a) {
        this._renderCmd.setShapeType(a)
    },
    isActive: function() {
        return this._isActive
    },
    getParticleCount: function() {
        return this.particleCount
    },
    setParticleCount: function(a) {
        this.particleCount = a
    },
    getDuration: function() {
        return this.duration
    },
    setDuration: function(a) {
        this.duration = a
    },
    getSourcePosition: function() {
        return {
            x: this._sourcePosition.x,
            y: this._sourcePosition.y
        }
    },
    setSourcePosition: function(a) {
        this._sourcePosition = a
    },
    getPosVar: function() {
        return {
            x: this._posVar.x,
            y: this._posVar.y
        }
    },
    setPosVar: function(a) {
        this._posVar = a
    },
    getLife: function() {
        return this.life
    },
    setLife: function(a) {
        this.life = a
    },
    getLifeVar: function() {
        return this.lifeVar
    },
    setLifeVar: function(a) {
        this.lifeVar = a
    },
    getAngle: function() {
        return this.angle
    },
    setAngle: function(a) {
        this.angle = a
    },
    getAngleVar: function() {
        return this.angleVar
    },
    setAngleVar: function(a) {
        this.angleVar = a
    },
    getGravity: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getGravity() : Particle Mode should be Gravity");
        var a = this.modeA.gravity;
        return cc.p(a.x, a.y)
    },
    setGravity: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setGravity() : Particle Mode should be Gravity");
        this.modeA.gravity = a
    },
    getSpeed: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeed() : Particle Mode should be Gravity");
        return this.modeA.speed
    },
    setSpeed: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeed() : Particle Mode should be Gravity");
        this.modeA.speed = a
    },
    getSpeedVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getSpeedVar() : Particle Mode should be Gravity");
        return this.modeA.speedVar
    },
    setSpeedVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setSpeedVar() : Particle Mode should be Gravity");
        this.modeA.speedVar = a
    },
    getTangentialAccel: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccel() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccel
    },
    setTangentialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setTangentialAccel() : Particle Mode should be Gravity");
        this.modeA.tangentialAccel = a
    },
    getTangentialAccelVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getTangentialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.tangentialAccelVar
    },
    setTangentialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY &&
            cc.log("cc.ParticleBatchNode.setTangentialAccelVar() : Particle Mode should be Gravity");
        this.modeA.tangentialAccelVar = a
    },
    getRadialAccel: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccel() : Particle Mode should be Gravity");
        return this.modeA.radialAccel
    },
    setRadialAccel: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccel() : Particle Mode should be Gravity");
        this.modeA.radialAccel = a
    },
    getRadialAccelVar: function() {
        this.emitterMode !==
            cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRadialAccelVar() : Particle Mode should be Gravity");
        return this.modeA.radialAccelVar
    },
    setRadialAccelVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRadialAccelVar() : Particle Mode should be Gravity");
        this.modeA.radialAccelVar = a
    },
    getRotationIsDir: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.getRotationIsDir() : Particle Mode should be Gravity");
        return this.modeA.rotationIsDir
    },
    setRotationIsDir: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_GRAVITY && cc.log("cc.ParticleBatchNode.setRotationIsDir() : Particle Mode should be Gravity");
        this.modeA.rotationIsDir = a
    },
    getStartRadius: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadius() : Particle Mode should be Radius");
        return this.modeB.startRadius
    },
    setStartRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadius() : Particle Mode should be Radius");
        this.modeB.startRadius = a
    },
    getStartRadiusVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getStartRadiusVar() : Particle Mode should be Radius");
        return this.modeB.startRadiusVar
    },
    setStartRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setStartRadiusVar() : Particle Mode should be Radius");
        this.modeB.startRadiusVar = a
    },
    getEndRadius: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadius() : Particle Mode should be Radius");
        return this.modeB.endRadius
    },
    setEndRadius: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadius() : Particle Mode should be Radius");
        this.modeB.endRadius = a
    },
    getEndRadiusVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getEndRadiusVar() : Particle Mode should be Radius");
        return this.modeB.endRadiusVar
    },
    setEndRadiusVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setEndRadiusVar() : Particle Mode should be Radius");
        this.modeB.endRadiusVar = a
    },
    getRotatePerSecond: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.getRotatePerSecond() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecond
    },
    setRotatePerSecond: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecond() : Particle Mode should be Radius");
        this.modeB.rotatePerSecond = a
    },
    getRotatePerSecondVar: function() {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS &&
            cc.log("cc.ParticleBatchNode.getRotatePerSecondVar() : Particle Mode should be Radius");
        return this.modeB.rotatePerSecondVar
    },
    setRotatePerSecondVar: function(a) {
        this.emitterMode !== cc.ParticleSystem.MODE_RADIUS && cc.log("cc.ParticleBatchNode.setRotatePerSecondVar() : Particle Mode should be Radius");
        this.modeB.rotatePerSecondVar = a
    },
    setScale: function(a, b) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScale.call(this, a, b)
    },
    setRotation: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setRotation.call(this,
            a)
    },
    setScaleX: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function(a) {
        this._transformSystemDirty = !0;
        cc.Node.prototype.setScaleY.call(this, a)
    },
    getStartSize: function() {
        return this.startSize
    },
    setStartSize: function(a) {
        this.startSize = a
    },
    getStartSizeVar: function() {
        return this.startSizeVar
    },
    setStartSizeVar: function(a) {
        this.startSizeVar = a
    },
    getEndSize: function() {
        return this.endSize
    },
    setEndSize: function(a) {
        this.endSize = a
    },
    getEndSizeVar: function() {
        return this.endSizeVar
    },
    setEndSizeVar: function(a) {
        this.endSizeVar = a
    },
    getStartColor: function() {
        return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a)
    },
    setStartColor: function(a) {
        this._startColor = cc.color(a)
    },
    getStartColorVar: function() {
        return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a)
    },
    setStartColorVar: function(a) {
        this._startColorVar = cc.color(a)
    },
    getEndColor: function() {
        return cc.color(this._endColor.r, this._endColor.g, this._endColor.b,
            this._endColor.a)
    },
    setEndColor: function(a) {
        this._endColor = cc.color(a)
    },
    getEndColorVar: function() {
        return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a)
    },
    setEndColorVar: function(a) {
        this._endColorVar = cc.color(a)
    },
    getStartSpin: function() {
        return this.startSpin
    },
    setStartSpin: function(a) {
        this.startSpin = a
    },
    getStartSpinVar: function() {
        return this.startSpinVar
    },
    setStartSpinVar: function(a) {
        this.startSpinVar = a
    },
    getEndSpin: function() {
        return this.endSpin
    },
    setEndSpin: function(a) {
        this.endSpin =
            a
    },
    getEndSpinVar: function() {
        return this.endSpinVar
    },
    setEndSpinVar: function(a) {
        this.endSpinVar = a
    },
    getEmissionRate: function() {
        return this.emissionRate
    },
    setEmissionRate: function(a) {
        this.emissionRate = a
    },
    getTotalParticles: function() {
        return this._totalParticles
    },
    setTotalParticles: function(a) {
        this._renderCmd.setTotalParticles(a)
    },
    getTexture: function() {
        return this._texture
    },
    setTexture: function(a) {
        a && (a.isLoaded() ? this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height)) : (this._textureLoaded = !1, a.addEventListener("load",
            function(a) {
                this._textureLoaded = !0;
                this.setTextureWithRect(a, cc.rect(0, 0, a.width, a.height))
            }, this)))
    },
    getBlendFunc: function() {
        return this._blendFunc
    },
    setBlendFunc: function(a, b) {
        if (void 0 === b) this._blendFunc !== a && (this._blendFunc = a, this._updateBlendFunc());
        else if (this._blendFunc.src !== a || this._blendFunc.dst !== b) this._blendFunc = {
            src: a,
            dst: b
        }, this._updateBlendFunc()
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    setOpacityModifyRGB: function(a) {
        this._opacityModifyRGB = a
    },
    isBlendAdditive: function() {
        return this._blendFunc.src ===
            cc.SRC_ALPHA && this._blendFunc.dst === cc.ONE || this._blendFunc.src === cc.ONE && this._blendFunc.dst === cc.ONE
    },
    setBlendAdditive: function(a) {
        var b = this._blendFunc;
        a ? (b.src = cc.SRC_ALPHA, b.dst = cc.ONE) : this._renderCmd._setBlendAdditive()
    },
    getPositionType: function() {
        return this.positionType
    },
    setPositionType: function(a) {
        this.positionType = a
    },
    isAutoRemoveOnFinish: function() {
        return this.autoRemoveOnFinish
    },
    setAutoRemoveOnFinish: function(a) {
        this.autoRemoveOnFinish = a
    },
    getEmitterMode: function() {
        return this.emitterMode
    },
    setEmitterMode: function(a) {
        this.emitterMode = a
    },
    init: function() {
        return this.initWithTotalParticles(150)
    },
    initWithFile: function(a) {
        this._plistFile = a;
        a = cc.loader.getRes(a);
        return a ? this.initWithDictionary(a, "") : (cc.log("cc.ParticleSystem.initWithFile(): Particles: file not found"), !1)
    },
    getBoundingBoxToWorld: function() {
        return cc.rect(0, 0, cc._canvas.width, cc._canvas.height)
    },
    initWithDictionary: function(a, b) {
        var c = !1,
            d = null,
            d = this._valueForKey,
            e = parseInt(d("maxParticles", a));
        if (this.initWithTotalParticles(e)) {
            this.angle =
                parseFloat(d("angle", a));
            this.angleVar = parseFloat(d("angleVariance", a));
            this.duration = parseFloat(d("duration", a));
            this._blendFunc.src = parseInt(d("blendFuncSource", a));
            this._blendFunc.dst = parseInt(d("blendFuncDestination", a));
            c = this._startColor;
            c.r = 255 * parseFloat(d("startColorRed", a));
            c.g = 255 * parseFloat(d("startColorGreen", a));
            c.b = 255 * parseFloat(d("startColorBlue", a));
            c.a = 255 * parseFloat(d("startColorAlpha", a));
            c = this._startColorVar;
            c.r = 255 * parseFloat(d("startColorVarianceRed", a));
            c.g = 255 * parseFloat(d("startColorVarianceGreen",
                a));
            c.b = 255 * parseFloat(d("startColorVarianceBlue", a));
            c.a = 255 * parseFloat(d("startColorVarianceAlpha", a));
            c = this._endColor;
            c.r = 255 * parseFloat(d("finishColorRed", a));
            c.g = 255 * parseFloat(d("finishColorGreen", a));
            c.b = 255 * parseFloat(d("finishColorBlue", a));
            c.a = 255 * parseFloat(d("finishColorAlpha", a));
            c = this._endColorVar;
            c.r = 255 * parseFloat(d("finishColorVarianceRed", a));
            c.g = 255 * parseFloat(d("finishColorVarianceGreen", a));
            c.b = 255 * parseFloat(d("finishColorVarianceBlue", a));
            c.a = 255 * parseFloat(d("finishColorVarianceAlpha",
                a));
            this.startSize = parseFloat(d("startParticleSize", a));
            this.startSizeVar = parseFloat(d("startParticleSizeVariance", a));
            this.endSize = parseFloat(d("finishParticleSize", a));
            this.endSizeVar = parseFloat(d("finishParticleSizeVariance", a));
            this.setPosition(parseFloat(d("sourcePositionx", a)), parseFloat(d("sourcePositiony", a)));
            this._posVar.x = parseFloat(d("sourcePositionVariancex", a));
            this._posVar.y = parseFloat(d("sourcePositionVariancey", a));
            this.startSpin = parseFloat(d("rotationStart", a));
            this.startSpinVar =
                parseFloat(d("rotationStartVariance", a));
            this.endSpin = parseFloat(d("rotationEnd", a));
            this.endSpinVar = parseFloat(d("rotationEndVariance", a));
            this.emitterMode = parseInt(d("emitterType", a));
            if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) c = this.modeA, c.gravity.x = parseFloat(d("gravityx", a)), c.gravity.y = parseFloat(d("gravityy", a)), c.speed = parseFloat(d("speed", a)), c.speedVar = parseFloat(d("speedVariance", a)), e = d("radialAcceleration", a), c.radialAccel = e ? parseFloat(e) : 0, e = d("radialAccelVariance", a), c.radialAccelVar =
                e ? parseFloat(e) : 0, e = d("tangentialAcceleration", a), c.tangentialAccel = e ? parseFloat(e) : 0, e = d("tangentialAccelVariance", a), c.tangentialAccelVar = e ? parseFloat(e) : 0, e = d("rotationIsDir", a).toLowerCase(), c.rotationIsDir = null != e && ("true" === e || "1" === e);
            else if (this.emitterMode === cc.ParticleSystem.MODE_RADIUS) c = this.modeB, c.startRadius = parseFloat(d("maxRadius", a)), c.startRadiusVar = parseFloat(d("maxRadiusVariance", a)), c.endRadius = parseFloat(d("minRadius", a)), c.endRadiusVar = 0, c.rotatePerSecond = parseFloat(d("rotatePerSecond",
                a)), c.rotatePerSecondVar = parseFloat(d("rotatePerSecondVariance", a));
            else return cc.log("cc.ParticleSystem.initWithDictionary(): Invalid emitterType in config file"), !1;
            this.life = parseFloat(d("particleLifespan", a));
            this.lifeVar = parseFloat(d("particleLifespanVariance", a));
            this.emissionRate = this._totalParticles / this.life;
            if (!this._batchNode)
                if (this._opacityModifyRGB = !1, c = d("textureFileName", a), c = cc.path.changeBasename(this._plistFile, c), e = cc.textureCache.getTextureForKey(c)) this.setTexture(e);
                else if ((d =
                    d("textureImageData", a)) && 0 !== d.length) {
                d = cc.unzipBase64AsArray(d, 1);
                if (!d) return cc.log("cc.ParticleSystem: error decoding or ungzipping textureImageData"), !1;
                e = cc.getImageFormatByData(d);
                if (e !== cc.FMT_TIFF && e !== cc.FMT_PNG) return cc.log("cc.ParticleSystem: unknown image format with Data"), !1;
                var f = document.createElement("canvas");
                e === cc.FMT_PNG ? (new cc.PNGReader(d)).render(f) : cc.tiffReader.parseTIFF(d, f);
                cc.textureCache.cacheImage(c, f);
                (d = cc.textureCache.getTextureForKey(c)) || cc.log("cc.ParticleSystem.initWithDictionary() : error loading the texture");
                this.setTexture(d)
            } else {
                e = cc.textureCache.addImage(c);
                if (!e) return !1;
                this.setTexture(e)
            }
            c = !0
        }
        return c
    },
    initWithTotalParticles: function(a) {
        this._totalParticles = a;
        var b, c = this._particles;
        for (b = c.length = 0; b < a; b++) c[b] = new cc.Particle;
        if (!c) return cc.log("Particle system: not enough memory"), !1;
        this._allocatedParticles = a;
        if (this._batchNode)
            for (b = 0; b < this._totalParticles; b++) c[b].atlasIndex = b;
        this._isActive = !0;
        this._blendFunc.src = cc.BLEND_SRC;
        this._blendFunc.dst = cc.BLEND_DST;
        this.positionType = cc.ParticleSystem.TYPE_FREE;
        this.emitterMode = cc.ParticleSystem.MODE_GRAVITY;
        this._transformSystemDirty = this.autoRemoveOnFinish = !1;
        this.scheduleUpdateWithPriority(1);
        this._renderCmd._initWithTotalParticles(a);
        return !0
    },
    destroyParticleSystem: function() {
        this.unscheduleUpdate()
    },
    addParticle: function() {
        if (this.isFull()) return !1;
        var a = this._renderCmd.addParticle();
        this.initParticle(a);
        ++this.particleCount;
        return !0
    },
    initParticle: function(a) {
        var b = cc.randomMinus1To1;
        a.timeToLive = this.life + this.lifeVar * b();
        a.timeToLive = Math.max(0, a.timeToLive);
        a.pos.x = this._sourcePosition.x + this._posVar.x * b();
        a.pos.y = this._sourcePosition.y + this._posVar.y * b();
        var c, d;
        c = this._startColor;
        var e = this._startColorVar,
            f = this._endColor;
        d = this._endColorVar;
        c = {
            r: cc.clampf(c.r + e.r * b(), 0, 255),
            g: cc.clampf(c.g + e.g * b(), 0, 255),
            b: cc.clampf(c.b + e.b * b(), 0, 255),
            a: cc.clampf(c.a + e.a * b(), 0, 255)
        };
        d = {
            r: cc.clampf(f.r + d.r * b(), 0, 255),
            g: cc.clampf(f.g + d.g * b(), 0, 255),
            b: cc.clampf(f.b + d.b * b(), 0, 255),
            a: cc.clampf(f.a + d.a * b(), 0, 255)
        };
        a.color = c;
        e = a.deltaColor;
        f = a.timeToLive;
        e.r = (d.r - c.r) / f;
        e.g = (d.g - c.g) / f;
        e.b = (d.b - c.b) / f;
        e.a = (d.a - c.a) / f;
        c = this.startSize + this.startSizeVar * b();
        c = Math.max(0, c);
        a.size = c;
        this.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE ? a.deltaSize = 0 : (d = this.endSize + this.endSizeVar * b(), d = Math.max(0, d), a.deltaSize = (d - c) / f);
        c = this.startSpin + this.startSpinVar * b();
        d = this.endSpin + this.endSpinVar * b();
        a.rotation = c;
        a.deltaRotation = (d - c) / f;
        this.positionType === cc.ParticleSystem.TYPE_FREE ? a.startPos = this.convertToWorldSpace(this._pointZeroForParticle) : this.positionType ===
            cc.ParticleSystem.TYPE_RELATIVE && (a.startPos.x = this._position.x, a.startPos.y = this._position.y);
        c = cc.degreesToRadians(this.angle + this.angleVar * b());
        if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) f = this.modeA, d = a.modeA, e = f.speed + f.speedVar * b(), d.dir.x = Math.cos(c), d.dir.y = Math.sin(c), cc.pMultIn(d.dir, e), d.radialAccel = f.radialAccel + f.radialAccelVar * b(), d.tangentialAccel = f.tangentialAccel + f.tangentialAccelVar * b(), f.rotationIsDir && (a.rotation = -cc.radiansToDegrees(cc.pToAngle(d.dir)));
        else {
            d = this.modeB;
            a = a.modeB;
            var e = d.startRadius + d.startRadiusVar * b(),
                g = d.endRadius + d.endRadiusVar * b();
            a.radius = e;
            a.deltaRadius = d.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (g - e) / f;
            a.angle = c;
            a.degreesPerSecond = cc.degreesToRadians(d.rotatePerSecond + d.rotatePerSecondVar * b())
        }
    },
    stopSystem: function() {
        this._isActive = !1;
        this._elapsed = this.duration;
        this._emitCounter = 0
    },
    resetSystem: function() {
        this._isActive = !0;
        this._elapsed = 0;
        var a = this._particles;
        for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) a[this._particleIdx].timeToLive =
            0
    },
    isFull: function() {
        return this.particleCount >= this._totalParticles
    },
    updateQuadWithParticle: function(a, b) {
        this._renderCmd.updateQuadWithParticle(a, b)
    },
    postStep: function() {
        this._renderCmd.postStep()
    },
    update: function(a) {
        if (this._isActive && this.emissionRate) {
            var b = 1 / this.emissionRate;
            this.particleCount < this._totalParticles && (this._emitCounter += a);
            for (; this.particleCount < this._totalParticles && this._emitCounter > b;) this.addParticle(), this._emitCounter -= b;
            this._elapsed += a; - 1 !== this.duration && this.duration <
                this._elapsed && this.stopSystem()
        }
        this._particleIdx = 0;
        b = cc.Particle.TemporaryPoints[0];
        this.positionType === cc.ParticleSystem.TYPE_FREE ? cc.pIn(b, this.convertToWorldSpace(this._pointZeroForParticle)) : this.positionType === cc.ParticleSystem.TYPE_RELATIVE && (b.x = this._position.x, b.y = this._position.y);
        if (this._visible) {
            for (var c = cc.Particle.TemporaryPoints[1], d = cc.Particle.TemporaryPoints[2], e = cc.Particle.TemporaryPoints[3], f = this._particles; this._particleIdx < this.particleCount;) {
                cc.pZeroIn(c);
                cc.pZeroIn(d);
                cc.pZeroIn(e);
                var g = f[this._particleIdx];
                g.timeToLive -= a;
                if (0 < g.timeToLive) {
                    if (this.emitterMode === cc.ParticleSystem.MODE_GRAVITY) {
                        var h = e,
                            k = c,
                            m = d;
                        g.pos.x || g.pos.y ? (cc.pIn(k, g.pos), cc.pNormalizeIn(k)) : cc.pZeroIn(k);
                        cc.pIn(m, k);
                        cc.pMultIn(k, g.modeA.radialAccel);
                        var n = m.x;
                        m.x = -m.y;
                        m.y = n;
                        cc.pMultIn(m, g.modeA.tangentialAccel);
                        cc.pIn(h, k);
                        cc.pAddIn(h, m);
                        cc.pAddIn(h, this.modeA.gravity);
                        cc.pMultIn(h, a);
                        cc.pAddIn(g.modeA.dir, h);
                        cc.pIn(h, g.modeA.dir);
                        cc.pMultIn(h, a);
                        cc.pAddIn(g.pos, h)
                    } else h = g.modeB, h.angle +=
                        h.degreesPerSecond * a, h.radius += h.deltaRadius * a, g.pos.x = -Math.cos(h.angle) * h.radius, g.pos.y = -Math.sin(h.angle) * h.radius;
                    this._renderCmd._updateDeltaColor(g, a);
                    g.size += g.deltaSize * a;
                    g.size = Math.max(0, g.size);
                    g.rotation += g.deltaRotation * a;
                    h = c;
                    this.positionType === cc.ParticleSystem.TYPE_FREE || this.positionType === cc.ParticleSystem.TYPE_RELATIVE ? (k = d, cc.pIn(k, b), cc.pSubIn(k, g.startPos), cc.pIn(h, g.pos), cc.pSubIn(h, k)) : cc.pIn(h, g.pos);
                    this._batchNode && (h.x += this._position.x, h.y += this._position.y);
                    this._renderCmd.updateParticlePosition(g,
                        h);
                    ++this._particleIdx
                } else if (g = g.atlasIndex, this._particleIdx !== this.particleCount - 1 && (h = f[this._particleIdx], f[this._particleIdx] = f[this.particleCount - 1], f[this.particleCount - 1] = h), this._batchNode && (this._batchNode.disableParticle(this.atlasIndex + g), f[this.particleCount - 1].atlasIndex = g), --this.particleCount, 0 === this.particleCount && this.autoRemoveOnFinish) {
                    this.unscheduleUpdate();
                    this._parent.removeChild(this, !0);
                    return
                }
            }
            this._transformSystemDirty = !1
        }
        this._batchNode || this.postStep()
    },
    updateWithNoTime: function() {
        this.update(0)
    },
    _valueForKey: function(a, b) {
        if (b) {
            var c = b[a];
            return null != c ? c : ""
        }
        return ""
    },
    _updateBlendFunc: function() {
        if (this._batchNode) cc.log("Can't change blending functions when the particle is being batched");
        else {
            var a = this._texture;
            if (a && a instanceof cc.Texture2D) {
                this._opacityModifyRGB = !1;
                var b = this._blendFunc;
                b.src === cc.BLEND_SRC && b.dst === cc.BLEND_DST && (a.hasPremultipliedAlpha() ? this._opacityModifyRGB = !0 : (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA))
            }
        }
    },
    clone: function() {
        var a = new cc.ParticleSystem;
        if (a.initWithTotalParticles(this.getTotalParticles())) {
            a.setAngle(this.getAngle());
            a.setAngleVar(this.getAngleVar());
            a.setDuration(this.getDuration());
            var b = this.getBlendFunc();
            a.setBlendFunc(b.src, b.dst);
            a.setStartColor(this.getStartColor());
            a.setStartColorVar(this.getStartColorVar());
            a.setEndColor(this.getEndColor());
            a.setEndColorVar(this.getEndColorVar());
            a.setStartSize(this.getStartSize());
            a.setStartSizeVar(this.getStartSizeVar());
            a.setEndSize(this.getEndSize());
            a.setEndSizeVar(this.getEndSizeVar());
            a.setPosition(cc.p(this.x, this.y));
            a.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
            a.setPositionType(this.getPositionType());
            a.setStartSpin(this.getStartSpin() || 0);
            a.setStartSpinVar(this.getStartSpinVar() || 0);
            a.setEndSpin(this.getEndSpin() || 0);
            a.setEndSpinVar(this.getEndSpinVar() || 0);
            a.setEmitterMode(this.getEmitterMode());
            this.getEmitterMode() === cc.ParticleSystem.MODE_GRAVITY ? (b = this.getGravity(), a.setGravity(cc.p(b.x, b.y)), a.setSpeed(this.getSpeed()), a.setSpeedVar(this.getSpeedVar()), a.setRadialAccel(this.getRadialAccel()), a.setRadialAccelVar(this.getRadialAccelVar()), a.setTangentialAccel(this.getTangentialAccel()),
                a.setTangentialAccelVar(this.getTangentialAccelVar())) : this.getEmitterMode() === cc.ParticleSystem.MODE_RADIUS && (a.setStartRadius(this.getStartRadius()), a.setStartRadiusVar(this.getStartRadiusVar()), a.setEndRadius(this.getEndRadius()), a.setEndRadiusVar(this.getEndRadiusVar()), a.setRotatePerSecond(this.getRotatePerSecond()), a.setRotatePerSecondVar(this.getRotatePerSecondVar()));
            a.setLife(this.getLife());
            a.setLifeVar(this.getLifeVar());
            a.setEmissionRate(this.getEmissionRate());
            if (!this.getBatchNode() &&
                (a.setOpacityModifyRGB(this.isOpacityModifyRGB()), b = this.getTexture())) {
                var c = b.getContentSize();
                a.setTextureWithRect(b, cc.rect(0, 0, c.width, c.height))
            }
        }
        return a
    },
    setDisplayFrame: function(a) {
        if (a) {
            var b = a.getOffsetInPixels();
            0 === b.x && 0 === b.y || cc.log("cc.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets");
            a = a.getTexture();
            this._texture !== a && this.setTexture(a)
        }
    },
    setTextureWithRect: function(a, b) {
        this._texture !== a && (this._texture = a, this._updateBlendFunc());
        this.initTexCoordsWithRect(b)
    },
    listenBackToForeground: function(a) {}
});
_p = cc.ParticleSystem.prototype;
cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode);
cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType);
cc.defineGetterSetter(_p, "active", _p.isActive);
cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleSystem.create = function(a) {
    return new cc.ParticleSystem(a)
};
cc.ParticleSystem.createWithTotalParticles = cc.ParticleSystem.create;
cc.ParticleSystem.ModeA = function(a, b, c, d, e, f, g, h) {
    this.gravity = a ? a : cc.p(0, 0);
    this.speed = b || 0;
    this.speedVar = c || 0;
    this.tangentialAccel = d || 0;
    this.tangentialAccelVar = e || 0;
    this.radialAccel = f || 0;
    this.radialAccelVar = g || 0;
    this.rotationIsDir = h || !1
};
cc.ParticleSystem.ModeB = function(a, b, c, d, e, f) {
    this.startRadius = a || 0;
    this.startRadiusVar = b || 0;
    this.endRadius = c || 0;
    this.endRadiusVar = d || 0;
    this.rotatePerSecond = e || 0;
    this.rotatePerSecondVar = f || 0
};
cc.ParticleSystem.SHAPE_MODE = 0;
cc.ParticleSystem.TEXTURE_MODE = 1;
cc.ParticleSystem.STAR_SHAPE = 0;
cc.ParticleSystem.BALL_SHAPE = 1;
cc.ParticleSystem.DURATION_INFINITY = -1;
cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
cc.ParticleSystem.MODE_GRAVITY = 0;
cc.ParticleSystem.MODE_RADIUS = 1;
cc.ParticleSystem.TYPE_FREE = 0;
cc.ParticleSystem.TYPE_RELATIVE = 1;
cc.ParticleSystem.TYPE_GROUPED = 2;
(function() {
    cc.ParticleSystem.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._drawMode = cc.ParticleSystem.TEXTURE_MODE;
        this._shapeType = cc.ParticleSystem.BALL_SHAPE;
        this._pointRect = cc.rect(0, 0, 0, 0);
        this._tintCache = document.createElement("canvas")
    };
    var a = cc.ParticleSystem.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ParticleSystem.CanvasRenderCmd;
    a.getDrawMode = function() {
        return this._drawMode
    };
    a.setDrawMode = function(a) {
        this._drawMode =
            a
    };
    a.getShapeType = function() {
        return this._shapeType
    };
    a.setShapeType = function(a) {
        this._shapeType = a
    };
    a.setBatchNode = function(a) {
        this._batchNode !== a && (this._node._batchNode = a)
    };
    a.updateQuadWithParticle = function(a, c) {};
    a.updateParticlePosition = function(a, c) {
        cc.pIn(a.drawPos, c)
    };
    a.rendering = function(a, c, d) {
        a = a || cc._renderContext;
        var e = a.getContext(),
            f = this._node,
            g = this._pointRect;
        a.setTransform(this._worldTransform, c, d);
        a.save();
        f.isBlendAdditive() ? e.globalCompositeOperation = "lighter" : e.globalCompositeOperation =
            "source-over";
        var h, k;
        d = this._node.particleCount;
        var m = this._node._particles;
        if (f.drawMode !== cc.ParticleSystem.SHAPE_MODE && f._texture) {
            if (!f._texture._textureLoaded) {
                a.restore();
                return
            }
            var n = f._texture.getHtmlElementObj();
            if (!n.width || !n.height) {
                a.restore();
                return
            }
            h = n;
            for (c = 0; c < d; c++)
                if (h = m[c], k = h.color.a / 255, 0 !== k) {
                    e.globalAlpha = k;
                    e.save();
                    e.translate(0 | h.drawPos.x, -(0 | h.drawPos.y));
                    var p = 4 * Math.floor(h.size / 4);
                    k = g.width;
                    var s = g.height;
                    e.scale(Math.max(1 / k * p, 1E-6), Math.max(1 / s * p, 1E-6));
                    h.rotation &&
                        e.rotate(cc.degreesToRadians(h.rotation));
                    h = h.isChangeColor ? this._changeTextureColor(f._texture, h.color, this._pointRect) : n;
                    e.drawImage(h, -(0 | k / 2), -(0 | s / 2));
                    e.restore()
                }
        } else
            for (n = cc._drawingUtil, c = 0; c < d; c++) h = m[c], g = 0 | 0.5 * h.size, k = h.color.a / 255, 0 !== k && (e.globalAlpha = k, e.save(), e.translate(0 | h.drawPos.x, -(0 | h.drawPos.y)), f.shapeType === cc.ParticleSystem.STAR_SHAPE ? (h.rotation && e.rotate(cc.degreesToRadians(h.rotation)), n.drawStar(a, g, h.color)) : n.drawColorBall(a, g, h.color), e.restore());
        a.restore();
        cc.g_NumberOfDraws++
    };
    a._changeTextureColor = function(a, c, d) {
        var e = this._tintCache,
            f = a.getContentSize();
        e.width = f.width;
        e.height = f.height;
        return a._generateColorTexture(c.r, c.g, c.b, d, e)
    };
    a.initTexCoordsWithRect = function(a) {
        this._pointRect = a
    };
    a.setTotalParticles = function(a) {
        this._node._totalParticles = 200 > a ? a : 200
    };
    a.addParticle = function() {
        var a = this._node,
            c = a._particles;
        a.particleCount < c.length ? a = c[a.particleCount] : (a = new cc.Particle, c.push(a));
        return a
    };
    a._setupVBO = function() {};
    a._allocMemory = function() {
        return !0
    };
    a.postStep =
        function() {};
    a._setBlendAdditive = function() {
        var a = this._node._blendFunc;
        a.src = cc.BLEND_SRC;
        a.dst = cc.BLEND_DST
    };
    a._initWithTotalParticles = function(a) {};
    a._updateDeltaColor = function(a, c) {
        this._node._dontTint || (a.color.r += a.deltaColor.r * c, a.color.g += a.deltaColor.g * c, a.color.b += a.deltaColor.b * c, a.color.a += a.deltaColor.a * c, a.isChangeColor = !0)
    }
})();
(function() {
    cc.ParticleSystem.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._buffersVBO = [0, 0];
        this._quads = [];
        this._indices = [];
        this._quadsArrayBuffer = null
    };
    var a = cc.ParticleSystem.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ParticleSystem.WebGLRenderCmd;
    a.getDrawMode = function() {};
    a.setDrawMode = function(a) {};
    a.getShapeType = function() {};
    a.setShapeType = function(a) {};
    a.setBatchNode = function(a) {
        var c = this._node;
        if (c._batchNode !==
            a) {
            var d = c._batchNode;
            if (c._batchNode = a)
                for (var e = c._particles, f = 0; f < c._totalParticles; f++) e[f].atlasIndex = f;
            a ? d || (c._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, c.atlasIndex), cc._renderContext.deleteBuffer(this._buffersVBO[1])) : (this._allocMemory(), this.initIndices(c._totalParticles), c.setTexture(d.getTexture()), this._setupVBO())
        }
    };
    a.initIndices = function(a) {
        for (var c = this._indices, d = 0; d < a; ++d) {
            var e = 6 * d,
                f = 4 * d;
            c[e + 0] = f + 0;
            c[e + 1] = f + 1;
            c[e + 2] = f + 2;
            c[e + 5] = f + 1;
            c[e + 4] = f + 2;
            c[e + 3] = f + 3
        }
    };
    a.isDifferentTexture =
        function(a, c) {
            return a === c
        };
    a.updateParticlePosition = function(a, c) {
        this.updateQuadWithParticle(a, c)
    };
    a.updateQuadWithParticle = function(a, c) {
        var d = null,
            e = this._node;
        e._batchNode ? (d = e._batchNode.textureAtlas.quads[e.atlasIndex + a.atlasIndex], e._batchNode.textureAtlas.dirty = !0) : d = this._quads[e._particleIdx];
        var f, g, h;
        e._opacityModifyRGB ? (e = 0 | a.color.r * a.color.a / 255, f = 0 | a.color.g * a.color.a / 255, g = 0 | a.color.b * a.color.a / 255) : (e = 0 | a.color.r, f = 0 | a.color.g, g = 0 | a.color.b);
        h = 0 | a.color.a;
        var k = d.bl.colors,
            m = d.br.colors,
            n = d.tl.colors,
            p = d.tr.colors;
        k.r = m.r = n.r = p.r = e;
        k.g = m.g = n.g = p.g = f;
        k.b = m.b = n.b = p.b = g;
        k.a = m.a = n.a = p.a = h;
        e = a.size / 2;
        a.rotation ? (f = -e, g = -e, h = c.x, k = c.y, n = -cc.degreesToRadians(a.rotation), m = Math.cos(n), n = Math.sin(n), d.bl.vertices.x = f * m - g * n + h, d.bl.vertices.y = f * n + g * m + k, d.br.vertices.x = e * m - g * n + h, d.br.vertices.y = e * n + g * m + k, d.tl.vertices.x = f * m - e * n + h, d.tl.vertices.y = f * n + e * m + k, d.tr.vertices.x = e * m - e * n + h, d.tr.vertices.y = e * n + e * m + k) : (d.bl.vertices.x = c.x - e, d.bl.vertices.y = c.y - e, d.br.vertices.x = c.x + e, d.br.vertices.y = c.y -
            e, d.tl.vertices.x = c.x - e, d.tl.vertices.y = c.y + e, d.tr.vertices.x = c.x + e, d.tr.vertices.y = c.y + e)
    };
    a.rendering = function(a) {
        var c = this._node;
        c._texture && (a = a || cc._renderContext, this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBindTexture2D(c._texture), cc.glBlendFuncForParticle(c._blendFunc.src, c._blendFunc.dst), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]), a.vertexAttribPointer(cc.VERTEX_ATTRIB_POSITION,
            3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(cc.VERTEX_ATTRIB_COLOR, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(cc.VERTEX_ATTRIB_TEX_COORDS, 2, a.FLOAT, !1, 24, 16), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]), a.drawElements(a.TRIANGLES, 6 * c._particleIdx, a.UNSIGNED_SHORT, 0))
    };
    a.initTexCoordsWithRect = function(a) {
        var c = this._node,
            d = c.texture,
            e = cc.contentScaleFactor(),
            f = cc.rect(a.x * e, a.y * e, a.width * e, a.height * e),
            e = a.width,
            g = a.height;
        d && (e = d.pixelsWidth, g = d.pixelsHeight);
        cc.FIX_ARTIFACTS_BY_STRECHING_TEXEL ?
            (d = (2 * f.x + 1) / (2 * e), a = (2 * f.y + 1) / (2 * g), e = d + (2 * f.width - 2) / (2 * e), f = a + (2 * f.height - 2) / (2 * g)) : (d = f.x / e, a = f.y / g, e = d + f.width / e, f = a + f.height / g);
        g = f;
        f = a;
        a = g;
        var h = 0,
            k = 0;
        c._batchNode ? (g = c._batchNode.textureAtlas.quads, h = c.atlasIndex, k = c.atlasIndex + c._totalParticles) : (g = this._quads, h = 0, k = c._totalParticles);
        for (c = h; c < k; c++) g[c] || (g[c] = cc.V3F_C4B_T2F_QuadZero()), h = g[c], h.bl.texCoords.u = d, h.bl.texCoords.v = a, h.br.texCoords.u = e, h.br.texCoords.v = a, h.tl.texCoords.u = d, h.tl.texCoords.v = f, h.tr.texCoords.u = e, h.tr.texCoords.v =
            f
    };
    a.setTotalParticles = function(a) {
        var c = this._node;
        if (a > c._allocatedParticles) {
            var d = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            this._indices = new Uint16Array(6 * a);
            var e = new ArrayBuffer(a * d),
                f = c._particles;
            f.length = 0;
            for (var g = this._quads, h = g.length = 0; h < a; h++) f[h] = new cc.Particle, g[h] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, e, h * d);
            c._allocatedParticles = a;
            c._totalParticles = a;
            if (c._batchNode)
                for (d = 0; d < a; d++) f[d].atlasIndex = d;
            this._quadsArrayBuffer = e;
            this.initIndices(a);
            this._setupVBO();
            c._texture && this.initTexCoordsWithRect(cc.rect(0,
                0, c._texture.width, c._texture.height))
        } else c._totalParticles = a;
        c.resetSystem()
    };
    a.addParticle = function() {
        var a = this._node;
        return a._particles[a.particleCount]
    };
    a._setupVBO = function() {
        var a = cc._renderContext;
        this._buffersVBO[0] = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW);
        this._buffersVBO[1] = a.createBuffer();
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indices,
            a.STATIC_DRAW)
    };
    a._allocMemory = function() {
        var a = this._node;
        if (a._batchNode) return cc.log("cc.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode"), !1;
        var c = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT,
            a = a._totalParticles,
            d = this._quads;
        d.length = 0;
        this._indices = new Uint16Array(6 * a);
        for (var e = new ArrayBuffer(c * a), f = 0; f < a; f++) d[f] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, e, f * c);
        if (!d || !this._indices) return cc.log("cocos2d: Particle system: not enough memory"), !1;
        this._quadsArrayBuffer =
            e;
        return !0
    };
    a.postStep = function() {
        var a = cc._renderContext;
        a.bindBuffer(a.ARRAY_BUFFER, this._buffersVBO[0]);
        a.bufferData(a.ARRAY_BUFFER, this._quadsArrayBuffer, a.DYNAMIC_DRAW)
    };
    a._setBlendAdditive = function() {
        var a = this._node._blendFunc;
        this._texture && !this._texture.hasPremultipliedAlpha() ? (a.src = cc.SRC_ALPHA, a.dst = cc.ONE_MINUS_SRC_ALPHA) : (a.src = cc.BLEND_SRC, a.dst = cc.BLEND_DST)
    };
    a._initWithTotalParticles = function(a) {
        if (!this._allocMemory()) return !1;
        this.initIndices(a);
        this._setupVBO();
        this._shaderProgram =
            cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    };
    a._updateDeltaColor = function(a, c) {
        a.color.r += a.deltaColor.r * c;
        a.color.g += a.deltaColor.g * c;
        a.color.b += a.deltaColor.b * c;
        a.color.a += a.deltaColor.a * c;
        a.isChangeColor = !0
    }
})();
cc.ParticleFire = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 300 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(60), this.setSpeedVar(20), this.setAngle(90), this.setAngleVar(10),
            a = cc.director.getWinSize(), this.setPosition(a.width / 2, 60), this.setPosVar(cc.p(40, 20)), this.setLife(3), this.setLifeVar(0.25), this.setStartSize(54), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFire.create = function() {
    return new cc.ParticleFire
};
cc.ParticleFireworks = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1500 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -90)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(180), this.setSpeedVar(50), a = cc.director.getWinSize(),
            this.setPosition(a.width / 2, a.height / 2), this.setAngle(90), this.setAngleVar(20), this.setLife(3.5), this.setLifeVar(1), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 255)), this.setEndColor(cc.color(26, 26, 26, 51)), this.setEndColorVar(cc.color(26, 26, 26, 51)), this.setStartSize(8), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleFireworks.create = function() {
    return new cc.ParticleFireworks
};
cc.ParticleSun = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 350 : 150)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setBlendAdditive(!0), this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(20), this.setSpeedVar(5),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(1), this.setLifeVar(0.5), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(194, 64, 31, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), !0) : !1
    }
});
cc.ParticleSun.create = function() {
    return new cc.ParticleSun
};
cc.ParticleGalaxy = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(60), this.setSpeedVar(10), this.setRadialAccel(-80), this.setRadialAccelVar(0), this.setTangentialAccel(80),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(37), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(31, 64, 194, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0,
                0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleGalaxy.create = function() {
    return new cc.ParticleGalaxy
};
cc.ParticleFlower = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 250 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(80), this.setSpeedVar(10), this.setRadialAccel(-60), this.setRadialAccelVar(0), this.setTangentialAccel(15),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(30), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 128)), this.setEndColor(cc.color(0, 0, 0, 255)),
            this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleFlower.create = function() {
    return new cc.ParticleFlower
};
cc.ParticleMeteor = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 150 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(-200, 200)), this.setSpeed(15), this.setSpeedVar(5), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(2), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(51, 102, 179)), this.setStartColorVar(cc.color(0, 0, 51, 26)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0,
                0, 0, 0)), this.setBlendAdditive(!0), !0) : !1
    }
});
cc.ParticleMeteor.create = function() {
    return new cc.ParticleMeteor
};
cc.ParticleSpiral = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 500 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(150), this.setSpeedVar(0), this.setRadialAccel(-380), this.setRadialAccelVar(0), this.setTangentialAccel(45),
            this.setTangentialAccelVar(0), this.setAngle(90), this.setAngleVar(0), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(12), this.setLifeVar(0), this.setStartSize(20), this.setStartSizeVar(0), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(128, 128, 128, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 255)),
            this.setEndColorVar(cc.color(128, 128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSpiral.create = function() {
    return new cc.ParticleSpiral
};
cc.ParticleExplosion = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 300)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(0.1), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setSpeed(70), this.setSpeedVar(40), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setTangentialAccel(0), this.setTangentialAccelVar(0),
            this.setAngle(90), this.setAngleVar(360), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height / 2), this.setPosVar(cc.p(0, 0)), this.setLife(5), this.setLifeVar(2), this.setStartSize(15), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getDuration()), this.setStartColor(cc.color(179, 26, 51, 255)), this.setStartColorVar(cc.color(128, 128, 128, 0)), this.setEndColor(cc.color(128, 128, 128, 0)), this.setEndColorVar(cc.color(128,
                128, 128, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleExplosion.create = function() {
    return new cc.ParticleExplosion
};
cc.ParticleSmoke = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 200 : 100)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, 0)), this.setRadialAccel(0), this.setRadialAccelVar(0), this.setSpeed(25), this.setSpeedVar(10), this.setAngle(90),
            this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, 0), this.setPosVar(cc.p(20, 0)), this.setLife(4), this.setLifeVar(1), this.setStartSize(60), this.setStartSizeVar(10), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(this.getTotalParticles() / this.getLife()), this.setStartColor(cc.color(204, 204, 204, 255)), this.setStartColorVar(cc.color(5, 5, 5, 0)), this.setEndColor(cc.color(0, 0, 0, 255)), this.setEndColorVar(cc.color(0, 0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSmoke.create = function() {
    return new cc.ParticleSmoke
};
cc.ParticleSnow = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 700 : 250)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(0, -1)), this.setSpeed(5), this.setSpeedVar(1), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0),
            this.setTangentialAccelVar(1), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height + 10), this.setPosVar(cc.p(a.width / 2, 0)), this.setAngle(-90), this.setAngleVar(5), this.setLife(45), this.setLifeVar(15), this.setStartSize(10), this.setStartSizeVar(5), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(10), this.setStartColor(cc.color(255, 255, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(255, 255, 255, 0)), this.setEndColorVar(cc.color(0,
                0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleSnow.create = function() {
    return new cc.ParticleSnow
};
cc.ParticleRain = cc.ParticleSystem.extend({
    ctor: function() {
        cc.ParticleSystem.prototype.ctor.call(this, cc._renderType === cc.game.RENDER_TYPE_WEBGL ? 1E3 : 300)
    },
    initWithTotalParticles: function(a) {
        return cc.ParticleSystem.prototype.initWithTotalParticles.call(this, a) ? (this.setDuration(cc.ParticleSystem.DURATION_INFINITY), this.setEmitterMode(cc.ParticleSystem.MODE_GRAVITY), this.setGravity(cc.p(10, -10)), this.setRadialAccel(0), this.setRadialAccelVar(1), this.setTangentialAccel(0), this.setTangentialAccelVar(1),
            this.setSpeed(130), this.setSpeedVar(30), this.setAngle(-90), this.setAngleVar(5), a = cc.director.getWinSize(), this.setPosition(a.width / 2, a.height), this.setPosVar(cc.p(a.width / 2, 0)), this.setLife(4.5), this.setLifeVar(0), this.setStartSize(4), this.setStartSizeVar(2), this.setEndSize(cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE), this.setEmissionRate(20), this.setStartColor(cc.color(179, 204, 255, 255)), this.setStartColorVar(cc.color(0, 0, 0, 0)), this.setEndColor(cc.color(179, 204, 255, 128)), this.setEndColorVar(cc.color(0,
                0, 0, 0)), this.setBlendAdditive(!1), !0) : !1
    }
});
cc.ParticleRain.create = function() {
    return new cc.ParticleRain
};
cc.PARTICLE_DEFAULT_CAPACITY = 500;
cc.ParticleBatchNode = cc.Node.extend({
    textureAtlas: null,
    _blendFunc: null,
    _className: "ParticleBatchNode",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        cc.isString(a) ? this.init(a, b) : a instanceof cc.Texture2D && this.initWithTexture(a, b)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleBatchNode.CanvasRenderCmd(this) : new cc.ParticleBatchNode.WebGLRenderCmd(this)
    },
    initWithTexture: function(a, b) {
        this.textureAtlas =
            new cc.TextureAtlas;
        this.textureAtlas.initWithTexture(a, b);
        this._children.length = 0;
        this._renderCmd._initWithTexture();
        return !0
    },
    initWithFile: function(a, b) {
        var c = cc.textureCache.addImage(a);
        return this.initWithTexture(c, b)
    },
    init: function(a, b) {
        var c = cc.textureCache.addImage(a);
        return this.initWithTexture(c, b)
    },
    addChild: function(a, b, c) {
        if (!a) throw Error("cc.ParticleBatchNode.addChild() : child should be non-null");
        if (!(a instanceof cc.ParticleSystem)) throw Error("cc.ParticleBatchNode.addChild() : only supports cc.ParticleSystem as children");
        b = null == b ? a.zIndex : b;
        c = null == c ? a.tag : c;
        if (a.getTexture() !== this.textureAtlas.texture) throw Error("cc.ParticleSystem.addChild() : the child is not using the same texture id");
        var d = a.getBlendFunc();
        if (0 === this._children.length) this.setBlendFunc(d);
        else if (d.src !== this._blendFunc.src || d.dst !== this._blendFunc.dst) {
            cc.log("cc.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function");
            return
        }
        b = this._addChildHelper(a, b, c);
        c = 0;
        0 !== b ? (b = this._children[b - 1], c = b.getAtlasIndex() +
            b.getTotalParticles()) : c = 0;
        this.insertChild(a, c);
        a.setBatchNode(this)
    },
    insertChild: function(a, b) {
        var c = a.getTotalParticles(),
            d = this.textureAtlas,
            e = d.totalQuads;
        a.setAtlasIndex(b);
        e + c > d.getCapacity() && (this._increaseAtlasCapacityTo(e + c), d.fillWithEmptyQuadsFromIndex(d.getCapacity() - c, c));
        a.getAtlasIndex() + c !== e && d.moveQuadsFromIndex(b, b + c);
        d.increaseTotalQuadsWith(c);
        this._updateAllAtlasIndexes()
    },
    removeChild: function(a, b) {
        if (null != a) {
            if (!(a instanceof cc.ParticleSystem)) throw Error("cc.ParticleBatchNode.removeChild(): only supports cc.ParticleSystem as children");
            if (-1 === this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it");
            else {
                cc.Node.prototype.removeChild.call(this, a, b);
                var c = this.textureAtlas;
                c.removeQuadsAtIndex(a.getAtlasIndex(), a.getTotalParticles());
                c.fillWithEmptyQuadsFromIndex(c.totalQuads, a.getTotalParticles());
                a.setBatchNode(null);
                this._updateAllAtlasIndexes()
            }
        }
    },
    reorderChild: function(a, b) {
        if (!a) throw Error("cc.ParticleBatchNode.reorderChild(): child should be non-null");
        if (!(a instanceof cc.ParticleSystem)) throw Error("cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children");
        if (-1 === this._children.indexOf(a)) cc.log("cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch");
        else if (b !== a.zIndex) {
            if (1 < this._children.length) {
                var c = this._getCurrentIndex(a, b);
                if (c.oldIndex !== c.newIndex) {
                    this._children.splice(c.oldIndex, 1);
                    this._children.splice(c.newIndex, 0, a);
                    c = a.getAtlasIndex();
                    this._updateAllAtlasIndexes();
                    for (var d = 0, e = this._children, f = 0; f <
                        e.length; f++)
                        if (e[f] === a) {
                            d = a.getAtlasIndex();
                            break
                        }
                    this.textureAtlas.moveQuadsFromIndex(c, a.getTotalParticles(), d);
                    a.updateWithNoTime()
                }
            }
            a._setLocalZOrder(b)
        }
    },
    removeChildAtIndex: function(a, b) {
        this.removeChild(this._children[i], b)
    },
    removeAllChildren: function(a) {
        for (var b = this._children, c = 0; c < b.length; c++) b[c].setBatchNode(null);
        cc.Node.prototype.removeAllChildren.call(this, a);
        this.textureAtlas.removeAllQuads()
    },
    disableParticle: function(a) {
        a = this.textureAtlas.quads[a];
        a.br.vertices.x = a.br.vertices.y =
            a.tr.vertices.x = a.tr.vertices.y = a.tl.vertices.x = a.tl.vertices.y = a.bl.vertices.x = a.bl.vertices.y = 0;
        this.textureAtlas._setDirty(!0)
    },
    getTexture: function() {
        return this.textureAtlas.texture
    },
    setTexture: function(a) {
        this.textureAtlas.texture = a;
        var b = this._blendFunc;
        a && !a.hasPremultipliedAlpha() && b.src === cc.BLEND_SRC && b.dst === cc.BLEND_DST && (b.src = cc.SRC_ALPHA, b.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a,
            this._blendFunc.src = b)
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    _updateAllAtlasIndexes: function() {
        for (var a = 0, b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            d.setAtlasIndex(a);
            a += d.getTotalParticles()
        }
    },
    _increaseAtlasCapacityTo: function(a) {
        cc.log("cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [" + this.textureAtlas.getCapacity() + "] to [" + a + "].");
        this.textureAtlas.resizeCapacity(a) || cc.log("cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas")
    },
    _searchNewPositionInChildrenForZ: function(a) {
        for (var b = this._children, c = b.length, d = 0; d < c; d++)
            if (b[d].zIndex > a) return d;
        return c
    },
    _getCurrentIndex: function(a, b) {
        for (var c = !1, d = !1, e = 0, f = 0, g = 0, h = this._children, k = h.length, m = 0; m < k; m++) {
            var n = h[m];
            if (n.zIndex > b && !d && (e = m, d = !0, c && d)) break;
            if (a === n && (f = m, c = !0, d || (g = -1), c && d)) break
        }
        d || (e = k);
        return {
            newIndex: e + g,
            oldIndex: f
        }
    },
    _addChildHelper: function(a, b, c) {
        if (!a) throw Error("cc.ParticleBatchNode._addChildHelper(): child should be non-null");
        if (a.parent) return cc.log("cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again"),
            null;
        this._children || (this._children = []);
        var d = this._searchNewPositionInChildrenForZ(b);
        this._children.splice(d, 0, a);
        a.tag = c;
        a._setLocalZOrder(b);
        a.parent = this;
        this._running && (a.onEnter(), a.onEnterTransitionDidFinish());
        return d
    },
    _updateBlendFunc: function() {
        this.textureAtlas.texture.hasPremultipliedAlpha() || (this._blendFunc.src = cc.SRC_ALPHA, this._blendFunc.dst = cc.ONE_MINUS_SRC_ALPHA)
    },
    getTextureAtlas: function() {
        return this.textureAtlas
    },
    setTextureAtlas: function(a) {
        this.textureAtlas = a
    }
});
_p = cc.ParticleBatchNode.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.ParticleBatchNode.create = function(a, b) {
    return new cc.ParticleBatchNode(a, b)
};
(function() {
    cc.ParticleBatchNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ParticleBatchNode.CanvasRenderCmd;
    a._initWithTexture = function() {}
})();
(function() {
    cc.ParticleBatchNode.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    a.constructor = cc.ParticleBatchNode.WebGLRenderCmd;
    a.rendering = function(a) {
        a = this._node;
        0 !== a.textureAtlas.totalQuads && (this._shaderProgram.use(), this._shaderProgram._setUniformForMVPMatrixWithMat4(this._stackMatrix), cc.glBlendFuncForParticle(a._blendFunc.src, a._blendFunc.dst), a.textureAtlas.drawQuads())
    };
    a._initWithTexture = function() {
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    };
    a.visit = function(a) {
        if (this._node._visible) {
            var c = cc.current_stack;
            c.stack.push(c.top);
            this._syncStatus(a);
            c.top = this._stackMatrix;
            cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0;
            cc.kmGLPopMatrix()
        }
    }
})();
cc.IMEKeyboardNotificationInfo = function(a, b, c) {
    this.begin = a || cc.rect(0, 0, 0, 0);
    this.end = b || cc.rect(0, 0, 0, 0);
    this.duration = c || 0
};
cc.IMEDelegate = cc.Class.extend({
    ctor: function() {
        cc.imeDispatcher.addDelegate(this)
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return !1
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return !1
    },
    didDetachWithIME: function() {},
    insertText: function(a, b) {},
    deleteBackward: function() {},
    getContentText: function() {
        return ""
    },
    keyboardWillShow: function(a) {},
    keyboardDidShow: function(a) {},
    keyboardWillHide: function(a) {},
    keyboardDidHide: function(a) {}
});
cc.IMEDispatcher = cc.Class.extend({
    _domInputControl: null,
    impl: null,
    _currentInputString: "",
    _lastClickPosition: null,
    ctor: function() {
        this.impl = new cc.IMEDispatcher.Impl;
        this._lastClickPosition = cc.p(0, 0)
    },
    init: function() {
        if (!cc.sys.isMobile) {
            this._domInputControl = cc.$("#imeDispatcherInput");
            this._domInputControl || (this._domInputControl = cc.$new("input"), this._domInputControl.setAttribute("type", "text"), this._domInputControl.setAttribute("id", "imeDispatcherInput"), this._domInputControl.resize(0, 0), this._domInputControl.translates(0,
                0), this._domInputControl.style.opacity = "0", this._domInputControl.style.fontSize = "1px", this._domInputControl.setAttribute("tabindex", 2), this._domInputControl.style.position = "absolute", this._domInputControl.style.top = 0, this._domInputControl.style.left = 0, document.body.appendChild(this._domInputControl));
            var a = this;
            this._domInputControl.addEventListener("input", function() {
                a._processDomInputString(a._domInputControl.value)
            }, !1);
            this._domInputControl.addEventListener("keydown", function(b) {
                b.keyCode === cc.KEY.tab ?
                    (b.stopPropagation(), b.preventDefault()) : b.keyCode === cc.KEY.enter && (a.dispatchInsertText("\n", 1), b.stopPropagation(), b.preventDefault())
            }, !1);
            /msie/i.test(navigator.userAgent) && this._domInputControl.addEventListener("keyup", function(b) {
                b.keyCode === cc.KEY.backspace && a._processDomInputString(a._domInputControl.value)
            }, !1);
            window.addEventListener("mousedown", function(b) {
                var c = b.pageY || 0;
                a._lastClickPosition.x = b.pageX || 0;
                a._lastClickPosition.y = c
            }, !1)
        }
    },
    _processDomInputString: function(a) {
        var b, c;
        b = this._currentInputString.length <
            a.length ? this._currentInputString.length : a.length;
        for (c = 0; c < b && a[c] === this._currentInputString[c]; c++);
        var d = this._currentInputString.length - c,
            e = a.length - c;
        for (b = 0; b < d; b++) this.dispatchDeleteBackward();
        for (b = 0; b < e; b++) this.dispatchInsertText(a[c + b], 1);
        this._currentInputString = a
    },
    dispatchInsertText: function(a, b) {
        !this.impl || !a || 0 >= b || this.impl._delegateWithIme && this.impl._delegateWithIme.insertText(a, b)
    },
    dispatchDeleteBackward: function() {
        this.impl && this.impl._delegateWithIme && this.impl._delegateWithIme.deleteBackward()
    },
    getContentText: function() {
        if (this.impl && this.impl._delegateWithIme) {
            var a = this.impl._delegateWithIme.getContentText();
            return a ? a : ""
        }
        return ""
    },
    dispatchKeyboardWillShow: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillShow(a)
            }
    },
    dispatchKeyboardDidShow: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidShow(a)
            }
    },
    dispatchKeyboardWillHide: function(a) {
        if (this.impl)
            for (var b =
                    0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardWillHide(a)
            }
    },
    dispatchKeyboardDidHide: function(a) {
        if (this.impl)
            for (var b = 0; b < this.impl._delegateList.length; b++) {
                var c = this.impl._delegateList[b];
                c && c.keyboardDidHide(a)
            }
    },
    addDelegate: function(a) {
        a && this.impl && (-1 < this.impl._delegateList.indexOf(a) || this.impl._delegateList.splice(0, 0, a))
    },
    attachDelegateWithIME: function(a) {
        if (!this.impl || !a || -1 === this.impl._delegateList.indexOf(a)) return !1;
        if (this.impl._delegateWithIme) {
            if (!this.impl._delegateWithIme.canDetachWithIME() ||
                !a.canAttachWithIME()) return !1;
            var b = this.impl._delegateWithIme;
            this.impl._delegateWithIme = null;
            b.didDetachWithIME();
            this._focusDomInput(a);
            return !0
        }
        if (!a.canAttachWithIME()) return !1;
        this._focusDomInput(a);
        return !0
    },
    _focusDomInput: function(a) {
        cc.sys.isMobile ? (this.impl._delegateWithIme = a, a.didAttachWithIME(), this._currentInputString = a.string || "", a = a.getTipMessage ? a.getTipMessage() : "please enter your word:", a = window.Window && Window.prototype.prompt != prompt ? Window.prototype.prompt.call(window, a, this._currentInputString) :
            prompt(a, this._currentInputString), null != a && this._processDomInputString(a), this.dispatchInsertText("\n", 1)) : (this.impl._delegateWithIme = a, this._currentInputString = a.string || "", a.didAttachWithIME(), this._domInputControl.focus(), this._domInputControl.value = this._currentInputString, this._domInputControlTranslate())
    },
    _domInputControlTranslate: function() {
        /msie/i.test(navigator.userAgent) ? (this._domInputControl.style.left = this._lastClickPosition.x + "px", this._domInputControl.style.top = this._lastClickPosition.y +
            "px") : this._domInputControl.translates(this._lastClickPosition.x, this._lastClickPosition.y)
    },
    detachDelegateWithIME: function(a) {
        if (!this.impl || !a || this.impl._delegateWithIme !== a || !a.canDetachWithIME()) return !1;
        this.impl._delegateWithIme = null;
        a.didDetachWithIME();
        cc._canvas.focus();
        return !0
    },
    removeDelegate: function(a) {
        this.impl && a && -1 !== this.impl._delegateList.indexOf(a) && (this.impl._delegateWithIme && a === this.impl._delegateWithIme && (this.impl._delegateWithIme = null), cc.arrayRemoveObject(this.impl._delegateList,
            a))
    },
    processKeycode: function(a) {
        32 > a ? a === cc.KEY.backspace ? this.dispatchDeleteBackward() : a === cc.KEY.enter && this.dispatchInsertText("\n", 1) : 255 > a && this.dispatchInsertText(String.fromCharCode(a), 1)
    }
});
cc.IMEDispatcher.Impl = cc.Class.extend({
    _delegateWithIme: null,
    _delegateList: null,
    ctor: function() {
        this._delegateList = []
    },
    findDelegate: function(a) {
        for (var b = 0; b < this._delegateList.length; b++)
            if (this._delegateList[b] === a) return b;
        return null
    }
});
cc.imeDispatcher = new cc.IMEDispatcher;
document.body ? cc.imeDispatcher.init() : window.addEventListener("load", function() {
    cc.imeDispatcher.init()
}, !1);
cc.TextFieldDelegate = cc.Class.extend({
    onTextFieldAttachWithIME: function(a) {
        return !1
    },
    onTextFieldDetachWithIME: function(a) {
        return !1
    },
    onTextFieldInsertText: function(a, b, c) {
        return !1
    },
    onTextFieldDeleteBackward: function(a, b, c) {
        return !1
    },
    onDraw: function(a) {
        return !1
    }
});
cc.TextFieldTTF = cc.LabelTTF.extend({
    delegate: null,
    colorSpaceHolder: null,
    _colorText: null,
    _lens: null,
    _inputText: "",
    _placeHolder: "",
    _charCount: 0,
    _className: "TextFieldTTF",
    ctor: function(a, b, c, d, e) {
        this.colorSpaceHolder = cc.color(127, 127, 127);
        this._colorText = cc.color(255, 255, 255, 255);
        cc.LabelTTF.prototype.ctor.call(this);
        void 0 !== e ? (this.initWithPlaceHolder("", b, c, d, e), a && this.setPlaceHolder(a)) : void 0 === d && void 0 !== c && (this.initWithString("", b, c), a && this.setPlaceHolder(a))
    },
    onEnter: function() {
        cc.LabelTTF.prototype.onEnter.call(this);
        cc.imeDispatcher.addDelegate(this)
    },
    onExit: function() {
        cc.LabelTTF.prototype.onExit.call(this);
        cc.imeDispatcher.removeDelegate(this)
    },
    getDelegate: function() {
        return this.delegate
    },
    setDelegate: function(a) {
        this.delegate = a
    },
    getCharCount: function() {
        return this._charCount
    },
    getColorSpaceHolder: function() {
        return cc.color(this.colorSpaceHolder)
    },
    setColorSpaceHolder: function(a) {
        this.colorSpaceHolder.r = a.r;
        this.colorSpaceHolder.g = a.g;
        this.colorSpaceHolder.b = a.b;
        this.colorSpaceHolder.a = cc.isUndefined(a.a) ? 255 :
            a.a;
        this._inputText.length || this.setColor(this.colorSpaceHolder)
    },
    setTextColor: function(a) {
        this._colorText.r = a.r;
        this._colorText.g = a.g;
        this._colorText.b = a.b;
        this._colorText.a = cc.isUndefined(a.a) ? 255 : a.a;
        this._inputText.length && this.setColor(this._colorText)
    },
    initWithPlaceHolder: function(a, b, c, d, e) {
        switch (arguments.length) {
            case 5:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, d, e, b, c);
            case 3:
                return a && this.setPlaceHolder(a), this.initWithString(this._placeHolder, arguments[1],
                    arguments[2]);
            default:
                throw Error("Argument must be non-nil ");
        }
    },
    setString: function(a) {
        this._inputText = (a = String(a)) || "";
        this._inputText.length ? (cc.LabelTTF.prototype.setString.call(this, this._inputText), this.setColor(this._colorText)) : (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder));
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._renderCmd._updateTexture();
        this._charCount = this._inputText.length
    },
    getString: function() {
        return this._inputText
    },
    setPlaceHolder: function(a) {
        this._placeHolder =
            a || "";
        this._inputText.length || (cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder))
    },
    getPlaceHolder: function() {
        return this._placeHolder
    },
    draw: function(a) {
        a = a || cc._renderContext;
        this.delegate && this.delegate.onDraw(this) || cc.LabelTTF.prototype.draw.call(this, a)
    },
    visit: function(a) {
        this._super(a)
    },
    attachWithIME: function() {
        return cc.imeDispatcher.attachDelegateWithIME(this)
    },
    detachWithIME: function() {
        return cc.imeDispatcher.detachDelegateWithIME(this)
    },
    canAttachWithIME: function() {
        return this.delegate ?
            !this.delegate.onTextFieldAttachWithIME(this) : !0
    },
    didAttachWithIME: function() {},
    canDetachWithIME: function() {
        return this.delegate ? !this.delegate.onTextFieldDetachWithIME(this) : !0
    },
    didDetachWithIME: function() {},
    deleteBackward: function() {
        var a = this._inputText.length;
        0 === a || this.delegate && this.delegate.onTextFieldDeleteBackward(this, this._inputText[a - 1], 1) || (1 >= a ? (this._inputText = "", this._charCount = 0, cc.LabelTTF.prototype.setString.call(this, this._placeHolder), this.setColor(this.colorSpaceHolder)) : this.string =
            this._inputText.substring(0, a - 1))
    },
    removeDelegate: function() {
        cc.imeDispatcher.removeDelegate(this)
    },
    _tipMessage: "please enter your word:",
    setTipMessage: function(a) {
        null != a && (this._tipMessage = a)
    },
    getTipMessage: function() {
        return this._tipMessage
    },
    insertText: function(a, b) {
        var c = a,
            d = c.indexOf("\n"); - 1 < d && (c = c.substring(0, d));
        if (0 < c.length) {
            if (this.delegate && this.delegate.onTextFieldInsertText(this, c, c.length)) return;
            c = this._inputText + c;
            this._charCount = c.length;
            this.string = c
        } - 1 !== d && (this.delegate && this.delegate.onTextFieldInsertText(this,
            "\n", 1) || this.detachWithIME())
    },
    getContentText: function() {
        return this._inputText
    },
    keyboardWillShow: function(a) {},
    keyboardDidShow: function(a) {},
    keyboardWillHide: function(a) {},
    keyboardDidHide: function(a) {}
});
_p = cc.TextFieldTTF.prototype;
cc.defineGetterSetter(_p, "charCount", _p.getCharCount);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.TextFieldTTF.create = function(a, b, c, d, e) {
    return new cc.TextFieldTTF(a, b, c, d, e)
};
cc._globalFontSize = cc.ITEM_SIZE;
cc._globalFontName = "Arial";
cc._globalFontNameRelease = !1;
cc.MenuItem = cc.Node.extend({
    _enabled: !1,
    _target: null,
    _callback: null,
    _isSelected: !1,
    _className: "MenuItem",
    ctor: function(a, b) {
        var c = cc.Node.prototype;
        c.ctor.call(this);
        this._callback = this._target = null;
        this._enabled = this._isSelected = !1;
        c.setAnchorPoint.call(this, 0.5, 0.5);
        this._target = b || null;
        if (this._callback = a || null) this._enabled = !0
    },
    isSelected: function() {
        return this._isSelected
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    setTarget: function(a, b) {
        this._target = b;
        this._callback =
            a
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    initWithCallback: function(a, b) {
        this.anchorY = this.anchorX = 0.5;
        this._target = b;
        this._callback = a;
        this._enabled = !0;
        this._isSelected = !1;
        return !0
    },
    rect: function() {
        var a = this._position,
            b = this._contentSize,
            c = this._anchorPoint;
        return cc.rect(a.x - b.width * c.x, a.y - b.height * c.y, b.width, b.height)
    },
    selected: function() {
        this._isSelected = !0
    },
    unselected: function() {
        this._isSelected = !1
    },
    setCallback: function(a, b) {
        this._target = b;
        this._callback =
            a
    },
    activate: function() {
        if (this._enabled) {
            var a = this._target,
                b = this._callback;
            if (b)
                if (a && cc.isString(b)) a[b](this);
                else a && cc.isFunction(b) ? b.call(a, this) : b(this)
        }
    }
});
_p = cc.MenuItem.prototype;
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.MenuItem.create = function(a, b) {
    return new cc.MenuItem(a, b)
};
cc.MenuItemLabel = cc.MenuItem.extend({
    _disabledColor: null,
    _label: null,
    _originalScale: 0,
    _colorBackup: null,
    ctor: function(a, b, c) {
        cc.MenuItem.prototype.ctor.call(this, b, c);
        this._colorBackup = this._label = this._disabledColor = null;
        a && (this._originalScale = 1, this._colorBackup = cc.color.WHITE, this._disabledColor = cc.color(126, 126, 126), this.setLabel(a), this.setCascadeColorEnabled(!0), this.setCascadeOpacityEnabled(!0))
    },
    getDisabledColor: function() {
        return this._disabledColor
    },
    setDisabledColor: function(a) {
        this._disabledColor =
            a
    },
    getLabel: function() {
        return this._label
    },
    setLabel: function(a) {
        a && (this.addChild(a), a.anchorX = 0, a.anchorY = 0, this.width = a.width, this.height = a.height, a.setCascadeColorEnabled(!0));
        this._label && this.removeChild(this._label, !0);
        this._label = a
    },
    setEnabled: function(a) {
        this._enabled !== a && (a ? this.setColor(this._colorBackup) : (this._colorBackup = this.color, this.setColor(this._disabledColor)));
        cc.MenuItem.prototype.setEnabled.call(this, a)
    },
    initWithLabel: function(a, b, c) {
        this.initWithCallback(b, c);
        this._originalScale =
            1;
        this._colorBackup = cc.color.WHITE;
        this._disabledColor = cc.color(126, 126, 126);
        this.setLabel(a);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    },
    setString: function(a) {
        this._label.string = a;
        this.width = this._label.width;
        this.height = this._label.height
    },
    getString: function() {
        return this._label.string
    },
    activate: function() {
        this._enabled && (this.stopAllActions(), this.scale = this._originalScale, cc.MenuItem.prototype.activate.call(this))
    },
    selected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.selected.call(this);
            var a = this.getActionByTag(cc.ZOOM_ACTION_TAG);
            a ? this.stopAction(a) : this._originalScale = this.scale;
            a = cc.scaleTo(0.1, 1.2 * this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    },
    unselected: function() {
        if (this._enabled) {
            cc.MenuItem.prototype.unselected.call(this);
            this.stopActionByTag(cc.ZOOM_ACTION_TAG);
            var a = cc.scaleTo(0.1, this._originalScale);
            a.setTag(cc.ZOOM_ACTION_TAG);
            this.runAction(a)
        }
    }
});
_p = cc.MenuItemLabel.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "disabledColor", _p.getDisabledColor, _p.setDisabledColor);
cc.defineGetterSetter(_p, "label", _p.getLabel, _p.setLabel);
cc.MenuItemLabel.create = function(a, b, c) {
    return new cc.MenuItemLabel(a, b, c)
};
cc.MenuItemAtlasFont = cc.MenuItemLabel.extend({
    ctor: function(a, b, c, d, e, f, g) {
        var h;
        a && 0 < a.length && (h = new cc.LabelAtlas(a, b, c, d, e));
        cc.MenuItemLabel.prototype.ctor.call(this, h, f, g)
    },
    initWithString: function(a, b, c, d, e, f, g) {
        if (!a || 0 === a.length) throw Error("cc.MenuItemAtlasFont.initWithString(): value should be non-null and its length should be greater than 0");
        var h = new cc.LabelAtlas;
        h.initWithString(a, b, c, d, e);
        this.initWithLabel(h, f, g);
        return !0
    }
});
cc.MenuItemAtlasFont.create = function(a, b, c, d, e, f, g) {
    return new cc.MenuItemAtlasFont(a, b, c, d, e, f, g)
};
cc.MenuItemFont = cc.MenuItemLabel.extend({
    _fontSize: null,
    _fontName: null,
    ctor: function(a, b, c) {
        var d;
        a && 0 < a.length ? (this._fontName = cc._globalFontName, this._fontSize = cc._globalFontSize, d = new cc.LabelTTF(a, this._fontName, this._fontSize)) : (this._fontSize = 0, this._fontName = "");
        cc.MenuItemLabel.prototype.ctor.call(this, d, b, c)
    },
    initWithString: function(a, b, c) {
        if (!a || 0 === a.length) throw Error("Value should be non-null and its length should be greater than 0");
        this._fontName = cc._globalFontName;
        this._fontSize = cc._globalFontSize;
        a = new cc.LabelTTF(a, this._fontName, this._fontSize);
        this.initWithLabel(a, b, c);
        return !0
    },
    setFontSize: function(a) {
        this._fontSize = a;
        this._recreateLabel()
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName = a;
        this._recreateLabel()
    },
    getFontName: function() {
        return this._fontName
    },
    _recreateLabel: function() {
        var a = new cc.LabelTTF(this._label.string, this._fontName, this._fontSize);
        this.setLabel(a)
    }
});
cc.MenuItemFont.setFontSize = function(a) {
    cc._globalFontSize = a
};
cc.MenuItemFont.fontSize = function() {
    return cc._globalFontSize
};
cc.MenuItemFont.setFontName = function(a) {
    cc._globalFontNameRelease && (cc._globalFontName = "");
    cc._globalFontName = a;
    cc._globalFontNameRelease = !0
};
_p = cc.MenuItemFont.prototype;
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.MenuItemFont.fontName = function() {
    return cc._globalFontName
};
cc.MenuItemFont.create = function(a, b, c) {
    return new cc.MenuItemFont(a, b, c)
};
cc.MenuItemSprite = cc.MenuItem.extend({
    _normalImage: null,
    _selectedImage: null,
    _disabledImage: null,
    ctor: function(a, b, c, d, e) {
        cc.MenuItem.prototype.ctor.call(this);
        this._disabledImage = this._selectedImage = this._normalImage = null;
        if (void 0 !== b) {
            var f, g, h;
            void 0 !== e ? (f = c, h = d, g = e) : void 0 !== d && cc.isFunction(d) ? (f = c, h = d) : void 0 !== d && cc.isFunction(c) ? (g = d, h = c, f = null) : void 0 === c && (f = null);
            this.initWithNormalSprite(a, b, f, h, g)
        }
    },
    getNormalImage: function() {
        return this._normalImage
    },
    setNormalImage: function(a) {
        this._normalImage !==
            a && (a && (this.addChild(a, 0, cc.NORMAL_TAG), a.anchorX = 0, a.anchorY = 0), this._normalImage && this.removeChild(this._normalImage, !0), this._normalImage = a) && (this.width = this._normalImage.width, this.height = this._normalImage.height, this._updateImagesVisibility(), a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
                this.width = a.width;
                this.height = a.height
            }, this))
    },
    getSelectedImage: function() {
        return this._selectedImage
    },
    setSelectedImage: function(a) {
        this._selectedImage !== a && (a && (this.addChild(a,
            0, cc.SELECTED_TAG), a.anchorX = 0, a.anchorY = 0), this._selectedImage && this.removeChild(this._selectedImage, !0), this._selectedImage = a, this._updateImagesVisibility())
    },
    getDisabledImage: function() {
        return this._disabledImage
    },
    setDisabledImage: function(a) {
        this._disabledImage !== a && (a && (this.addChild(a, 0, cc.DISABLE_TAG), a.anchorX = 0, a.anchorY = 0), this._disabledImage && this.removeChild(this._disabledImage, !0), this._disabledImage = a, this._updateImagesVisibility())
    },
    initWithNormalSprite: function(a, b, c, d, e) {
        this.initWithCallback(d,
            e);
        this.setNormalImage(a);
        this.setSelectedImage(b);
        this.setDisabledImage(c);
        if (a = this._normalImage) this.width = a.width, this.height = a.height, a.textureLoaded && !a.textureLoaded() && a.addEventListener("load", function(a) {
            this.width = a.width;
            this.height = a.height;
            this.setCascadeColorEnabled(!0);
            this.setCascadeOpacityEnabled(!0)
        }, this);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this._normalImage && (this._disabledImage &&
            (this._disabledImage.visible = !1), this._selectedImage ? (this._normalImage.visible = !1, this._selectedImage.visible = !0) : this._normalImage.visible = !0)
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this._normalImage && (this._normalImage.visible = !0, this._selectedImage && (this._selectedImage.visible = !1), this._disabledImage && (this._disabledImage.visible = !1))
    },
    setEnabled: function(a) {
        this._enabled !== a && (cc.MenuItem.prototype.setEnabled.call(this, a), this._updateImagesVisibility())
    },
    _updateImagesVisibility: function() {
        var a =
            this._normalImage,
            b = this._selectedImage,
            c = this._disabledImage;
        this._enabled ? (a && (a.visible = !0), b && (b.visible = !1), c && (c.visible = !1)) : c ? (a && (a.visible = !1), b && (b.visible = !1), c && (c.visible = !0)) : (a && (a.visible = !0), b && (b.visible = !1))
    }
});
_p = cc.MenuItemSprite.prototype;
cc.defineGetterSetter(_p, "normalImage", _p.getNormalImage, _p.setNormalImage);
cc.defineGetterSetter(_p, "selectedImage", _p.getSelectedImage, _p.setSelectedImage);
cc.defineGetterSetter(_p, "disabledImage", _p.getDisabledImage, _p.setDisabledImage);
cc.MenuItemSprite.create = function(a, b, c, d, e) {
    return new cc.MenuItemSprite(a, b, c, d, e || void 0)
};
cc.MenuItemImage = cc.MenuItemSprite.extend({
    ctor: function(a, b, c, d, e) {
        var f = null,
            g = null,
            h = null,
            k = null,
            m = null;
        void 0 === a || null === a ? cc.MenuItemSprite.prototype.ctor.call(this) : (f = new cc.Sprite(a), b && (g = new cc.Sprite(b)), void 0 === d ? k = c : void 0 === e ? (k = c, m = d) : e && (h = new cc.Sprite(c), k = d, m = e), cc.MenuItemSprite.prototype.ctor.call(this, f, g, h, k, m))
    },
    setNormalSpriteFrame: function(a) {
        this.setNormalImage(new cc.Sprite(a))
    },
    setSelectedSpriteFrame: function(a) {
        this.setSelectedImage(new cc.Sprite(a))
    },
    setDisabledSpriteFrame: function(a) {
        this.setDisabledImage(new cc.Sprite(a))
    },
    initWithNormalImage: function(a, b, c, d, e) {
        var f = null,
            g = null,
            h = null;
        a && (f = new cc.Sprite(a));
        b && (g = new cc.Sprite(b));
        c && (h = new cc.Sprite(c));
        return this.initWithNormalSprite(f, g, h, d, e)
    }
});
cc.MenuItemImage.create = function(a, b, c, d, e) {
    return new cc.MenuItemImage(a, b, c, d, e)
};
cc.MenuItemToggle = cc.MenuItem.extend({
    subItems: null,
    _selectedIndex: 0,
    _opacity: null,
    _color: null,
    ctor: function() {
        cc.MenuItem.prototype.ctor.call(this);
        this._selectedIndex = 0;
        this.subItems = [];
        this._opacity = 0;
        this._color = cc.color.WHITE;
        0 < arguments.length && this.initWithItems(Array.prototype.slice.apply(arguments))
    },
    getOpacity: function() {
        return this._opacity
    },
    setOpacity: function(a) {
        this._opacity = a;
        if (this.subItems && 0 < this.subItems.length)
            for (var b = 0; b < this.subItems.length; b++) this.subItems[b].opacity = a;
        this._color.a = a
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setColor: function(a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b;
        if (this.subItems && 0 < this.subItems.length)
            for (b = 0; b < this.subItems.length; b++) this.subItems[b].setColor(a);
        void 0 === a.a || a.a_undefined || this.setOpacity(a.a)
    },
    getSelectedIndex: function() {
        return this._selectedIndex
    },
    setSelectedIndex: function(a) {
        if (a !== this._selectedIndex) {
            this._selectedIndex = a;
            (a = this.getChildByTag(cc.CURRENT_ITEM)) && a.removeFromParent(!1);
            a = this.subItems[this._selectedIndex];
            this.addChild(a, 0, cc.CURRENT_ITEM);
            var b = a.width,
                c = a.height;
            this.width = b;
            this.height = c;
            a.setPosition(b / 2, c / 2)
        }
    },
    getSubItems: function() {
        return this.subItems
    },
    setSubItems: function(a) {
        this.subItems = a
    },
    initWithItems: function(a) {
        var b = a.length;
        cc.isFunction(a[a.length - 2]) ? (this.initWithCallback(a[a.length - 2], a[a.length - 1]), b -= 2) : cc.isFunction(a[a.length - 1]) ? (this.initWithCallback(a[a.length - 1], null), b -= 1) : this.initWithCallback(null, null);
        for (var c = this.subItems, d = c.length =
                0; d < b; d++) a[d] && c.push(a[d]);
        this._selectedIndex = cc.UINT_MAX;
        this.setSelectedIndex(0);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        return !0
    },
    addSubItem: function(a) {
        this.subItems.push(a)
    },
    activate: function() {
        this._enabled && this.setSelectedIndex((this._selectedIndex + 1) % this.subItems.length);
        cc.MenuItem.prototype.activate.call(this)
    },
    selected: function() {
        cc.MenuItem.prototype.selected.call(this);
        this.subItems[this._selectedIndex].selected()
    },
    unselected: function() {
        cc.MenuItem.prototype.unselected.call(this);
        this.subItems[this._selectedIndex].unselected()
    },
    setEnabled: function(a) {
        if (this._enabled !== a) {
            cc.MenuItem.prototype.setEnabled.call(this, a);
            var b = this.subItems;
            if (b && 0 < b.length)
                for (var c = 0; c < b.length; c++) b[c].enabled = a
        }
    },
    selectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    getSelectedItem: function() {
        return this.subItems[this._selectedIndex]
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.setSelectedIndex(this._selectedIndex)
    }
});
_p = cc.MenuItemToggle.prototype;
cc.defineGetterSetter(_p, "selectedIndex", _p.getSelectedIndex, _p.setSelectedIndex);
cc.MenuItemToggle.create = function() {
    0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
    var a = new cc.MenuItemToggle;
    a.initWithItems(Array.prototype.slice.apply(arguments));
    return a
};
cc.MENU_STATE_WAITING = 0;
cc.MENU_STATE_TRACKING_TOUCH = 1;
cc.MENU_HANDLER_PRIORITY = -128;
cc.DEFAULT_PADDING = 5;
cc.Menu = cc.Layer.extend({
    enabled: !1,
    _selectedItem: null,
    _state: -1,
    _touchListener: null,
    _className: "Menu",
    ctor: function(a) {
        cc.Layer.prototype.ctor.call(this);
        this._color = cc.color.WHITE;
        this.enabled = !1;
        this._opacity = 255;
        this._selectedItem = null;
        this._state = -1;
        this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this._onTouchBegan,
            onTouchMoved: this._onTouchMoved,
            onTouchEnded: this._onTouchEnded,
            onTouchCancelled: this._onTouchCancelled
        });
        0 < arguments.length &&
            null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var b = arguments.length,
            c;
        if (0 === b) c = [];
        else if (1 === b) c = a instanceof Array ? a : [a];
        else if (1 < b) {
            c = [];
            for (var d = 0; d < b; d++) arguments[d] && c.push(arguments[d])
        }
        this.initWithArray(c)
    },
    onEnter: function() {
        var a = this._touchListener;
        a._isRegistered() || cc.eventManager.addListener(a, this);
        cc.Node.prototype.onEnter.call(this)
    },
    isEnabled: function() {
        return this.enabled
    },
    setEnabled: function(a) {
        this.enabled = a
    },
    initWithItems: function(a) {
        var b = [];
        if (a)
            for (var c = 0; c < a.length; c++) a[c] && b.push(a[c]);
        return this.initWithArray(b)
    },
    initWithArray: function(a) {
        if (cc.Layer.prototype.init.call(this)) {
            this.enabled = !0;
            var b = cc.winSize;
            this.setPosition(b.width / 2, b.height / 2);
            this.setContentSize(b);
            this.setAnchorPoint(0.5, 0.5);
            this.ignoreAnchorPointForPosition(!0);
            if (a)
                for (b = 0; b < a.length; b++) this.addChild(a[b], b);
            this._selectedItem = null;
            this._state = cc.MENU_STATE_WAITING;
            return this.cascadeOpacity = this.cascadeColor = !0
        }
        return !1
    },
    addChild: function(a, b, c) {
        if (!(a instanceof cc.MenuItem)) throw Error("cc.Menu.addChild() : Menu only supports MenuItem objects as children");
        cc.Layer.prototype.addChild.call(this, a, b, c)
    },
    alignItemsVertically: function() {
        this.alignItemsVerticallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsVerticallyWithPadding: function(a) {
        var b = -a,
            c = this._children,
            d, e, f, g;
        if (c && 0 < c.length) {
            e = 0;
            for (d = c.length; e < d; e++) b += c[e].height * c[e].scaleY + a;
            var h = b / 2;
            e = 0;
            for (d = c.length; e < d; e++) g = c[e], f = g.height, b = g.scaleY, g.setPosition(0, h - f * b / 2), h -= f * b + a
        }
    },
    alignItemsHorizontally: function() {
        this.alignItemsHorizontallyWithPadding(cc.DEFAULT_PADDING)
    },
    alignItemsHorizontallyWithPadding: function(a) {
        var b = -a,
            c = this._children,
            d, e, f, g;
        if (c && 0 < c.length) {
            d = 0;
            for (e = c.length; d < e; d++) b += c[d].width * c[d].scaleX + a;
            var h = -b / 2;
            d = 0;
            for (e = c.length; d < e; d++) g = c[d], b = g.scaleX, f = c[d].width, g.setPosition(h + f * b / 2, 0), h += f * b + a
        }
    },
    alignItemsInColumns: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        for (var a = [], b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var c = -5,
            d = 0,
            e = 0,
            f = 0,
            g, h, k, m =
            this._children;
        if (m && 0 < m.length)
            for (b = 0, k = m.length; b < k; b++) d >= a.length || !(g = a[d]) || (h = m[b].height, e = e >= h || isNaN(h) ? e : h, ++f, f >= g && (c += e + 5, e = f = 0, ++d));
        var n = cc.director.getWinSize(),
            p = g = e = d = 0,
            s = 0,
            c = c / 2;
        if (m && 0 < m.length)
            for (b = 0, k = m.length; b < k; b++) {
                var r = m[b];
                0 === g && (g = a[d], s = p = n.width / (1 + g));
                h = r._getHeight();
                e = e >= h || isNaN(h) ? e : h;
                r.setPosition(s - n.width / 2, c - h / 2);
                s += p;
                ++f;
                f >= g && (c -= e + 5, e = g = f = 0, ++d)
            }
    },
    alignItemsInRows: function() {
        0 < arguments.length && null == arguments[arguments.length - 1] && cc.log("parameters should not be ending with null in Javascript");
        var a = [],
            b;
        for (b = 0; b < arguments.length; b++) a.push(arguments[b]);
        var c = [],
            d = [],
            e = -10,
            f = -5,
            g = 0,
            h = 0,
            k = 0,
            m, n, p, s, r = this._children;
        if (r && 0 < r.length)
            for (b = 0, p = r.length; b < p; b++)(n = r[b], g >= a.length || !(m = a[g])) || (s = n.width, h = h >= s || isNaN(s) ? h : s, f += n.height + 5, ++k, k >= m && (c.push(h), d.push(f), e += h + 10, h = k = 0, f = -5, ++g));
        f = cc.director.getWinSize();
        m = h = g = 0;
        var e = -e / 2,
            u = 0;
        if (r && 0 < r.length)
            for (b = 0, p = r.length; b < p; b++) n = r[b], 0 === m && (m = a[g], u = d[g]), s = n._getWidth(), h = h >= s || isNaN(s) ? h : s, n.setPosition(e + c[g] / 2, u - f.height / 2),
                u -= n.height + 10, ++k, k >= m && (e += h + 5, h = m = k = 0, ++g)
    },
    removeChild: function(a, b) {
        null != a && (a instanceof cc.MenuItem ? (this._selectedItem === a && (this._selectedItem = null), cc.Node.prototype.removeChild.call(this, a, b)) : cc.log("cc.Menu.removeChild():Menu only supports MenuItem objects as children"))
    },
    _onTouchBegan: function(a, b) {
        var c = b.getCurrentTarget();
        if (c._state !== cc.MENU_STATE_WAITING || !c._visible || !c.enabled) return !1;
        for (var d = c.parent; null != d; d = d.parent)
            if (!d.isVisible()) return !1;
        c._selectedItem = c._itemForTouch(a);
        return c._selectedItem ? (c._state = cc.MENU_STATE_TRACKING_TOUCH, c._selectedItem.selected(), c._selectedItem.setNodeDirty(), !0) : !1
    },
    _onTouchEnded: function(a, b) {
        var c = b.getCurrentTarget();
        c._state !== cc.MENU_STATE_TRACKING_TOUCH ? cc.log("cc.Menu.onTouchEnded(): invalid state") : (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty(), c._selectedItem.activate()), c._state = cc.MENU_STATE_WAITING)
    },
    _onTouchCancelled: function(a, b) {
        var c = b.getCurrentTarget();
        c._state !== cc.MENU_STATE_TRACKING_TOUCH ?
            cc.log("cc.Menu.onTouchCancelled(): invalid state") : (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty()), c._state = cc.MENU_STATE_WAITING)
    },
    _onTouchMoved: function(a, b) {
        var c = b.getCurrentTarget();
        if (c._state !== cc.MENU_STATE_TRACKING_TOUCH) cc.log("cc.Menu.onTouchMoved(): invalid state");
        else {
            var d = c._itemForTouch(a);
            d !== c._selectedItem && (c._selectedItem && (c._selectedItem.unselected(), c._selectedItem.setNodeDirty()), c._selectedItem = d, c._selectedItem && (c._selectedItem.selected(),
                c._selectedItem.setNodeDirty()))
        }
    },
    onExit: function() {
        this._state === cc.MENU_STATE_TRACKING_TOUCH && (this._selectedItem && (this._selectedItem.unselected(), this._selectedItem = null), this._state = cc.MENU_STATE_WAITING);
        cc.Node.prototype.onExit.call(this)
    },
    setOpacityModifyRGB: function(a) {},
    isOpacityModifyRGB: function() {
        return !1
    },
    _itemForTouch: function(a) {
        a = a.getLocation();
        var b = this._children,
            c;
        if (b && 0 < b.length)
            for (var d = b.length - 1; 0 <= d; d--)
                if (c = b[d], c.isVisible() && c.isEnabled()) {
                    var e = c.convertToNodeSpace(a),
                        f = c.rect();
                    f.x = 0;
                    f.y = 0;
                    if (cc.rectContainsPoint(f, e)) return c
                }
        return null
    }
});
_p = cc.Menu.prototype;
cc.Menu.create = function(a) {
    var b = arguments.length;
    0 < b && null == arguments[b - 1] && cc.log("parameters should not be ending with null in Javascript");
    return 0 === b ? new cc.Menu : 1 === b ? new cc.Menu(a) : new cc.Menu(Array.prototype.slice.call(arguments, 0))
};
cc.TGA_OK = 0;
cc.TGA_ERROR_FILE_OPEN = 1;
cc.TGA_ERROR_READING_FILE = 2;
cc.TGA_ERROR_INDEXED_COLOR = 3;
cc.TGA_ERROR_MEMORY = 4;
cc.TGA_ERROR_COMPRESSED_FILE = 5;
cc.ImageTGA = function(a, b, c, d, e, f, g) {
    this.status = a || 0;
    this.type = b || 0;
    this.pixelDepth = c || 0;
    this.width = d || 0;
    this.height = e || 0;
    this.imageData = f || [];
    this.flipped = g || 0
};
cc.tgaLoadHeader = function(a, b, c) {
    var d = 2;
    if (d + 1 > b) return !1;
    a = new cc.BinaryStreamReader(a);
    a.setOffset(d);
    c.type = a.readByte();
    d += 10;
    if (d + 4 + 1 > b) return !1;
    a.setOffset(d);
    c.width = a.readUnsignedShort();
    c.height = a.readUnsignedInteger();
    c.pixelDepth = a.readByte();
    if (d + 5 + 1 > b) return !1;
    b = a.readByte();
    c.flipped = 0;
    b & 32 && (c.flipped = 1);
    return !0
};
cc.tgaLoadImageData = function(a, b, c) {
    var d, e;
    d = 0 | c.pixelDepth / 2;
    e = c.height * c.width * d;
    if (18 + e > b) return !1;
    c.imageData = cc.__getSubArray(a, 18, 18 + e);
    if (3 <= d)
        for (a = 0; a < e; a += d) b = c.imageData[a], c.imageData[a] = c.imageData[a + 2], c.imageData[a + 2] = b;
    return !0
};
cc.tgaRGBtogreyscale = function(a) {
    var b, c;
    if (8 !== a.pixelDepth) {
        var d = a.pixelDepth / 8,
            e = new Uint8Array(a.height * a.width);
        if (null !== e) {
            for (c = b = 0; c < a.width * a.height; b += d, c++) e[c] = 0.3 * a.imageData[b] + 0.59 * a.imageData[b + 1] + 0.11 * a.imageData[b + 2];
            a.pixelDepth = 8;
            a.type = 3;
            a.imageData = e
        }
    }
};
cc.tgaDestroy = function(a) {
    a && (a.imageData = null)
};
cc.tgaLoadRLEImageData = function(a, b, c) {
    var d, e, f, g = 0,
        h = 0,
        k = 0,
        m = [],
        n = 0,
        p = 18;
    d = c.pixelDepth / 8;
    e = c.height * c.width;
    for (f = 0; f < e; f++) {
        if (0 !== n) n--, h = 0 !== k;
        else {
            if (p + 1 > b) break;
            n = a[p];
            p += 1;
            (k = n & 128) && (n -= 128);
            h = 0
        }
        if (!h) {
            if (p + d > b) break;
            m = cc.__getSubArray(a, p, p + d);
            p += d;
            3 <= d && (h = m[0], m[0] = m[2], m[2] = h)
        }
        for (h = 0; h < d; h++) c.imageData[g + h] = m[h];
        g += d
    }
    return !0
};
cc.tgaFlipImage = function(a) {
    for (var b = a.pixelDepth / 8 * a.width, c = 0; c < a.height / 2; c++) {
        var d = cc.__getSubArray(a.imageData, c * b, c * b + b);
        cc.__setDataToArray(cc.__getSubArray(a.imageData, (a.height - (c + 1)) * b, b), a.imageData, c * b);
        cc.__setDataToArray(d, a.imageData, (a.height - (c + 1)) * b)
    }
    a.flipped = 0
};
cc.__getSubArray = function(a, b, c) {
    return a instanceof Array ? a.slice(b, c) : a.subarray(b, c)
};
cc.__setDataToArray = function(a, b, c) {
    for (var d = 0; d < a.length; d++) b[c + d] = a[d]
};
cc.BinaryStreamReader = cc.Class.extend({
    _binaryData: null,
    _offset: 0,
    ctor: function(a) {
        this._binaryData = a
    },
    setBinaryData: function(a) {
        this._binaryData = a;
        this._offset = 0
    },
    getBinaryData: function() {
        return this._binaryData
    },
    _checkSize: function(a) {
        if (!(this._offset + Math.ceil(a / 8) < this._data.length)) throw Error("Index out of bound");
    },
    _decodeFloat: function(a, b) {
        var c = a + b + 1,
            d = c >> 3;
        this._checkSize(c);
        var c = Math.pow(2, b - 1) - 1,
            e = this._readBits(a + b, 1, d),
            f = this._readBits(a, b, d),
            g = 0,
            h = 2,
            k = 0;
        do
            for (var m = this._readByte(++k,
                    d), n = a % 8 || 8, p = 1 << n; p >>= 1;) m & p && (g += 1 / h), h *= 2; while (a -= n);
        this._offset += d;
        return f === (c << 1) + 1 ? g ? NaN : e ? -Infinity : Infinity : (1 + -2 * e) * (f || g ? f ? Math.pow(2, f - c) * (1 + g) : Math.pow(2, -c + 1) * g : 0)
    },
    _readByte: function(a, b) {
        return this._data[this._offset + b - a - 1]
    },
    _decodeInt: function(a, b) {
        var c = this._readBits(0, a, a / 8),
            d = Math.pow(2, a);
        this._offset += a / 8;
        return b && c >= d / 2 ? c - d : c
    },
    _shl: function(a, b) {
        for (++b; --b; a = 1073741824 === ((a %= 2147483648) & 1073741824) ? 2 * a : 2 * (a - 1073741824) + 2147483648);
        return a
    },
    _readBits: function(a, b, c) {
        var d =
            (a + b) % 8,
            e = a % 8,
            f = c - (a >> 3) - 1;
        a = c + (-(a + b) >> 3);
        var g = f - a;
        b = this._readByte(f, c) >> e & (1 << (g ? 8 - e : b)) - 1;
        for (g && d && (b += (this._readByte(a++, c) & (1 << d) - 1) << (g-- << 3) - e); g;) b += this._shl(this._readByte(a++, c), (g-- << 3) - e);
        return b
    },
    readInteger: function() {
        return this._decodeInt(32, !0)
    },
    readUnsignedInteger: function() {
        return this._decodeInt(32, !1)
    },
    readSingle: function() {
        return this._decodeFloat(23, 8)
    },
    readShort: function() {
        return this._decodeInt(16, !0)
    },
    readUnsignedShort: function() {
        return this._decodeInt(16, !1)
    },
    readByte: function() {
        var a =
            this._data[this._offset];
        this._offset += 1;
        return a
    },
    readData: function(a, b) {
        return this._binaryData instanceof Array ? this._binaryData.slice(a, b) : this._binaryData.subarray(a, b)
    },
    setOffset: function(a) {
        this._offset = a
    },
    getOffset: function() {
        return this._offset
    }
});
cc.TMX_ORIENTATION_ORTHO = 0;
cc.TMX_ORIENTATION_HEX = 1;
cc.TMX_ORIENTATION_ISO = 2;
cc.TMXTiledMap = cc.Node.extend({
    properties: null,
    mapOrientation: null,
    objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _tileProperties: null,
    _className: "TMXTiledMap",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height =
            a
    },
    getMapOrientation: function() {
        return this.mapOrientation
    },
    setMapOrientation: function(a) {
        this.mapOrientation = a
    },
    getObjectGroups: function() {
        return this.objectGroups
    },
    setObjectGroups: function(a) {
        this.objectGroups = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        if (!a || 0 === a.length) throw Error("cc.TMXTiledMap.initWithTMXFile(): tmxFile should be non-null or non-empty string.");
        this.height = this.width = 0;
        a = new cc.TMXMapInfo(a);
        if (!a) return !1;
        var b = a.getTilesets();
        b && 0 !== b.length || cc.log("cc.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.");
        this._buildWithMapInfo(a);
        return !0
    },
    initWithXML: function(a, b) {
        this.height = this.width = 0;
        var c = new cc.TMXMapInfo(a, b),
            d = c.getTilesets();
        d && 0 !== d.length || cc.log("cc.TMXTiledMap.initWithXML(): Map not found. Please check the filename.");
        this._buildWithMapInfo(c);
        return !0
    },
    _buildWithMapInfo: function(a) {
        this._mapSize = a.getMapSize();
        this._tileSize = a.getTileSize();
        this.mapOrientation =
            a.orientation;
        this.objectGroups = a.getObjectGroups();
        this.properties = a.properties;
        this._tileProperties = a.getTileProperties();
        var b = 0,
            c = a.getLayers();
        if (c)
            for (var d = null, e = 0, f = c.length; e < f; e++)(d = c[e]) && d.visible && (d = this._parseLayer(d, a), this.addChild(d, b, b), this.width = Math.max(this.width, d.width), this.height = Math.max(this.height, d.height), b++)
    },
    allLayers: function() {
        for (var a = [], b = this._children, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            e && e instanceof cc.TMXLayer && a.push(e)
        }
        return a
    },
    getLayer: function(a) {
        if (!a ||
            0 === a.length) throw Error("cc.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.");
        for (var b = this._children, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.layerName === a) return d
        }
        return null
    },
    getObjectGroup: function(a) {
        if (!a || 0 === a.length) throw Error("cc.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.");
        if (this.objectGroups)
            for (var b = 0; b < this.objectGroups.length; b++) {
                var c = this.objectGroups[b];
                if (c && c.groupName === a) return c
            }
        return null
    },
    getProperty: function(a) {
        return this.properties[a.toString()]
    },
    propertiesForGID: function(a) {
        cc.log("propertiesForGID is deprecated. Please use getPropertiesForGID instead.");
        return this.getPropertiesForGID[a]
    },
    getPropertiesForGID: function(a) {
        return this._tileProperties[a]
    },
    _parseLayer: function(a, b) {
        var c = this._tilesetForLayer(a, b),
            c = new cc.TMXLayer(c, a, b);
        a.ownTiles = !1;
        c.setupTiles();
        return c
    },
    _tilesetForLayer: function(a, b) {
        var c = a._layerSize,
            d = b.getTilesets();
        if (d)
            for (var e = d.length - 1; 0 <= e; e--) {
                var f = d[e];
                if (f)
                    for (var g = 0; g < c.height; g++)
                        for (var h = 0; h < c.width; h++) {
                            var k =
                                a._tiles[h + c.width * g];
                            if (0 !== k && (k & cc.TMX_TILE_FLIPPED_MASK) >>> 0 >= f.firstGid) return f
                        }
            }
        cc.log("cocos2d: Warning: TMX Layer " + a.name + " has no tiles");
        return null
    }
});
_p = cc.TMXTiledMap.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXTiledMap.create = function(a, b) {
    return new cc.TMXTiledMap(a, b)
};
cc.TMX_PROPERTY_NONE = 0;
cc.TMX_PROPERTY_MAP = 1;
cc.TMX_PROPERTY_LAYER = 2;
cc.TMX_PROPERTY_OBJECTGROUP = 3;
cc.TMX_PROPERTY_OBJECT = 4;
cc.TMX_PROPERTY_TILE = 5;
cc.TMX_TILE_HORIZONTAL_FLAG = 2147483648;
cc.TMX_TILE_VERTICAL_FLAG = 1073741824;
cc.TMX_TILE_DIAGONAL_FLAG = 536870912;
cc.TMX_TILE_FLIPPED_ALL = (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_DIAGONAL_FLAG) >>> 0;
cc.TMX_TILE_FLIPPED_MASK = ~cc.TMX_TILE_FLIPPED_ALL >>> 0;
cc.TMXLayerInfo = cc.Class.extend({
    properties: null,
    name: "",
    _layerSize: null,
    _tiles: null,
    visible: null,
    _opacity: null,
    ownTiles: !0,
    _minGID: 1E5,
    _maxGID: 0,
    offset: null,
    ctor: function() {
        this.properties = [];
        this.name = "";
        this._layerSize = null;
        this._tiles = [];
        this.visible = !0;
        this._opacity = 0;
        this.ownTiles = !0;
        this._minGID = 1E5;
        this._maxGID = 0;
        this.offset = cc.p(0, 0)
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    }
});
cc.TMXTilesetInfo = cc.Class.extend({
    name: "",
    firstGid: 0,
    _tileSize: null,
    spacing: 0,
    margin: 0,
    sourceImage: "",
    imageSize: null,
    ctor: function() {
        this._tileSize = cc.size(0, 0);
        this.imageSize = cc.size(0, 0)
    },
    rectForGID: function(a) {
        var b = cc.rect(0, 0, 0, 0);
        b.width = this._tileSize.width;
        b.height = this._tileSize.height;
        a &= cc.TMX_TILE_FLIPPED_MASK;
        a -= parseInt(this.firstGid, 10);
        var c = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        b.x = parseInt(a % c * (this._tileSize.width + this.spacing) +
            this.margin, 10);
        b.y = parseInt(parseInt(a / c, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
        return b
    }
});
cc.TMXMapInfo = cc.SAXParser.extend({
    properties: null,
    orientation: null,
    parentElement: null,
    parentGID: null,
    layerAttrs: 0,
    storingCharacters: !1,
    tmxFileName: null,
    currentString: null,
    _objectGroups: null,
    _mapSize: null,
    _tileSize: null,
    _layers: null,
    _tilesets: null,
    _tileProperties: null,
    _resources: "",
    _currentFirstGID: 0,
    ctor: function(a, b) {
        cc.SAXParser.prototype.ctor.apply(this);
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
        this._layers = [];
        this._tilesets = [];
        this._objectGroups = [];
        this.properties = [];
        this._tileProperties = {};
        this._currentFirstGID = 0;
        void 0 !== b ? this.initWithXML(a, b) : void 0 !== a && this.initWithTMXFile(a)
    },
    getOrientation: function() {
        return this.orientation
    },
    setOrientation: function(a) {
        this.orientation = a
    },
    getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height)
    },
    setMapSize: function(a) {
        this._mapSize.width = a.width;
        this._mapSize.height = a.height
    },
    _getMapWidth: function() {
        return this._mapSize.width
    },
    _setMapWidth: function(a) {
        this._mapSize.width = a
    },
    _getMapHeight: function() {
        return this._mapSize.height
    },
    _setMapHeight: function(a) {
        this._mapSize.height = a
    },
    getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height)
    },
    setTileSize: function(a) {
        this._tileSize.width = a.width;
        this._tileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._tileSize.width
    },
    _setTileWidth: function(a) {
        this._tileSize.width = a
    },
    _getTileHeight: function() {
        return this._tileSize.height
    },
    _setTileHeight: function(a) {
        this._tileSize.height = a
    },
    getLayers: function() {
        return this._layers
    },
    setLayers: function(a) {
        this._layers.push(a)
    },
    getTilesets: function() {
        return this._tilesets
    },
    setTilesets: function(a) {
        this._tilesets.push(a)
    },
    getObjectGroups: function() {
        return this._objectGroups
    },
    setObjectGroups: function(a) {
        this._objectGroups.push(a)
    },
    getParentElement: function() {
        return this.parentElement
    },
    setParentElement: function(a) {
        this.parentElement = a
    },
    getParentGID: function() {
        return this.parentGID
    },
    setParentGID: function(a) {
        this.parentGID = a
    },
    getLayerAttribs: function() {
        return this.layerAttrs
    },
    setLayerAttribs: function(a) {
        this.layerAttrs = a
    },
    getStoringCharacters: function() {
        return this.storingCharacters
    },
    setStoringCharacters: function(a) {
        this.storingCharacters = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTMXFile: function(a) {
        this._internalInit(a, null);
        return this.parseXMLFile(a)
    },
    initWithXML: function(a, b) {
        this._internalInit(null, b);
        return this.parseXMLString(a)
    },
    parseXMLFile: function(a, b) {
        var c = (b = b || !1) ? a : cc.loader.getRes(a);
        if (!c) throw Error("Please load the resource first : " + a);
        var d, e, c = this._parseXML(c).documentElement;
        d = c.getAttribute("version");
        e = c.getAttribute("orientation");
        if ("map" === c.nodeName && ("1.0" !== d && null !== d && cc.log("cocos2d: TMXFormat: Unsupported TMX version:" + d), "orthogonal" === e ? this.orientation = cc.TMX_ORIENTATION_ORTHO : "isometric" === e ? this.orientation = cc.TMX_ORIENTATION_ISO : "hexagonal" === e ? this.orientation = cc.TMX_ORIENTATION_HEX : null !== e && cc.log("cocos2d: TMXFomat: Unsupported orientation:" + e), d = cc.size(0, 0), d.width = parseFloat(c.getAttribute("width")), d.height = parseFloat(c.getAttribute("height")), this.setMapSize(d), d = cc.size(0,
                0), d.width = parseFloat(c.getAttribute("tilewidth")), d.height = parseFloat(c.getAttribute("tileheight")), this.setTileSize(d), e = c.querySelectorAll("map \x3e properties \x3e  property"))) {
            var f = {};
            for (d = 0; d < e.length; d++) f[e[d].getAttribute("name")] = e[d].getAttribute("value");
            this.properties = f
        }
        f = c.getElementsByTagName("tileset");
        "map" !== c.nodeName && (f = [], f.push(c));
        for (d = 0; d < f.length; d++) {
            e = f[d];
            var g = e.getAttribute("source");
            if (g) e = b ? cc.path.join(this._resources, g) : cc.path.changeBasename(a, g), this.parseXMLFile(e);
            else {
                g = new cc.TMXTilesetInfo;
                g.name = e.getAttribute("name") || "";
                g.firstGid = parseInt(e.getAttribute("firstgid")) || 0;
                g.spacing = parseInt(e.getAttribute("spacing")) || 0;
                g.margin = parseInt(e.getAttribute("margin")) || 0;
                var h = cc.size(0, 0);
                h.width = parseFloat(e.getAttribute("tilewidth"));
                h.height = parseFloat(e.getAttribute("tileheight"));
                g._tileSize = h;
                var h = e.getElementsByTagName("image")[0].getAttribute("source"),
                    k = -1;
                this.tmxFileName && (k = this.tmxFileName.lastIndexOf("/")); - 1 !== k ? (k = this.tmxFileName.substr(0,
                    k + 1), g.sourceImage = k + h) : g.sourceImage = this._resources + (this._resources ? "/" : "") + h;
                this.setTilesets(g);
                if (h = e.getElementsByTagName("tile"))
                    for (k = 0; k < h.length; k++) {
                        e = h[k];
                        this.parentGID = parseInt(g.firstGid) + parseInt(e.getAttribute("id") || 0);
                        var m = e.querySelectorAll("properties \x3e property");
                        if (m) {
                            var n = {};
                            for (e = 0; e < m.length; e++) {
                                var p = m[e].getAttribute("name");
                                n[p] = m[e].getAttribute("value")
                            }
                            this._tileProperties[this.parentGID] = n
                        }
                    }
            }
        }
        if (f = c.getElementsByTagName("layer"))
            for (d = 0; d < f.length; d++) {
                h = f[d];
                k = h.getElementsByTagName("data")[0];
                g = new cc.TMXLayerInfo;
                g.name = h.getAttribute("name");
                e = cc.size(0, 0);
                e.width = parseFloat(h.getAttribute("width"));
                e.height = parseFloat(h.getAttribute("height"));
                g._layerSize = e;
                e = h.getAttribute("visible");
                g.visible = "0" != e;
                e = h.getAttribute("opacity") || 1;
                g._opacity = e ? parseInt(255 * parseFloat(e)) : 255;
                g.offset = cc.p(parseFloat(h.getAttribute("x")) || 0, parseFloat(h.getAttribute("y")) || 0);
                m = "";
                for (e = 0; e < k.childNodes.length; e++) m += k.childNodes[e].nodeValue;
                m = m.trim();
                e = k.getAttribute("compression");
                n = k.getAttribute("encoding");
                if (e && "gzip" !== e && "zlib" !== e) return cc.log("cc.TMXMapInfo.parseXMLFile(): unsupported compression method"), null;
                switch (e) {
                    case "gzip":
                        g._tiles = cc.unzipBase64AsArray(m, 4);
                        break;
                    case "zlib":
                        e = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(m, 1));
                        g._tiles = cc.uint8ArrayToUint32Array(e.decompress());
                        break;
                    case null:
                    case "":
                        if ("base64" === n) g._tiles = cc.Codec.Base64.decodeAsArray(m, 4);
                        else if ("csv" === n)
                            for (g._tiles = [], e = m.split(","), k = 0; k < e.length; k++) g._tiles.push(parseInt(e[k]));
                        else
                            for (e = k.getElementsByTagName("tile"), g._tiles = [], k = 0; k < e.length; k++) g._tiles.push(parseInt(e[k].getAttribute("gid")));
                        break;
                    default:
                        this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE && cc.log("cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported")
                }
                if (h = h.querySelectorAll("properties \x3e property")) {
                    k = {};
                    for (e = 0; e < h.length; e++) k[h[e].getAttribute("name")] = h[e].getAttribute("value");
                    g.properties = k
                }
                this.setLayers(g)
            }
        if (f = c.getElementsByTagName("objectgroup"))
            for (d = 0; d < f.length; d++) {
                h =
                    f[d];
                g = new cc.TMXObjectGroup;
                g.groupName = h.getAttribute("name");
                g.setPositionOffset(cc.p(parseFloat(h.getAttribute("x")) * this.getTileSize().width || 0, parseFloat(h.getAttribute("y")) * this.getTileSize().height || 0));
                if (k = h.querySelectorAll("objectgroup \x3e properties \x3e property"))
                    for (e = 0; e < k.length; e++) m = {}, m[k[e].getAttribute("name")] = k[e].getAttribute("value"), g.properties = m;
                h = h.querySelectorAll("object");
                k = cc.director.getContentScaleFactor();
                if (h)
                    for (e = 0; e < h.length; e++) {
                        n = h[e];
                        m = {};
                        m.name = n.getAttribute("name") ||
                            "";
                        m.type = n.getAttribute("type") || "";
                        m.width = parseInt(n.getAttribute("width")) || 0;
                        m.height = parseInt(n.getAttribute("height")) || 0;
                        m.x = (((n.getAttribute("x") || 0) | 0) + g.getPositionOffset().x) / k;
                        p = ((n.getAttribute("y") || 0) | 0) + g.getPositionOffset().y / k;
                        m.y = (parseInt(this.getMapSize().height * this.getTileSize().height) - p - m.height) / cc.director.getContentScaleFactor();
                        m.rotation = parseInt(n.getAttribute("rotation")) || 0;
                        if (p = n.querySelectorAll("properties \x3e property"))
                            for (var s = 0; s < p.length; s++) m[p[s].getAttribute("name")] =
                                p[s].getAttribute("value");
                        (p = n.querySelectorAll("polygon")) && 0 < p.length && (p = p[0].getAttribute("points")) && (m.points = this._parsePointsString(p));
                        (n = n.querySelectorAll("polyline")) && 0 < n.length && (n = n[0].getAttribute("points")) && (m.polylinePoints = this._parsePointsString(n));
                        g.setObjects(m)
                    }
                this.setObjectGroups(g)
            }
        return c
    },
    _parsePointsString: function(a) {
        if (!a) return null;
        var b = [];
        a = a.split(" ");
        for (var c = 0; c < a.length; c++) {
            var d = a[c].split(",");
            b.push({
                x: d[0],
                y: d[1]
            })
        }
        return b
    },
    parseXMLString: function(a) {
        return this.parseXMLFile(a, !0)
    },
    getTileProperties: function() {
        return this._tileProperties
    },
    setTileProperties: function(a) {
        this._tileProperties.push(a)
    },
    getCurrentString: function() {
        return this.currentString
    },
    setCurrentString: function(a) {
        this.currentString = a
    },
    getTMXFileName: function() {
        return this.tmxFileName
    },
    setTMXFileName: function(a) {
        this.tmxFileName = a
    },
    _internalInit: function(a, b) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this.tmxFileName = a;
        b && (this._resources = b);
        this._objectGroups.length = 0;
        this.properties.length = 0;
        this._tileProperties.length =
            0;
        this.currentString = "";
        this.storingCharacters = !1;
        this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
        this.parentElement = cc.TMX_PROPERTY_NONE;
        this._currentFirstGID = 0
    }
});
_p = cc.TMXMapInfo.prototype;
cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXMapInfo.create = function(a, b) {
    return new cc.TMXMapInfo(a, b)
};
cc.loader.register(["tmx", "tsx"], cc._txtLoader);
cc.TMXLayerInfo.ATTRIB_NONE = 1;
cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
cc.TMXLayerInfo.ATTRIB_GZIP = 4;
cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
cc.TMXObjectGroup = cc.Class.extend({
    properties: null,
    groupName: "",
    _positionOffset: null,
    _objects: null,
    ctor: function() {
        this.groupName = "";
        this._positionOffset = cc.p(0, 0);
        this.properties = [];
        this._objects = []
    },
    getPositionOffset: function() {
        return cc.p(this._positionOffset)
    },
    setPositionOffset: function(a) {
        this._positionOffset.x = a.x;
        this._positionOffset.y = a.y
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties.push(a)
    },
    getGroupName: function() {
        return this.groupName.toString()
    },
    setGroupName: function(a) {
        this.groupName = a
    },
    propertyNamed: function(a) {
        return this.properties[a]
    },
    objectNamed: function(a) {
        return this.getObject(a)
    },
    getObject: function(a) {
        if (this._objects && 0 < this._objects.length)
            for (var b = this._objects, c = 0, d = b.length; c < d; c++) {
                var e = b[c].name;
                if (e && e === a) return b[c]
            }
        return null
    },
    getObjects: function() {
        return this._objects
    },
    setObjects: function(a) {
        this._objects.push(a)
    }
});
cc.TMXLayer = cc.SpriteBatchNode.extend({
    tiles: null,
    tileset: null,
    layerOrientation: null,
    properties: null,
    layerName: "",
    _layerSize: null,
    _mapTileSize: null,
    _opacity: 255,
    _minGID: null,
    _maxGID: null,
    _vertexZvalue: null,
    _useAutomaticVertexZ: null,
    _reusedTile: null,
    _atlasIndexArray: null,
    _contentScaleFactor: null,
    _className: "TMXLayer",
    ctor: function(a, b, c) {
        cc.SpriteBatchNode.prototype.ctor.call(this);
        this._descendants = [];
        this._layerSize = cc.size(0, 0);
        this._mapTileSize = cc.size(0, 0);
        void 0 !== c && this.initWithTilesetInfo(a,
            b, c)
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.TMXLayer.CanvasRenderCmd(this) : new cc.TMXLayer.WebGLRenderCmd(this)
    },
    setContentSize: function(a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b);
        this._renderCmd._updateCacheContext(a, b)
    },
    getTexture: function() {
        return this._renderCmd.getTexture()
    },
    getLayerSize: function() {
        return cc.size(this._layerSize.width, this._layerSize.height)
    },
    setLayerSize: function(a) {
        this._layerSize.width = a.width;
        this._layerSize.height =
            a.height
    },
    _getLayerWidth: function() {
        return this._layerSize.width
    },
    _setLayerWidth: function(a) {
        this._layerSize.width = a
    },
    _getLayerHeight: function() {
        return this._layerSize.height
    },
    _setLayerHeight: function(a) {
        this._layerSize.height = a
    },
    getMapTileSize: function() {
        return cc.size(this._mapTileSize.width, this._mapTileSize.height)
    },
    setMapTileSize: function(a) {
        this._mapTileSize.width = a.width;
        this._mapTileSize.height = a.height
    },
    _getTileWidth: function() {
        return this._mapTileSize.width
    },
    _setTileWidth: function(a) {
        this._mapTileSize.width =
            a
    },
    _getTileHeight: function() {
        return this._mapTileSize.height
    },
    _setTileHeight: function(a) {
        this._mapTileSize.height = a
    },
    getTiles: function() {
        return this.tiles
    },
    setTiles: function(a) {
        this.tiles = a
    },
    getTileset: function() {
        return this.tileset
    },
    setTileset: function(a) {
        this.tileset = a
    },
    getLayerOrientation: function() {
        return this.layerOrientation
    },
    setLayerOrientation: function(a) {
        this.layerOrientation = a
    },
    getProperties: function() {
        return this.properties
    },
    setProperties: function(a) {
        this.properties = a
    },
    initWithTilesetInfo: function(a,
        b, c) {
        var d = b._layerSize,
            e = 0.35 * parseInt(d.width * d.height) + 1,
            f;
        a && (f = cc.textureCache.addImage(a.sourceImage));
        return this.initWithTexture(f, e) ? (this.layerName = b.name, this._layerSize = d, this.tiles = b._tiles, this._minGID = b._minGID, this._maxGID = b._maxGID, this._opacity = b._opacity, this.properties = b.properties, this._contentScaleFactor = cc.director.getContentScaleFactor(), this.tileset = a, this._mapTileSize = c.getTileSize(), this.layerOrientation = c.orientation, a = this._calculateLayerOffset(b.offset), this.setPosition(cc.pointPixelsToPoints(a)),
            this._atlasIndexArray = [], this.setContentSize(cc.sizePixelsToPoints(cc.size(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height))), this._useAutomaticVertexZ = !1, this._vertexZvalue = 0, !0) : !1
    },
    releaseMap: function() {
        this.tiles && (this.tiles = null);
        this._atlasIndexArray && (this._atlasIndexArray = null)
    },
    getTileAt: function(a, b) {
        if (!a) throw Error("cc.TMXLayer.getTileAt(): pos should be non-null");
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height ||
            0 > a.x || 0 > a.y) throw Error("cc.TMXLayer.getTileAt(): invalid position");
        if (!this.tiles || !this._atlasIndexArray) return cc.log("cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released"), null;
        var c = null,
            d = this.getTileGIDAt(a);
        if (0 === d) return c;
        var e = 0 | a.x + a.y * this._layerSize.width,
            c = this.getChildByTag(e);
        c || (d = this.tileset.rectForGID(d), d = cc.rectPixelsToPoints(d), c = new cc.Sprite, c.initWithTexture(this.texture, d), c.batchNode = this, c.setPosition(this.getPositionAt(a)), c.vertexZ = this._vertexZForPos(a),
            c.anchorX = 0, c.anchorY = 0, c.opacity = this._opacity, d = this._atlasIndexForExistantZ(e), this.addSpriteWithoutQuad(c, d, e));
        return c
    },
    getTileGIDAt: function(a, b) {
        if (null == a) throw Error("cc.TMXLayer.getTileGIDAt(): pos should be non-null");
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw Error("cc.TMXLayer.getTileGIDAt(): invalid position");
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_MASK) >>>
            0 : (cc.log("cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released"), null)
    },
    getTileFlagsAt: function(a, b) {
        if (!a) throw Error("cc.TMXLayer.getTileFlagsAt(): pos should be non-null");
        void 0 !== b && (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw Error("cc.TMXLayer.getTileFlagsAt(): invalid position");
        return this.tiles && this._atlasIndexArray ? (this.tiles[0 | a.x + a.y * this._layerSize.width] & cc.TMX_TILE_FLIPPED_ALL) >>> 0 : (cc.log("cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released"),
            null)
    },
    setTileGID: function(a, b, c, d) {
        if (!b) throw Error("cc.TMXLayer.setTileGID(): pos should be non-null");
        void 0 !== d ? b = cc.p(b, c) : d = c;
        if (b.x >= this._layerSize.width || b.y >= this._layerSize.height || 0 > b.x || 0 > b.y) throw Error("cc.TMXLayer.setTileGID(): invalid position");
        if (this.tiles && this._atlasIndexArray)
            if (0 !== a && a < this.tileset.firstGid) cc.log("cc.TMXLayer.setTileGID(): invalid gid:" + a);
            else {
                d = d || 0;
                this._setNodeDirtyForCache();
                c = this.getTileFlagsAt(b);
                var e = this.getTileGIDAt(b);
                if (e !== a || c !== d)
                    if (c = (a |
                            d) >>> 0, 0 === a) this.removeTileAt(b);
                    else if (0 === e) this._insertTileForGID(c, b);
                else {
                    var e = b.x + b.y * this._layerSize.width,
                        f = this.getChildByTag(e);
                    f ? (a = this.tileset.rectForGID(a), a = cc.rectPixelsToPoints(a), f.setTextureRect(a, !1), null != d && this._setupTileSprite(f, b, c), this.tiles[e] = c) : this._updateTileForGID(c, b)
                }
            }
        else cc.log("cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released")
    },
    removeTileAt: function(a, b) {
        if (!a) throw Error("cc.TMXLayer.removeTileAt(): pos should be non-null");
        void 0 !== b &&
            (a = cc.p(a, b));
        if (a.x >= this._layerSize.width || a.y >= this._layerSize.height || 0 > a.x || 0 > a.y) throw Error("cc.TMXLayer.removeTileAt(): invalid position");
        if (!this.tiles || !this._atlasIndexArray) cc.log("cc.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released");
        else if (0 !== this.getTileGIDAt(a)) {
            cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
            var c = 0 | a.x + a.y * this._layerSize.width,
                d = this._atlasIndexForExistantZ(c);
            this.tiles[c] = 0;
            this._atlasIndexArray.splice(d, 1);
            if (c =
                this.getChildByTag(c)) cc.SpriteBatchNode.prototype.removeChild.call(this, c, !0);
            else if (cc._renderType === cc.game.RENDER_TYPE_WEBGL && this.textureAtlas.removeQuadAtIndex(d), this._children)
                for (var c = this._children, e = 0, f = c.length; e < f; e++) {
                    var g = c[e];
                    if (g) {
                        var h = g.atlasIndex;
                        h >= d && (g.atlasIndex = h - 1)
                    }
                }
        }
    },
    getPositionAt: function(a, b) {
        void 0 !== b && (a = cc.p(a, b));
        var c = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                c = this._positionForOrthoAt(a);
                break;
            case cc.TMX_ORIENTATION_ISO:
                c = this._positionForIsoAt(a);
                break;
            case cc.TMX_ORIENTATION_HEX:
                c = this._positionForHexAt(a)
        }
        return cc.pointPixelsToPoints(c)
    },
    getProperty: function(a) {
        return this.properties[a]
    },
    setupTiles: function() {
        this._renderCmd.initImageSize();
        this._parseInternalProperties();
        cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
        for (var a = this._layerSize.height, b = this._layerSize.width, c = 0; c < a; c++)
            for (var d = 0; d < b; d++) {
                var e = this.tiles[d + b * c];
                0 !== e && (this._appendTileForGID(e, cc.p(d, c)), this._minGID = Math.min(e, this._minGID),
                    this._maxGID = Math.max(e, this._maxGID))
            }
        this._maxGID >= this.tileset.firstGid && this._minGID >= this.tileset.firstGid || cc.log("cocos2d:TMX: Only 1 tileset per layer is supported")
    },
    addChild: function(a, b, c) {
        cc.log("addChild: is not supported on cc.TMXLayer. Instead use setTileGID or tileAt.")
    },
    removeChild: function(a, b) {
        if (a)
            if (-1 === this._children.indexOf(a)) cc.log("cc.TMXLayer.removeChild(): Tile does not belong to TMXLayer");
            else {
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && this._setNodeDirtyForCache();
                var c = a.atlasIndex;
                this.tiles[this._atlasIndexArray[c]] = 0;
                this._atlasIndexArray.splice(c, 1);
                cc.SpriteBatchNode.prototype.removeChild.call(this, a, b);
                cc.renderer.childrenOrderDirty = !0
            }
    },
    getLayerName: function() {
        return this.layerName
    },
    setLayerName: function(a) {
        this.layerName = a
    },
    _positionForIsoAt: function(a) {
        return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + a.x - a.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - a.x - a.y - 2))
    },
    _positionForOrthoAt: function(a) {
        return cc.p(a.x * this._mapTileSize.width,
            (this._layerSize.height - a.y - 1) * this._mapTileSize.height)
    },
    _positionForHexAt: function(a) {
        return cc.p(a.x * this._mapTileSize.width * 3 / 4, (this._layerSize.height - a.y - 1) * this._mapTileSize.height + (1 === a.x % 2 ? -this._mapTileSize.height / 2 : 0))
    },
    _calculateLayerOffset: function(a) {
        var b = cc.p(0, 0);
        switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ORTHO:
                b = cc.p(a.x * this._mapTileSize.width, -a.y * this._mapTileSize.height);
                break;
            case cc.TMX_ORIENTATION_ISO:
                b = cc.p(this._mapTileSize.width / 2 * (a.x - a.y), this._mapTileSize.height /
                    2 * (-a.x - a.y));
                break;
            case cc.TMX_ORIENTATION_HEX:
                0 === a.x && 0 === a.y || cc.log("offset for hexagonal map not implemented yet")
        }
        return b
    },
    _appendTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            c = cc.rectPixelsToPoints(c),
            d = 0 | b.x + b.y * this._layerSize.width,
            c = this._renderCmd._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexArray.length;
        this.insertQuadFromSprite(c, e);
        this._atlasIndexArray.splice(e, 0, d);
        return c
    },
    _insertTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            c = cc.rectPixelsToPoints(c),
            d = 0 | b.x + b.y * this._layerSize.width,
            c = this._renderCmd._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        var e = this._atlasIndexForNewZ(d);
        this.insertQuadFromSprite(c, e);
        this._atlasIndexArray.splice(e, 0, d);
        if (this._children)
            for (var f = this._children, g = 0, h = f.length; g < h; g++) {
                var k = f[g];
                if (k) {
                    var m = k.atlasIndex;
                    m >= e && (k.atlasIndex = m + 1)
                }
            }
        this.tiles[d] = a;
        return c
    },
    _updateTileForGID: function(a, b) {
        var c = this.tileset.rectForGID(a),
            d = this._contentScaleFactor,
            c = cc.rect(c.x / d, c.y / d, c.width /
                d, c.height / d),
            d = b.x + b.y * this._layerSize.width,
            c = this._renderCmd._reusedTileWithRect(c);
        this._setupTileSprite(c, b, a);
        c.atlasIndex = this._atlasIndexForExistantZ(d);
        c.dirty = !0;
        c.updateTransform();
        this.tiles[d] = a;
        return c
    },
    _parseInternalProperties: function() {
        var a = this.getProperty("cc_vertexz");
        if (a)
            if ("automatic" === a) {
                this._useAutomaticVertexZ = !0;
                var b = this.getProperty("cc_alpha_func"),
                    a = 0;
                b && (a = parseFloat(b));
                cc._renderType === cc.game.RENDER_TYPE_WEBGL && (this.shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLORALPHATEST),
                    b = cc._renderContext.getUniformLocation(this.shaderProgram.getProgram(), cc.UNIFORM_ALPHA_TEST_VALUE_S), this.shaderProgram.use(), this.shaderProgram.setUniformLocationWith1f(b, a))
            } else this._vertexZvalue = parseInt(a, 10)
    },
    _setupTileSprite: function(a, b, c) {
        var d = b.x + b.y * this._layerSize.width;
        a.setPosition(this.getPositionAt(b));
        cc._renderType === cc.game.RENDER_TYPE_WEBGL ? a.vertexZ = this._vertexZForPos(b) : a.tag = d;
        a.anchorX = 0;
        a.anchorY = 0;
        a.opacity = this._opacity;
        cc._renderType === cc.game.RENDER_TYPE_WEBGL && (a.rotation =
            0);
        a.setFlippedX(!1);
        a.setFlippedY(!1);
        (c & cc.TMX_TILE_DIAGONAL_FLAG) >>> 0 ? (a.anchorX = 0.5, a.anchorY = 0.5, a.x = this.getPositionAt(b).x + a.width / 2, a.y = this.getPositionAt(b).y + a.height / 2, b = (c & (cc.TMX_TILE_HORIZONTAL_FLAG | cc.TMX_TILE_VERTICAL_FLAG) >>> 0) >>> 0, b === cc.TMX_TILE_HORIZONTAL_FLAG ? a.rotation = 90 : b === cc.TMX_TILE_VERTICAL_FLAG ? a.rotation = 270 : (a.rotation = b === (cc.TMX_TILE_VERTICAL_FLAG | cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 ? 90 : 270, a.setFlippedX(!0))) : ((c & cc.TMX_TILE_HORIZONTAL_FLAG) >>> 0 && a.setFlippedX(!0), (c &
            cc.TMX_TILE_VERTICAL_FLAG) >>> 0 && a.setFlippedY(!0))
    },
    _vertexZForPos: function(a) {
        var b = 0,
            c = 0;
        if (this._useAutomaticVertexZ) switch (this.layerOrientation) {
            case cc.TMX_ORIENTATION_ISO:
                c = this._layerSize.width + this._layerSize.height;
                b = -(c - (a.x + a.y));
                break;
            case cc.TMX_ORIENTATION_ORTHO:
                b = -(this._layerSize.height - a.y);
                break;
            case cc.TMX_ORIENTATION_HEX:
                cc.log("TMX Hexa zOrder not supported");
                break;
            default:
                cc.log("TMX invalid value")
        } else b = this._vertexZvalue;
        return b
    },
    _atlasIndexForExistantZ: function(a) {
        var b;
        if (this._atlasIndexArray)
            for (var c = this._atlasIndexArray, d = 0, e = c.length; d < e && (b = c[d], b !== a); d++);
        cc.isNumber(b) || cc.log("cc.TMXLayer._atlasIndexForExistantZ(): TMX atlas index not found. Shall not happen");
        return d
    },
    _atlasIndexForNewZ: function(a) {
        for (var b = this._atlasIndexArray, c = 0, d = b.length; c < d && !(a < b[c]); c++);
        return c
    }
});
_p = cc.TMXLayer.prototype;
cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
cc.defineGetterSetter(_p, "layerWidth", _p._getLayerWidth, _p._setLayerWidth);
cc.defineGetterSetter(_p, "layerHeight", _p._getLayerHeight, _p._setLayerHeight);
cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
cc.TMXLayer.create = function(a, b, c) {
    return new cc.TMXLayer(a, b, c)
};
(function() {
    cc.TMXLayer.CanvasRenderCmd = function(a) {
        cc.SpriteBatchNode.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._realWorldTransform = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            tx: 0,
            ty: 0
        };
        var c = cc._canvas;
        a = document.createElement("canvas");
        a.width = c.width;
        a.height = c.height;
        this._cacheCanvas = a;
        this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"));
        c = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        this._cacheTexture = c;
        this._cacheDirty = !1
    };
    var a = cc.TMXLayer.CanvasRenderCmd.prototype =
        Object.create(cc.SpriteBatchNode.CanvasRenderCmd.prototype);
    a.constructor = cc.TMXLayer.CanvasRenderCmd;
    a._setNodeDirtyForCache = function() {
        this._cacheDirty = !0
    };
    a._renderingChildToCache = function() {
        if (this._cacheDirty) {
            var a = this._cacheContext,
                c = a.getContext(),
                d = this._cacheCanvas;
            c.setTransform(1, 0, 0, 1, 0, 0);
            c.clearRect(0, 0, d.width, d.height);
            for (var c = this._node._children, d = 0, e = c.length; d < e; d++)
                if (c[d]) {
                    var f = c[d]._renderCmd;
                    f && (f.rendering(a, 1, 1), f._cacheDirty = !1)
                }
            this._cacheDirty = !1
        }
    };
    a.rendering = function(a,
        c, d) {
        var e = this._displayedOpacity / 255;
        if (!(0 >= e)) {
            var f = this._node;
            this._renderingChildToCache();
            var g = a || cc._renderContext;
            a = g.getContext();
            g.setGlobalAlpha(e);
            (e = this._cacheCanvas) && 0 !== e.width && 0 !== e.height && (g.setTransform(this._realWorldTransform, c, d), g = e.height * d, f.layerOrientation === cc.TMX_ORIENTATION_HEX ? a.drawImage(e, 0, 0, e.width, e.height, 0, -g + 0.5 * f._mapTileSize.height * d, e.width * c, g) : a.drawImage(e, 0, 0, e.width, e.height, 0, -g, e.width * c, g));
            cc.g_NumberOfDraws++
        }
    };
    a._updateCacheContext = function(a,
        c) {
        var d = this._node,
            e = d._contentSize,
            f = this._cacheCanvas,
            g = cc.contentScaleFactor();
        f.width = 0 | 1.5 * e.width * g;
        f.height = 0 | 1.5 * e.height * g;
        d.layerOrientation === cc.TMX_ORIENTATION_HEX ? this._cacheContext.setOffset(0, 0.5 * -d._mapTileSize.height) : this._cacheContext.setOffset(0, 0);
        d = this._cacheTexture._contentSize;
        d.width = f.width;
        d.height = f.height
    };
    a.getTexture = function() {
        return this._cacheTexture
    };
    a.visit = function(a) {
        var c = this._node,
            d, e = c._children;
        if (c._visible && e && 0 !== e.length) {
            if (a = a || this.getParentRenderCmd()) this._curLevel =
                a._curLevel + 1;
            this._syncStatus(a);
            if (this._cacheDirty) {
                a = this._cacheContext;
                var f = this._cacheCanvas,
                    g = a.getContext(),
                    h = c.__instanceId,
                    k = cc.renderer;
                k._turnToCacheMode(h);
                c.sortAllChildren();
                c = 0;
                for (d = e.length; c < d; c++)
                    if (e[c]) {
                        var m = e[c]._renderCmd;
                        m && (m.visit(this), m._cacheDirty = !1)
                    }
                g.setTransform(1, 0, 0, 1, 0, 0);
                g.clearRect(0, 0, f.width, f.height);
                k._renderingToCacheCanvas(a, h);
                this._cacheDirty = !1
            }
            cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0
        }
    };
    a.transform = function(a, c) {
        var d = this.getNodeToParentTransform(),
            e = this._realWorldTransform;
        if (a) {
            var f = a._worldTransform;
            e.a = d.a * f.a + d.b * f.c;
            e.b = d.a * f.b + d.b * f.d;
            e.c = d.c * f.a + d.d * f.c;
            e.d = d.c * f.b + d.d * f.d;
            e.tx = f.a * d.tx + f.c * d.ty + f.tx;
            e.ty = f.d * d.ty + f.ty + f.b * d.tx
        } else e.a = d.a, e.b = d.b, e.c = d.c, e.d = d.d, e.tx = d.tx, e.ty = d.ty;
        if (c && (d = this._node._children) && 0 !== d.length)
            for (e = 0, f = d.length; e < f; e++) d[e]._renderCmd.transform(this, c)
    };
    a.initImageSize = function() {
        this._node.tileset.imageSize = this._texture.getContentSizeInPixels()
    };
    a._reusedTileWithRect = function(a) {
        var c = this._node;
        c._reusedTile = new cc.Sprite;
        c._reusedTile.initWithTexture(this._texture, a, !1);
        c._reusedTile.batchNode = c;
        c._reusedTile.parent = c;
        c._reusedTile._renderCmd._cachedParent = c._renderCmd;
        return c._reusedTile
    }
})();
(function() {
    cc.TMXLayer.WebGLRenderCmd = function(a) {
        cc.SpriteBatchNode.WebGLRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = cc.TMXLayer.WebGLRenderCmd.prototype = Object.create(cc.SpriteBatchNode.WebGLRenderCmd.prototype);
    a.constructor = cc.TMXLayer.WebGLRenderCmd;
    a._updateCacheContext = function() {};
    a.initImageSize = function() {
        this._node.tileset.imageSize = this._textureAtlas.texture.getContentSizeInPixels();
        this._textureAtlas.texture.setAliasTexParameters()
    };
    a._reusedTileWithRect = function(a) {
        var c = this._node;
        c._reusedTile ? (c._reusedTile.batchNode = null, c._reusedTile.setTextureRect(a, !1)) : (c._reusedTile = new cc.Sprite, c._reusedTile.initWithTexture(c.texture, a, !1));
        c._reusedTile.batchNode = c;
        return c._reusedTile
    }
})();
cc.PointObject = cc.Class.extend({
    _ratio: null,
    _offset: null,
    _child: null,
    ctor: function(a, b) {
        this.initWithCCPoint(a, b)
    },
    getRatio: function() {
        return this._ratio
    },
    setRatio: function(a) {
        this._ratio = a
    },
    getOffset: function() {
        return this._offset
    },
    setOffset: function(a) {
        this._offset = a
    },
    getChild: function() {
        return this._child
    },
    setChild: function(a) {
        this._child = a
    },
    initWithCCPoint: function(a, b) {
        this._ratio = a;
        this._offset = b;
        this._child = null;
        return !0
    }
});
cc.PointObject.create = function(a, b) {
    return new cc.PointObject(a, b)
};
cc.ParallaxNode = cc.Node.extend({
    parallaxArray: null,
    _lastPosition: null,
    _className: "ParallaxNode",
    getParallaxArray: function() {
        return this.parallaxArray
    },
    setParallaxArray: function(a) {
        this.parallaxArray = a
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this.parallaxArray = [];
        this._lastPosition = cc.p(-100, -100)
    },
    addChild: function(a, b, c, d) {
        if (3 === arguments.length) cc.log("ParallaxNode: use addChild(child, z, ratio, offset) instead");
        else {
            if (!a) throw Error("cc.ParallaxNode.addChild(): child should be non-null");
            var e = new cc.PointObject(c, d);
            e.setChild(a);
            this.parallaxArray.push(e);
            a.setPosition(this._position.x * c.x + d.x, this._position.y * c.y + d.y);
            cc.Node.prototype.addChild.call(this, a, b, a.tag)
        }
    },
    removeChild: function(a, b) {
        for (var c = this.parallaxArray, d = 0; d < c.length; d++)
            if (c[d].getChild() === a) {
                c.splice(d, 1);
                break
            }
        cc.Node.prototype.removeChild.call(this, a, b)
    },
    removeAllChildren: function(a) {
        this.parallaxArray.length = 0;
        cc.Node.prototype.removeAllChildren.call(this, a)
    },
    _updateParallaxPosition: function() {
        var a = this._absolutePosition();
        if (!cc.pointEqualToPoint(a, this._lastPosition)) {
            for (var b = this.parallaxArray, c = 0, d = b.length; c < d; c++) {
                var e = b[c];
                e.getChild().setPosition(-a.x + a.x * e.getRatio().x + e.getOffset().x, -a.y + a.y * e.getRatio().y + e.getOffset().y)
            }
            this._lastPosition = a
        }
    },
    _absolutePosition: function() {
        for (var a = this._position, b = this; null !== b.parent;) b = b.parent, a = cc.pAdd(a, b.getPosition());
        return a
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParallaxNode.CanvasRenderCmd(this) : new cc.ParallaxNode.WebGLRenderCmd(this)
    }
});
cc.ParallaxNode.create = function() {
    return new cc.ParallaxNode
};
(function() {
    cc.ParallaxNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = cc.ParallaxNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = cc.ParallaxNode.CanvasRenderCmd;
    a.updateStatus = function() {
        this._node._updateParallaxPosition();
        cc.Node.CanvasRenderCmd.prototype.updateStatus.call(this)
    };
    a._syncStatus = function(a) {
        this._node._updateParallaxPosition();
        cc.Node.CanvasRenderCmd.prototype._syncStatus.call(this, a)
    }
})();
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
        cc.ParallaxNode.WebGLRenderCmd = function(a) {
            cc.Node.WebGLRenderCmd.call(this, a);
            this._needDraw = !1
        };
        var a = cc.ParallaxNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        a.constructor = cc.ParallaxNode.WebGLRenderCmd;
        a.updateStatus = function() {
            this._node._updateParallaxPosition();
            cc.Node.WebGLRenderCmd.prototype.updateStatus.call(this)
        };
        a._syncStatus = function(a) {
            this._node._updateParallaxPosition();
            cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, a)
        }
    }
});
(function() {
    var a = cc.sys,
        b = a.browserVersion,
        c = !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext),
        d = {
            common: {
                MULTI_CHANNEL: !0,
                WEB_AUDIO: c,
                AUTOPLAY: !0
            }
        };
    d[a.BROWSER_TYPE_IE] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: c,
        AUTOPLAY: !0,
        USE_EMPTIED_EVENT: !0
    };
    d[a.BROWSER_TYPE_ANDROID] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1
    };
    d[a.BROWSER_TYPE_CHROME] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: !0,
        AUTOPLAY: !1
    };
    d[a.BROWSER_TYPE_FIREFOX] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: !0,
        AUTOPLAY: !0,
        DELAY_CREATE_CTX: !0
    };
    d[a.BROWSER_TYPE_UC] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: !1,
        AUTOPLAY: !1
    };
    d[a.BROWSER_TYPE_QQ] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !0
    };
    d[a.BROWSER_TYPE_OUPENG] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    };
    d[a.BROWSER_TYPE_WECHAT] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    };
    d[a.BROWSER_TYPE_360] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !0
    };
    d[a.BROWSER_TYPE_MIUI] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !0
    };
    d[a.BROWSER_TYPE_LIEBAO] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    };
    d[a.BROWSER_TYPE_SOUGOU] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    };
    d[a.BROWSER_TYPE_BAIDU] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    };
    d[a.BROWSER_TYPE_BAIDU_APP] = {
        MULTI_CHANNEL: !1,
        WEB_AUDIO: !1,
        AUTOPLAY: !1,
        REPLAY_AFTER_TOUCH: !0,
        USE_EMPTIED_EVENT: !0
    };
    d[a.BROWSER_TYPE_SAFARI] = {
        MULTI_CHANNEL: !0,
        WEB_AUDIO: !0,
        AUTOPLAY: !1,
        webAudioCallback: function(a) {
            document.createElement("audio").src =
                a
        }
    };
    if (cc.sys.isMobile) window.__audioSupport = cc.sys.os !== cc.sys.OS_IOS ? d[a.browserType] || d.common : d[a.BROWSER_TYPE_SAFARI];
    else switch (a.browserType) {
        case a.BROWSER_TYPE_IE:
            window.__audioSupport = d[a.BROWSER_TYPE_IE];
            break;
        case a.BROWSER_TYPE_FIREFOX:
            window.__audioSupport = d[a.BROWSER_TYPE_FIREFOX];
            break;
        default:
            window.__audioSupport = d.common
    }
    if (b) switch (a.browserType) {
        case a.BROWSER_TYPE_CHROME:
            b = parseInt(b);
            30 > b ? window.__audioSupport = {
                MULTI_CHANNEL: !1,
                WEB_AUDIO: !0,
                AUTOPLAY: !1
            } : 42 === b && (window.__audioSupport.NEED_MANUAL_LOOP = !0);
            break;
        case a.BROWSER_TYPE_MIUI:
            cc.sys.isMobile && (b = b.match(/\d+/g), 2 > b[0] || 2 === b[0] && 0 === b[1] && 1 >= b[2]) && (window.__audioSupport.AUTOPLAY = !1)
    }
})();
cc.Audio = cc.Class.extend({
    volume: 1,
    loop: !1,
    src: null,
    _touch: !1,
    _playing: !1,
    _AUDIO_TYPE: "AUDIO",
    _pause: !1,
    _buffer: null,
    _currentSource: null,
    _startTime: null,
    _currentTime: null,
    _context: null,
    _volume: null,
    _ignoreEnded: !1,
    _manualLoop: !1,
    _element: null,
    ctor: function(a, b, c) {
        a && (this._context = a);
        b && (this._volume = b);
        a && b && (this._AUDIO_TYPE = "WEBAUDIO");
        this.src = c
    },
    _setBufferCallback: null,
    setBuffer: function(a) {
        if (a) {
            var b = this._playing;
            this._AUDIO_TYPE = "WEBAUDIO";
            this._buffer && this._buffer !== a && this.getPlaying() &&
                this.stop();
            this._buffer = a;
            b && this.play();
            this._volume.gain.value = this.volume;
            this._setBufferCallback && this._setBufferCallback(a)
        }
    },
    _setElementCallback: null,
    setElement: function(a) {
        if (a) {
            var b = this._playing;
            this._AUDIO_TYPE = "AUDIO";
            this._element && this._element !== a && this.getPlaying() && this.stop();
            this._element = a;
            b && this.play();
            a.volume = this.volume;
            a.loop = this.loop;
            this._setElementCallback && this._setElementCallback(a)
        }
    },
    play: function(a, b) {
        this._playing = !0;
        this.loop = void 0 === b ? this.loop : b;
        "AUDIO" === this._AUDIO_TYPE ?
            this._playOfAudio(a) : this._playOfWebAudio(a)
    },
    getPlaying: function() {
        if (!this._playing) return !1;
        if ("AUDIO" === this._AUDIO_TYPE) {
            var a = this._element;
            return !a || this._pause || a.ended ? this._playing = !1 : !0
        }
        return (a = this._currentSource) && a.playbackState ? this._currentTime + this._context.currentTime - this._startTime < a.buffer.duration : !0
    },
    _playOfWebAudio: function(a) {
        var b = this._currentSource;
        if (this._buffer) {
            if (!this._pause && b)
                if (0 === this._context.currentTime || this._currentTime + this._context.currentTime - this._startTime >
                    b.buffer.duration) this._stopOfWebAudio();
                else return;
            b = this._context.createBufferSource();
            b.buffer = this._buffer;
            b.connect(this._volume);
            b.loop = this._manualLoop ? !1 : this.loop;
            this._startTime = this._context.currentTime;
            this._currentTime = a || 0;
            this._ignoreEnded = !1;
            if (b.start) b.start(0, a || 0);
            else if (b.noteGrainOn) {
                var c = b.buffer.duration;
                this.loop ? b.noteGrainOn(0, a, c) : b.noteGrainOn(0, a, c - a)
            } else b.noteOn(0);
            this._currentSource = b;
            var d = this;
            b.onended = function() {
                d._manualLoop && d._playing && d.loop ? (d.stop(),
                    d.play()) : d._ignoreEnded ? d._ignoreEnded = !1 : d._pause ? d._playing = !1 : d.stop()
            }
        }
    },
    _playOfAudio: function() {
        var a = this._element;
        a && (a.loop = this.loop, a.play())
    },
    stop: function() {
        this._playing = !1;
        "AUDIO" === this._AUDIO_TYPE ? this._stopOfAudio() : this._stopOfWebAudio()
    },
    _stopOfWebAudio: function() {
        var a = this._currentSource;
        this._ignoreEnded = !0;
        a && (a.stop(0), this._currentSource = null)
    },
    _stopOfAudio: function() {
        var a = this._element;
        a && (a.pause(), a.duration && Infinity !== a.duration && (a.currentTime = 0))
    },
    pause: function() {
        !1 !==
            this.getPlaying() && (this._playing = !1, this._pause = !0, "AUDIO" === this._AUDIO_TYPE ? this._pauseOfAudio() : this._pauseOfWebAudio())
    },
    _pauseOfWebAudio: function() {
        this._currentTime += this._context.currentTime - this._startTime;
        var a = this._currentSource;
        a && a.stop(0)
    },
    _pauseOfAudio: function() {
        var a = this._element;
        a && a.pause()
    },
    resume: function() {
        this._pause && ("AUDIO" === this._AUDIO_TYPE ? this._resumeOfAudio() : this._resumeOfWebAudio(), this._pause = !1, this._playing = !0)
    },
    _resumeOfWebAudio: function() {
        var a = this._currentSource;
        a && (this._startTime = this._context.currentTime, this._playOfWebAudio(this._currentTime % a.buffer.duration))
    },
    _resumeOfAudio: function() {
        var a = this._element;
        a && a.play()
    },
    setVolume: function(a) {
        1 < a && (a = 1);
        0 > a && (a = 0);
        this.volume = a;
        "AUDIO" === this._AUDIO_TYPE ? this._element && (this._element.volume = a) : this._volume && (this._volume.gain.value = a)
    },
    getVolume: function() {
        return this.volume
    },
    cloneNode: function() {
        var a, b;
        if ("AUDIO" === this._AUDIO_TYPE) {
            a = new cc.Audio;
            var c = document.createElement("audio");
            c.src = this.src;
            a.setElement(c)
        } else c = this._context.createGain(), c.gain.value = 1, c.connect(this._context.destination), a = new cc.Audio(this._context, c, this.src), this._buffer ? a.setBuffer(this._buffer) : (b = this, this._setBufferCallback = function(c) {
            a.setBuffer(c);
            b._setBufferCallback = null
        }), a._manualLoop = this._manualLoop;
        a._AUDIO_TYPE = this._AUDIO_TYPE;
        return a
    }
});
(function(a) {
    var b = a.WEB_AUDIO,
        c = a.MULTI_CHANNEL,
        d = a.AUTOPLAY,
        e = [];
    (function() {
        var a = document.createElement("audio");
        if (a.canPlayType) {
            var b = a.canPlayType('audio/ogg; codecs\x3d"vorbis"');
            b && "" !== b && e.push(".ogg");
            (b = a.canPlayType("audio/mpeg")) && "" !== b && e.push(".mp3");
            (b = a.canPlayType('audio/wav; codecs\x3d"1"')) && "" !== b && e.push(".wav");
            (b = a.canPlayType("audio/mp4")) && "" !== b && e.push(".mp4");
            (a = a.canPlayType("audio/x-m4a")) && "" !== a && e.push(".m4a")
        }
    })();
    try {
        if (b) {
            var f = new(window.AudioContext || window.webkitAudioContext ||
                window.mozAudioContext);
            a.DELAY_CREATE_CTX && setTimeout(function() {
                f = new(window.AudioContext || window.webkitAudioContext || window.mozAudioContext)
            }, 0)
        }
    } catch (g) {
        b = !1, cc.log("browser don't support web audio")
    }
    var h = {
        cache: {},
        load: function(c, d, g, k) {
            if (0 === e.length) return k("can not support audio!");
            cc.loader.audioPath && (c = cc.path.join(cc.loader.audioPath, c));
            var r = cc.path.extname(c),
                u = [r];
            for (g = 0; g < e.length; g++) r !== e[g] && u.push(e[g]);
            var t;
            if (h.cache[d]) return k(null, h.cache[d]);
            if (b) try {
                var v = f.createGain();
                v.gain.value = 1;
                v.connect(f.destination);
                t = new cc.Audio(f, v, c);
                a.NEED_MANUAL_LOOP && (t._manualLoop = !0)
            } catch (w) {
                b = !1, cc.log("browser don't support web audio"), t = new cc.Audio(null, null, c)
            } else t = new cc.Audio(null, null, c);
            this.loadAudioFromExtList(c, u, t, k);
            h.cache[d] = t
        },
        loadAudioFromExtList: function(c, d, g, k) {
            if (0 === d.length) {
                var r = "can not found the resource of audio! Last match url is : ",
                    r = r + c.replace(/\.(.*)?$/, "(");
                e.forEach(function(a) {
                    r += a + "|"
                });
                r = r.replace(/\|$/, ")");
                return k({
                        status: 520,
                        errorMessage: r
                    },
                    null)
            }
            c = cc.path.changeExtname(c, d.splice(0, 1));
            if (b) {
                a.webAudioCallback && a.webAudioCallback(c);
                var u = new XMLHttpRequest;
                u.open("GET", c, !0);
                u.responseType = "arraybuffer";
                u.onload = function() {
                    f.decodeAudioData(u.response, function(a) {
                        g.setBuffer(a);
                        k(null, g)
                    }, function() {
                        h.loadAudioFromExtList(c, d, g, k)
                    })
                };
                u.onerror = function() {
                    k({
                        status: 520,
                        errorMessage: r
                    }, null)
                };
                u.send()
            } else {
                var t = document.createElement("audio"),
                    v = !1,
                    w = !1,
                    A = setTimeout(function() {
                        0 === t.readyState ? x() : (w = !0, t.pause(), document.body.removeChild(t),
                            k("audio load timeout : " + c, g))
                    }, 1E4),
                    C = function() {
                        if (!v) {
                            try {
                                t.currentTime = 0, t.volume = 1
                            } catch (a) {}
                            document.body.removeChild(t);
                            g.setElement(t);
                            t.removeEventListener("canplaythrough", C, !1);
                            t.removeEventListener("error", E, !1);
                            t.removeEventListener("emptied", x, !1);
                            !w && k(null, g);
                            v = !0;
                            clearTimeout(A)
                        }
                    },
                    E = function() {
                        v && (document.body.removeChild(t), t.removeEventListener("canplaythrough", C, !1), t.removeEventListener("error", E, !1), t.removeEventListener("emptied", x, !1), !w && h.loadAudioFromExtList(c, d, g, k),
                            v = !0, clearTimeout(A))
                    },
                    x = function() {
                        w = !0;
                        C();
                        k(null, g)
                    };
                t.addEventListener("canplaythrough", C, !1);
                t.addEventListener("error", E, !1);
                a.USE_EMPTIED_EVENT && t.addEventListener("emptied", x, !1);
                t.src = c;
                document.body.appendChild(t);
                t.volume = 0
            }
        }
    };
    cc.loader.register(["mp3", "ogg", "wav", "mp4", "m4a"], h);
    cc.audioEngine = {
        _currMusic: null,
        _musicVolume: 1,
        features: a,
        willPlayMusic: function() {
            return !1
        },
        playMusic: function(a, b) {
            var c = this._currMusic;
            c && c.src !== a && c.getPlaying() && c.stop();
            c = h.cache[a];
            c || (cc.loader.load(a),
                c = h.cache[a]);
            c.play(0, b);
            c.setVolume(this._musicVolume);
            this._currMusic = c
        },
        stopMusic: function(a) {
            var b = this._currMusic;
            b && (b.stop(), a && cc.loader.release(b.src))
        },
        pauseMusic: function() {
            var a = this._currMusic;
            a && a.pause()
        },
        resumeMusic: function() {
            var a = this._currMusic;
            a && a.resume()
        },
        rewindMusic: function() {
            var a = this._currMusic;
            a && (a.stop(), a.play())
        },
        getMusicVolume: function() {
            return this._musicVolume
        },
        setMusicVolume: function(a) {
            a -= 0;
            isNaN(a) && (a = 1);
            1 < a && (a = 1);
            0 > a && (a = 0);
            this._musicVolume = a;
            var b = this._currMusic;
            b && b.setVolume(a)
        },
        isMusicPlaying: function() {
            var a = this._currMusic;
            return a ? a.getPlaying() : !1
        },
        _audioPool: {},
        _maxAudioInstance: 5,
        _effectVolume: 1,
        playEffect: function(a, d) {
            if (!c) return null;
            var e = this._audioPool[a];
            e || (e = this._audioPool[a] = []);
            var f;
            for (f = 0; f < e.length && e[f].getPlaying(); f++);
            if (e[f]) g = e[f], g.setVolume(this._effectVolume), g.play(0, d);
            else if (!b && f > this._maxAudioInstance) cc.log("Error: %s greater than %d", a, this._maxAudioInstance);
            else {
                var g = h.cache[a];
                g || (cc.loader.load(a), g = h.cache[a]);
                g = g.cloneNode();
                g.setVolume(this._effectVolume);
                g.loop = d || !1;
                g.play();
                e.push(g)
            }
            return g
        },
        setEffectsVolume: function(a) {
            a -= 0;
            isNaN(a) && (a = 1);
            1 < a && (a = 1);
            0 > a && (a = 0);
            this._effectVolume = a;
            var b = this._audioPool,
                c;
            for (c in b) {
                var d = b[c];
                if (Array.isArray(d))
                    for (var e = 0; e < d.length; e++) d[e].setVolume(a)
            }
        },
        getEffectsVolume: function() {
            return this._effectVolume
        },
        pauseEffect: function(a) {
            a && a.pause()
        },
        pauseAllEffects: function() {
            var a = this._audioPool,
                b;
            for (b in a)
                for (var c = a[b], d = 0; d < a[b].length; d++) c[d].getPlaying() &&
                    c[d].pause()
        },
        resumeEffect: function(a) {
            a && a.resume()
        },
        resumeAllEffects: function() {
            var a = this._audioPool,
                b;
            for (b in a)
                for (var c = a[b], d = 0; d < a[b].length; d++) c[d].resume()
        },
        stopEffect: function(a) {
            a && a.stop()
        },
        stopAllEffects: function() {
            var a = this._audioPool,
                b;
            for (b in a)
                for (var c = a[b], d = 0; d < a[b].length; d++) c[d].stop()
        },
        unloadEffect: function(a) {
            if (a) {
                cc.loader.release(a);
                var b = this._audioPool[a];
                b && (b.length = 0);
                delete this._audioPool[a];
                delete h.cache[a]
            }
        },
        end: function() {
            this.stopMusic();
            this.stopAllEffects()
        },
        _pauseCache: [],
        _pausePlaying: function() {
            var a = this._currMusic;
            a && a.getPlaying() && (a.pause(), this._pauseCache.push(a));
            var a = this._audioPool,
                b;
            for (b in a)
                for (var c = a[b], d = 0; d < a[b].length; d++) c[d].getPlaying() && (c[d].pause(), this._pauseCache.push(c[d]))
        },
        _resumePlaying: function() {
            for (var a = this._pauseCache, b = 0; b < a.length; b++) a[b].resume();
            a.length = 0
        }
    };
    if (!d) {
        var k = function() {
            var b = cc.audioEngine._currMusic;
            b && !1 === b._touch && b._playing && b.getPlaying() && (b._touch = !0, b.play(0, b.loop), !a.REPLAY_AFTER_TOUCH &&
                cc._canvas.removeEventListener("touchstart", k))
        };
        setTimeout(function() {
            cc._canvas && cc._canvas.addEventListener("touchstart", k, !1)
        }, 150)
    }
})(window.__audioSupport);
cc.ProtectedNode = cc.Node.extend({
    _protectedChildren: null,
    _reorderProtectedChildDirty: !1,
    _insertProtectedChild: function(a, b) {
        this._reorderProtectedChildDirty = !0;
        this._protectedChildren.push(a);
        a._setLocalZOrder(b)
    },
    ctor: function() {
        cc.Node.prototype.ctor.call(this);
        this._protectedChildren = []
    },
    addProtectedChild: function(a, b, c) {
        cc.assert(null != a, "child must be non-nil");
        cc.assert(!a.parent, "child already added. It can't be added again");
        b = b || a.getLocalZOrder();
        c && a.setTag(c);
        this._insertProtectedChild(a,
            b);
        a.setParent(this);
        a.setOrderOfArrival(cc.s_globalOrderOfArrival);
        if (this._running && (a.onEnter(), this._isTransitionFinished)) a.onEnterTransitionDidFinish();
        this._cascadeColorEnabled && this._renderCmd.setCascadeColorEnabledDirty();
        this._cascadeOpacityEnabled && this._renderCmd.setCascadeOpacityEnabledDirty()
    },
    getProtectedChildByTag: function(a) {
        cc.assert(a !== cc.NODE_TAG_INVALID, "Invalid tag");
        for (var b = this._protectedChildren, c = 0, d = b.length; c < d; c++)
            if (b.getTag() === a) return b[c];
        return null
    },
    removeProtectedChild: function(a,
        b) {
        null == b && (b = !0);
        var c = this._protectedChildren;
        if (0 !== c.length) {
            var d = c.indexOf(a); - 1 < d && (this._running && (a.onExitTransitionDidStart(), a.onExit()), b && a.cleanup(), a.setParent(null), c.splice(d, 1))
        }
    },
    removeProtectedChildByTag: function(a, b) {
        cc.assert(a !== cc.NODE_TAG_INVALID, "Invalid tag");
        null == b && (b = !0);
        var c = this.getProtectedChildByTag(a);
        null == c ? cc.log("cocos2d: removeChildByTag(tag \x3d %d): child not found!", a) : this.removeProtectedChild(c, b)
    },
    removeAllProtectedChildren: function() {
        this.removeAllProtectedChildrenWithCleanup(!0)
    },
    removeAllProtectedChildrenWithCleanup: function(a) {
        null == a && (a = !0);
        for (var b = this._protectedChildren, c = 0, d = b.length; c < d; c++) {
            var e = b[c];
            this._running && (e.onExitTransitionDidStart(), e.onExit());
            a && e.cleanup();
            e.setParent(null)
        }
        b.length = 0
    },
    reorderProtectedChild: function(a, b) {
        cc.assert(null != a, "Child must be non-nil");
        this._reorderProtectedChildDirty = !0;
        a.setOrderOfArrival(cc.s_globalOrderOfArrival++);
        a._setLocalZOrder(b)
    },
    sortAllProtectedChildren: function() {
        if (this._reorderProtectedChildDirty) {
            var a =
                this._protectedChildren,
                b = a.length,
                c, d, e;
            for (c = 1; c < b; c++) {
                e = a[c];
                for (d = c - 1; 0 <= d;) {
                    if (e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
                    else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder < a[d].arrivalOrder) a[d + 1] = a[d];
                    else break;
                    d--
                }
                a[d + 1] = e
            }
            this._reorderProtectedChildDirty = !1
        }
    },
    _changePosition: function() {},
    cleanup: function() {
        cc.Node.prototype.cleanup.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].cleanup()
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        for (var a =
                this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].onEnter()
    },
    onEnterTransitionDidFinish: function() {
        cc.Node.prototype.onEnterTransitionDidFinish.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].onEnterTransitionDidFinish()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        for (var a = this._protectedChildren, b = 0, c = a.length; b < c; b++) a[b].onExit()
    },
    onExitTransitionDidStart: function() {
        cc.Node.prototype.onExitTransitionDidStart.call(this);
        for (var a = this._protectedChildren, b =
                0, c = a.length; b < c; b++) a[b].onExitTransitionDidStart()
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ProtectedNode.CanvasRenderCmd(this) : new cc.ProtectedNode.WebGLRenderCmd(this)
    }
});
cc.ProtectedNode.create = function() {
    return new cc.ProtectedNode
};
(function() {
    cc.ProtectedNode.RenderCmd = {
        _updateDisplayColor: function(a) {
            var c = this._node,
                d = this._displayedColor,
                e = c._realColor,
                f, g;
            if (this._cascadeColorEnabledDirty && !c._cascadeColorEnabled) {
                d.r = e.r;
                d.g = e.g;
                d.b = e.b;
                d = new cc.Color(255, 255, 255, 255);
                f = c._children;
                e = 0;
                for (a = f.length; e < a; e++)(g = f[e]) && g._renderCmd && g._renderCmd._updateDisplayColor(d);
                this._cascadeColorEnabledDirty = !1
            } else {
                void 0 === a && (a = (a = c._parent) && a._cascadeColorEnabled ? a.getDisplayedColor() : cc.color.WHITE);
                d.r = 0 | e.r * a.r / 255;
                d.g = 0 |
                    e.g * a.g / 255;
                d.b = 0 | e.b * a.b / 255;
                if (c._cascadeColorEnabled)
                    for (f = c._children, e = 0, a = f.length; e < a; e++)(g = f[e]) && g._renderCmd && (g._renderCmd._updateDisplayColor(d), g._renderCmd._updateColor());
                f = c._protectedChildren;
                e = 0;
                for (a = f.length; e < a; e++)(g = f[e]) && g._renderCmd && (g._renderCmd._updateDisplayColor(d), g._renderCmd._updateColor())
            }
            this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.colorDirty
        },
        _updateDisplayOpacity: function(a) {
            var c = this._node,
                d, e, f;
            if (this._cascadeOpacityEnabledDirty && !c._cascadeOpacityEnabled) {
                this._displayedOpacity =
                    c._realOpacity;
                e = c._children;
                a = 0;
                for (d = e.length; a < d; a++)(f = e[a]) && f._renderCmd && f._renderCmd._updateDisplayOpacity(255);
                this._cascadeOpacityEnabledDirty = !1
            } else {
                void 0 === a && (d = c._parent, a = 255, d && d._cascadeOpacityEnabled && (a = d.getDisplayedOpacity()));
                this._displayedOpacity = c._realOpacity * a / 255;
                if (c._cascadeOpacityEnabled)
                    for (e = c._children, a = 0, d = e.length; a < d; a++)(f = e[a]) && f._renderCmd && (f._renderCmd._updateDisplayOpacity(this._displayedOpacity), f._renderCmd._updateColor());
                e = c._protectedChildren;
                a =
                    0;
                for (d = e.length; a < d; a++)(f = e[a]) && f._renderCmd && (f._renderCmd._updateDisplayOpacity(this._displayedOpacity), f._renderCmd._updateColor())
            }
            this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.opacityDirty
        },
        _changeProtectedChild: function(a) {
            a = a._renderCmd;
            var c = a._dirtyFlag,
                d = cc.Node._dirtyFlags;
            this._dirtyFlag & d.colorDirty && (c |= d.colorDirty);
            this._dirtyFlag & d.opacityDirty && (c |= d.opacityDirty);
            var e = c & d.colorDirty,
                c = c & d.opacityDirty;
            e && a._updateDisplayColor(this._displayedColor);
            c && a._updateDisplayOpacity(this._displayedOpacity);
            (e || c) && a._updateColor()
        }
    };
    cc.ProtectedNode.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._cachedParent = null;
        this._cacheDirty = !1
    };
    var a = cc.ProtectedNode.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    cc.inject(cc.ProtectedNode.RenderCmd, a);
    a.constructor = cc.ProtectedNode.CanvasRenderCmd;
    a.visit = function(a) {
        var c = this._node;
        if (c._visible) {
            var d = c._children,
                e = c._protectedChildren,
                f = c._children.length,
                g = e.length;
            this._syncStatus(a);
            c.sortAllChildren();
            c.sortAllProtectedChildren();
            var h;
            for (a = 0; a < f; a++)
                if (c = d[a], 0 > c._localZOrder) c.visit(this);
                else break;
            for (c = 0; c < g; c++)
                if ((h = e[c]) && 0 > h._localZOrder) this._changeProtectedChild(h), h.visit(this);
                else break;
            for (cc.renderer.pushRenderCommand(this); a < f; a++) d[a] && d[a].visit(this);
            for (; c < g; c++)
                if (h = e[c]) this._changeProtectedChild(h), h.visit(this);
            this._dirtyFlag = 0;
            this._cacheDirty = !1
        }
    };
    a.transform = function(a, c) {
        var d = this._node;
        d._changePosition && d._changePosition();
        var e = d.getNodeToParentTransform(),
            f =
            this._worldTransform;
        if (a) {
            var g = a._worldTransform;
            f.a = e.a * g.a + e.b * g.c;
            f.b = e.a * g.b + e.b * g.d;
            f.c = e.c * g.a + e.d * g.c;
            f.d = e.c * g.b + e.d * g.d;
            f.tx = g.a * e.tx + g.c * e.ty + g.tx;
            f.ty = g.d * e.ty + g.ty + g.b * e.tx
        } else f.a = e.a, f.b = e.b, f.c = e.c, f.d = e.d, f.tx = e.tx, f.ty = e.ty;
        g = d._children;
        if (c && g && 0 !== g.length)
            for (e = 0, f = g.length; e < f; e++) g[e]._renderCmd.transform(this, c);
        g = d._protectedChildren;
        if (c && g && 0 !== g.length)
            for (e = 0, f = g.length; e < f; e++) g[e]._renderCmd.transform(this, c)
    }
})();
(function() {
    if (cc.Node.WebGLRenderCmd) {
        cc.ProtectedNode.WebGLRenderCmd = function(a) {
            cc.Node.WebGLRenderCmd.call(this, a)
        };
        var a = cc.ProtectedNode.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        cc.inject(cc.ProtectedNode.RenderCmd, a);
        a.constructor = cc.ProtectedNode.WebGLRenderCmd;
        a.visit = function(a) {
            var c = this._node;
            if (c._visible) {
                var d, e = cc.current_stack;
                e.stack.push(e.top);
                this._syncStatus(a);
                e.top = this._stackMatrix;
                var f = c.grid;
                f && f._active && f.beforeDraw();
                var g = c._children,
                    h = c._protectedChildren,
                    k = g.length,
                    m = h.length;
                c.sortAllChildren();
                c.sortAllProtectedChildren();
                var n;
                for (a = 0; a < k; a++)
                    if (g[a] && 0 > g[a]._localZOrder) g[a].visit(this);
                    else break;
                for (d = 0; d < m; d++)
                    if ((n = h[d]) && 0 > n._localZOrder) this._changeProtectedChild(n), n.visit(this);
                    else break;
                for (cc.renderer.pushRenderCommand(this); a < k; a++) g[a] && g[a].visit(this);
                for (; d < m; d++)
                    if (n = h[d]) this._changeProtectedChild(n), n.visit(this);
                f && f._active && f.afterDraw(c);
                this._dirtyFlag = 0;
                e.top = e.stack.pop()
            }
        };
        a.transform = function(a,
            c) {
            var d = this._node,
                e = this._transform4x4,
                f = this._stackMatrix,
                g = a ? a._stackMatrix : cc.current_stack.top,
                h = d.getNodeToParentTransform();
            d._changePosition && d._changePosition();
            var k = e.mat;
            k[0] = h.a;
            k[4] = h.c;
            k[12] = h.tx;
            k[1] = h.b;
            k[5] = h.d;
            k[13] = h.ty;
            k[14] = d._vertexZ;
            cc.kmMat4Multiply(f, g, e);
            if (null !== d._camera && (null === d.grid || !d.grid.isActive()))
                if (g = this._anchorPointInPoints.x, h = this._anchorPointInPoints.y, k = 0 !== g || 0 !== h) {
                    cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (g |= 0, h |= 0);
                    var m = cc.math.Matrix4.createByTranslation(g,
                        h, 0, e);
                    f.multiply(k);
                    d._camera._locateForRenderer(f);
                    m = cc.math.Matrix4.createByTranslation(-g, -h, 0, m);
                    f.multiply(m);
                    e.identity()
                } else d._camera._locateForRenderer(f);
            g = d._children;
            if (c && g && 0 !== g.length)
                for (e = 0, f = g.length; e < f; e++) g[e]._renderCmd.transform(this, c);
            g = d._protectedChildren;
            if (c && g && 0 !== g.length)
                for (e = 0, f = g.length; e < f; e++) g[e]._renderCmd.transform(this, c)
        }
    }
})();
var ccui = ccui || {};
ccui.Class = ccui.Class || cc.Class;
ccui.Class.extend = ccui.Class.extend || cc.Class.extend;
ccui.Node = ccui.Node || cc.Node;
ccui.Node.extend = ccui.Node.extend || cc.Node.extend;
ccui.ProtectedNode = ccui.ProtectedNode || cc.ProtectedNode;
ccui.ProtectedNode.extend = ccui.ProtectedNode.extend || cc.ProtectedNode.extend;
ccui.cocosGUIVersion = "CocosGUI v1.0.0.0";
ccui._FocusNavigationController = cc.Class.extend({
    _keyboardListener: null,
    _firstFocusedWidget: null,
    _enableFocusNavigation: !1,
    _keyboardEventPriority: 1,
    enableFocusNavigation: function(a) {
        this._enableFocusNavigation !== a && ((this._enableFocusNavigation = a) ? this._addKeyboardEventListener() : this._removeKeyboardEventListener())
    },
    _setFirstFocsuedWidget: function(a) {
        this._firstFocusedWidget = a
    },
    _onKeyPressed: function(a, b) {
        this._enableFocusNavigation && this._firstFocusedWidget && (a === cc.KEY.dpadDown && (this._firstFocusedWidget =
            this._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.DOWN, this._firstFocusedWidget)), a === cc.KEY.dpadUp && (this._firstFocusedWidget = this._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.UP, this._firstFocusedWidget)), a === cc.KEY.dpadLeft && (this._firstFocusedWidget = this._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.LEFT, this._firstFocusedWidget)), a === cc.KEY.dpadRight && (this._firstFocusedWidget = this._firstFocusedWidget.findNextFocusedWidget(ccui.Widget.RIGHT, this._firstFocusedWidget)))
    },
    _addKeyboardEventListener: function() {
        this._keyboardListener || (this._keyboardListener = cc.EventListener.create({
            event: cc.EventListener.KEYBOARD,
            onKeyReleased: this._onKeyPressed.bind(this)
        }), cc.eventManager.addListener(this._keyboardListener, this._keyboardEventPriority))
    },
    _removeKeyboardEventListener: function() {
        this._keyboardListener && (cc.eventManager.removeEventListener(this._keyboardListener), this._keyboardListener = null)
    }
});
ccui.__LAYOUT_COMPONENT_NAME = "__ui_layout";
ccui.Widget = ccui.ProtectedNode.extend({
    _enabled: !0,
    _bright: !0,
    _touchEnabled: !1,
    _brightStyle: null,
    _touchBeganPosition: null,
    _touchMovePosition: null,
    _touchEndPosition: null,
    _touchEventListener: null,
    _touchEventSelector: null,
    _name: "default",
    _widgetType: null,
    _actionTag: 0,
    _customSize: null,
    _layoutParameterDictionary: null,
    _layoutParameterType: 0,
    _focused: !1,
    _focusEnabled: !0,
    _ignoreSize: !1,
    _affectByClipping: !1,
    _sizeType: null,
    _sizePercent: null,
    _positionType: null,
    _positionPercent: null,
    _hit: !1,
    _nodes: null,
    _touchListener: null,
    _className: "Widget",
    _flippedX: !1,
    _flippedY: !1,
    _opacity: 255,
    _highlight: !1,
    _touchEventCallback: null,
    _clickEventListener: null,
    _propagateTouchEvents: !0,
    _unifySize: !1,
    _callbackName: null,
    _callbackType: null,
    _usingLayoutComponent: !1,
    _inViewRect: !0,
    ctor: function() {
        cc.ProtectedNode.prototype.ctor.call(this);
        this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE;
        this._touchBeganPosition = cc.p(0, 0);
        this._touchMovePosition = cc.p(0, 0);
        this._touchEndPosition = cc.p(0, 0);
        this._widgetType = ccui.Widget.TYPE_WIDGET;
        this._customSize =
            cc.size(0, 0);
        this._layoutParameterDictionary = {};
        this._sizeType = ccui.Widget.SIZE_ABSOLUTE;
        this._sizePercent = cc.p(0, 0);
        this._positionType = ccui.Widget.POSITION_ABSOLUTE;
        this._positionPercent = cc.p(0, 0);
        this._nodes = [];
        this._layoutParameterType = ccui.LayoutParameter.NONE;
        this.init()
    },
    init: function() {
        return cc.ProtectedNode.prototype.init.call(this) ? (this._layoutParameterDictionary = {}, this._initRenderer(), this.setBright(!0), this.onFocusChanged = this.onFocusChange.bind(this), this.onNextFocusedWidget = null, this.setAnchorPoint(cc.p(0.5,
            0.5)), this.ignoreContentAdaptWithSize(!0), !0) : !1
    },
    onEnter: function() {
        var a = this._touchListener;
        a && !a._isRegistered() && this._touchEnabled && cc.eventManager.addListener(a, this);
        this._usingLayoutComponent || this.updateSizeAndPosition();
        cc.ProtectedNode.prototype.onEnter.call(this)
    },
    onExit: function() {
        this.unscheduleUpdate();
        cc.ProtectedNode.prototype.onExit.call(this)
    },
    _getOrCreateLayoutComponent: function() {
        var a = this.getComponent(ccui.__LAYOUT_COMPONENT_NAME);
        null == a && (a = new ccui.LayoutComponent, this.addComponent(a));
        return a
    },
    getWidgetParent: function() {
        var a = this.getParent();
        return a instanceof ccui.Widget ? a : null
    },
    _updateContentSizeWithTextureSize: function(a) {
        this._unifySize ? this.setContentSize(a) : this.setContentSize(this._ignoreSize ? a : this._customSize)
    },
    _isAncestorsEnabled: function() {
        var a = this._getAncensterWidget(this);
        return null == a ? !0 : a && !a.isEnabled() ? !1 : a._isAncestorsEnabled()
    },
    setPropagateTouchEvents: function(a) {
        this._propagateTouchEvents = a
    },
    isPropagateTouchEvents: function() {
        return this._propagateTouchEvents
    },
    setSwallowTouches: function(a) {
        this._touchListener && this._touchListener.setSwallowTouches(a)
    },
    isSwallowTouches: function() {
        return this._touchListener ? this._touchListener.isSwallowTouches() : !1
    },
    _getAncensterWidget: function(a) {
        if (null == a) return null;
        a = a.getParent();
        return null == a ? null : a instanceof ccui.Widget ? a : this._getAncensterWidget(a.getParent())
    },
    _isAncestorsVisible: function(a) {
        return null == a ? !0 : (a = a.getParent()) && !a.isVisible() ? !1 : this._isAncestorsVisible(a)
    },
    _cleanupWidget: function() {
        this._eventDispatcher.removeEventListener(this._touchListener);
        this._touchEnabled = !1;
        this._touchListener = null;
        ccui.Widget._focusedWidget === this && (ccui.Widget._focusedWidget = null, ccui.Widget._focusNavigationController = null)
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    _initRenderer: function() {},
    setContentSize: function(a, b) {
        var c = void 0 === b ? a.width : a,
            d = void 0 === b ? a.height : b;
        cc.Node.prototype.setContentSize.call(this, c, d);
        this._customSize.width = c;
        this._customSize.height = d;
        !this._unifySize && this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        if (!this._usingLayoutComponent &&
            this._running) {
            var e = this.getWidgetParent(),
                e = e ? e.getContentSize() : this._parent.getContentSize();
            this._sizePercent.x = 0 < e.width ? c / e.width : 0;
            this._sizePercent.y = 0 < e.height ? d / e.height : 0
        }
        this._onSizeChanged()
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._customSize.width = a;
        !this._unifySize && this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        !this._usingLayoutComponent && this._running && (a = (a = this.getWidgetParent()) ? a.width : this._parent.width, this._sizePercent.x =
            0 < a ? this._customSize.width / a : 0);
        this._onSizeChanged()
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this, a);
        this._customSize.height = a;
        !this._unifySize && this._ignoreSize && (this._contentSize = this.getVirtualRendererSize());
        !this._usingLayoutComponent && this._running && (a = (a = this.getWidgetParent()) ? a.height : this._parent.height, this._sizePercent.y = 0 < a ? this._customSize.height / a : 0);
        this._onSizeChanged()
    },
    setSizePercent: function(a) {
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            b.setUsingPercentContentSize(!0);
            b.setPercentContentSize(a);
            b.refreshLayout()
        } else {
            this._sizePercent.x = a.x;
            this._sizePercent.y = a.y;
            var b = this._customSize.width,
                c = this._customSize.height;
            this._running && ((c = this.getWidgetParent()) ? (b = c.width * a.x, c = c.height * a.y) : (b = this._parent.width * a.x, c = this._parent.height * a.y));
            this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(b, c);
            this._customSize.width = b;
            this._customSize.height = c
        }
    },
    _setWidthPercent: function(a) {
        this._sizePercent.x =
            a;
        var b = this._customSize.width;
        this._running && (b = this.getWidgetParent(), b = (b ? b.width : this._parent.width) * a);
        this._ignoreSize ? this._setWidth(this.getVirtualRendererSize().width) : this._setWidth(b);
        this._customSize.width = b
    },
    _setHeightPercent: function(a) {
        this._sizePercent.y = a;
        var b = this._customSize.height;
        this._running && (b = this.getWidgetParent(), b = (b ? b.height : this._parent.height) * a);
        this._ignoreSize ? this._setHeight(this.getVirtualRendererSize().height) : this._setHeight(b);
        this._customSize.height = b
    },
    updateSizeAndPosition: function(a) {
        a ||
            (a = (a = this.getWidgetParent()) ? a.getLayoutSize() : this._parent.getContentSize());
        switch (this._sizeType) {
            case ccui.Widget.SIZE_ABSOLUTE:
                this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) : this.setContentSize(this._customSize);
                this._sizePercent.x = 0 < a.width ? this._customSize.width / a.width : 0;
                this._sizePercent.y = 0 < a.height ? this._customSize.height / a.height : 0;
                break;
            case ccui.Widget.SIZE_PERCENT:
                var b = cc.size(a.width * this._sizePercent.x, a.height * this._sizePercent.y);
                this._ignoreSize ? this.setContentSize(this.getVirtualRendererSize()) :
                    this.setContentSize(b);
                this._customSize.width = b.width;
                this._customSize.height = b.height
        }
        this._onSizeChanged();
        b = this.getPosition();
        switch (this._positionType) {
            case ccui.Widget.POSITION_ABSOLUTE:
                0 >= a.width || 0 >= a.height ? this._positionPercent.x = this._positionPercent.y = 0 : (this._positionPercent.x = b.x / a.width, this._positionPercent.y = b.y / a.height);
                break;
            case ccui.Widget.POSITION_PERCENT:
                b = cc.p(a.width * this._positionPercent.x, a.height * this._positionPercent.y)
        }
        if (this._parent instanceof ccui.ImageView && (a = this._parent._imageRenderer) &&
            !a._textureLoaded) return;
        this.setPosition(b)
    },
    setSizeType: function(a) {
        this._sizeType = a;
        this._usingLayoutComponent && this._getOrCreateLayoutComponent().setUsingPercentContentSize(this._sizeType === ccui.SIZE_PERCENT)
    },
    getSizeType: function() {
        return this._sizeType
    },
    ignoreContentAdaptWithSize: function(a) {
        this._unifySize ? this.setContentSize(this._customSize) : this._ignoreSize !== a && (this._ignoreSize = a, this.setContentSize(a ? this.getVirtualRendererSize() : this._customSize))
    },
    isIgnoreContentAdaptWithSize: function() {
        return this._ignoreSize
    },
    getCustomSize: function() {
        return cc.size(this._customSize)
    },
    getLayoutSize: function() {
        return cc.size(this._contentSize)
    },
    getSizePercent: function() {
        this._usingLayoutComponent && (this._sizePercent = this._getOrCreateLayoutComponent().getPercentContentSize());
        return this._sizePercent
    },
    _getWidthPercent: function() {
        return this._sizePercent.x
    },
    _getHeightPercent: function() {
        return this._sizePercent.y
    },
    getWorldPosition: function() {
        return this.convertToWorldSpace(cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y *
            this._contentSize.height))
    },
    getVirtualRenderer: function() {
        return this
    },
    getVirtualRendererSize: function() {
        return cc.size(this._contentSize)
    },
    _onSizeChanged: function() {
        if (!this._usingLayoutComponent)
            for (var a = this.getChildren(), b = 0, c = a.length; b < c; b++) {
                var d = a[b];
                d instanceof ccui.Widget && d.updateSizeAndPosition()
            }
    },
    setTouchEnabled: function(a) {
        this._touchEnabled !== a && ((this._touchEnabled = a) ? (this._touchListener || (this._touchListener = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: this.onTouchBegan.bind(this),
            onTouchMoved: this.onTouchMoved.bind(this),
            onTouchEnded: this.onTouchEnded.bind(this)
        })), cc.eventManager.addListener(this._touchListener, this)) : cc.eventManager.removeListener(this._touchListener))
    },
    isTouchEnabled: function() {
        return this._touchEnabled
    },
    isHighlighted: function() {
        return this._highlight
    },
    setHighlighted: function(a) {
        a !== this._highlight && (this._highlight = a, this._bright ? this._highlight ? this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT) : this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL) :
            this._onPressStateChangedToDisabled())
    },
    isFocused: function() {
        return this._focused
    },
    setFocused: function(a) {
        if (this._focused = a) ccui.Widget._focusedWidget = this, ccui.Widget._focusNavigationController && ccui.Widget._focusNavigationController._setFirstFocsuedWidget(this)
    },
    isFocusEnabled: function() {
        return this._focusEnabled
    },
    setFocusEnabled: function(a) {
        this._focusEnabled = a
    },
    findNextFocusedWidget: function(a, b) {
        if (null === this.onNextFocusedWidget || null == this.onNextFocusedWidget(a)) {
            var c = b instanceof ccui.Layout;
            if (this.isFocused() || c) {
                var d = this.getParent();
                return null !== d && d instanceof ccui.Layout ? d.findNextFocusedWidget(a, b) : c ? b.findNextFocusedWidget(a, b) : b
            }
            return b
        }
        c = this.onNextFocusedWidget(a);
        this.dispatchFocusEvent(this, c);
        return c
    },
    requestFocus: function() {
        this !== ccui.Widget._focusedWidget && this.dispatchFocusEvent(ccui.Widget._focusedWidget, this)
    },
    getCurrentFocusedWidget: function() {
        return ccui.Widget._focusedWidget
    },
    onFocusChanged: null,
    onNextFocusedWidget: null,
    interceptTouchEvent: function(a, b, c) {
        var d =
            this.getWidgetParent();
        d && d.interceptTouchEvent(a, b, c)
    },
    onFocusChange: function(a, b) {
        a && a.setFocused(!1);
        b && b.setFocused(!0)
    },
    dispatchFocusEvent: function(a, b) {
        a && !a.isFocused() && (a = ccui.Widget._focusedWidget);
        if (b !== a) {
            if (b && b.onFocusChanged) b.onFocusChanged(a, b);
            if (a && b.onFocusChanged) a.onFocusChanged(a, b);
            cc.eventManager.dispatchEvent(new cc.EventFocus(a, b))
        }
    },
    setBright: function(a) {
        (this._bright = a) ? (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this.setBrightStyle(ccui.Widget.BRIGHT_STYLE_NORMAL)) :
        this._onPressStateChangedToDisabled()
    },
    setBrightStyle: function(a) {
        if (this._brightStyle !== a) switch (this._brightStyle = a = a || ccui.Widget.BRIGHT_STYLE_NORMAL, this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                this._onPressStateChangedToNormal();
                break;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                this._onPressStateChangedToPressed()
        }
    },
    _onPressStateChangedToNormal: function() {},
    _onPressStateChangedToPressed: function() {},
    _onPressStateChangedToDisabled: function() {},
    _updateChildrenDisplayedRGBA: function() {
        this.setColor(this.getColor());
        this.setOpacity(this.getOpacity())
    },
    didNotSelectSelf: function() {},
    onTouchBegan: function(a, b) {
        this._hit = !1;
        if (this.isVisible() && this.isEnabled() && this._isAncestorsEnabled() && this._isAncestorsVisible(this)) {
            var c = a.getLocation();
            this._touchBeganPosition.x = c.x;
            this._touchBeganPosition.y = c.y;
            this.hitTest(this._touchBeganPosition) && this.isClippingParentContainsPoint(this._touchBeganPosition) && (this._hit = !0)
        }
        if (!this._hit) return !1;
        this.setHighlighted(!0);
        this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_BEGAN,
            this, a);
        this._pushDownEvent();
        return !0
    },
    propagateTouchEvent: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.interceptTouchEvent(a, b, c)
    },
    onTouchMoved: function(a, b) {
        var c = a.getLocation();
        this._touchMovePosition.x = c.x;
        this._touchMovePosition.y = c.y;
        this.setHighlighted(this.hitTest(c));
        this._propagateTouchEvents && this.propagateTouchEvent(ccui.Widget.TOUCH_MOVED, this, a);
        this._moveEvent()
    },
    onTouchEnded: function(a, b) {
        var c = a.getLocation();
        this._touchEndPosition.x = c.x;
        this._touchEndPosition.y = c.y;
        this._propagateTouchEvents &&
            this.propagateTouchEvent(ccui.Widget.TOUCH_ENDED, this, a);
        c = this._highlight;
        this.setHighlighted(!1);
        c ? this._releaseUpEvent() : this._cancelUpEvent()
    },
    onTouchCancelled: function(a) {
        this.setHighlighted(!1);
        this._cancelUpEvent()
    },
    onTouchLongClicked: function(a) {
        this.longClickEvent()
    },
    _pushDownEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_BEGAN);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_BEGAN)
    },
    _moveEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_MOVED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_MOVED)
    },
    _releaseUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_ENDED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_ENDED);
        this._clickEventListener &&
            this._clickEventListener(this)
    },
    _cancelUpEvent: function() {
        this._touchEventCallback && this._touchEventCallback(this, ccui.Widget.TOUCH_CANCELED);
        this._touchEventListener && this._touchEventSelector && this._touchEventSelector.call(this._touchEventListener, this, ccui.Widget.TOUCH_CANCELED)
    },
    longClickEvent: function() {},
    addTouchEventListener: function(a, b) {
        void 0 === b ? this._touchEventCallback = a : (this._touchEventSelector = a, this._touchEventListener = b)
    },
    addClickEventListener: function(a) {
        this._clickEventListener =
            a
    },
    hitTest: function(a) {
        var b = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
        return cc.rectContainsPoint(b, this.convertToNodeSpace(a))
    },
    isClippingParentContainsPoint: function(a) {
        this._affectByClipping = !1;
        for (var b = this.getParent(), c = null; b;) {
            if (b instanceof ccui.Layout && b.isClippingEnabled()) {
                this._affectByClipping = !0;
                c = b;
                break
            }
            b = b.getParent()
        }
        return this._affectByClipping ? c ? c.hitTest(a) ? c.isClippingParentContainsPoint(a) : !1 : !0 : !0
    },
    checkChildInfo: function(a, b, c) {
        var d = this.getWidgetParent();
        d && d.checkChildInfo(a, b, c)
    },
    setPosition: function(a, b) {
        if (!this._usingLayoutComponent && this._running) {
            var c = this.getWidgetParent();
            c && (c = c.getContentSize(), 0 >= c.width || 0 >= c.height ? (this._positionPercent.x = 0, this._positionPercent.y = 0) : void 0 === b ? (this._positionPercent.x = a.x / c.width, this._positionPercent.y = a.y / c.height) : (this._positionPercent.x = a / c.width, this._positionPercent.y = b / c.height))
        }
        cc.Node.prototype.setPosition.call(this, a, b)
    },
    setPositionX: function(a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.width, this._positionPercent.x = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionX.call(this, a)
    },
    setPositionY: function(a) {
        if (this._running) {
            var b = this.getWidgetParent();
            b && (b = b.height, this._positionPercent.y = 0 >= b ? 0 : a / b)
        }
        cc.Node.prototype.setPositionY.call(this, a)
    },
    setPositionPercent: function(a) {
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            b.setPositionPercentX(a.x);
            b.setPositionPercentY(a.y);
            b.refreshLayout()
        } else this._setXPercent(a.x), this._setYPercent(a.y), this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    _setXPercent: function(a) {
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            b.setPositionPercentX(a.x);
            b.refreshLayout()
        } else this._positionPercent.x = a
    },
    _setYPercent: function(a) {
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            b.setPositionPercentY(a.x);
            b.refreshLayout()
        } else this._positionPercent.y = a
    },
    getPositionPercent: function() {
        if (this._usingLayoutComponent) {
            var a = this._getOrCreateLayoutComponent();
            this._positionPercent.x = a.getPositionPercentX();
            this._positionPercent.y =
                a.getPositionPercentY()
        }
        return cc.p(this._positionPercent)
    },
    _getXPercent: function() {
        if (this._usingLayoutComponent) {
            var a = this._getOrCreateLayoutComponent();
            this._positionPercent.x = a.getPositionPercentX();
            this._positionPercent.y = a.getPositionPercentY()
        }
        return this._positionPercent.x
    },
    _getYPercent: function() {
        if (this._usingLayoutComponent) {
            var a = this._getOrCreateLayoutComponent();
            this._positionPercent.x = a.getPositionPercentX();
            this._positionPercent.y = a.getPositionPercentY()
        }
        return this._positionPercent.y
    },
    setPositionType: function(a) {
        this._positionType = a;
        if (this._usingLayoutComponent) {
            var b = this._getOrCreateLayoutComponent();
            a === ccui.POSITION_ABSOLUTE ? (b.setPositionPercentXEnabled(!1), b.setPositionPercentYEnabled(!1)) : (b.setPositionPercentXEnabled(!0), b.setPositionPercentYEnabled(!0))
        }
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    getPositionType: function() {
        return this._positionType
    },
    setFlippedX: function(a) {
        var b = this.getScaleX();
        this._flippedX = a;
        this.setScaleX(b)
    },
    isFlippedX: function() {
        return this._flippedX
    },
    setFlippedY: function(a) {
        var b = this.getScaleY();
        this._flippedY = a;
        this.setScaleY(b)
    },
    isFlippedY: function() {
        return this._flippedY
    },
    _adaptRenderers: function() {},
    isBright: function() {
        return this._bright
    },
    isEnabled: function() {
        return this._enabled
    },
    getLeftBoundary: function() {
        return this.getPositionX() - this._getAnchorX() * this._contentSize.width
    },
    getBottomBoundary: function() {
        return this.getPositionY() - this._getAnchorY() * this._contentSize.height
    },
    getRightBoundary: function() {
        return this.getLeftBoundary() + this._contentSize.width
    },
    getTopBoundary: function() {
        return this.getBottomBoundary() + this._contentSize.height
    },
    getTouchBeganPosition: function() {
        return cc.p(this._touchBeganPosition)
    },
    getTouchMovePosition: function() {
        return cc.p(this._touchMovePosition)
    },
    getTouchEndPosition: function() {
        return cc.p(this._touchEndPosition)
    },
    getWidgetType: function() {
        return this._widgetType
    },
    setLayoutParameter: function(a) {
        a && (this._layoutParameterDictionary[a.getLayoutType()] = a, this._layoutParameterType = a.getLayoutType())
    },
    getLayoutParameter: function(a) {
        a =
            a || this._layoutParameterType;
        return this._layoutParameterDictionary[a]
    },
    getDescription: function() {
        return "Widget"
    },
    clone: function() {
        var a = this._createCloneInstance();
        a._copyProperties(this);
        a._copyClonedWidgetChildren(this);
        return a
    },
    _createCloneInstance: function() {
        return new ccui.Widget
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getChildren();
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            c instanceof ccui.Widget && this.addChild(c.clone())
        }
    },
    _copySpecialProperties: function(a) {},
    _copyProperties: function(a) {
        this.setEnabled(a.isEnabled());
        this.setVisible(a.isVisible());
        this.setBright(a.isBright());
        this.setTouchEnabled(a.isTouchEnabled());
        this.setLocalZOrder(a.getLocalZOrder());
        this.setTag(a.getTag());
        this.setName(a.getName());
        this.setActionTag(a.getActionTag());
        this._ignoreSize = a._ignoreSize;
        this.setContentSize(a._contentSize);
        this._customSize.width = a._customSize.width;
        this._customSize.height = a._customSize.height;
        this._copySpecialProperties(a);
        this._sizeType = a.getSizeType();
        this._sizePercent.x = a._sizePercent.x;
        this._sizePercent.y =
            a._sizePercent.y;
        this._positionType = a._positionType;
        this._positionPercent.x = a._positionPercent.x;
        this._positionPercent.y = a._positionPercent.y;
        this.setPosition(a.getPosition());
        this.setAnchorPoint(a.getAnchorPoint());
        this.setScaleX(a.getScaleX());
        this.setScaleY(a.getScaleY());
        this.setRotation(a.getRotation());
        this.setRotationX(a.getRotationX());
        this.setRotationY(a.getRotationY());
        this.setFlippedX(a.isFlippedX());
        this.setFlippedY(a.isFlippedY());
        this.setColor(a.getColor());
        this.setOpacity(a.getOpacity());
        this._touchEventCallback = a._touchEventCallback;
        this._touchEventListener = a._touchEventListener;
        this._touchEventSelector = a._touchEventSelector;
        this._clickEventListener = a._clickEventListener;
        this._focused = a._focused;
        this._focusEnabled = a._focusEnabled;
        this._propagateTouchEvents = a._propagateTouchEvents;
        for (var b in a._layoutParameterDictionary) {
            var c = a._layoutParameterDictionary[b];
            c && this.setLayoutParameter(c.clone())
        }
        this._onSizeChanged()
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    getLeftInParent: function() {
        cc.log("getLeftInParent is deprecated. Please use getLeftBoundary instead.");
        return this.getLeftBoundary()
    },
    getBottomInParent: function() {
        cc.log("getBottomInParent is deprecated. Please use getBottomBoundary instead.");
        return this.getBottomBoundary()
    },
    getRightInParent: function() {
        cc.log("getRightInParent is deprecated. Please use getRightBoundary instead.");
        return this.getRightBoundary()
    },
    getTopInParent: function() {
        cc.log("getTopInParent is deprecated. Please use getTopBoundary instead.");
        return this.getTopBoundary()
    },
    getTouchEndPos: function() {
        cc.log("getTouchEndPos is deprecated. Please use getTouchEndPosition instead.");
        return this.getTouchEndPosition()
    },
    getTouchMovePos: function() {
        cc.log("getTouchMovePos is deprecated. Please use getTouchMovePosition instead.");
        return this.getTouchMovePosition()
    },
    clippingParentAreaContainPoint: function(a) {
        cc.log("clippingParentAreaContainPoint is deprecated. Please use isClippingParentContainsPoint instead.");
        this.isClippingParentContainsPoint(a)
    },
    getTouchStartPos: function() {
        cc.log("getTouchStartPos is deprecated. Please use getTouchBeganPosition instead.");
        return this.getTouchBeganPosition()
    },
    setSize: function(a) {
        this.setContentSize(a)
    },
    getSize: function() {
        return this.getContentSize()
    },
    addNode: function(a, b, c) {
        a instanceof ccui.Widget ? cc.log("Please use addChild to add a Widget.") : (cc.Node.prototype.addChild.call(this, a, b, c), this._nodes.push(a))
    },
    getNodeByTag: function(a) {
        for (var b = this._nodes, c = 0; c < b.length; c++) {
            var d = b[c];
            if (d && d.getTag() ===
                a) return d
        }
        return null
    },
    getNodes: function() {
        return this._nodes
    },
    removeNode: function(a, b) {
        cc.Node.prototype.removeChild.call(this, a, b);
        cc.arrayRemoveObject(this._nodes, a)
    },
    removeNodeByTag: function(a, b) {
        var c = this.getChildByTag(a);
        c ? this.removeChild(c, b) : cc.log("cocos2d: removeNodeByTag(tag \x3d %d): child not found!", a)
    },
    removeAllNodes: function() {
        for (var a = 0; a < this._nodes.length; a++) cc.Node.prototype.removeChild.call(this, this._nodes[a]);
        this._nodes.length = 0
    },
    _findLayout: function() {
        cc.renderer.childrenOrderDirty = !0;
        for (var a = this._parent; a;)
            if (a._doLayout) {
                a._doLayoutDirty = !0;
                break
            } else a = a._parent
    },
    isUnifySizeEnabled: function() {
        return this._unifySize
    },
    setUnifySizeEnabled: function(a) {
        this._unifySize = a
    },
    _ccEventCallback: null,
    addCCSEventListener: function(a) {
        this._ccEventCallback = a
    },
    setScaleX: function(a) {
        this._flippedX && (a *= -1);
        cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function(a) {
        this._flippedY && (a *= -1);
        cc.Node.prototype.setScaleY.call(this, a)
    },
    setScale: function(a, b) {
        void 0 === b && (b = a);
        this.setScaleX(a);
        this.setScaleY(b)
    },
    getScaleX: function() {
        var a = cc.Node.prototype.getScaleX.call(this);
        this._flippedX && (a *= -1);
        return a
    },
    getScaleY: function() {
        var a = cc.Node.prototype.getScaleY.call(this);
        this._flippedY && (a *= -1);
        return a
    },
    getScale: function() {
        this.getScaleX() !== this.getScaleY() && cc.log("Widget#scale. ScaleX !\x3d ScaleY. Don't know which one to return");
        return this.getScaleX()
    },
    setCallbackName: function(a) {
        this._callbackName = a
    },
    getCallbackName: function() {
        return this._callbackName
    },
    setCallbackType: function(a) {
        this._callbackType =
            a
    },
    getCallbackType: function() {
        return this._callbackType
    },
    setLayoutComponentEnabled: function(a) {
        this._usingLayoutComponent = a
    },
    isLayoutComponentEnabled: function() {
        return this._usingLayoutComponent
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new ccui.Widget.WebGLRenderCmd(this) : new ccui.Widget.CanvasRenderCmd(this)
    }
});
_p = ccui.Widget.prototype;
cc.defineGetterSetter(_p, "xPercent", _p._getXPercent, _p._setXPercent);
cc.defineGetterSetter(_p, "yPercent", _p._getYPercent, _p._setYPercent);
cc.defineGetterSetter(_p, "widthPercent", _p._getWidthPercent, _p._setWidthPercent);
cc.defineGetterSetter(_p, "heightPercent", _p._getHeightPercent, _p._setHeightPercent);
cc.defineGetterSetter(_p, "widgetParent", _p.getWidgetParent);
cc.defineGetterSetter(_p, "enabled", _p.isEnabled, _p.setEnabled);
cc.defineGetterSetter(_p, "focused", _p.isFocused, _p.setFocused);
cc.defineGetterSetter(_p, "sizeType", _p.getSizeType, _p.setSizeType);
cc.defineGetterSetter(_p, "widgetType", _p.getWidgetType);
cc.defineGetterSetter(_p, "touchEnabled", _p.isTouchEnabled, _p.setTouchEnabled);
cc.defineGetterSetter(_p, "updateEnabled", _p.isUpdateEnabled, _p.setUpdateEnabled);
cc.defineGetterSetter(_p, "bright", _p.isBright, _p.setBright);
cc.defineGetterSetter(_p, "name", _p.getName, _p.setName);
cc.defineGetterSetter(_p, "actionTag", _p.getActionTag, _p.setActionTag);
cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
_p = null;
ccui.Widget.create = function() {
    return new ccui.Widget
};
ccui.Widget._focusedWidget = null;
ccui.Widget._focusNavigationController = null;
ccui.Widget.enableDpadNavigation = function(a) {
    a ? (null == ccui.Widget._focusNavigationController && (ccui.Widget._focusNavigationController = new ccui._FocusNavigationController, ccui.Widget._focusedWidget && ccui.Widget._focusNavigationController._setFirstFocsuedWidget(ccui.Widget._focusedWidget)), ccui.Widget._focusNavigationController.enableFocusNavigation(!0)) : ccui.Widget._focusNavigationController && (ccui.Widget._focusNavigationController.enableFocusNavigation(!1), ccui.Widget._focusNavigationController = null)
};
ccui.Widget.getCurrentFocusedWidget = function() {
    return ccui.Widget._focusedWidget
};
ccui.Widget.BRIGHT_STYLE_NONE = -1;
ccui.Widget.BRIGHT_STYLE_NORMAL = 0;
ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT = 1;
ccui.Widget.TYPE_WIDGET = 0;
ccui.Widget.TYPE_CONTAINER = 1;
ccui.Widget.LEFT = 0;
ccui.Widget.RIGHT = 1;
ccui.Widget.UP = 2;
ccui.Widget.DOWN = 3;
ccui.Widget.LOCAL_TEXTURE = 0;
ccui.Widget.PLIST_TEXTURE = 1;
ccui.Widget.TOUCH_BEGAN = 0;
ccui.Widget.TOUCH_MOVED = 1;
ccui.Widget.TOUCH_ENDED = 2;
ccui.Widget.TOUCH_CANCELED = 3;
ccui.Widget.SIZE_ABSOLUTE = 0;
ccui.Widget.SIZE_PERCENT = 1;
ccui.Widget.POSITION_ABSOLUTE = 0;
ccui.Widget.POSITION_PERCENT = 1;
cc.game.addEventListener(cc.game.EVENT_RENDERER_INITED, function() {
    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
        ccui.Widget.CanvasRenderCmd = function(a) {
            cc.ProtectedNode.CanvasRenderCmd.call(this, a);
            this._needDraw = !1
        };
        var a = ccui.Widget.CanvasRenderCmd.prototype = Object.create(cc.ProtectedNode.CanvasRenderCmd.prototype);
        a.constructor = ccui.Widget.CanvasRenderCmd;
        a.visit = function(a) {
            var c = this._node;
            c._visible && (c._adaptRenderers(), cc.ProtectedNode.CanvasRenderCmd.prototype.visit.call(this, a))
        };
        a.transform =
            function(a, c) {
                var d = this._node;
                if (d._visible) {
                    d._adaptRenderers();
                    if (!this._usingLayoutComponent) {
                        var e = d.getWidgetParent();
                        e && (e = e.getContentSize(), 0 !== e.width && 0 !== e.height && (d._position.x = e.width * d._positionPercent.x, d._position.y = e.height * d._positionPercent.y))
                    }
                    cc.ProtectedNode.CanvasRenderCmd.prototype.transform.call(this, a, c)
                }
            }
    } else ccui.Widget.WebGLRenderCmd = function(a) {
            cc.ProtectedNode.WebGLRenderCmd.call(this, a);
            this._needDraw = !1
        }, a = ccui.Widget.WebGLRenderCmd.prototype = Object.create(cc.ProtectedNode.WebGLRenderCmd.prototype),
        a.constructor = ccui.Widget.WebGLRenderCmd, a.visit = function(a) {
            var c = this._node;
            c._visible && (c._adaptRenderers(), cc.ProtectedNode.WebGLRenderCmd.prototype.visit.call(this, a))
        }, a.transform = function(a, c) {
            var d = this._node;
            if (d._visible) {
                d._adaptRenderers();
                if (!this._usingLayoutComponent) {
                    var e = d.getWidgetParent();
                    e && (e = e.getContentSize(), 0 !== e.width && 0 !== e.height && (d._position.x = e.width * d._positionPercent.x, d._position.y = e.height * d._positionPercent.y))
                }
                cc.ProtectedNode.WebGLRenderCmd.prototype.transform.call(this,
                    a, c)
            }
        }
});
ccui.Scale9Sprite = cc.Scale9Sprite = cc.Node.extend({
    _spriteRect: null,
    _capInsetsInternal: null,
    _positionsAreDirty: !1,
    _scale9Image: null,
    _topLeft: null,
    _top: null,
    _topRight: null,
    _left: null,
    _centre: null,
    _right: null,
    _bottomLeft: null,
    _bottom: null,
    _bottomRight: null,
    _scale9Enabled: !0,
    _scale9Dirty: !0,
    _brightState: 0,
    _renderers: null,
    _opacityModifyRGB: !1,
    _originalSize: null,
    _preferredSize: null,
    _opacity: 0,
    _color: null,
    _capInsets: null,
    _insetLeft: 0,
    _insetTop: 0,
    _insetRight: 0,
    _insetBottom: 0,
    _spritesGenerated: !1,
    _spriteFrameRotated: !1,
    _textureLoaded: !1,
    _className: "Scale9Sprite",
    _flippedX: !1,
    _flippedY: !1,
    textureLoaded: function() {
        return this._textureLoaded
    },
    addLoadedEventListener: function(a, b) {
        this.addEventListener("load", a, b)
    },
    _updateCapInset: function() {
        var a;
        a = this._insetLeft;
        var b = this._insetTop,
            c = this._insetRight,
            d = this._spriteRect,
            e = this._insetBottom;
        a = 0 === a && 0 === b && 0 === c && 0 === e ? cc.rect(0, 0, 0, 0) : this._spriteFrameRotated ? cc.rect(e, a, d.width - c - a, d.height - b - e) : cc.rect(a, b, d.width - a - c, d.height - b - e);
        this.setCapInsets(a)
    },
    _updatePositions: function() {
        if (this._topLeft &&
            this._topRight && this._bottomRight && this._bottomLeft && this._centre) {
            var a = this._contentSize,
                b = this._topLeft,
                c = this._topRight,
                d = this._bottomRight,
                e = this._bottomLeft,
                f = this._left,
                g = this._right,
                h = this._top,
                k = this._bottom,
                m = this._centre,
                n = this._centre.getContentSize(),
                p = b.getContentSize(),
                s = e.getContentSize(),
                r = a.width - p.width - c.getContentSize().width,
                a = a.height - p.height - d.getContentSize().height,
                r = r / n.width,
                a = a / n.height,
                p = n.width * r,
                u = n.height * a,
                t = s.width,
                s = s.height,
                v = cc.p(this._offset.x * r, this._offset.y *
                    a);
            if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                var w = Math.round(p);
                p !== w && (p = w, r = p / n.width);
                w = Math.round(u);
                u !== w && (u = w, a = u / n.height)
            }
            m.setScaleX(r);
            m.setScaleY(a);
            e.setAnchorPoint(1, 1);
            e.setPosition(t, s);
            d.setAnchorPoint(0, 1);
            d.setPosition(t + p, s);
            b.setAnchorPoint(1, 0);
            b.setPosition(t, s + u);
            c.setAnchorPoint(0, 0);
            c.setPosition(t + p, s + u);
            f.setAnchorPoint(1, 0.5);
            f.setPosition(t, s + u / 2 + v.y);
            f.setScaleY(a);
            g.setAnchorPoint(0, 0.5);
            g.setPosition(t + p, s + u / 2 + v.y);
            g.setScaleY(a);
            h.setAnchorPoint(0.5, 0);
            h.setPosition(t +
                p / 2 + v.x, s + u);
            h.setScaleX(r);
            k.setAnchorPoint(0.5, 1);
            k.setPosition(t + p / 2 + v.x, s);
            k.setScaleX(r);
            m.setAnchorPoint(0.5, 0.5);
            m.setPosition(t + p / 2 + v.x, s + u / 2 + v.y);
            m.setScaleX(r);
            m.setScaleY(a)
        }
    },
    ctor: function(a, b, c) {
        cc.Node.prototype.ctor.call(this);
        this._spriteRect = cc.rect(0, 0, 0, 0);
        this._capInsetsInternal = cc.rect(0, 0, 0, 0);
        this._originalSize = cc.size(0, 0);
        this._preferredSize = cc.size(0, 0);
        this._capInsets = cc.rect(0, 0, 0, 0);
        this._renderers = [];
        if (void 0 != a)
            if (a instanceof cc.SpriteFrame) this.initWithSpriteFrame(a,
                b);
            else {
                var d = cc.spriteFrameCache.getSpriteFrame(a);
                null != d ? this.initWithSpriteFrame(d, b) : this.initWithFile(a, b, c)
            }
        else this.init()
    },
    getSprite: function() {
        return this._scale9Image
    },
    getOriginalSize: function() {
        return cc.size(this._originalSize)
    },
    getPreferredSize: function() {
        return cc.size(this._preferredSize)
    },
    _getPreferredWidth: function() {
        return this._preferredSize.width
    },
    _getPreferredHeight: function() {
        return this._preferredSize.height
    },
    setPreferredSize: function(a) {
        this.setContentSize(a);
        this._preferredSize =
            a;
        this._positionsAreDirty && (this._updatePositions(), this._positionsAreDirty = !1, this._scale9Dirty = !0)
    },
    _setPreferredWidth: function(a) {
        this._setWidth(a);
        this._preferredSize.width = a
    },
    _setPreferredHeight: function(a) {
        this._setHeight(a);
        this._preferredSize.height = a
    },
    setOpacity: function(a) {
        cc.Node.prototype.setOpacity.call(this, a);
        if (this._scale9Enabled)
            for (var b = this._renderers, c = 0; c < b.length; c++) b[c].setOpacity(a);
        else this._scale9Image && this._scale9Image.setOpacity(a);
        this._scale9Dirty = !0
    },
    setColor: function(a) {
        cc.Node.prototype.setColor.call(this,
            a);
        if (this._scale9Enabled)
            for (var b = this._renderers, c = 0; c < b.length; c++) {
                var d = b[c];
                d && d.setColor(a)
            } else this._scale9Image && this._scale9Image.setColor(a);
        this._scale9Dirty = !0
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setCapInsets: function(a) {
        var b = this._contentSize,
            c = b.width,
            b = b.height;
        this.updateWithSprite(this._scale9Image, this._spriteRect, this._spriteFrameRotated, this._offset, this._originalSize, a);
        this._insetLeft = a.x;
        this._insetTop = a.y;
        this._insetRight = this._originalSize.width -
            this._insetLeft - a.width;
        this._insetBottom = this._originalSize.height - this._insetTop - a.height;
        this.setContentSize(c, b)
    },
    getInsetLeft: function() {
        return this._insetLeft
    },
    setInsetLeft: function(a) {
        this._insetLeft = a;
        this._updateCapInset()
    },
    getInsetTop: function() {
        return this._insetTop
    },
    setInsetTop: function(a) {
        this._insetTop = a;
        this._updateCapInset()
    },
    getInsetRight: function() {
        return this._insetRight
    },
    setInsetRight: function(a) {
        this._insetRight = a;
        this._updateCapInset()
    },
    getInsetBottom: function() {
        return this._insetBottom
    },
    setInsetBottom: function(a) {
        this._insetBottom = a;
        this._updateCapInset()
    },
    setContentSize: function(a, b) {
        cc.Node.prototype.setContentSize.call(this, a, b);
        this._positionsAreDirty = !0
    },
    setAnchorPoint: function(a, b) {
        cc.Node.prototype.setAnchorPoint.call(this, a, b);
        !this._scale9Enabled && this._scale9Image && (this._scale9Image.setAnchorPoint(a, b), this._positionsAreDirty = !0)
    },
    _setWidth: function(a) {
        cc.Node.prototype._setWidth.call(this, a);
        this._positionsAreDirty = !0
    },
    _setHeight: function(a) {
        cc.Node.prototype._setHeight.call(this,
            a);
        this._positionsAreDirty = !0
    },
    init: function() {
        return this.initWithBatchNode(null, cc.rect(0, 0, 0, 0), !1, cc.rect(0, 0, 0, 0))
    },
    initWithBatchNode: function(a, b, c, d) {
        void 0 === d && (d = c, c = !1);
        a && this.updateWithBatchNode(a, b, c, d);
        this.setCascadeColorEnabled(!0);
        this.setCascadeOpacityEnabled(!0);
        this.setAnchorPoint(0.5, 0.5);
        return this._positionsAreDirty = !0
    },
    initWithFile: function(a, b, c) {
        a instanceof cc.Rect ? (c = a = b, b = cc.rect(0, 0, 0, 0)) : (b = b || cc.rect(0, 0, 0, 0), c = c || cc.rect(0, 0, 0, 0));
        if (!a) throw Error("ccui.Scale9Sprite.initWithFile(): file should be non-null");
        var d = cc.textureCache.getTextureForKey(a);
        d || (d = cc.textureCache.addImage(a));
        var e = d.isLoaded();
        (this._textureLoaded = e) || d.addEventListener("load", function(a) {
            var b = this._preferredSize,
                c = 0 !== b.width && 0 !== b.height;
            c && (b = cc.size(b.width, b.height));
            a = a.getContentSize();
            this.updateWithBatchNode(this._scale9Image, cc.rect(0, 0, a.width, a.height), !1, this._capInsets);
            c && this.setPreferredSize(b);
            this._positionsAreDirty = !0;
            this.setNodeDirty();
            this.dispatchEvent("load")
        }, this);
        return this.initWithBatchNode(new cc.SpriteBatchNode(a,
            9), b, !1, c)
    },
    initWithSpriteFrame: function(a, b) {
        if (!a || !a.getTexture()) throw Error("ccui.Scale9Sprite.initWithSpriteFrame(): spriteFrame should be non-null and its texture should be non-null");
        b = b || cc.rect(0, 0, 0, 0);
        var c = a.textureLoaded();
        (this._textureLoaded = c) || a.addEventListener("load", function(a) {
            var b = this._preferredSize,
                c = 0 !== b.width && 0 !== b.height;
            c && (b = cc.size(b.width, b.height));
            this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType === cc.game.RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets);
            c && this.setPreferredSize(b);
            this._positionsAreDirty = !0;
            this.setNodeDirty();
            this.dispatchEvent("load")
        }, this);
        c = new cc.SpriteBatchNode(a.getTexture(), 9);
        return this.initWithBatchNode(c, a.getRect(), cc._renderType === cc.game.RENDER_TYPE_WEBGL && a.isRotated(), b)
    },
    initWithSpriteFrameName: function(a, b) {
        if (!a) throw Error("ccui.Scale9Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null");
        b = b || cc.rect(0, 0, 0, 0);
        var c = cc.spriteFrameCache.getSpriteFrame(a);
        return null == c ? (cc.log("ccui.Scale9Sprite.initWithSpriteFrameName(): can't find the sprite frame by spriteFrameName"), !1) : this.initWithSpriteFrame(c, b)
    },
    resizableSpriteWithCapInsets: function(a) {
        var b = new ccui.Scale9Sprite;
        return b && b.initWithBatchNode(this._scale9Image, this._spriteRect, !1, a) ? b : null
    },
    setOpacityModifyRGB: function(a) {
        if (this._scale9Image) {
            this._opacityModifyRGB = a;
            var b = this._scale9Image.getChildren();
            if (b)
                for (var c = 0, d = b.length; c < d; c++) b[c].setOpacityModifyRGB(a)
        }
    },
    isOpacityModifyRGB: function() {
        return this._opacityModifyRGB
    },
    createSlicedSprites: function() {
        var a = this._originalSize.width,
            b = this._originalSize.height,
            c = this._spriteRect,
            d = Math.floor(this._offset.x + (a - c.width) / 2),
            e = Math.floor(this._offset.y + (b - c.height) / 2),
            f = c.x,
            g = c.y,
            h = this._capInsetsInternal,
            k = this._scale9Image.getTexture(),
            m = this._spriteFrameRotated,
            n = cc.rect(c.x, c.y, c.width, c.height);
        cc._rectEqualToZero(h) && (h = cc.rect(a / 3, b / 3, a / 3, b / 3));
        this._spriteFrameRotated ? (f -= e, g -= d) : (f -= d, g -= e);
        var c = cc.rect(f, g, a, b),
            p = h.x,
            s = h.width,
            r = c.width - (p + s),
            u = h.y,
            t = h.height,
            v = c.height - (u + t),
            w = 0,
            A = 0,
            h = c = cc.rect(w + 0.5 | 0, A + 0.5 | 0, p + 0.5 | 0, u + 0.5 | 0),
            w = w + p,
            a = cc.rect(w +
                0.5 | 0, A + 0.5 | 0, s + 0.5 | 0, u + 0.5 | 0),
            b = cc.rect(w + s + 0.5 | 0, A + 0.5 | 0, r + 0.5 | 0, u + 0.5 | 0),
            w = 0,
            A = 0 + u,
            d = cc.rect(w + 0.5 | 0, A + 0.5 | 0, p + 0.5 | 0, t + 0.5 | 0),
            w = w + p,
            f = e = cc.rect(w + 0.5 | 0, A + 0.5 | 0, s + 0.5 | 0, t + 0.5 | 0),
            w = w + s,
            g = cc.rect(w + 0.5 | 0, A + 0.5 | 0, r + 0.5 | 0, t + 0.5 | 0),
            w = 0,
            A = 0 + u + t,
            u = cc.rect(w + 0.5 | 0, A + 0.5 | 0, p + 0.5 | 0, v + 0.5 | 0),
            w = w + p,
            p = cc.rect(w + 0.5 | 0, A + 0.5 | 0, s + 0.5 | 0, v + 0.5 | 0),
            w = w + s,
            r = s = cc.rect(w + 0.5 | 0, A + 0.5 | 0, r + 0.5 | 0, v + 0.5 | 0),
            v = c,
            w = e,
            A = s,
            t = f,
            C = r,
            E = u,
            x = b,
            B = h,
            z = g,
            D = d,
            G = p,
            F = a,
            y = cc.affineTransformMakeIdentity();
        m ? (y = cc.affineTransformTranslate(y,
                n.height + n.x, n.y), y = cc.affineTransformRotate(y, 1.57079633), c = cc.rectApplyAffineTransform(c, y), e = cc.rectApplyAffineTransform(e, y), s = cc.rectApplyAffineTransform(s, y), f = cc.rectApplyAffineTransform(f, y), r = cc.rectApplyAffineTransform(r, y), u = cc.rectApplyAffineTransform(u, y), b = cc.rectApplyAffineTransform(b, y), h = cc.rectApplyAffineTransform(h, y), g = cc.rectApplyAffineTransform(g, y), d = cc.rectApplyAffineTransform(d, y), p = cc.rectApplyAffineTransform(p, y), a = cc.rectApplyAffineTransform(a, y), v.x = c.x, w.x = e.x, A.x = s.x,
            t.x = f.x, C.x = r.x, E.x = u.x, x.x = b.x, B.x = h.x, z.x = g.x, D.x = d.x, G.x = p.x, F.x = a.x, v.y = c.y, w.y = e.y, A.y = s.y, t.y = f.y, C.y = r.y, E.y = u.y, x.y = b.y, B.y = h.y, z.y = g.y, D.y = d.y, G.y = p.y, F.y = a.y) : (y = cc.affineTransformTranslate(y, n.x, n.y), cc.rectApplyAffineTransform(v, y), cc.rectApplyAffineTransform(w, y), cc.rectApplyAffineTransform(A, y), t = cc.rectApplyAffineTransform(t, y), C = cc.rectApplyAffineTransform(C, y), E = cc.rectApplyAffineTransform(E, y), x = cc.rectApplyAffineTransform(x, y), B = cc.rectApplyAffineTransform(B, y), z = cc.rectApplyAffineTransform(z,
            y), D = cc.rectApplyAffineTransform(D, y), G = cc.rectApplyAffineTransform(G, y), F = cc.rectApplyAffineTransform(F, y));
        this._centre || (this._centre = new cc.Sprite);
        this._centre.initWithTexture(k, t, m);
        0 < t.width && 0 < t.height && this._renderers.push(this._centre);
        this._top || (this._top = new cc.Sprite);
        this._top.initWithTexture(k, F, m);
        0 < F.width && 0 < F.height && this._renderers.push(this._top);
        this._bottom || (this._bottom = new cc.Sprite);
        this._bottom.initWithTexture(k, G, m);
        0 < G.width && 0 < G.height && this._renderers.push(this._bottom);
        this._left || (this._left = new cc.Sprite);
        this._left.initWithTexture(k, D, m);
        0 < D.width && 0 < D.height && this._renderers.push(this._left);
        this._right || (this._right = new cc.Sprite);
        this._right.initWithTexture(k, z, m);
        0 < z.width && 0 < z.height && this._renderers.push(this._right);
        this._topLeft || (this._topLeft = new cc.Sprite);
        this._topLeft.initWithTexture(k, B, m);
        0 < B.width && 0 < B.height && this._renderers.push(this._topLeft);
        this._topRight || (this._topRight = new cc.Sprite);
        this._topRight.initWithTexture(k, x, m);
        0 < x.width && 0 <
            x.height && this._renderers.push(this._topRight);
        this._bottomLeft || (this._bottomLeft = new cc.Sprite);
        this._bottomLeft.initWithTexture(k, E, m);
        0 < E.width && 0 < E.height && this._renderers.push(this._bottomLeft);
        this._bottomRight || (this._bottomRight = new cc.Sprite);
        this._bottomRight.initWithTexture(k, C, m);
        0 < C.width && 0 < C.height && this._renderers.push(this._bottomRight)
    },
    updateWithSprite: function(a, b, c, d, e, f) {
        var g = this.getOpacity(),
            h = this.getColor();
        this._renderers.length = 0;
        if (a) {
            if (!a.getSpriteFrame()) return !1;
            this._scale9Image || (this._scale9Image = a)
        }
        if (!this._scale9Image) return !1;
        var k = b,
            m = e,
            n = this._scale9Image.getTexture(),
            p = n && n.isLoaded();
        this._textureLoaded = p;
        if (!p) return n.addEventListener("load", function(g) {
            this._positionsAreDirty = !0;
            this.updateWithSprite(a, b, c, d, e, f);
            this.setVisible(!0);
            this.setNodeDirty();
            this.dispatchEvent("load")
        }, this), this.setVisible(!1), !0;
        cc._rectEqualToZero(k) && (k = n.getContentSize(), k = cc.rect(0, 0, k.width, k.height));
        0 === m.width && 0 === m.height && (m = cc.size(k.width, k.height));
        this._capInsets = f;
        this._spriteRect = k;
        this._offset = d;
        this._spriteFrameRotated = c;
        this._preferredSize = this._originalSize = m;
        this._capInsetsInternal = f;
        this._scale9Enabled ? this.createSlicedSprites() : this._scale9Image.initWithTexture(n, this._spriteRect, this._spriteFrameRotated);
        this.setState(this._brightState);
        this.setContentSize(m);
        !0 === this._spritesGenerated && (this.setOpacity(g), this.setColor(h));
        return this._spritesGenerated = !0
    },
    updateWithBatchNode: function(a, b, c, d) {
        var e = new cc.Sprite(a.getTexture()),
            f = cc.p(0, 0),
            g = cc.size(b.width, b.height),
            h = a.getTexture(),
            k = h.isLoaded();
        this._textureLoaded = k;
        return k ? this.updateWithSprite(e, b, c, f, g, d) : (h.addEventListener("load", function(e) {
            this._positionsAreDirty = !0;
            this.updateWithBatchNode(a, b, c, d);
            this.setVisible(!0);
            this.setNodeDirty();
            this.dispatchEvent("load")
        }, this), this.setVisible(!1), !0)
    },
    setSpriteFrame: function(a, b) {
        b || (b = cc.rect());
        var c = new cc.Sprite(a.getTexture()),
            d = a.textureLoaded();
        (this._textureLoaded = d) || a.addEventListener("load", function(a) {
            var b =
                this._preferredSize,
                c = 0 !== b.width && 0 !== b.height;
            c && (b = cc.size(b.width, b.height));
            this.updateWithBatchNode(this._scale9Image, a.getRect(), cc._renderType === cc.game.RENDER_TYPE_WEBGL && a.isRotated(), this._capInsets);
            c && this.setPreferredSize(b);
            this._positionsAreDirty = !0;
            this.setNodeDirty();
            this.dispatchEvent("load")
        }, this);
        this.updateWithSprite(c, a.getRect(), a.isRotated(), a.getOffset(), a.getOriginalSize(), b);
        this._insetLeft = b.x;
        this._insetTop = b.y;
        this._insetRight = this._originalSize.width - this._insetLeft -
            b.width;
        this._insetBottom = this._originalSize.height - this._insetTop - b.height
    },
    setState: function(a) {
        this._renderCmd.setState(a)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled !== a && (this._scale9Enabled = a, this._renderers.length = 0, cc.Node.transformDirty = !0, this._scale9Enabled && this._scale9Image && this.updateWithSprite(this._scale9Image, this._spriteRect, this._spriteFrameRotated, this._offset, this._originalSize, this._capInsets), this._positionsAreDirty = !0)
    },
    _setRenderersPosition: function() {
        this._positionsAreDirty &&
            (this._updatePositions(), this._adjustScale9ImagePosition(), this._positionsAreDirty = !1)
    },
    _adjustScale9ImagePosition: function() {
        var a = this._scale9Image,
            b = this._contentSize;
        a && (a.x = b.width * a.getAnchorPoint().x, a.y = b.height * a.getAnchorPoint().y)
    },
    _adjustScale9ImageScale: function() {
        var a = this._scale9Image,
            b = this._contentSize;
        a && a.setScale(b.width / a.width, b.height / a.height)
    },
    setFlippedX: function(a) {
        var b = this.getScaleX();
        this._flippedX = a;
        this.setScaleX(b)
    },
    isFlippedX: function() {
        return this._flippedX
    },
    setFlippedY: function(a) {
        var b =
            this.getScaleY();
        this._flippedY = a;
        this.setScaleY(b)
    },
    isFlippedY: function() {
        return this._flippedY
    },
    setScaleX: function(a) {
        this._flippedX && (a *= -1);
        cc.Node.prototype.setScaleX.call(this, a)
    },
    setScaleY: function(a) {
        this._flippedY && (a *= -1);
        cc.Node.prototype.setScaleY.call(this, a)
    },
    setScale: function(a, b) {
        void 0 === b && (b = a);
        this.setScaleX(a);
        this.setScaleY(b)
    },
    getScaleX: function() {
        var a = cc.Node.prototype.getScaleX.call(this);
        this._flippedX && (a *= -1);
        return a
    },
    getScaleY: function() {
        var a = cc.Node.prototype.getScaleY.call(this);
        this._flippedY && (a *= -1);
        return a
    },
    getScale: function() {
        this.getScaleX() !== this.getScaleY() && cc.log("Scale9Sprite#scale. ScaleX !\x3d ScaleY. Don't know which one to return");
        return this.getScaleX()
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccui.Scale9Sprite.CanvasRenderCmd(this) : new ccui.Scale9Sprite.WebGLRenderCmd(this)
    }
});
_p = ccui.Scale9Sprite.prototype;
cc.EventHelper.prototype.apply(_p);
cc.defineGetterSetter(_p, "preferredSize", _p.getPreferredSize, _p.setPreferredSize);
cc.defineGetterSetter(_p, "capInsets", _p.getCapInsets, _p.setCapInsets);
cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
_p = null;
ccui.Scale9Sprite.create = function(a, b, c) {
    return new ccui.Scale9Sprite(a, b, c)
};
ccui.Scale9Sprite.createWithSpriteFrame = function(a, b) {
    return new ccui.Scale9Sprite(a, b)
};
ccui.Scale9Sprite.createWithSpriteFrameName = function(a, b) {
    return new ccui.Scale9Sprite(a, b)
};
ccui.Scale9Sprite.POSITIONS_CENTRE = 0;
ccui.Scale9Sprite.POSITIONS_TOP = 1;
ccui.Scale9Sprite.POSITIONS_LEFT = 2;
ccui.Scale9Sprite.POSITIONS_RIGHT = 3;
ccui.Scale9Sprite.POSITIONS_BOTTOM = 4;
ccui.Scale9Sprite.POSITIONS_TOPRIGHT = 5;
ccui.Scale9Sprite.POSITIONS_TOPLEFT = 6;
ccui.Scale9Sprite.POSITIONS_BOTTOMRIGHT = 7;
ccui.Scale9Sprite.state = {
    NORMAL: 0,
    GRAY: 1
};
(function() {
    ccui.Scale9Sprite.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._cachedParent = null;
        this._cacheDirty = !1;
        this._state = ccui.Scale9Sprite.state.NORMAL;
        a = this._node;
        var c = this._cacheCanvas = document.createElement("canvas");
        c.width = 1;
        c.height = 1;
        this._cacheContext = new cc.CanvasContextWrapper(c.getContext("2d"));
        var d = this._cacheTexture = new cc.Texture2D;
        d.initWithElement(c);
        d.handleLoadedTexture();
        this._cacheSprite = new cc.Sprite(d);
        this._cacheSprite.setAnchorPoint(0, 0);
        a.addChild(this._cacheSprite)
    };
    var a = ccui.Scale9Sprite.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    a.constructor = ccui.Scale9Sprite.CanvasRenderCmd;
    a.visit = function(a) {
        var c = this._node;
        c._visible && (c._positionsAreDirty && (c._updatePositions(), c._positionsAreDirty = !1, c._scale9Dirty = !0), this._cacheScale9Sprite(), c._scale9Dirty = !1, cc.Node.CanvasRenderCmd.prototype.visit.call(this, a))
    };
    a.transform = function(a) {
        var c = this._node;
        cc.Node.CanvasRenderCmd.prototype.transform.call(this, a);
        c._positionsAreDirty &&
            (c._updatePositions(), c._positionsAreDirty = !1, c._scale9Dirty = !0);
        this._cacheScale9Sprite();
        a = c._children;
        for (c = 0; c < a.length; c++) a[c].transform(this, !0)
    };
    a._updateDisplayColor = function(a) {
        cc.Node.CanvasRenderCmd.prototype._updateDisplayColor.call(this, a);
        var c = this._node;
        if (c) {
            var d = c._renderers;
            if (c._scale9Enabled) {
                for (var c = d.length, e = 0; e < c; e++) {
                    var f = d[e];
                    if (f) f._renderCmd._updateDisplayColor(a), f._renderCmd._updateColor();
                    else break
                }
                this._cacheScale9Sprite()
            } else c._scale9Image && (c._scale9Image._renderCmd._updateDisplayColor(a),
                c._scale9Image._renderCmd._updateColor(), this._cacheScale9Sprite())
        }
    };
    a._cacheScale9Sprite = function() {
        var a = this._node;
        if (a._scale9Image) {
            var c = cc.contentScaleFactor(),
                d = a._contentSize,
                e = cc.size(d.width * c, d.height * c),
                f = this._cacheCanvas,
                g = this._cacheContext,
                h = g.getContext(),
                k = !1;
            if (f.width !== e.width || f.height !== e.height) f.width = e.width, f.height = e.height, k = !0;
            cc.renderer._turnToCacheMode(a.__instanceId);
            if (a._scale9Enabled) {
                f = a._renderers;
                a._setRenderersPosition();
                for (var m = f.length, n = 0; n < m; n++) {
                    var p =
                        f[n];
                    if (p) p = p._renderCmd, p.updateStatus(), cc.renderer.pushRenderCommand(p);
                    else break
                }
            } else p = a._scale9Image._renderCmd, a._adjustScale9ImagePosition(), a._adjustScale9ImageScale(), p.updateStatus(), cc.renderer.pushRenderCommand(a._scale9Image._renderCmd);
            (f = a._scale9Image.getTexture()) && this._state === ccui.Scale9Sprite.state.GRAY && f._switchToGray(!0);
            h.setTransform(1, 0, 0, 1, 0, 0);
            h.clearRect(0, 0, e.width, e.height);
            cc.renderer._renderingToCacheCanvas(g, a.__instanceId, c, c);
            cc.renderer._turnToNormalMode();
            f && this._state === ccui.Scale9Sprite.state.GRAY && f._switchToGray(!1);
            k && this._cacheSprite.setTextureRect(cc.rect(0, 0, d.width, d.height));
            this._cacheSprite.getParent() || a.addChild(this._cacheSprite, -1)
        }
    };
    a.setState = function(a) {
        this._node._scale9Image && (this._state = a, this._cacheScale9Sprite())
    }
})();
(function() {
    if (cc.Node.WebGLRenderCmd) {
        ccui.Scale9Sprite.WebGLRenderCmd = function(a) {
            cc.Node.WebGLRenderCmd.call(this, a);
            this._cachedParent = null;
            this._cacheDirty = !1
        };
        var a = ccui.Scale9Sprite.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        a.constructor = ccui.Scale9Sprite.WebGLRenderCmd;
        a.visit = function(a) {
            var c = this._node;
            if (c._visible && c._scale9Image) {
                c._positionsAreDirty && (c._updatePositions(), c._positionsAreDirty = !1, c._scale9Dirty = !0);
                a = a || this.getParentRenderCmd();
                c._parent &&
                    c._parent._renderCmd && (this._curLevel = c._parent._renderCmd._curLevel + 1);
                this._syncStatus(a);
                if (c._scale9Enabled)
                    for (var c = c._renderers, d = c.length, e = 0; e < d; e++) {
                        var f = c[e];
                        if (f) f._renderCmd.visit(this);
                        else break
                    } else c._adjustScale9ImageScale(), c._adjustScale9ImagePosition(), c._scale9Image._renderCmd.visit(this);
                this._dirtyFlag = 0;
                cc.Node.WebGLRenderCmd.prototype.visit.call(this, a)
            }
        };
        a.transform = function(a, c) {
            var d = this._node;
            cc.Node.WebGLRenderCmd.prototype.transform.call(this, a, c);
            d._positionsAreDirty &&
                (d._updatePositions(), d._positionsAreDirty = !1, d._scale9Dirty = !0);
            if (d._scale9Enabled)
                for (var d = d._renderers, e = d.length, f = 0; f < e; f++) {
                    var g = d[f];
                    if (g) g._renderCmd.transform(this, !0);
                    else break
                } else d._adjustScale9ImageScale(), d._adjustScale9ImagePosition(), d._scale9Image._renderCmd.transform(this, !0)
        };
        a._syncStatus = function(a) {
            cc.Node.WebGLRenderCmd.prototype._syncStatus.call(this, a);
            this._updateDisplayColor(this._displayedColor);
            this._updateDisplayOpacity(this._displayedOpacity)
        };
        a._updateDisplayColor =
            function(a) {
                cc.Node.WebGLRenderCmd.prototype._updateDisplayColor.call(this, a);
                var c = this._node,
                    d = c._scale9Image;
                a = this._displayedColor;
                if (c._scale9Enabled)
                    for (c = c._renderers, d = 0; d < c.length; d++) c[d]._renderCmd._updateDisplayColor(a), c[d]._renderCmd._updateColor();
                else d._renderCmd._updateDisplayColor(a), d._renderCmd._updateColor()
            };
        a._updateDisplayOpacity = function(a) {
            cc.Node.WebGLRenderCmd.prototype._updateDisplayOpacity.call(this, a);
            var c = this._node,
                d = c._scale9Image;
            a = this._displayedOpacity;
            if (c._scale9Enabled)
                for (c =
                    c._renderers, d = 0; d < c.length; d++) c[d]._renderCmd._updateDisplayOpacity(a);
            else d._renderCmd._updateDisplayOpacity(a)
        };
        a.setState = function(a) {
            var c = this._node._scale9Image;
            null != c && (a === ccui.Scale9Sprite.state.NORMAL ? c.setShaderProgram(cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)) : a === ccui.Scale9Sprite.state.GRAY && c.setShaderProgram(ccui.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram()))
        };
        ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram = null;
        ccui.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram =
            function() {
                var a = ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram;
                if (a) return a;
                a = new cc.GLProgram;
                a.initWithVertexShaderByteArray(cc.SHADER_POSITION_TEXTURE_COLOR_VERT, ccui.Scale9Sprite.WebGLRenderCmd._grayShaderFragment);
                a.addAttribute(cc.ATTRIBUTE_NAME_POSITION, cc.VERTEX_ATTRIB_POSITION);
                a.addAttribute(cc.ATTRIBUTE_NAME_COLOR, cc.VERTEX_ATTRIB_COLOR);
                a.addAttribute(cc.ATTRIBUTE_NAME_TEX_COORD, cc.VERTEX_ATTRIB_TEX_COORDS);
                a.link();
                a.updateUniforms();
                return ccui.Scale9Sprite.WebGLRenderCmd._grayShaderProgram =
                    a
            };
        ccui.Scale9Sprite.WebGLRenderCmd._grayShaderFragment = "precision lowp float;\nvarying vec4 v_fragmentColor; \nvarying vec2 v_texCoord; \nvoid main() \n{ \n    vec4 c \x3d texture2D(CC_Texture0, v_texCoord); \n    gl_FragColor.xyz \x3d vec3(0.2126*c.r + 0.7152*c.g + 0.0722*c.b); \n     gl_FragColor.w \x3d c.w ; \n}"
    }
})();
ccui.Layout = ccui.Widget.extend({
    _clippingEnabled: !1,
    _backGroundScale9Enabled: null,
    _backGroundImage: null,
    _backGroundImageFileName: null,
    _backGroundImageCapInsets: null,
    _colorType: null,
    _bgImageTexType: ccui.Widget.LOCAL_TEXTURE,
    _colorRender: null,
    _gradientRender: null,
    _color: null,
    _startColor: null,
    _endColor: null,
    _alongVector: null,
    _opacity: 255,
    _backGroundImageTextureSize: null,
    _layoutType: null,
    _doLayoutDirty: !0,
    _clippingRectDirty: !0,
    _clippingType: null,
    _clippingStencil: null,
    _scissorRectDirty: !1,
    _clippingRect: null,
    _clippingParent: null,
    _className: "Layout",
    _backGroundImageColor: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _backGroundImageOpacity: 0,
    _loopFocus: !1,
    __passFocusToChild: !0,
    _isFocusPassing: !1,
    _isInterceptTouch: !1,
    ctor: function() {
        this._layoutType = ccui.Layout.ABSOLUTE;
        this._widgetType = ccui.Widget.TYPE_CONTAINER;
        this._clippingType = ccui.Layout.CLIPPING_STENCIL;
        this._colorType = ccui.Layout.BG_COLOR_NONE;
        ccui.Widget.prototype.ctor.call(this);
        this._backGroundImageCapInsets = cc.rect(0, 0, 0, 0);
        this._color = cc.color(255,
            255, 255, 255);
        this._startColor = cc.color(255, 255, 255, 255);
        this._endColor = cc.color(255, 255, 255, 255);
        this._alongVector = cc.p(0, -1);
        this._backGroundImageTextureSize = cc.size(0, 0);
        this._clippingRect = cc.rect(0, 0, 0, 0);
        this._backGroundImageColor = cc.color(255, 255, 255, 255)
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this);
        if (this._clippingStencil) this._clippingStencil.onEnter();
        this._clippingRectDirty = this._doLayoutDirty = !0
    },
    onExit: function() {
        ccui.Widget.prototype.onExit.call(this);
        if (this._clippingStencil) this._clippingStencil.onExit()
    },
    setLoopFocus: function(a) {
        this._loopFocus = a
    },
    isLoopFocus: function() {
        return this._loopFocus
    },
    setPassFocusToChild: function(a) {
        this.__passFocusToChild = a
    },
    isPassFocusToChild: function() {
        return this.__passFocusToChild
    },
    findNextFocusedWidget: function(a, b) {
        if (this._isFocusPassing || this.isFocused()) {
            var c = this.getParent();
            this._isFocusPassing = !1;
            if (this.__passFocusToChild) {
                var d = this._passFocusToChild(a, b);
                return d instanceof ccui.Layout && c ? (c._isFocusPassing = !0, c.findNextFocusedWidget(a, this)) : d
            }
            if (null ==
                c || !(c instanceof ccui.Layout)) return this;
            c._isFocusPassing = !0;
            return c.findNextFocusedWidget(a, this)
        }
        if (b.isFocused() || b instanceof ccui.Layout)
            if (this._layoutType === ccui.Layout.LINEAR_HORIZONTAL) switch (a) {
                    case ccui.Widget.LEFT:
                        return this._getPreviousFocusedWidget(a, b);
                    case ccui.Widget.RIGHT:
                        return this._getNextFocusedWidget(a, b);
                    case ccui.Widget.DOWN:
                    case ccui.Widget.UP:
                        return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? ccui.Widget.prototype.findNextFocusedWidget.call(this,
                            a, this) : b : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this);
                    default:
                        return cc.assert(0, "Invalid Focus Direction"), b
                } else if (this._layoutType === ccui.Layout.LINEAR_VERTICAL) switch (a) {
                    case ccui.Widget.LEFT:
                    case ccui.Widget.RIGHT:
                        return this._isLastWidgetInContainer(this, a) ? this._isWidgetAncestorSupportLoopFocus(b, a) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this) : b : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this);
                    case ccui.Widget.DOWN:
                        return this._getNextFocusedWidget(a,
                            b);
                    case ccui.Widget.UP:
                        return this._getPreviousFocusedWidget(a, b);
                    default:
                        return cc.assert(0, "Invalid Focus Direction"), b
                } else return cc.assert(0, "Un Supported Layout type, please use VBox and HBox instead!!!"), b;
                else return b
    },
    onPassFocusToChild: null,
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.ignoreContentAdaptWithSize(!1), this.setContentSize(cc.size(0, 0)), this.setAnchorPoint(0, 0), this.onPassFocusToChild = this._findNearestChildWidgetIndex.bind(this), !0) : !1
    },
    addChild: function(a,
        b, c) {
        a instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(a);
        ccui.Widget.prototype.addChild.call(this, a, b, c);
        this._doLayoutDirty = !0
    },
    removeChild: function(a, b) {
        ccui.Widget.prototype.removeChild.call(this, a, b);
        this._doLayoutDirty = !0
    },
    removeAllChildren: function(a) {
        ccui.Widget.prototype.removeAllChildren.call(this, a);
        this._doLayoutDirty = !0
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.Widget.prototype.removeAllChildrenWithCleanup.call(this, a);
        this._doLayoutDirty = !0
    },
    isClippingEnabled: function() {
        return this._clippingEnabled
    },
    visit: function(a) {
        if (this._visible)
            if (this._adaptRenderers(), this._doLayout(), this._clippingEnabled) switch (this._clippingType) {
                case ccui.Layout.CLIPPING_STENCIL:
                    this._renderCmd.stencilClippingVisit(a);
                    break;
                case ccui.Layout.CLIPPING_SCISSOR:
                    this._renderCmd.scissorClippingVisit(a)
            } else ccui.Widget.prototype.visit.call(this, a)
    },
    setClippingEnabled: function(a) {
        if (a !== this._clippingEnabled) switch (this._clippingEnabled = a, this._clippingType) {
            case ccui.Layout.CLIPPING_STENCIL:
                if (a) {
                    this._clippingStencil =
                        new cc.DrawNode;
                    this._renderCmd.rebindStencilRendering(this._clippingStencil);
                    if (this._running) this._clippingStencil.onEnter();
                    this._setStencilClippingSize(this._contentSize)
                } else {
                    if (this._running && this._clippingStencil) this._clippingStencil.onExit();
                    this._clippingStencil = null
                }
        }
    },
    setClippingType: function(a) {
        if (a !== this._clippingType)
            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS && a === ccui.Layout.CLIPPING_SCISSOR) cc.log("Only supports STENCIL on canvas mode.");
            else {
                var b = this.isClippingEnabled();
                this.setClippingEnabled(!1);
                this._clippingType = a;
                this.setClippingEnabled(b)
            }
    },
    getClippingType: function() {
        return this._clippingType
    },
    _setStencilClippingSize: function(a) {
        if (this._clippingEnabled && this._clippingType === ccui.Layout.CLIPPING_STENCIL) {
            var b = [];
            b[0] = cc.p(0, 0);
            b[1] = cc.p(a.width, 0);
            b[2] = cc.p(a.width, a.height);
            b[3] = cc.p(0, a.height);
            a = cc.color.GREEN;
            this._clippingStencil.clear();
            this._clippingStencil.drawPoly(b, 4, a, 0, a)
        }
    },
    _getClippingRect: function() {
        if (this._clippingRectDirty) {
            for (var a = this.convertToWorldSpace(cc.p(0,
                    0)), b = this.getNodeToWorldTransform(), c = this._contentSize.width * b.a, d = this._contentSize.height * b.d, b = this; b;)
                if ((b = b.getParent()) && b instanceof ccui.Layout && b.isClippingEnabled()) {
                    this._clippingParent = b;
                    break
                }
            if (this._clippingParent) {
                var b = this._clippingParent._getClippingRect(),
                    e = a.x - c * this._anchorPoint.x,
                    f = a.y - d * this._anchorPoint.y,
                    g = c,
                    h = d,
                    k = a.x - b.x;
                0 > k && (e = b.x, g += k);
                c = a.x + c - (b.x + b.width);
                0 < c && (g -= c);
                c = a.y + d - (b.y + b.height);
                0 < c && (h -= c);
                a = a.y - b.y;
                0 > a && (f = b.x, h += a);
                0 > g && (g = 0);
                0 > h && (h = 0);
                this._clippingRect.x =
                    e;
                this._clippingRect.y = f;
                this._clippingRect.width = g;
                this._clippingRect.height = h
            } else this._clippingRect.x = a.x - c * this._anchorPoint.x, this._clippingRect.y = a.y - d * this._anchorPoint.y, this._clippingRect.width = c, this._clippingRect.height = d;
            this._clippingRectDirty = !1
        }
        return this._clippingRect
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._setStencilClippingSize(a);
        this._clippingRectDirty = this._doLayoutDirty = !0;
        this._backGroundImage && (this._backGroundImage.setPosition(0.5 *
            a.width, 0.5 * a.height), this._backGroundScale9Enabled && this._backGroundImage instanceof ccui.Scale9Sprite && this._backGroundImage.setPreferredSize(a));
        this._colorRender && this._colorRender.setContentSize(a);
        this._gradientRender && this._gradientRender.setContentSize(a)
    },
    setBackGroundImageScale9Enabled: function(a) {
        this._backGroundScale9Enabled !== a && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundScale9Enabled = a, this._addBackGroundImage(), this.setBackGroundImage(this._backGroundImageFileName,
            this._bgImageTexType), this.setBackGroundImageCapInsets(this._backGroundImageCapInsets))
    },
    isBackGroundImageScale9Enabled: function() {
        return this._backGroundScale9Enabled
    },
    setBackGroundImage: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            null === this._backGroundImage && (this._addBackGroundImage(), this.setBackGroundImageScale9Enabled(this._backGroundScale9Enabled));
            this._backGroundImageFileName = a;
            this._bgImageTexType = b;
            var c = this._backGroundImage;
            switch (this._bgImageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._backGroundScale9Enabled && c.setPreferredSize(this._contentSize);
            this._backGroundImageTextureSize = c.getContentSize();
            c.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height);
            this._updateBackGroundImageColor()
        }
    },
    setBackGroundImageCapInsets: function(a) {
        if (a) {
            var b = this._backGroundImageCapInsets;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._backGroundScale9Enabled && this._backGroundImage.setCapInsets(a)
        }
    },
    getBackGroundImageCapInsets: function() {
        return cc.rect(this._backGroundImageCapInsets)
    },
    _supplyTheLayoutParameterLackToChild: function(a) {
        if (a) switch (this._layoutType) {
            case ccui.Layout.LINEAR_HORIZONTAL:
            case ccui.Layout.LINEAR_VERTICAL:
                var b = a.getLayoutParameter(ccui.LayoutParameter.LINEAR);
                b || a.setLayoutParameter(new ccui.LinearLayoutParameter);
                break;
            case ccui.Layout.RELATIVE:
                (b = a.getLayoutParameter(ccui.LayoutParameter.RELATIVE)) || a.setLayoutParameter(new ccui.RelativeLayoutParameter)
        }
    },
    _addBackGroundImage: function() {
        var a = this._contentSize;
        this._backGroundScale9Enabled ? (this._backGroundImage =
            new ccui.Scale9Sprite, this._backGroundImage.setPreferredSize(a)) : this._backGroundImage = new cc.Sprite;
        this.addProtectedChild(this._backGroundImage, ccui.Layout.BACKGROUND_IMAGE_ZORDER, -1);
        this._backGroundImage.setPosition(0.5 * a.width, 0.5 * a.height)
    },
    removeBackGroundImage: function() {
        this._backGroundImage && (this.removeProtectedChild(this._backGroundImage), this._backGroundImage = null, this._backGroundImageFileName = "", this._backGroundImageTextureSize.width = 0, this._backGroundImageTextureSize.height = 0)
    },
    setBackGroundColorType: function(a) {
        if (this._colorType !==
            a) {
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_NONE:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender = null);
                    break;
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender && (this.removeProtectedChild(this._colorRender), this._colorRender = null);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender && (this.removeProtectedChild(this._gradientRender), this._gradientRender =
                        null)
            }
            this._colorType = a;
            switch (this._colorType) {
                case ccui.Layout.BG_COLOR_SOLID:
                    this._colorRender = new cc.LayerColor;
                    this._colorRender.setContentSize(this._contentSize);
                    this._colorRender.setOpacity(this._opacity);
                    this._colorRender.setColor(this._color);
                    this.addProtectedChild(this._colorRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1);
                    break;
                case ccui.Layout.BG_COLOR_GRADIENT:
                    this._gradientRender = new cc.LayerGradient(cc.color(255, 0, 0, 255), cc.color(0, 255, 0, 255)), this._gradientRender.setContentSize(this._contentSize),
                        this._gradientRender.setOpacity(this._opacity), this._gradientRender.setStartColor(this._startColor), this._gradientRender.setEndColor(this._endColor), this._gradientRender.setVector(this._alongVector), this.addProtectedChild(this._gradientRender, ccui.Layout.BACKGROUND_RENDERER_ZORDER, -1)
            }
        }
    },
    getBackGroundColorType: function() {
        return this._colorType
    },
    setBackGroundColor: function(a, b) {
        b ? (this._startColor.r = a.r, this._startColor.g = a.g, this._startColor.b = a.b, this._gradientRender && this._gradientRender.setStartColor(a),
            this._endColor.r = b.r, this._endColor.g = b.g, this._endColor.b = b.b, this._gradientRender && this._gradientRender.setEndColor(b)) : (this._color.r = a.r, this._color.g = a.g, this._color.b = a.b, this._colorRender && this._colorRender.setColor(a))
    },
    getBackGroundColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundStartColor: function() {
        var a = this._startColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundEndColor: function() {
        var a = this._endColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    setBackGroundColorOpacity: function(a) {
        this._opacity =
            a;
        switch (this._colorType) {
            case ccui.Layout.BG_COLOR_SOLID:
                this._colorRender.setOpacity(a);
                break;
            case ccui.Layout.BG_COLOR_GRADIENT:
                this._gradientRender.setOpacity(a)
        }
    },
    getBackGroundColorOpacity: function() {
        return this._opacity
    },
    setBackGroundColorVector: function(a) {
        this._alongVector.x = a.x;
        this._alongVector.y = a.y;
        this._gradientRender && this._gradientRender.setVector(a)
    },
    getBackGroundColorVector: function() {
        return this._alongVector
    },
    setBackGroundImageColor: function(a) {
        this._backGroundImageColor.r = a.r;
        this._backGroundImageColor.g =
            a.g;
        this._backGroundImageColor.b = a.b;
        this._updateBackGroundImageColor()
    },
    setBackGroundImageOpacity: function(a) {
        this._backGroundImageColor.a = a;
        this.getBackGroundImageColor()
    },
    getBackGroundImageColor: function() {
        var a = this._backGroundImageColor;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getBackGroundImageOpacity: function() {
        return this._backGroundImageColor.a
    },
    _updateBackGroundImageColor: function() {
        this._backGroundImage && this._backGroundImage.setColor(this._backGroundImageColor)
    },
    getBackGroundImageTextureSize: function() {
        return this._backGroundImageTextureSize
    },
    setLayoutType: function(a) {
        this._layoutType = a;
        a = this._children;
        for (var b = null, c = 0; c < a.length; c++) b = a[c], b instanceof ccui.Widget && this._supplyTheLayoutParameterLackToChild(b);
        this._doLayoutDirty = !0
    },
    getLayoutType: function() {
        return this._layoutType
    },
    requestDoLayout: function() {
        this._doLayoutDirty = !0
    },
    _doLayout: function() {
        if (this._doLayoutDirty) {
            this.sortAllChildren();
            var a = ccui.getLayoutManager(this._layoutType);
            a && a._doLayout(this);
            this._doLayoutDirty = !1
        }
    },
    _getLayoutContentSize: function() {
        return this.getContentSize()
    },
    _getLayoutElements: function() {
        return this.getChildren()
    },
    _updateBackGroundImageOpacity: function() {
        this._backGroundImage && this._backGroundImage.setOpacity(this._backGroundImageOpacity)
    },
    _updateBackGroundImageRGBA: function() {
        this._backGroundImage && (this._backGroundImage.setColor(this._backGroundImageColor), this._backGroundImage.setOpacity(this._backGroundImageOpacity))
    },
    _getLayoutAccumulatedSize: function() {
        for (var a = this.getChildren(), b = cc.size(0, 0), c = 0, d, e = 0, f = a.length; e < f; e++)
            if (d = a[e], null !== d &&
                d instanceof ccui.Layout) d = d._getLayoutAccumulatedSize(), b.width += d.width, b.height += d.height;
            else if (d instanceof ccui.Widget) {
            c++;
            var g = d.getLayoutParameter().getMargin();
            d = d.getContentSize();
            b.width += d.width + 0.5 * (g.right + g.left);
            b.height += d.height + 0.5 * (g.top + g.bottom)
        }
        a = this.getLayoutType();
        a === ccui.Layout.LINEAR_HORIZONTAL && (b.height -= b.height / c * (c - 1));
        a === ccui.Layout.LINEAR_VERTICAL && (b.width -= b.width / c * (c - 1));
        return b
    },
    _findNearestChildWidgetIndex: function(a, b) {
        if (null == b || b === this) return this._findFirstFocusEnabledWidgetIndex();
        var c = 0,
            d = this.getChildren(),
            e = d.length,
            f, g = cc.FLT_MAX,
            h = 0;
        if (a === ccui.Widget.LEFT || a === ccui.Widget.RIGHT || a === ccui.Widget.DOWN || a === ccui.Widget.UP) {
            for (f = this._getWorldCenterPoint(b); c < e;) {
                var k = d[c];
                k && k instanceof ccui.Widget && k.isFocusEnabled() && (k = k instanceof ccui.Layout ? k._calculateNearestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(k), f)), k < g && (h = c, g = k));
                c++
            }
            return h
        }
        cc.log("invalid focus direction!");
        return 0
    },
    _findFarthestChildWidgetIndex: function(a, b) {
        if (null == b || b === this) return this._findFirstFocusEnabledWidgetIndex();
        var c = 0,
            d = this.getChildren(),
            e = d.length,
            f = -cc.FLT_MAX,
            g = 0;
        if (a === ccui.Widget.LEFT || a === ccui.Widget.RIGHT || a === ccui.Widget.DOWN || a === ccui.Widget.UP) {
            for (var h = this._getWorldCenterPoint(b); c < e;) {
                var k = d[c];
                k && k instanceof ccui.Widget && k.isFocusEnabled() && (k = k instanceof ccui.Layout ? k._calculateFarthestDistance(b) : cc.pLength(cc.pSub(this._getWorldCenterPoint(k), h)), k > f && (g = c, f = k));
                c++
            }
            return g
        }
        cc.log("invalid focus direction!!!");
        return 0
    },
    _calculateNearestDistance: function(a) {
        for (var b = cc.FLT_MAX, c =
                this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g instanceof ccui.Layout) g = g._calculateNearestDistance(a);
            else if (g instanceof ccui.Widget && g.isFocusEnabled()) g = cc.pLength(cc.pSub(this._getWorldCenterPoint(g), c));
            else continue;
            g < b && (b = g)
        }
        return b
    },
    _calculateFarthestDistance: function(a) {
        for (var b = -cc.FLT_MAX, c = this._getWorldCenterPoint(a), d = this._children, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g instanceof ccui.Layout) g = g._calculateFarthestDistance(a);
            else if (g instanceof ccui.Widget && g.isFocusEnabled()) g = this._getWorldCenterPoint(g), g = cc.pLength(cc.pSub(g, c));
            else continue;
            g > b && (b = g)
        }
        return b
    },
    _findProperSearchingFunctor: function(a, b) {
        if (null != b) {
            var c = this._getWorldCenterPoint(b),
                d = this._getWorldCenterPoint(this._findFirstNonLayoutWidget());
            a === ccui.Widget.LEFT ? this.onPassFocusToChild = c.x > d.x ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a === ccui.Widget.RIGHT ? this.onPassFocusToChild = c.x > d.x ? this._findFarthestChildWidgetIndex.bind(this) :
                this._findNearestChildWidgetIndex.bind(this) : a === ccui.Widget.DOWN ? this.onPassFocusToChild = c.y > d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : a === ccui.Widget.UP ? this.onPassFocusToChild = c.y < d.y ? this._findNearestChildWidgetIndex.bind(this) : this._findFarthestChildWidgetIndex.bind(this) : cc.log("invalid direction!")
        }
    },
    _findFirstNonLayoutWidget: function() {
        for (var a = this._children, b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            if (d instanceof ccui.Layout) {
                if (d = d._findFirstNonLayoutWidget()) return d
            } else if (d instanceof ccui.Widget) return d
        }
        return null
    },
    _findFirstFocusEnabledWidgetIndex: function() {
        for (var a = 0, b = this.getChildren(), c = b.length; a < c;) {
            var d = b[a];
            if (d && d instanceof ccui.Widget && d.isFocusEnabled()) return a;
            a++
        }
        return 0
    },
    _findFocusEnabledChildWidgetByIndex: function(a) {
        var b = this._getChildWidgetByIndex(a);
        return b ? b.isFocusEnabled() ? b : this._findFocusEnabledChildWidgetByIndex(a + 1) : null
    },
    _getWorldCenterPoint: function(a) {
        var b = a instanceof ccui.Layout ? a._getLayoutAccumulatedSize() : a.getContentSize();
        return a.convertToWorldSpace(cc.p(b.width /
            2, b.height / 2))
    },
    _getNextFocusedWidget: function(a, b) {
        var c = null,
            c = this._children,
            d = c.indexOf(b),
            d = d + 1;
        if (d < c.length) {
            if (c = this._getChildWidgetByIndex(d)) {
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getNextFocusedWidget(a, c)
            }
            return b
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                c = this._getChildWidgetByIndex(0);
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getNextFocusedWidget(a, c)
            }
            return b instanceof ccui.Layout ? b : ccui.Widget._focusedWidget
        }
        return this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this) : b instanceof ccui.Layout ? b : ccui.Widget._focusedWidget : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this)
    },
    _getPreviousFocusedWidget: function(a, b) {
        var c = null,
            c = this._children,
            d = c.indexOf(b),
            d = d - 1;
        if (0 <= d) {
            c = this._getChildWidgetByIndex(d);
            if (c.isFocusEnabled()) {
                if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                this.dispatchFocusEvent(b, c);
                return c
            }
            return this._getPreviousFocusedWidget(a, c)
        }
        if (this._loopFocus) {
            if (this._checkFocusEnabledChild()) {
                d = c.length - 1;
                c = this._getChildWidgetByIndex(d);
                if (c.isFocusEnabled()) {
                    if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
                    this.dispatchFocusEvent(b, c);
                    return c
                }
                return this._getPreviousFocusedWidget(a,
                    c)
            }
            return b instanceof ccui.Layout ? b : ccui.Widget._focusedWidget
        }
        return this._isLastWidgetInContainer(b, a) ? this._isWidgetAncestorSupportLoopFocus(this, a) ? ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this) : b instanceof ccui.Layout ? b : ccui.Widget._focusedWidget : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, this)
    },
    _getChildWidgetByIndex: function(a) {
        for (var b = this._children, c = b.length, d = 0, e = a; a < c;) {
            var f = b[a];
            if (f && f instanceof ccui.Widget) return f;
            d++;
            a++
        }
        for (a = 0; a < e;) {
            if ((c = b[a]) &&
                c instanceof ccui.Widget) return c;
            d++;
            a++
        }
        return null
    },
    _isLastWidgetInContainer: function(a, b) {
        var c = a.getParent();
        if (null == c || !(c instanceof ccui.Layout)) return !0;
        var d = c.getChildren(),
            e = d.indexOf(a);
        if (c.getLayoutType() === ccui.Layout.LINEAR_HORIZONTAL) {
            if (b === ccui.Widget.LEFT) return 0 === e ? this._isLastWidgetInContainer(c, b) : !1;
            if (b === ccui.Widget.RIGHT) return e === d.length - 1 ? this._isLastWidgetInContainer(c, b) : !1;
            if (b === ccui.Widget.DOWN || b === ccui.Widget.UP) return this._isLastWidgetInContainer(c, b)
        } else if (c.getLayoutType() ===
            ccui.Layout.LINEAR_VERTICAL) {
            if (b === ccui.Widget.UP) return 0 === e ? this._isLastWidgetInContainer(c, b) : !1;
            if (b === ccui.Widget.DOWN) return e === d.length - 1 ? this._isLastWidgetInContainer(c, b) : !1;
            if (b === ccui.Widget.LEFT || b === ccui.Widget.RIGHT) return this._isLastWidgetInContainer(c, b)
        } else return cc.log("invalid layout Type"), !1
    },
    _isWidgetAncestorSupportLoopFocus: function(a, b) {
        var c = a.getParent();
        if (null == c || !(c instanceof ccui.Layout)) return !1;
        if (c.isLoopFocus()) {
            var d = c.getLayoutType();
            if (d === ccui.Layout.LINEAR_HORIZONTAL) return b ===
                ccui.Widget.LEFT || b === ccui.Widget.RIGHT ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b);
            if (d === ccui.Layout.LINEAR_VERTICAL) return b === ccui.Widget.DOWN || b === ccui.Widget.UP ? !0 : this._isWidgetAncestorSupportLoopFocus(c, b);
            cc.assert(0, "invalid layout type");
            return !1
        }
        return this._isWidgetAncestorSupportLoopFocus(c, b)
    },
    _passFocusToChild: function(a, b) {
        if (this._checkFocusEnabledChild()) {
            var c = ccui.Widget.getCurrentFocusedWidget();
            this._findProperSearchingFunctor(a, c);
            c = this.onPassFocusToChild(a, c);
            c = this._getChildWidgetByIndex(c);
            if (c instanceof ccui.Layout) return c._isFocusPassing = !0, c.findNextFocusedWidget(a, c);
            this.dispatchFocusEvent(b, c);
            return c
        }
        return this
    },
    _checkFocusEnabledChild: function() {
        for (var a = this._children, b = 0, c = a.length; b < c; b++) {
            var d = a[b];
            if (d && d instanceof ccui.Widget && d.isFocusEnabled()) return !0
        }
        return !1
    },
    getDescription: function() {
        return "Layout"
    },
    _createCloneInstance: function() {
        return new ccui.Layout
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Widget.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function(a) {
        a instanceof
        ccui.Layout && (this.setBackGroundImageScale9Enabled(a._backGroundScale9Enabled), this.setBackGroundImage(a._backGroundImageFileName, a._bgImageTexType), this.setBackGroundImageCapInsets(a._backGroundImageCapInsets), this.setBackGroundColorType(a._colorType), this.setBackGroundColor(a._color), this.setBackGroundColor(a._startColor, a._endColor), this.setBackGroundColorOpacity(a._opacity), this.setBackGroundColorVector(a._alongVector), this.setLayoutType(a._layoutType), this.setClippingEnabled(a._clippingEnabled),
            this.setClippingType(a._clippingType), this._loopFocus = a._loopFocus, this.__passFocusToChild = a.__passFocusToChild, this._isInterceptTouch = a._isInterceptTouch)
    },
    forceDoLayout: function() {
        this.requestDoLayout();
        this._doLayout()
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new ccui.Layout.WebGLRenderCmd(this) : new ccui.Layout.CanvasRenderCmd(this)
    }
});
_p = ccui.Layout.prototype;
cc.defineGetterSetter(_p, "clippingEnabled", _p.isClippingEnabled, _p.setClippingEnabled);
cc.defineGetterSetter(_p, "clippingType", null, _p.setClippingType);
cc.defineGetterSetter(_p, "layoutType", _p.getLayoutType, _p.setLayoutType);
_p = null;
ccui.Layout.create = function() {
    return new ccui.Layout
};
ccui.Layout.BG_COLOR_NONE = 0;
ccui.Layout.BG_COLOR_SOLID = 1;
ccui.Layout.BG_COLOR_GRADIENT = 2;
ccui.Layout.ABSOLUTE = 0;
ccui.Layout.LINEAR_VERTICAL = 1;
ccui.Layout.LINEAR_HORIZONTAL = 2;
ccui.Layout.RELATIVE = 3;
ccui.Layout.CLIPPING_STENCIL = 0;
ccui.Layout.CLIPPING_SCISSOR = 1;
ccui.Layout.BACKGROUND_IMAGE_ZORDER = -1;
ccui.Layout.BACKGROUND_RENDERER_ZORDER = -2;
(function() {
    ccui.Layout.CanvasRenderCmd = function(a) {
        ccui.ProtectedNode.CanvasRenderCmd.call(this, a);
        this._clipElemType = this._needDraw = !1;
        this._locCache = null;
        this._rendererSaveCmd = new cc.CustomRenderCmd(this, this._onRenderSaveCmd);
        this._rendererSaveCmdSprite = new cc.CustomRenderCmd(this, this._onRenderSaveSpriteCmd);
        this._rendererClipCmd = new cc.CustomRenderCmd(this, this._onRenderClipCmd);
        this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._onRenderRestoreCmd)
    };
    var a = ccui.Layout.CanvasRenderCmd.prototype =
        Object.create(ccui.ProtectedNode.CanvasRenderCmd.prototype);
    a.constructor = ccui.Layout.CanvasRenderCmd;
    a.visit = function(a) {
        var c = this._node;
        if (c._visible)
            if (c._adaptRenderers(), c._doLayout(), c._clippingEnabled) switch (c._clippingType) {
                case ccui.Layout.CLIPPING_STENCIL:
                    this.stencilClippingVisit(a);
                    break;
                case ccui.Layout.CLIPPING_SCISSOR:
                    this.scissorClippingVisit(a)
            } else ccui.Widget.CanvasRenderCmd.prototype.visit.call(this, a)
    };
    a._onRenderSaveCmd = function(a, c, d) {
        a = a || cc._renderContext;
        var e = a.getContext();
        this._clipElemType ? (c = e.canvas, this._locCache = ccui.Layout.CanvasRenderCmd._getSharedCache(), this._locCache.width = c.width, this._locCache.height = c.height, this._locCache.getContext("2d").drawImage(c, 0, 0)) : (a.save(), a.save(), a.setTransform(this._worldTransform, c, d))
    };
    a._onRenderSaveSpriteCmd = function(a) {
        a = a || cc._renderContext;
        this._clipElemType && a.setCompositeOperation("destination-in")
    };
    a._onRenderClipCmd = function(a) {
        a = a || cc._renderContext;
        var c = a.getContext();
        this._clipElemType || (a.restore(), c.clip())
    };
    a._onRenderRestoreCmd = function(a) {
        a = a || cc._renderContext;
        var c = a.getContext();
        this._clipElemType ? (c.save(), c.setTransform(1, 0, 0, 1, 0, 0), c.globalCompositeOperation = "destination-over", c.drawImage(this._locCache, 0, 0), c.restore()) : a.restore()
    };
    a.rebindStencilRendering = function(a) {
        a._renderCmd.rendering = this.__stencilDraw
    };
    a.__stencilDraw = function(a, c, d) {
        a = (a || cc._renderContext).getContext();
        for (var e = this._buffer, f = 0, g = e.length; f < g; f++) {
            var h = e[f].verts,
                k = h[0];
            a.beginPath();
            a.moveTo(k.x * c, -k.y * d);
            for (var k =
                    1, m = h.length; k < m; k++) a.lineTo(h[k].x * c, -h[k].y * d);
            a.closePath()
        }
    };
    a.stencilClippingVisit = a.scissorClippingVisit = function(a) {
        var c = this._node;
        if (c._clippingStencil && c._clippingStencil.isVisible()) {
            this._clipElemType = c._stencil instanceof cc.Sprite;
            this._syncStatus(a);
            cc.renderer.pushRenderCommand(this._rendererSaveCmd);
            this._clipElemType && (cc.ProtectedNode.prototype.visit.call(c, a), cc.renderer.pushRenderCommand(this._rendererSaveCmdSprite));
            c._clippingStencil.visit(this);
            cc.renderer.pushRenderCommand(this._rendererClipCmd);
            if (!this._clipElemType) {
                c.sortAllChildren();
                c.sortAllProtectedChildren();
                a = c._children;
                for (var d = 0, c = c._protectedChildren, e = 0, f, g = a.length, h = c.length; e < g; e++)
                    if ((f = a[e]) && 0 > f.getLocalZOrder()) f.visit(this);
                    else break;
                for (; d < h; d++)
                    if ((f = c[d]) && 0 > f.getLocalZOrder()) f.visit(this);
                    else break;
                for (; e < g; e++) a[e].visit(this);
                for (; d < h; d++) c[d].visit(this);
                cc.renderer.pushRenderCommand(this._rendererRestoreCmd)
            }
            this._dirtyFlag = 0
        }
    };
    ccui.Layout.CanvasRenderCmd._getSharedCache = function() {
        return cc.ClippingNode._sharedCache ||
            (cc.ClippingNode._sharedCache = document.createElement("canvas"))
    }
})();
(function() {
    if (ccui.ProtectedNode.WebGLRenderCmd) {
        ccui.Layout.WebGLRenderCmd = function(a) {
            ccui.ProtectedNode.WebGLRenderCmd.call(this, a);
            this._needDraw = !1;
            this._currentStencilPassDepthPass = this._currentStencilPassDepthFail = this._currentStencilFail = this._currentStencilValueMask = this._currentStencilRef = this._currentStencilFunc = this._currentStencilWriteMask = this._currentStencilEnabled = 0;
            this._currentDepthWriteMask = !1;
            this._mask_layer_le = 0;
            this._beforeVisitCmdStencil = new cc.CustomRenderCmd(this, this._onBeforeVisitStencil);
            this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
            this._afterVisitCmdStencil = new cc.CustomRenderCmd(this, this._onAfterVisitStencil);
            this._beforeVisitCmdScissor = new cc.CustomRenderCmd(this, this._onBeforeVisitScissor);
            this._afterVisitCmdScissor = new cc.CustomRenderCmd(this, this._onAfterVisitScissor)
        };
        var a = ccui.Layout.WebGLRenderCmd.prototype = Object.create(ccui.ProtectedNode.WebGLRenderCmd.prototype);
        a.constructor = ccui.Layout.WebGLRenderCmd;
        a.visit = function(a) {
            var c = this._node;
            if (c._visible)
                if (c._adaptRenderers(), c._doLayout(), c._clippingEnabled) switch (c._clippingType) {
                    case ccui.Layout.CLIPPING_STENCIL:
                        this.stencilClippingVisit(a);
                        break;
                    case ccui.Layout.CLIPPING_SCISSOR:
                        this.scissorClippingVisit(a)
                } else ccui.Widget.WebGLRenderCmd.prototype.visit.call(this, a)
        };
        a._onBeforeVisitStencil = function(a) {
            a = a || cc._renderContext;
            ccui.Layout.WebGLRenderCmd._layer++;
            var c = 1 << ccui.Layout.WebGLRenderCmd._layer;
            this._mask_layer_le = c | c - 1;
            this._currentStencilEnabled = a.isEnabled(a.STENCIL_TEST);
            this._currentStencilWriteMask = a.getParameter(a.STENCIL_WRITEMASK);
            this._currentStencilFunc = a.getParameter(a.STENCIL_FUNC);
            this._currentStencilRef = a.getParameter(a.STENCIL_REF);
            this._currentStencilValueMask = a.getParameter(a.STENCIL_VALUE_MASK);
            this._currentStencilFail = a.getParameter(a.STENCIL_FAIL);
            this._currentStencilPassDepthFail = a.getParameter(a.STENCIL_PASS_DEPTH_FAIL);
            this._currentStencilPassDepthPass = a.getParameter(a.STENCIL_PASS_DEPTH_PASS);
            a.enable(a.STENCIL_TEST);
            a.stencilMask(c);
            this._currentDepthWriteMask =
                a.getParameter(a.DEPTH_WRITEMASK);
            a.depthMask(!1);
            a.stencilFunc(a.NEVER, c, c);
            a.stencilOp(a.ZERO, a.KEEP, a.KEEP);
            this._drawFullScreenQuadClearStencil();
            a.stencilFunc(a.NEVER, c, c);
            a.stencilOp(a.REPLACE, a.KEEP, a.KEEP)
        };
        a._onAfterDrawStencil = function(a) {
            a = a || cc._renderContext;
            a.depthMask(this._currentDepthWriteMask);
            a.stencilFunc(a.EQUAL, this._mask_layer_le, this._mask_layer_le);
            a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
        };
        a._onAfterVisitStencil = function(a) {
            a = a || cc._renderContext;
            a.stencilFunc(this._currentStencilFunc,
                this._currentStencilRef, this._currentStencilValueMask);
            a.stencilOp(this._currentStencilFail, this._currentStencilPassDepthFail, this._currentStencilPassDepthPass);
            a.stencilMask(this._currentStencilWriteMask);
            this._currentStencilEnabled || a.disable(a.STENCIL_TEST);
            ccui.Layout.WebGLRenderCmd._layer--
        };
        a._onBeforeVisitScissor = function(a) {
            var c = this._getClippingRect();
            a = a || cc._renderContext;
            a.enable(a.SCISSOR_TEST);
            cc.view.setScissorInPoints(c.x, c.y, c.width, c.height)
        };
        a._onAfterVisitScissor = function(a) {
            a =
                a || cc._renderContext;
            a.disable(a.SCISSOR_TEST)
        };
        a._drawFullScreenQuadClearStencil = function() {
            cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
            cc.kmGLPushMatrix();
            cc.kmGLLoadIdentity();
            cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
            cc.kmGLPushMatrix();
            cc.kmGLLoadIdentity();
            cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
            cc.kmGLMatrixMode(cc.KM_GL_PROJECTION);
            cc.kmGLPopMatrix();
            cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW);
            cc.kmGLPopMatrix()
        };
        a.rebindStencilRendering = function(a) {};
        a.transform = function(a,
            c) {
            var d = this._node;
            ccui.ProtectedNode.WebGLRenderCmd.prototype.transform.call(this, a, c);
            d._clippingStencil && d._clippingStencil._renderCmd.transform(this, c)
        };
        a.stencilClippingVisit = function(a) {
            var c = this._node;
            if (c._clippingStencil && c._clippingStencil.isVisible())
                if (ccui.Layout.WebGLRenderCmd._layer + 1 === cc.stencilBits) ccui.Layout.WebGLRenderCmd._visit_once = !0, ccui.Layout.WebGLRenderCmd._visit_once && (cc.log("Nesting more than " + cc.stencilBits + "stencils is not supported. Everything will be drawn without stencil for this node and its childs."),
                    ccui.Layout.WebGLRenderCmd._visit_once = !1), cc.Node.prototype.visit.call(c, a);
                else {
                    cc.renderer.pushRenderCommand(this._beforeVisitCmdStencil);
                    var d = cc.current_stack;
                    d.stack.push(d.top);
                    this._syncStatus(a);
                    this._dirtyFlag = 0;
                    d.top = this._stackMatrix;
                    c._clippingStencil.visit(this);
                    cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
                    var e = a = 0;
                    c.sortAllChildren();
                    c.sortAllProtectedChildren();
                    for (var f = c._children, c = c._protectedChildren, g = f.length, h = c.length, k; a < g; a++)
                        if ((k = f[a]) && 0 > k.getLocalZOrder()) k.visit(this);
                        else break;
                    for (; e < h; e++)
                        if ((k = c[e]) && 0 > k.getLocalZOrder()) k.visit(this);
                        else break;
                    for (; a < g; a++) f[a].visit(this);
                    for (; e < h; e++) c[e].visit(this);
                    cc.renderer.pushRenderCommand(this._afterVisitCmdStencil);
                    d.top = d.stack.pop()
                }
        };
        a.scissorClippingVisit = function(a) {
            cc.renderer.pushRenderCommand(this._beforeVisitCmdScissor);
            cc.ProtectedNode.prototype.visit.call(this._node, a);
            cc.renderer.pushRenderCommand(this._afterVisitCmdScissor)
        };
        ccui.Layout.WebGLRenderCmd._layer = -1;
        ccui.Layout.WebGLRenderCmd._visit_once =
            null
    }
})();
ccui.Margin = ccui.Class.extend({
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    ctor: function(a, b, c, d) {
        void 0 !== a && void 0 === b && (this.left = a.left, this.top = a.top, this.right = a.right, this.bottom = a.bottom);
        void 0 !== d && (this.left = a, this.top = b, this.right = c, this.bottom = d)
    },
    setMargin: function(a, b, c, d) {
        this.left = a;
        this.top = b;
        this.right = c;
        this.bottom = d
    },
    equals: function(a) {
        return this.left === a.left && this.top === a.top && this.right === a.right && this.bottom === a.bottom
    }
});
ccui.MarginZero = function() {
    return new ccui.Margin(0, 0, 0, 0)
};
ccui.LayoutParameter = ccui.Class.extend({
    _margin: null,
    _layoutParameterType: null,
    ctor: function() {
        this._margin = new ccui.Margin;
        this._layoutParameterType = ccui.LayoutParameter.NONE
    },
    setMargin: function(a, b, c, d) {
        cc.isObject(a) ? (this._margin.left = a.left, this._margin.top = a.top, this._margin.right = a.right, this._margin.bottom = a.bottom) : (this._margin.left = a, this._margin.top = b, this._margin.right = c, this._margin.bottom = d)
    },
    getMargin: function() {
        return this._margin
    },
    getLayoutType: function() {
        return this._layoutParameterType
    },
    clone: function() {
        var a = this._createCloneInstance();
        a._copyProperties(this);
        return a
    },
    _createCloneInstance: function() {
        return new ccui.LayoutParameter
    },
    _copyProperties: function(a) {
        this._margin.bottom = a._margin.bottom;
        this._margin.left = a._margin.left;
        this._margin.right = a._margin.right;
        this._margin.top = a._margin.top
    }
});
ccui.LayoutParameter.create = function() {
    return new ccui.LayoutParameter
};
ccui.LayoutParameter.NONE = 0;
ccui.LayoutParameter.LINEAR = 1;
ccui.LayoutParameter.RELATIVE = 2;
ccui.LinearLayoutParameter = ccui.LayoutParameter.extend({
    _linearGravity: null,
    ctor: function() {
        ccui.LayoutParameter.prototype.ctor.call(this);
        this._linearGravity = ccui.LinearLayoutParameter.NONE;
        this._layoutParameterType = ccui.LayoutParameter.LINEAR
    },
    setGravity: function(a) {
        this._linearGravity = a
    },
    getGravity: function() {
        return this._linearGravity
    },
    _createCloneInstance: function() {
        return new ccui.LinearLayoutParameter
    },
    _copyProperties: function(a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a);
        a instanceof ccui.LinearLayoutParameter && this.setGravity(a._linearGravity)
    }
});
ccui.LinearLayoutParameter.create = function() {
    return new ccui.LinearLayoutParameter
};
ccui.LinearLayoutParameter.NONE = 0;
ccui.LinearLayoutParameter.LEFT = 1;
ccui.LinearLayoutParameter.TOP = 2;
ccui.LinearLayoutParameter.RIGHT = 3;
ccui.LinearLayoutParameter.BOTTOM = 4;
ccui.LinearLayoutParameter.CENTER_VERTICAL = 5;
ccui.LinearLayoutParameter.CENTER_HORIZONTAL = 6;
ccui.RelativeLayoutParameter = ccui.LayoutParameter.extend({
    _relativeAlign: null,
    _relativeWidgetName: "",
    _relativeLayoutName: "",
    _put: !1,
    ctor: function() {
        ccui.LayoutParameter.prototype.ctor.call(this);
        this._relativeAlign = ccui.RelativeLayoutParameter.NONE;
        this._relativeLayoutName = this._relativeWidgetName = "";
        this._put = !1;
        this._layoutParameterType = ccui.LayoutParameter.RELATIVE
    },
    setAlign: function(a) {
        this._relativeAlign = a
    },
    getAlign: function() {
        return this._relativeAlign
    },
    setRelativeToWidgetName: function(a) {
        this._relativeWidgetName =
            a
    },
    getRelativeToWidgetName: function() {
        return this._relativeWidgetName
    },
    setRelativeName: function(a) {
        this._relativeLayoutName = a
    },
    getRelativeName: function() {
        return this._relativeLayoutName
    },
    _createCloneInstance: function() {
        return new ccui.RelativeLayoutParameter
    },
    _copyProperties: function(a) {
        ccui.LayoutParameter.prototype._copyProperties.call(this, a);
        a instanceof ccui.RelativeLayoutParameter && (this.setAlign(a._relativeAlign), this.setRelativeToWidgetName(a._relativeWidgetName), this.setRelativeName(a._relativeLayoutName))
    }
});
ccui.RelativeLayoutParameter.create = function() {
    return new ccui.RelativeLayoutParameter
};
ccui.RelativeLayoutParameter.NONE = 0;
ccui.RelativeLayoutParameter.PARENT_TOP_LEFT = 1;
ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT = 3;
ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RelativeLayoutParameter.CENTER_IN_PARENT = 5;
ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM = 7;
ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM = 9;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN = 10;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER = 11;
ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN = 12;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN = 13;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER = 14;
ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN = 15;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN = 16;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER = 17;
ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN = 18;
ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN = 19;
ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER = 20;
ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN = 21;
ccui.LINEAR_GRAVITY_NONE = 0;
ccui.LINEAR_GRAVITY_LEFT = 1;
ccui.LINEAR_GRAVITY_TOP = 2;
ccui.LINEAR_GRAVITY_RIGHT = 3;
ccui.LINEAR_GRAVITY_BOTTOM = 4;
ccui.LINEAR_GRAVITY_CENTER_VERTICAL = 5;
ccui.LINEAR_GRAVITY_CENTER_HORIZONTAL = 6;
ccui.RELATIVE_ALIGN_NONE = 0;
ccui.RELATIVE_ALIGN_PARENT_TOP_LEFT = 1;
ccui.RELATIVE_ALIGN_PARENT_TOP_CENTER_HORIZONTAL = 2;
ccui.RELATIVE_ALIGN_PARENT_TOP_RIGHT = 3;
ccui.RELATIVE_ALIGN_PARENT_LEFT_CENTER_VERTICAL = 4;
ccui.RELATIVE_ALIGN_PARENT_CENTER = 5;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_CENTER_VERTICAL = 6;
ccui.RELATIVE_ALIGN_PARENT_LEFT_BOTTOM = 7;
ccui.RELATIVE_ALIGN_PARENT_BOTTOM_CENTER_HORIZONTAL = 8;
ccui.RELATIVE_ALIGN_PARENT_RIGHT_BOTTOM = 9;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_LEFT = 10;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_CENTER = 11;
ccui.RELATIVE_ALIGN_LOCATION_ABOVE_RIGHT = 12;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_TOP = 13;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_CENTER = 14;
ccui.RELATIVE_ALIGN_LOCATION_LEFT_BOTTOM = 15;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_TOP = 16;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_CENTER = 17;
ccui.RELATIVE_ALIGN_LOCATION_RIGHT_BOTTOM = 18;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_TOP = 19;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_CENTER = 20;
ccui.RELATIVE_ALIGN_LOCATION_BELOW_BOTTOM = 21;
ccui.getLayoutManager = function(a) {
    switch (a) {
        case ccui.Layout.LINEAR_VERTICAL:
            return ccui.linearVerticalLayoutManager;
        case ccui.Layout.LINEAR_HORIZONTAL:
            return ccui.linearHorizontalLayoutManager;
        case ccui.Layout.RELATIVE:
            return ccui.relativeLayoutManager
    }
    return null
};
ccui.linearVerticalLayoutManager = {
    _doLayout: function(a) {
        var b = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var c = b.height, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f) {
                var g = f.getLayoutParameter();
                if (g) {
                    var h = g.getGravity(),
                        k = f.getAnchorPoint(),
                        m = f.getContentSize(),
                        n = k.x * m.width,
                        c = c - (1 - k.y) * m.height;
                    switch (h) {
                        case ccui.LinearLayoutParameter.RIGHT:
                            n = b.width - (1 - k.x) * m.width;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_HORIZONTAL:
                            n = b.width / 2 - m.width * (0.5 - k.x)
                    }
                    g = g.getMargin();
                    n += g.left;
                    c -= g.top;
                    f.setPosition(n, c);
                    c = f.getPositionY() - k.y * m.height - g.bottom
                }
            }
        }
    }
};
ccui.linearHorizontalLayoutManager = {
    _doLayout: function(a) {
        var b = a._getLayoutContentSize();
        a = a._getLayoutElements();
        for (var c = 0, d = 0, e = a.length; d < e; d++) {
            var f = a[d];
            if (f) {
                var g = f.getLayoutParameter();
                if (g) {
                    var h = g.getGravity(),
                        k = f.getAnchorPoint(),
                        m = f.getContentSize(),
                        c = c + k.x * m.width,
                        n = b.height - (1 - k.y) * m.height;
                    switch (h) {
                        case ccui.LinearLayoutParameter.BOTTOM:
                            n = k.y * m.height;
                            break;
                        case ccui.LinearLayoutParameter.CENTER_VERTICAL:
                            n = b.height / 2 - m.height * (0.5 - k.y)
                    }
                    g = g.getMargin();
                    c += g.left;
                    n -= g.top;
                    f.setPosition(c,
                        n);
                    c = f.getRightBoundary() + g.right
                }
            }
        }
    }
};
ccui.relativeLayoutManager = {
    _unlayoutChildCount: 0,
    _widgetChildren: [],
    _widget: null,
    _finalPositionX: 0,
    _finalPositionY: 0,
    _relativeWidgetLP: null,
    _doLayout: function(a) {
        for (var b = this._widgetChildren = this._getAllWidgets(a); 0 < this._unlayoutChildCount;) {
            for (var c = 0, d = b.length; c < d; c++) {
                this._widget = b[c];
                var e = this._widget.getLayoutParameter();
                e && !e._put && this._calculateFinalPositionWithRelativeWidget(a) && (this._calculateFinalPositionWithRelativeAlign(), this._widget.setPosition(this._finalPositionX, this._finalPositionY),
                    e._put = !0)
            }
            this._unlayoutChildCount--
        }
        this._widgetChildren.length = 0
    },
    _getAllWidgets: function(a) {
        a = a._getLayoutElements();
        for (var b = this._widgetChildren, c = b.length = 0, d = a.length; c < d; c++) {
            var e = a[c];
            e && (e.getLayoutParameter()._put = !1, this._unlayoutChildCount++, b.push(e))
        }
        return b
    },
    _getRelativeWidget: function(a) {
        var b = null;
        if ((a = a.getLayoutParameter().getRelativeToWidgetName()) && 0 !== a.length)
            for (var c = this._widgetChildren, d = 0, e = c.length; d < e; d++) {
                var f = c[d];
                if (f) {
                    var g = f.getLayoutParameter();
                    if (g && g.getRelativeName() ===
                        a) {
                        b = f;
                        this._relativeWidgetLP = g;
                        break
                    }
                }
            }
        return b
    },
    _calculateFinalPositionWithRelativeWidget: function(a) {
        var b = this._widget,
            c = b.getAnchorPoint(),
            d = b.getContentSize();
        this._finalPositionY = this._finalPositionX = 0;
        var e = this._getRelativeWidget(b),
            b = b.getLayoutParameter().getAlign();
        a = a._getLayoutContentSize();
        switch (b) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX = c.x * d.width;
                this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionX =
                    0.5 * a.width - d.width * (0.5 - c.x);
                this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX = a.width - (1 - c.x) * d.width;
                this._finalPositionY = a.height - (1 - c.y) * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX = c.x * d.width;
                this._finalPositionY = 0.5 * a.height - d.height * (0.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.CENTER_IN_PARENT:
                this._finalPositionX = 0.5 * a.width - d.width * (0.5 - c.x);
                this._finalPositionY =
                    0.5 * a.height - d.height * (0.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX = a.width - (1 - c.x) * d.width;
                this._finalPositionY = 0.5 * a.height - d.height * (0.5 - c.y);
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX = c.x * d.width;
                this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionX = 0.5 * a.width - d.width * (0.5 - c.x);
                this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX =
                    a.width - (1 - c.x) * d.width;
                this._finalPositionY = c.y * d.height;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() + c.y * d.height;
                    this._finalPositionX = e.getLeftBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize();
                    this._finalPositionY = e.getTopBoundary() + c.y * d.height;
                    this._finalPositionX = e.getLeftBoundary() + 0.5 * a.width + c.x * d.width - 0.5 * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() + c.y * d.height;
                    this._finalPositionX = e.getRightBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() -
                        (1 - c.y) * d.height;
                    this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize();
                    this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width;
                    this._finalPositionY = e.getBottomBoundary() + 0.5 * a.height + c.y * d.height - 0.5 * d.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() + c.y * d.height;
                    this._finalPositionX = e.getLeftBoundary() - (1 - c.x) * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getTopBoundary() - (1 - c.y) * d.height;
                    this._finalPositionX = e.getRightBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize();
                    this._finalPositionX = e.getRightBoundary() + c.x * d.width;
                    this._finalPositionY = e.getBottomBoundary() + 0.5 * a.height + c.y * d.height - 0.5 * d.height
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() + c.y * d.height;
                    this._finalPositionX = e.getRightBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height;
                    this._finalPositionX = e.getLeftBoundary() + c.x * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                if (e) {
                    if (this._relativeWidgetLP && !this._relativeWidgetLP._put) return !1;
                    a = e.getContentSize();
                    this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height;
                    this._finalPositionX = e.getLeftBoundary() + 0.5 * a.width + c.x * d.width - 0.5 * d.width
                }
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                if (e) {
                    if (this._relativeWidgetLP &&
                        !this._relativeWidgetLP._put) return !1;
                    this._finalPositionY = e.getBottomBoundary() - (1 - c.y) * d.height;
                    this._finalPositionX = e.getRightBoundary() - (1 - c.x) * d.width
                }
        }
        return !0
    },
    _calculateFinalPositionWithRelativeAlign: function() {
        var a = this._widget.getLayoutParameter(),
            b = a.getMargin();
        switch (a.getAlign()) {
            case ccui.RelativeLayoutParameter.NONE:
            case ccui.RelativeLayoutParameter.PARENT_TOP_LEFT:
                this._finalPositionX += b.left;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_CENTER_HORIZONTAL:
                this._finalPositionY -=
                    b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_TOP_RIGHT:
                this._finalPositionX -= b.right;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_CENTER_VERTICAL:
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_CENTER_VERTICAL:
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.PARENT_LEFT_BOTTOM:
                this._finalPositionX += b.left;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_BOTTOM_CENTER_HORIZONTAL:
                this._finalPositionY +=
                    b.bottom;
                break;
            case ccui.RelativeLayoutParameter.PARENT_RIGHT_BOTTOM:
                this._finalPositionX -= b.right;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_LEFTALIGN:
                this._finalPositionY += b.bottom;
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_RIGHTALIGN:
                this._finalPositionY += b.bottom;
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_ABOVE_CENTER:
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_TOPALIGN:
                this._finalPositionX -=
                    b.right;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_BOTTOMALIGN:
                this._finalPositionX -= b.right;
                this._finalPositionY += b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_LEFT_OF_CENTER:
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_TOPALIGN:
                this._finalPositionX += b.left;
                this._finalPositionY -= b.top;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_BOTTOMALIGN:
                this._finalPositionX += b.left;
                this._finalPositionY +=
                    b.bottom;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_RIGHT_OF_CENTER:
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_LEFTALIGN:
                this._finalPositionY -= b.top;
                this._finalPositionX += b.left;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_RIGHTALIGN:
                this._finalPositionY -= b.top;
                this._finalPositionX -= b.right;
                break;
            case ccui.RelativeLayoutParameter.LOCATION_BELOW_CENTER:
                this._finalPositionY -= b.top
        }
    }
};
ccui.HBox = ccui.Layout.extend({
    ctor: function(a) {
        ccui.Layout.prototype.ctor.call(this, a);
        void 0 !== a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.HBox.create = function(a) {
    return new ccui.HBox(a)
};
ccui.RelativeBox = ccui.Layout.extend({
    ctor: function(a) {
        a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.RELATIVE), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.RelativeBox.create = function(a) {
    return new ccui.RelativeBox(a)
};
ccui.VBox = ccui.Layout.extend({
    ctor: function(a) {
        ccui.Layout.prototype.ctor.call(this, a);
        void 0 !== a ? this.initWithSize(a) : this.init()
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    initWithSize: function(a) {
        return this.init() ? (this.setContentSize(a), !0) : !1
    }
});
ccui.VBox.create = function(a) {
    return new ccui.VBox(a)
};
ccui.helper = {
    seekWidgetByTag: function(a, b) {
        if (!a) return null;
        if (a.getTag() === b) return a;
        for (var c = a.getChildren(), d = c.length, e = 0; e < d; e++) {
            var f = ccui.helper.seekWidgetByTag(c[e], b);
            if (null !== f) return f
        }
        return null
    },
    seekWidgetByName: function(a, b) {
        if (!a) return null;
        if (a.getName() === b) return a;
        for (var c = a.getChildren(), d = c.length, e = 0; e < d; e++) {
            var f = ccui.helper.seekWidgetByName(c[e], b);
            if (null !== f) return f
        }
        return null
    },
    seekWidgetByRelativeName: function(a, b) {
        if (!a) return null;
        for (var c = a.getChildren(),
                d = c.length, e = 0; e < d; e++) {
            var f = c[e],
                g = f.getLayoutParameter(ccui.LayoutParameter.RELATIVE);
            if (g && g.getRelativeName() === b) return f
        }
        return null
    },
    seekActionWidgetByActionTag: function(a, b) {
        if (!a) return null;
        if (a.getActionTag() === b) return a;
        for (var c = a.getChildren(), d = 0; d < c.length; d++) {
            var e = ccui.helper.seekActionWidgetByActionTag(c[d], b);
            if (null !== e) return e
        }
        return null
    },
    _activeLayout: !0,
    doLayout: function(a) {
        if (this._activeLayout) {
            a = a.getChildren();
            for (var b, c = 0, d = a.length; c < d; c++) {
                b = a[c];
                var e = b.getComponent(ccui.LayoutComponent.NAME);
                b = b.getParent();
                null != e && null !== b && e.refreshLayout && e.refreshLayout()
            }
        }
    },
    changeLayoutSystemActiveState: function(a) {
        this._activeLayout = a
    },
    restrictCapInsetRect: function(a, b) {
        var c = a.x,
            d = a.y,
            e = a.width,
            f = a.height;
        b.width < e && (e = c = 0);
        b.height < f && (f = d = 0);
        return cc.rect(c, d, e, f)
    }
};
ccui.Button = ccui.Widget.extend({
    _buttonNormalRenderer: null,
    _buttonClickedRenderer: null,
    _buttonDisableRenderer: null,
    _titleRenderer: null,
    _normalFileName: "",
    _clickedFileName: "",
    _disabledFileName: "",
    _prevIgnoreSize: !0,
    _scale9Enabled: !1,
    _capInsetsNormal: null,
    _capInsetsPressed: null,
    _capInsetsDisabled: null,
    _normalTexType: ccui.Widget.LOCAL_TEXTURE,
    _pressedTexType: ccui.Widget.LOCAL_TEXTURE,
    _disabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _normalTextureSize: null,
    _pressedTextureSize: null,
    _disabledTextureSize: null,
    pressedActionEnabled: !1,
    _titleColor: null,
    _normalTextureScaleXInSize: 1,
    _normalTextureScaleYInSize: 1,
    _pressedTextureScaleXInSize: 1,
    _pressedTextureScaleYInSize: 1,
    _zoomScale: 0.1,
    _normalTextureLoaded: !1,
    _pressedTextureLoaded: !1,
    _disabledTextureLoaded: !1,
    _className: "Button",
    _normalTextureAdaptDirty: !0,
    _pressedTextureAdaptDirty: !0,
    _disabledTextureAdaptDirty: !0,
    _fontName: "Thonburi",
    _fontSize: 12,
    _type: 0,
    ctor: function(a, b, c, d) {
        this._capInsetsNormal = cc.rect(0, 0, 0, 0);
        this._capInsetsPressed = cc.rect(0, 0, 0, 0);
        this._capInsetsDisabled =
            cc.rect(0, 0, 0, 0);
        this._normalTextureSize = cc.size(0, 0);
        this._pressedTextureSize = cc.size(0, 0);
        this._disabledTextureSize = cc.size(0, 0);
        this._titleColor = cc.color.WHITE;
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        if (ccui.Widget.prototype.init.call(this)) {
            if (void 0 === a) return !0;
            this.loadTextures(a, b, c, d)
        }
        return !1
    },
    _initRenderer: function() {
        this._buttonNormalRenderer = new cc.Sprite;
        this._buttonClickedRenderer = new cc.Sprite;
        this._buttonDisableRenderer =
            new cc.Sprite;
        this._titleRenderer = new cc.LabelTTF("");
        this._titleRenderer.setAnchorPoint(0.5, 0.5);
        this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._buttonDisableRenderer, ccui.Button.DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._titleRenderer, ccui.Button.TITLE_RENDERER_ZORDER, -1)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled !==
            a && (this._brightStyle = ccui.Widget.BRIGHT_STYLE_NONE, this._scale9Enabled = a, this.removeProtectedChild(this._buttonNormalRenderer), this.removeProtectedChild(this._buttonClickedRenderer), this.removeProtectedChild(this._buttonDisableRenderer), this._scale9Enabled ? (this._buttonNormalRenderer = new ccui.Scale9Sprite, this._buttonClickedRenderer = new ccui.Scale9Sprite, this._buttonDisableRenderer = new ccui.Scale9Sprite) : (this._buttonNormalRenderer = new cc.Sprite, this._buttonClickedRenderer = new cc.Sprite, this._buttonDisableRenderer =
                new cc.Sprite), this._buttonClickedRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!1), this.loadTextureNormal(this._normalFileName, this._normalTexType), this.loadTexturePressed(this._clickedFileName, this._pressedTexType), this.loadTextureDisabled(this._disabledFileName, this._disabledTexType), this.addProtectedChild(this._buttonNormalRenderer, ccui.Button.NORMAL_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonClickedRenderer, ccui.Button.PRESSED_RENDERER_ZORDER, -1), this.addProtectedChild(this._buttonDisableRenderer,
                ccui.Button.DISABLED_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsNormalRenderer(this._capInsetsNormal), this.setCapInsetsPressedRenderer(this._capInsetsPressed), this.setCapInsetsDisabledRenderer(this._capInsetsDisabled), this.setBright(this._bright), this._disabledTextureAdaptDirty = this._pressedTextureAdaptDirty = this._normalTextureAdaptDirty = !0)
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (this._unifySize) this._updateContentSize();
        else if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    getVirtualRendererSize: function() {
        return this._unifySize ? this._getNormalSize() : !this._normalTextureLoaded && 0 < this._titleRenderer.getString().length ? this._titleRenderer.getContentSize() : cc.size(this._normalTextureSize)
    },
    loadTextures: function(a, b, c, d) {
        this.loadTextureNormal(a, d);
        this.loadTexturePressed(b, d);
        this.loadTextureDisabled(c, d)
    },
    loadTextureNormal: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._normalFileName = a;
            this._normalTexType = b;
            var c = this,
                d = this._buttonNormalRenderer;
            d._textureLoaded || d.addEventListener("load", function() {
                c.loadTextureNormal(c._normalFileName, c._normalTexType)
            });
            switch (this._normalTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._normalTextureLoaded = d._textureLoaded;
            this._normalTextureSize = this._buttonNormalRenderer.getContentSize();
            this._updateChildrenDisplayedRGBA();
            this._unifySize ? this._scale9Enabled && (d.setCapInsets(this._capInsetsNormal), this._updateContentSizeWithTextureSize(this._getNormalSize())) : this._updateContentSizeWithTextureSize(this._normalTextureSize);
            this._normalTextureAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTexturePressed: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._clickedFileName = a;
            this._pressedTexType = b;
            var c = this,
                d = this._buttonClickedRenderer;
            d._textureLoaded || d.addEventListener("load", function() {
                c.loadTexturePressed(c._clickedFileName, c._pressedTexType)
            });
            switch (this._pressedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._scale9Enabled && d.setCapInsets(this._capInsetsPressed);
            this._pressedTextureSize = this._buttonClickedRenderer.getContentSize();
            this._updateChildrenDisplayedRGBA();
            this._pressedTextureAdaptDirty = this._pressedTextureLoaded = !0;
            this._findLayout()
        }
    },
    loadTextureDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._disabledFileName = a;
            this._disabledTexType = b;
            var c = this,
                d = this._buttonDisableRenderer;
            d._textureLoaded || d.addEventListener("load", function() {
                c.loadTextureDisabled(c._disabledFileName, c._disabledTexType)
            });
            switch (this._disabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    d.initWithSpriteFrameName(a)
            }
            this._scale9Enabled && d.setCapInsets(this._capInsetsDisabled);
            this._disabledTextureSize =
                this._buttonDisableRenderer.getContentSize();
            this._updateChildrenDisplayedRGBA();
            this._disabledTextureAdaptDirty = this._disabledTextureLoaded = !0;
            this._findLayout()
        }
    },
    setCapInsets: function(a) {
        this.setCapInsetsNormalRenderer(a);
        this.setCapInsetsPressedRenderer(a);
        this.setCapInsetsDisabledRenderer(a)
    },
    setCapInsetsNormalRenderer: function(a) {
        if (a) {
            var b = a.x,
                c = a.y,
                d = a.width;
            a = a.height;
            this._normalTextureSize.width < d && (d = b = 0);
            this._normalTextureSize.height < a && (a = c = 0);
            var e = this._capInsetsNormal;
            e.x = b;
            e.y =
                c;
            e.width = d;
            e.height = a;
            this._scale9Enabled && this._buttonNormalRenderer.setCapInsets(e)
        }
    },
    getCapInsetsNormalRenderer: function() {
        return cc.rect(this._capInsetsNormal)
    },
    setCapInsetsPressedRenderer: function(a) {
        if (a && this._scale9Enabled) {
            var b = a.x,
                c = a.y,
                d = a.width;
            a = a.height;
            this._pressedTextureSize.width < d && (d = b = 0);
            this._pressedTextureSize.height < a && (a = c = 0);
            var e = this._capInsetsPressed;
            e.x = b;
            e.y = c;
            e.width = d;
            e.height = a;
            this._buttonClickedRenderer.setCapInsets(e)
        }
    },
    getCapInsetsPressedRenderer: function() {
        return cc.rect(this._capInsetsPressed)
    },
    setCapInsetsDisabledRenderer: function(a) {
        if (a && this._scale9Enabled) {
            var b = a.x,
                c = a.y,
                d = a.width;
            a = a.height;
            this._disabledTextureSize.width < d && (d = b = 0);
            this._disabledTextureSize.height < a && (a = c = 0);
            var e = this._capInsetsDisabled;
            e.x = b;
            e.y = c;
            e.width = d;
            e.height = a;
            this._buttonDisableRenderer.setCapInsets(e)
        }
    },
    getCapInsetsDisabledRenderer: function() {
        return cc.rect(this._capInsetsDisabled)
    },
    _onPressStateChangedToNormal: function() {
        this._buttonNormalRenderer.setVisible(!0);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonDisableRenderer.setVisible(!1);
        this._scale9Enabled && this._buttonNormalRenderer.setState(ccui.Scale9Sprite.state.NORMAL);
        if (this._pressedTextureLoaded) {
            if (this.pressedActionEnabled)
                if (this._buttonNormalRenderer.stopAllActions(), this._buttonClickedRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize), this._titleRenderer.stopAllActions(),
                    this._unifySize) {
                    var a = cc.scaleTo(ccui.Button.ZOOM_ACTION_TIME_STEP, 1, 1);
                    this._titleRenderer.runAction(a)
                } else this._titleRenderer.setScaleX(1), this._titleRenderer.setScaleY(1)
        } else this._buttonNormalRenderer.stopAllActions(), this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize), this._titleRenderer.stopAllActions(), this._scale9Enabled && this._buttonNormalRenderer.setColor(cc.color.WHITE), this._titleRenderer.setScaleX(1), this._titleRenderer.setScaleY(1)
    },
    _onPressStateChangedToPressed: function() {
        var a = this._buttonNormalRenderer;
        this._scale9Enabled && a.setState(ccui.Scale9Sprite.state.NORMAL);
        if (this._pressedTextureLoaded) {
            if (a.setVisible(!1), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), this.pressedActionEnabled) {
                a.stopAllActions();
                this._buttonClickedRenderer.stopAllActions();
                var b = cc.scaleTo(ccui.Button.ZOOM_ACTION_TIME_STEP, this._pressedTextureScaleXInSize + this._zoomScale, this._pressedTextureScaleYInSize + this._zoomScale);
                this._buttonClickedRenderer.runAction(b);
                a.setScale(this._pressedTextureScaleXInSize + this._zoomScale, this._pressedTextureScaleYInSize + this._zoomScale);
                this._titleRenderer.stopAllActions();
                this._titleRenderer.runAction(cc.scaleTo(ccui.Button.ZOOM_ACTION_TIME_STEP, 1 + this._zoomScale, 1 + this._zoomScale))
            }
        } else a.setVisible(!0), this._buttonClickedRenderer.setVisible(!0), this._buttonDisableRenderer.setVisible(!1), a.stopAllActions(), a.setScale(this._normalTextureScaleXInSize + this._zoomScale, this._normalTextureScaleYInSize +
            this._zoomScale), this._titleRenderer.stopAllActions(), this._titleRenderer.setScaleX(1 + this._zoomScale), this._titleRenderer.setScaleY(1 + this._zoomScale)
    },
    _onPressStateChangedToDisabled: function() {
        this._disabledTextureLoaded ? (this._buttonNormalRenderer.setVisible(!1), this._buttonDisableRenderer.setVisible(!0)) : this._normalTextureLoaded && this._scale9Enabled && this._buttonNormalRenderer.setState(ccui.Scale9Sprite.state.GRAY);
        this._buttonClickedRenderer.setVisible(!1);
        this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize,
            this._normalTextureScaleYInSize);
        this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize)
    },
    _updateContentSize: function() {
        if (this._unifySize) {
            if (this._scale9Enabled) ccui.ProtectedNode.setContentSize(this._customSize);
            else {
                var a = this._getNormalSize();
                ccui.ProtectedNode.setContentSize(a)
            }
            this._onSizeChanged()
        } else this._ignoreSize && this.setContentSize(this.getVirtualRendererSize())
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._updateTitleLocation();
        this._disabledTextureAdaptDirty = this._pressedTextureAdaptDirty = this._normalTextureAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        if (this._bright) switch (this._brightStyle) {
            case ccui.Widget.BRIGHT_STYLE_NORMAL:
                return this._buttonNormalRenderer;
            case ccui.Widget.BRIGHT_STYLE_HIGH_LIGHT:
                return this._buttonClickedRenderer;
            default:
                return null
        } else return this._buttonDisableRenderer
    },
    _normalTextureScaleChangedWithSize: function() {
        if (this._ignoreSize && !this._unifySize) this._scale9Enabled ||
            (this._buttonNormalRenderer.setScale(1), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1);
        else if (this._scale9Enabled) this._buttonNormalRenderer.setPreferredSize(this._contentSize), this._normalTextureScaleXInSize = this._normalTextureScaleYInSize = 1, this._buttonNormalRenderer.setScale(this._normalTextureScaleXInSize, this._normalTextureScaleYInSize);
        else {
            var a = this._normalTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonNormalRenderer.setScale(1);
                return
            }
            var b = this._contentSize.width /
                a.width,
                a = this._contentSize.height / a.height;
            this._buttonNormalRenderer.setScaleX(b);
            this._buttonNormalRenderer.setScaleY(a);
            this._normalTextureScaleXInSize = b;
            this._normalTextureScaleYInSize = a
        }
        this._buttonNormalRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _pressedTextureScaleChangedWithSize: function() {
        if (this._ignoreSize && !this._unifySize) this._scale9Enabled || (this._buttonClickedRenderer.setScale(1), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1);
        else if (this._scale9Enabled) this._buttonClickedRenderer.setPreferredSize(this._contentSize), this._pressedTextureScaleXInSize = this._pressedTextureScaleYInSize = 1, this._buttonClickedRenderer.setScale(this._pressedTextureScaleXInSize, this._pressedTextureScaleYInSize);
        else {
            var a = this._pressedTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonClickedRenderer.setScale(1);
                return
            }
            var b = this._contentSize.width / a.width,
                a = this._contentSize.height / a.height;
            this._buttonClickedRenderer.setScaleX(b);
            this._buttonClickedRenderer.setScaleY(a);
            this._pressedTextureScaleXInSize = b;
            this._pressedTextureScaleYInSize = a
        }
        this._buttonClickedRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _disabledTextureScaleChangedWithSize: function() {
        if (this._ignoreSize && !this._unifySize) this._scale9Enabled && this._buttonDisableRenderer.setScale(1);
        else if (this._scale9Enabled) this._buttonDisableRenderer.setScale(1), this._buttonDisableRenderer.setPreferredSize(this._contentSize);
        else {
            var a = this._disabledTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._buttonDisableRenderer.setScale(1);
                return
            }
            var b = this._contentSize.height / a.height;
            this._buttonDisableRenderer.setScaleX(this._contentSize.width / a.width);
            this._buttonDisableRenderer.setScaleY(b)
        }
        this._buttonDisableRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    _adaptRenderers: function() {
        this._normalTextureAdaptDirty && (this._normalTextureScaleChangedWithSize(), this._normalTextureAdaptDirty = !1);
        this._pressedTextureAdaptDirty && (this._pressedTextureScaleChangedWithSize(), this._pressedTextureAdaptDirty = !1);
        this._disabledTextureAdaptDirty &&
            (this._disabledTextureScaleChangedWithSize(), this._disabledTextureAdaptDirty = !1)
    },
    _updateTitleLocation: function() {
        this._titleRenderer.setPosition(0.5 * this._contentSize.width, 0.5 * this._contentSize.height)
    },
    setPressedActionEnabled: function(a) {
        this.pressedActionEnabled = a
    },
    setTitleText: function(a) {
        a !== this.getTitleText() && (this._titleRenderer.setString(a), this._ignoreSize ? (a = this.getVirtualRendererSize(), this.setContentSize(a)) : this._titleRenderer._renderCmd._updateTTF())
    },
    getTitleText: function() {
        return this._titleRenderer.getString()
    },
    setTitleColor: function(a) {
        this._titleRenderer.setFontFillColor(a)
    },
    getTitleColor: function() {
        return this._titleRenderer._getFillStyle()
    },
    setTitleFontSize: function(a) {
        this._titleRenderer.setFontSize(a);
        this._fontSize = a
    },
    getTitleFontSize: function() {
        return this._titleRenderer.getFontSize()
    },
    setZoomScale: function(a) {
        this._zoomScale = a
    },
    getZoomScale: function() {
        return this._zoomScale
    },
    getNormalTextureSize: function() {
        return this._normalTextureSize
    },
    setTitleFontName: function(a) {
        this._titleRenderer.setFontName(a);
        this._fontName = a
    },
    getTitleRenderer: function() {
        return this._titleRenderer
    },
    getTitleFontName: function() {
        return this._titleRenderer.getFontName()
    },
    _setTitleFont: function(a) {
        this._titleRenderer.font = a
    },
    _getTitleFont: function() {
        return this._titleRenderer.font
    },
    getDescription: function() {
        return "Button"
    },
    _createCloneInstance: function() {
        return new ccui.Button
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadTextureNormal(a._normalFileName,
            a._normalTexType);
        this.loadTexturePressed(a._clickedFileName, a._pressedTexType);
        this.loadTextureDisabled(a._disabledFileName, a._disabledTexType);
        this.setCapInsetsNormalRenderer(a._capInsetsNormal);
        this.setCapInsetsPressedRenderer(a._capInsetsPressed);
        this.setCapInsetsDisabledRenderer(a._capInsetsDisabled);
        this.setTitleText(a.getTitleText());
        this.setTitleFontName(a.getTitleFontName());
        this.setTitleFontSize(a.getTitleFontSize());
        this.setTitleColor(a.getTitleColor());
        this.setPressedActionEnabled(a.pressedActionEnabled);
        this.setZoomScale(a._zoomScale)
    },
    _getNormalSize: function() {
        var a;
        null !== this._titleRenderer && (a = this._titleRenderer.getContentSize());
        var b;
        null !== this._buttonNormalRenderer && (b = this._buttonNormalRenderer.getContentSize());
        return cc.size(a.width > b.width ? a.width : b.width, a.height > b.height ? a.height : b.height)
    }
});
_p = ccui.Button.prototype;
cc.defineGetterSetter(_p, "titleText", _p.getTitleText, _p.setTitleText);
cc.defineGetterSetter(_p, "titleFont", _p._getTitleFont, _p._setTitleFont);
cc.defineGetterSetter(_p, "titleFontSize", _p.getTitleFontSize, _p.setTitleFontSize);
cc.defineGetterSetter(_p, "titleFontName", _p.getTitleFontName, _p.setTitleFontName);
cc.defineGetterSetter(_p, "titleColor", _p.getTitleColor, _p.setTitleColor);
_p = null;
ccui.Button.create = function(a, b, c, d) {
    return new ccui.Button(a, b, c, d)
};
ccui.Button.NORMAL_RENDERER_ZORDER = -2;
ccui.Button.PRESSED_RENDERER_ZORDER = -2;
ccui.Button.DISABLED_RENDERER_ZORDER = -2;
ccui.Button.TITLE_RENDERER_ZORDER = -1;
ccui.Button.ZOOM_ACTION_TIME_STEP = 0.05;
ccui.Button.SYSTEM = 0;
ccui.Button.TTF = 1;
ccui.CheckBox = ccui.Widget.extend({
    _backGroundBoxRenderer: null,
    _backGroundSelectedBoxRenderer: null,
    _frontCrossRenderer: null,
    _backGroundBoxDisabledRenderer: null,
    _frontCrossDisabledRenderer: null,
    _isSelected: !0,
    _checkBoxEventListener: null,
    _checkBoxEventSelector: null,
    _backGroundTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundSelectedTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _frontCrossDisabledTexType: ccui.Widget.LOCAL_TEXTURE,
    _backGroundFileName: "",
    _backGroundSelectedFileName: "",
    _frontCrossFileName: "",
    _backGroundDisabledFileName: "",
    _frontCrossDisabledFileName: "",
    _className: "CheckBox",
    _zoomScale: 0.1,
    _backgroundTextureScaleX: 0.1,
    _backgroundTextureScaleY: 0.1,
    _backGroundBoxRendererAdaptDirty: !0,
    _backGroundSelectedBoxRendererAdaptDirty: !0,
    _frontCrossRendererAdaptDirty: !0,
    _backGroundBoxDisabledRendererAdaptDirty: !0,
    _frontCrossDisabledRendererAdaptDirty: !0,
    ctor: function(a, b, c, d, e, f) {
        ccui.Widget.prototype.ctor.call(this);
        this.setTouchEnabled(!0);
        for (var g = 0, h = 0; h < arguments.length; h++) {
            var k = typeof arguments[h];
            "string" === k ? isNaN(arguments[h] - 0) ? g++ : (f = arguments[h], arguments[h] = void 0) : "number" === k && g++
        }
        switch (g) {
            case 2:
                f = c, c = b, b = void 0
        }
        this.init(a, b, c, d, e, void 0 === f ? 0 : f)
    },
    init: function(a, b, c, d, e, f) {
        return ccui.Widget.prototype.init.call(this) ? (this._isSelected = !0, this.setSelected(!1), this.loadTextures(a, b, c, d, e, f), !0) : !1
    },
    _initRenderer: function() {
        this._backGroundBoxRenderer = new cc.Sprite;
        this._backGroundSelectedBoxRenderer = new cc.Sprite;
        this._frontCrossRenderer = new cc.Sprite;
        this._backGroundBoxDisabledRenderer = new cc.Sprite;
        this._frontCrossDisabledRenderer = new cc.Sprite;
        this.addProtectedChild(this._backGroundBoxRenderer, ccui.CheckBox.BOX_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundSelectedBoxRenderer, ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossRenderer, ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._backGroundBoxDisabledRenderer, ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._frontCrossDisabledRenderer, ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER, -1)
    },
    loadTextures: function(a, b, c, d, e, f) {
        a && this.loadTextureBackGround(a, f);
        b && this.loadTextureBackGroundSelected(b, f);
        c && this.loadTextureFrontCross(c, f);
        d && this.loadTextureBackGroundDisabled(d, f);
        e && this.loadTextureFrontCrossDisabled(e, f)
    },
    loadTextureBackGround: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundFileName = a;
            this._backGroundTexType = b;
            var c = this._backGroundBoxRenderer;
            c._textureLoaded ? this._backGroundBoxRenderer.setContentSize(this._customSize) : c.addEventListener("load", function() {
                this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize());
                this.loadTextureBackGround(this._backGroundFileName, this._backGroundTexType)
            }, this);
            switch (this._backGroundTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._updateContentSizeWithTextureSize(this._backGroundBoxRenderer.getContentSize());
            this._backGroundBoxRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTextureBackGroundSelected: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundSelectedFileName = a;
            this._backGroundSelectedTexType = b;
            var c = this._backGroundSelectedBoxRenderer;
            c._textureLoaded || c.addEventListener("load", function() {
                this.loadTextureBackGroundSelected(this._backGroundSelectedFileName, this._backGroundSelectedTexType)
            }, this);
            switch (this._backGroundSelectedTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._backGroundSelectedBoxRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTextureFrontCross: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossFileName = a;
            this._frontCrossTexType = b;
            var c = this._frontCrossRenderer;
            c._textureLoaded || c.addEventListener("load", function() {
                this.loadTextureFrontCross(this._frontCrossFileName, this._frontCrossTexType)
            }, this);
            switch (this._frontCrossTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._frontCrossRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTextureBackGroundDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._backGroundDisabledFileName = a;
            this._backGroundDisabledTexType = b;
            var c = this._backGroundBoxDisabledRenderer;
            c._textureLoaded || c.addEventListener("load", function() {
                    this.loadTextureBackGroundDisabled(this._backGroundDisabledFileName, this._backGroundDisabledTexType)
                },
                this);
            switch (this._backGroundDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._backGroundBoxDisabledRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    loadTextureFrontCrossDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._frontCrossDisabledFileName = a;
            this._frontCrossDisabledTexType = b;
            var c = this._frontCrossDisabledRenderer;
            c._textureLoaded || c.addEventListener("load", function() {
                this.loadTextureFrontCrossDisabled(this._frontCrossDisabledFileName,
                    this._frontCrossDisabledTexType)
            }, this);
            switch (this._frontCrossDisabledTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._frontCrossDisabledRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    _onPressStateChangedToNormal: function() {
        this._backGroundBoxRenderer.setVisible(!0);
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._backGroundBoxDisabledRenderer.setVisible(!1);
        this._frontCrossDisabledRenderer.setVisible(!1);
        this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY);
        this._frontCrossRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY);
        this._isSelected && (this._frontCrossRenderer.setVisible(!0), this._frontCrossRendererAdaptDirty = !0)
    },
    _onPressStateChangedToPressed: function() {
        this._backGroundSelectedFileName ? (this._backGroundBoxRenderer.setVisible(!1), this._backGroundSelectedBoxRenderer.setVisible(!0), this._backGroundBoxDisabledRenderer.setVisible(!1),
            this._frontCrossDisabledRenderer.setVisible(!1)) : (this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX + this._zoomScale, this._backgroundTextureScaleY + this._zoomScale), this._frontCrossRenderer.setScale(this._backgroundTextureScaleX + this._zoomScale, this._backgroundTextureScaleY + this._zoomScale))
    },
    _onPressStateChangedToDisabled: function() {
        this._backGroundDisabledFileName && this._frontCrossDisabledFileName && (this._backGroundBoxRenderer.setVisible(!1), this._backGroundBoxDisabledRenderer.setVisible(!0));
        this._backGroundSelectedBoxRenderer.setVisible(!1);
        this._frontCrossRenderer.setVisible(!1);
        this._backGroundBoxRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY);
        this._frontCrossRenderer.setScale(this._backgroundTextureScaleX, this._backgroundTextureScaleY);
        this._isSelected && (this._frontCrossDisabledRenderer.setVisible(!0), this._frontCrossDisabledRendererAdaptDirty = !0)
    },
    setZoomScale: function(a) {
        this._zoomScale = a
    },
    getZoomScale: function() {
        return this._zoomScale
    },
    setSelectedState: function(a) {
        this.setSelected(a)
    },
    setSelected: function(a) {
        a !== this._isSelected && (this._isSelected = a, this._frontCrossRenderer.setVisible(this._isSelected))
    },
    getSelectedState: function() {
        return this.isSelected()
    },
    isSelected: function() {
        return this._isSelected
    },
    _selectedEvent: function() {
        this._checkBoxEventSelector && (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_SELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_SELECTED))
    },
    _unSelectedEvent: function() {
        this._checkBoxEventSelector &&
            (this._checkBoxEventListener ? this._checkBoxEventSelector.call(this._checkBoxEventListener, this, ccui.CheckBox.EVENT_UNSELECTED) : this._checkBoxEventSelector(this, ccui.CheckBox.EVENT_UNSELECTED))
    },
    _releaseUpEvent: function() {
        ccui.Widget.prototype._releaseUpEvent.call(this);
        this._isSelected ? (this.setSelected(!1), this._unSelectedEvent()) : (this.setSelected(!0), this._selectedEvent())
    },
    addEventListenerCheckBox: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._checkBoxEventSelector =
            a;
        this._checkBoxEventListener = b
    },
    getVirtualRendererSize: function() {
        return this._backGroundBoxRenderer.getContentSize()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._frontCrossDisabledRendererAdaptDirty = this._backGroundBoxDisabledRendererAdaptDirty = this._frontCrossRendererAdaptDirty = this._backGroundSelectedBoxRendererAdaptDirty = this._backGroundBoxRendererAdaptDirty = !0
    },
    getVirtualRenderer: function() {
        return this._backGroundBoxRenderer
    },
    _backGroundTextureScaleChangedWithSize: function() {
        var a =
            this._backGroundBoxRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1), this._backgroundTextureScaleX = this._backgroundTextureScaleY = 1;
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                this._backgroundTextureScaleX = this._backgroundTextureScaleY = 1;
                return
            }
            var d = b.width / c.width,
                c = b.height / c.height;
            this._backgroundTextureScaleX = d;
            this._backgroundTextureScaleY = c;
            a.setScaleX(d);
            a.setScaleY(c)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _backGroundSelectedTextureScaleChangedWithSize: function() {
        var a =
            this._backGroundSelectedBoxRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _frontCrossTextureScaleChangedWithSize: function() {
        var a = this._frontCrossRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height /
                c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _backGroundDisabledTextureScaleChangedWithSize: function() {
        var a = this._backGroundBoxDisabledRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    _frontCrossDisabledTextureScaleChangedWithSize: function() {
        var a = this._frontCrossDisabledRenderer,
            b = this._contentSize;
        if (this._ignoreSize) a.setScale(1);
        else {
            var c = a.getContentSize();
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width / c.width);
            a.setScaleY(d)
        }
        a.setPosition(0.5 * b.width, 0.5 * b.height)
    },
    getDescription: function() {
        return "CheckBox"
    },
    _createCloneInstance: function() {
        return new ccui.CheckBox
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.CheckBox && (this.loadTextureBackGround(a._backGroundFileName, a._backGroundTexType), this.loadTextureBackGroundSelected(a._backGroundSelectedFileName,
                a._backGroundSelectedTexType), this.loadTextureFrontCross(a._frontCrossFileName, a._frontCrossTexType), this.loadTextureBackGroundDisabled(a._backGroundDisabledFileName, a._backGroundDisabledTexType), this.loadTextureFrontCrossDisabled(a._frontCrossDisabledFileName, a._frontCrossDisabledTexType), this.setSelected(a._isSelected), this._checkBoxEventListener = a._checkBoxEventListener, this._checkBoxEventSelector = a._checkBoxEventSelector, this._ccEventCallback = a._ccEventCallback, this._zoomScale = a._zoomScale, this._backgroundTextureScaleX =
            a._backgroundTextureScaleX, this._backgroundTextureScaleY = a._backgroundTextureScaleY)
    },
    _adaptRenderers: function() {
        this._backGroundBoxRendererAdaptDirty && (this._backGroundTextureScaleChangedWithSize(), this._backGroundBoxRendererAdaptDirty = !1);
        this._backGroundSelectedBoxRendererAdaptDirty && (this._backGroundSelectedTextureScaleChangedWithSize(), this._backGroundSelectedBoxRendererAdaptDirty = !1);
        this._frontCrossRendererAdaptDirty && (this._frontCrossTextureScaleChangedWithSize(), this._frontCrossRendererAdaptDirty = !1);
        this._backGroundBoxDisabledRendererAdaptDirty && (this._backGroundDisabledTextureScaleChangedWithSize(), this._backGroundBoxDisabledRendererAdaptDirty = !1);
        this._frontCrossDisabledRendererAdaptDirty && (this._frontCrossDisabledTextureScaleChangedWithSize(), this._frontCrossDisabledRendererAdaptDirty = !1)
    }
});
_p = ccui.CheckBox.prototype;
cc.defineGetterSetter(_p, "selected", _p.isSelected, _p.setSelected);
_p = null;
ccui.CheckBox.create = function(a, b, c, d, e, f) {
    return new ccui.CheckBox(a, b, c, d, e, f)
};
ccui.CheckBox.EVENT_SELECTED = 0;
ccui.CheckBox.EVENT_UNSELECTED = 1;
ccui.CheckBox.BOX_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_SELECTED_RENDERER_ZORDER = -1;
ccui.CheckBox.BOX_DISABLED_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_RENDERER_ZORDER = -1;
ccui.CheckBox.FRONT_CROSS_DISABLED_RENDERER_ZORDER = -1;
ccui.ImageView = ccui.Widget.extend({
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _imageRenderer: null,
    _textureFile: "",
    _imageTexType: ccui.Widget.LOCAL_TEXTURE,
    _imageTextureSize: null,
    _className: "ImageView",
    _imageRendererAdaptDirty: !0,
    ctor: function(a, b) {
        this._capInsets = cc.rect(0, 0, 0, 0);
        this._imageTextureSize = cc.size(this._capInsets.width, this._capInsets.height);
        ccui.Widget.prototype.ctor.call(this);
        this._init(a, void 0 === b ? 0 : b)
    },
    _init: function(a, b) {
        void 0 === a ? this._imageTexType = ccui.Widget.LOCAL_TEXTURE :
            this.loadTexture(a, b)
    },
    _initRenderer: function() {
        this._imageRenderer = new cc.Sprite;
        this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1)
    },
    loadTexture: function(a, b) {
        if (a) {
            var c = this;
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._imageTexType = b;
            var d = c._imageRenderer;
            d._textureLoaded || d.addEventListener("load", function() {
                c.loadTexture(c._textureFile, c._imageTexType)
            });
            switch (c._imageTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c._scale9Enabled ? (d.initWithFile(a), d.setCapInsets(c._capInsets)) :
                        d.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c._scale9Enabled ? (d.initWithSpriteFrameName(a), d.setCapInsets(c._capInsets)) : d.initWithSpriteFrameName(a)
            }
            c._imageTextureSize = d.getContentSize();
            this._updateChildrenDisplayedRGBA();
            c._updateContentSizeWithTextureSize(c._imageTextureSize);
            c._imageRendererAdaptDirty = !0;
            c._findLayout()
        }
    },
    setTextureRect: function(a) {
        this._scale9Enabled || this._imageRenderer.setTextureRect(a)
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled !== a && (this._scale9Enabled =
            a, this.removeProtectedChild(this._imageRenderer), this._imageRenderer = null, this._imageRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : new cc.Sprite, this.loadTexture(this._textureFile, this._imageTexType), this.addProtectedChild(this._imageRenderer, ccui.ImageView.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets), this._imageRendererAdaptDirty = !0)
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    setCapInsets: function(a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._imageRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._imageRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._imageRendererAdaptDirty && (this._imageTextureScaleChangedWithSize(), this._imageRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return cc.size(this._imageTextureSize)
    },
    getVirtualRenderer: function() {
        return this._imageRenderer
    },
    _imageTextureScaleChangedWithSize: function() {
        if (this._ignoreSize) this._scale9Enabled || this._imageRenderer.setScale(1);
        else if (this._scale9Enabled) this._imageRenderer.setPreferredSize(this._contentSize),
            this._imageRenderer.setScale(1);
        else {
            var a = this._imageTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._imageRenderer.setScale(1);
                return
            }
            this._imageRenderer.setScaleX(this._contentSize.width / a.width);
            this._imageRenderer.setScaleY(this._contentSize.height / a.height)
        }
        this._imageRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "ImageView"
    },
    _createCloneInstance: function() {
        return new ccui.ImageView
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ImageView &&
            (this._prevIgnoreSize = a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._imageTexType), this.setCapInsets(a._capInsets))
    },
    setContentSize: function(a, b) {
        null != b && (a = cc.size(a, b));
        ccui.Widget.prototype.setContentSize.call(this, a);
        if (this._scale9Enabled) this._imageRenderer.setContentSize(a);
        else {
            var c = this._imageRenderer.getContentSize();
            this._imageRenderer.setScaleX(a.width / c.width);
            this._imageRenderer.setScaleY(a.height / c.height)
        }
    }
});
ccui.ImageView.create = function(a, b) {
    return new ccui.ImageView(a, b)
};
ccui.ImageView.RENDERER_ZORDER = -1;
ccui.LoadingBar = ccui.Widget.extend({
    _direction: null,
    _percent: 100,
    _totalLength: 0,
    _barRenderer: null,
    _renderBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _barRendererTextureSize: null,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _capInsets: null,
    _textureFile: "",
    _isTextureLoaded: !1,
    _className: "LoadingBar",
    _barRendererAdaptDirty: !0,
    ctor: function(a, b) {
        this._direction = ccui.LoadingBar.TYPE_LEFT;
        this._barRendererTextureSize = cc.size(0, 0);
        this._capInsets = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== a && this.loadTexture(a);
        void 0 !== b && this.setPercent(b)
    },
    _initRenderer: function() {
        this._barRenderer = new cc.Sprite;
        this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1);
        this._barRenderer.setAnchorPoint(0, 0.5)
    },
    setDirection: function(a) {
        if (this._direction !== a) switch (this._direction = a, this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                this._barRenderer.setAnchorPoint(0, 0.5);
                this._barRenderer.setPosition(0, 0.5 * this._contentSize.height);
                this._scale9Enabled || this._barRenderer.setFlippedX(!1);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                this._barRenderer.setAnchorPoint(1,
                    0.5), this._barRenderer.setPosition(this._totalLength, 0.5 * this._contentSize.height), this._scale9Enabled || this._barRenderer.setFlippedX(!0)
        }
    },
    getDirection: function() {
        return this._direction
    },
    loadTexture: function(a, b) {
        if (a) {
            this._renderBarTexType = b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            var c = this._barRenderer,
                d = this;
            c._textureLoaded || c.addEventListener("load", function() {
                d.loadTexture(d._textureFile, d._renderBarTexType);
                d._setPercent(d._percent)
            });
            switch (this._renderBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            var e = c.getContentSize();
            this._barRendererTextureSize.width = e.width;
            this._barRendererTextureSize.height = e.height;
            switch (this._direction) {
                case ccui.LoadingBar.TYPE_LEFT:
                    c.setAnchorPoint(0, 0.5);
                    this._scale9Enabled || c.setFlippedX(!1);
                    break;
                case ccui.LoadingBar.TYPE_RIGHT:
                    c.setAnchorPoint(1, 0.5), this._scale9Enabled || c.setFlippedX(!0)
            }
            this._scale9Enabled && c.setCapInsets(this._capInsets);
            this._updateChildrenDisplayedRGBA();
            this._barRendererScaleChangedWithSize();
            this._updateContentSizeWithTextureSize(this._barRendererTextureSize);
            this._barRendererAdaptDirty = !0;
            this._findLayout()
        }
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled !== a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer), this._barRenderer = this._scale9Enabled ? new ccui.Scale9Sprite : new cc.Sprite, this.loadTexture(this._textureFile, this._renderBarTexType), this.addProtectedChild(this._barRenderer, ccui.LoadingBar.RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1),
            this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsets(this._capInsets), this.setPercent(this._percent), this._barRendererAdaptDirty = !0)
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    setCapInsets: function(a) {
        if (a) {
            var b = this._capInsets;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsets: function() {
        return cc.rect(this._capInsets)
    },
    setPercent: function(a) {
        100 < a && (a = 100);
        0 > a && (a = 0);
        a !==
            this._percent && (this._percent = a, this._setPercent(a))
    },
    _setPercent: function() {
        var a, b, c, d;
        0 >= this._totalLength || (a = this._percent / 100, this._scale9Enabled ? this._setScale9Scale() : (c = this._barRenderer, d = this._barRendererTextureSize, b = c.getTextureRect(), b.width = d.width * a, c.setTextureRect(cc.rect(b.x, b.y, d.width * a, d.height), c._rectRotated)))
    },
    setContentSize: function(a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b);
        this._totalLength = void 0 === b ? a.width : a
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1)
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    getVirtualRendererSize: function() {
        return cc.size(this._barRendererTextureSize)
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        var a = this._barRenderer,
            b = this._contentSize;
        if (this._unifySize) this._totalLength = this._contentSize.width, this.setPercent(this._percent);
        else if (this._ignoreSize) this._scale9Enabled || (this._totalLength = this._barRendererTextureSize.width, a.setScale(1));
        else if (this._totalLength = b.width, this._scale9Enabled) this._setScale9Scale(), a.setScale(1);
        else {
            var c = this._barRendererTextureSize;
            if (0 >= c.width || 0 >= c.height) {
                a.setScale(1);
                return
            }
            var d = b.height / c.height;
            a.setScaleX(b.width /
                c.width);
            a.setScaleY(d)
        }
        switch (this._direction) {
            case ccui.LoadingBar.TYPE_LEFT:
                a.setPosition(0, 0.5 * b.height);
                break;
            case ccui.LoadingBar.TYPE_RIGHT:
                a.setPosition(this._totalLength, 0.5 * b.height)
        }
    },
    _setScale9Scale: function() {
        this._barRenderer.setPreferredSize(cc.size(this._percent / 100 * this._totalLength, this._contentSize.height))
    },
    getDescription: function() {
        return "LoadingBar"
    },
    _createCloneInstance: function() {
        return new ccui.LoadingBar
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.LoadingBar && (this._prevIgnoreSize =
            a._prevIgnoreSize, this.setScale9Enabled(a._scale9Enabled), this.loadTexture(a._textureFile, a._renderBarTexType), this.setCapInsets(a._capInsets), this.setPercent(a._percent), this.setDirection(a._direction))
    }
});
_p = ccui.LoadingBar.prototype;
cc.defineGetterSetter(_p, "direction", _p.getDirection, _p.setDirection);
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.LoadingBar.create = function(a, b) {
    return new ccui.LoadingBar(a, b)
};
ccui.LoadingBar.TYPE_LEFT = 0;
ccui.LoadingBar.TYPE_RIGHT = 1;
ccui.LoadingBar.RENDERER_ZORDER = -1;
ccui.Slider = ccui.Widget.extend({
    _barRenderer: null,
    _progressBarRenderer: null,
    _barTextureSize: null,
    _progressBarTextureSize: null,
    _slidBallNormalRenderer: null,
    _slidBallPressedRenderer: null,
    _slidBallDisabledRenderer: null,
    _slidBallRenderer: null,
    _barLength: 0,
    _percent: 0,
    _scale9Enabled: !1,
    _prevIgnoreSize: !0,
    _textureFile: "",
    _progressBarTextureFile: "",
    _slidBallNormalTextureFile: "",
    _slidBallPressedTextureFile: "",
    _slidBallDisabledTextureFile: "",
    _capInsetsBarRenderer: null,
    _capInsetsProgressBarRenderer: null,
    _sliderEventListener: null,
    _sliderEventSelector: null,
    _barTexType: ccui.Widget.LOCAL_TEXTURE,
    _progressBarTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballNTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballPTexType: ccui.Widget.LOCAL_TEXTURE,
    _ballDTexType: ccui.Widget.LOCAL_TEXTURE,
    _isTextureLoaded: !1,
    _className: "Slider",
    _barRendererAdaptDirty: !0,
    _progressBarRendererDirty: !0,
    _unifySize: !1,
    _zoomScale: 0.1,
    _sliderBallNormalTextureScaleX: 1,
    _sliderBallNormalTextureScaleY: 1,
    ctor: function(a, b, c) {
        this._barTextureSize = cc.size(0, 0);
        this._progressBarTextureSize =
            cc.size(0, 0);
        this._capInsetsBarRenderer = cc.rect(0, 0, 0, 0);
        this._capInsetsProgressBarRenderer = cc.rect(0, 0, 0, 0);
        ccui.Widget.prototype.ctor.call(this);
        c = null == c ? 0 : c;
        this.setTouchEnabled(!0);
        a && this.loadBarTexture(a, c);
        b && this.loadSlidBallTextures(b, c)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this)
    },
    _initRenderer: function() {
        this._barRenderer = new cc.Sprite;
        this._progressBarRenderer = new cc.Sprite;
        this._progressBarRenderer.setAnchorPoint(0, 0.5);
        this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1);
        this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1);
        this._slidBallNormalRenderer = new cc.Sprite;
        this._slidBallPressedRenderer = new cc.Sprite;
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer = new cc.Sprite;
        this._slidBallDisabledRenderer.setVisible(!1);
        this._slidBallRenderer = new cc.Node;
        this._slidBallRenderer.addChild(this._slidBallNormalRenderer);
        this._slidBallRenderer.addChild(this._slidBallPressedRenderer);
        this._slidBallRenderer.addChild(this._slidBallDisabledRenderer);
        this._slidBallRenderer.setCascadeColorEnabled(!0);
        this._slidBallRenderer.setCascadeOpacityEnabled(!0);
        this.addProtectedChild(this._slidBallRenderer, ccui.Slider.BALL_RENDERER_ZORDER, -1)
    },
    loadBarTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._textureFile = a;
            this._barTexType = b;
            var c = this._barRenderer,
                d = this;
            c._textureLoaded || c.addEventListener("load", function() {
                d.loadBarTexture(d._textureFile, d._barTexType)
            });
            switch (this._barTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._progressBarRendererDirty = this._barRendererAdaptDirty = !0;
            this._updateContentSizeWithTextureSize(this._barRenderer.getContentSize());
            this._findLayout();
            this._barTextureSize = this._barRenderer.getContentSize()
        }
    },
    loadProgressBarTexture: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._progressBarTextureFile = a;
            this._progressBarTexType = b;
            var c = this._progressBarRenderer,
                d = this;
            c._textureLoaded || c.addEventListener("load",
                function() {
                    d.loadProgressBarTexture(d._progressBarTextureFile, d._progressBarTexType)
                });
            switch (this._progressBarTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    c.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    c.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._progressBarRenderer.setAnchorPoint(cc.p(0, 0.5));
            c = this._progressBarRenderer.getContentSize();
            this._progressBarTextureSize = {
                width: c.width,
                height: c.height
            };
            this._progressBarRendererDirty = !0;
            this._findLayout()
        }
    },
    setScale9Enabled: function(a) {
        this._scale9Enabled !==
            a && (this._scale9Enabled = a, this.removeProtectedChild(this._barRenderer, !0), this.removeProtectedChild(this._progressBarRenderer, !0), this._progressBarRenderer = this._barRenderer = null, this._scale9Enabled ? (this._barRenderer = new ccui.Scale9Sprite, this._progressBarRenderer = new ccui.Scale9Sprite) : (this._barRenderer = new cc.Sprite, this._progressBarRenderer = new cc.Sprite), this.loadBarTexture(this._textureFile, this._barTexType), this.loadProgressBarTexture(this._progressBarTextureFile, this._progressBarTexType),
                this.addProtectedChild(this._barRenderer, ccui.Slider.BASEBAR_RENDERER_ZORDER, -1), this.addProtectedChild(this._progressBarRenderer, ccui.Slider.PROGRESSBAR_RENDERER_ZORDER, -1), this._scale9Enabled ? (a = this._ignoreSize, this.ignoreContentAdaptWithSize(!1), this._prevIgnoreSize = a) : this.ignoreContentAdaptWithSize(this._prevIgnoreSize), this.setCapInsetsBarRenderer(this._capInsetsBarRenderer), this.setCapInsetProgressBarRenderer(this._capInsetsProgressBarRenderer), this._progressBarRendererDirty = this._barRendererAdaptDirty = !0)
    },
    isScale9Enabled: function() {
        return this._scale9Enabled
    },
    ignoreContentAdaptWithSize: function(a) {
        if (!this._scale9Enabled || this._scale9Enabled && !a) ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a), this._prevIgnoreSize = a
    },
    setCapInsets: function(a) {
        this.setCapInsetsBarRenderer(a);
        this.setCapInsetProgressBarRenderer(a)
    },
    setCapInsetsBarRenderer: function(a) {
        if (a) {
            var b = this._capInsetsBarRenderer;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._barRenderer.setCapInsets(a)
        }
    },
    getCapInsetsBarRenderer: function() {
        return cc.rect(this._capInsetsBarRenderer)
    },
    setCapInsetProgressBarRenderer: function(a) {
        if (a) {
            var b = this._capInsetsProgressBarRenderer;
            b.x = a.x;
            b.y = a.y;
            b.width = a.width;
            b.height = a.height;
            this._scale9Enabled && this._progressBarRenderer.setCapInsets(a)
        }
    },
    getCapInsetsProgressBarRenderer: function() {
        return cc.rect(this._capInsetsProgressBarRenderer)
    },
    loadSlidBallTextures: function(a, b, c, d) {
        this.loadSlidBallTextureNormal(a, d);
        this.loadSlidBallTexturePressed(b, d);
        this.loadSlidBallTextureDisabled(c,
            d)
    },
    loadSlidBallTextureNormal: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallNormalTextureFile = a;
            this._ballNTexType = b;
            var c = this;
            this._slidBallNormalRenderer._textureLoaded || this._slidBallNormalRenderer.addEventListener("load", function() {
                c.loadSlidBallTextureNormal(c._slidBallNormalTextureFile, c._ballNTexType)
            });
            switch (this._ballNTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallNormalRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallNormalRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._findLayout()
        }
    },
    loadSlidBallTexturePressed: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallPressedTextureFile = a;
            this._ballPTexType = b;
            var c = this;
            this._slidBallPressedRenderer._textureLoaded || this._slidBallPressedRenderer.addEventListener("load", function() {
                c.loadSlidBallTexturePressed(c._slidBallPressedTextureFile, c._ballPTexType)
            });
            switch (this._ballPTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallPressedRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallPressedRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._findLayout()
        }
    },
    loadSlidBallTextureDisabled: function(a, b) {
        if (a) {
            b = b || ccui.Widget.LOCAL_TEXTURE;
            this._slidBallDisabledTextureFile = a;
            this._ballDTexType = b;
            var c = this;
            this._slidBallDisabledRenderer._textureLoaded || this._slidBallDisabledRenderer.addEventListener("load", function() {
                c.loadSlidBallTextureDisabled(c._slidBallDisabledTextureFile, c._ballDTexType)
            });
            switch (this._ballDTexType) {
                case ccui.Widget.LOCAL_TEXTURE:
                    this._slidBallDisabledRenderer.initWithFile(a);
                    break;
                case ccui.Widget.PLIST_TEXTURE:
                    this._slidBallDisabledRenderer.initWithSpriteFrameName(a)
            }
            this._updateChildrenDisplayedRGBA();
            this._findLayout()
        }
    },
    setPercent: function(a) {
        100 < a && (a = 100);
        0 > a && (a = 0);
        this._percent = a;
        a = a / 100 * this._barLength;
        this._slidBallRenderer.setPosition(a, this._contentSize.height / 2);
        if (this._scale9Enabled) this._progressBarRenderer.setPreferredSize(cc.size(a, this._contentSize.height));
        else {
            var b = this._progressBarRenderer,
                c = b.getTextureRect();
            b.setTextureRect(cc.rect(c.x, c.y, a / b._scaleX, c.height), b.isTextureRectRotated())
        }
    },
    hitTest: function(a) {
        a = this._slidBallNormalRenderer.convertToNodeSpace(a);
        var b = this._slidBallNormalRenderer.getContentSize(),
            b = cc.rect(0, 0, b.width, b.height);
        return a.x >= b.x && a.x <= b.x + b.width && a.y >= b.y && a.y <= b.y + b.height
    },
    onTouchBegan: function(a, b) {
        var c = ccui.Widget.prototype.onTouchBegan.call(this, a, b);
        if (this._hit) {
            var d = this.convertToNodeSpace(this._touchBeganPosition);
            this.setPercent(this._getPercentWithBallPos(d.x));
            this._percentChangedEvent()
        }
        return c
    },
    onTouchMoved: function(a, b) {
        var c = a.getLocation(),
            c = this.convertToNodeSpace(c);
        this.setPercent(this._getPercentWithBallPos(c.x));
        this._percentChangedEvent()
    },
    onTouchEnded: function(a,
        b) {
        ccui.Widget.prototype.onTouchEnded.call(this, a, b)
    },
    onTouchCancelled: function(a, b) {
        ccui.Widget.prototype.onTouchCancelled.call(this, a, b)
    },
    _getPercentWithBallPos: function(a) {
        return a / this._barLength * 100
    },
    addEventListenerSlider: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._sliderEventSelector = a;
        this._sliderEventListener = b
    },
    _percentChangedEvent: function() {
        this._sliderEventSelector && (this._sliderEventListener ? this._sliderEventSelector.call(this._sliderEventListener,
            this, ccui.Slider.EVENT_PERCENT_CHANGED) : this._sliderEventSelector(this, ccui.Slider.EVENT_PERCENT_CHANGED));
        this._ccEventCallback && this._ccEventCallback(this, ccui.Slider.EVENT_PERCENT_CHANGED)
    },
    getPercent: function() {
        return this._percent
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._progressBarRendererDirty = this._barRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._barRendererAdaptDirty && (this._barRendererScaleChangedWithSize(), this._barRendererAdaptDirty = !1);
        this._progressBarRendererDirty && (this._progressBarRendererScaleChangedWithSize(), this._progressBarRendererDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._barRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._barRenderer
    },
    _barRendererScaleChangedWithSize: function() {
        if (this._unifySize) this._barLength = this._contentSize.width, this._barRenderer.setPreferredSize(this._contentSize);
        else if (this._ignoreSize) this._barRenderer.setScale(1), this._barLength = this._contentSize.width;
        else if (this._barLength = this._contentSize.width, this._scale9Enabled) this._barRenderer.setPreferredSize(this._contentSize), this._barRenderer.setScale(1);
        else {
            var a = this._barTextureSize;
            if (0 >= a.width || 0 >= a.height) this._barRenderer.setScale(1);
            else {
                var b = this._contentSize.height / a.height;
                this._barRenderer.setScaleX(this._contentSize.width / a.width);
                this._barRenderer.setScaleY(b)
            }
        }
        this._barRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2);
        this.setPercent(this._percent)
    },
    _progressBarRendererScaleChangedWithSize: function() {
        if (this._unifySize) this._progressBarRenderer.setPreferredSize(this._contentSize);
        else if (this._ignoreSize) {
            if (!this._scale9Enabled) {
                var a = this._progressBarTextureSize,
                    b = this._contentSize.width / a.width,
                    a = this._contentSize.height / a.height;
                this._progressBarRenderer.setScaleX(b);
                this._progressBarRenderer.setScaleY(a)
            }
        } else if (this._scale9Enabled) this._progressBarRenderer.setPreferredSize(this._contentSize), this._progressBarRenderer.setScale(1);
        else {
            a = this._progressBarTextureSize;
            if (0 >= a.width || 0 >= a.height) {
                this._progressBarRenderer.setScale(1);
                return
            }
            b = this._contentSize.width / a.width;
            a = this._contentSize.height / a.height;
            this._progressBarRenderer.setScaleX(b);
            this._progressBarRenderer.setScaleY(a)
        }
        this._progressBarRenderer.setPosition(0, this._contentSize.height / 2);
        this.setPercent(this._percent)
    },
    _onPressStateChangedToNormal: function() {
        this._slidBallNormalRenderer.setVisible(!0);
        this._slidBallPressedRenderer.setVisible(!1);
        this._slidBallDisabledRenderer.setVisible(!1);
        this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX, this._sliderBallNormalTextureScaleY)
    },
    _onPressStateChangedToPressed: function() {
        this._slidBallPressedTextureFile ? (this._slidBallNormalRenderer.setVisible(!1), this._slidBallPressedRenderer.setVisible(!0), this._slidBallDisabledRenderer.setVisible(!1)) : this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX + this._zoomScale, this._sliderBallNormalTextureScaleY + this._zoomScale)
    },
    _onPressStateChangedToDisabled: function() {
        this._slidBallDisabledTextureFile && (this._slidBallNormalRenderer.setVisible(!1), this._slidBallDisabledRenderer.setVisible(!0));
        this._slidBallNormalRenderer.setScale(this._sliderBallNormalTextureScaleX, this._sliderBallNormalTextureScaleY);
        this._slidBallPressedRenderer.setVisible(!1)
    },
    setZoomScale: function(a) {
        this._zoomScale = a
    },
    getZoomScale: function() {
        return this._zoomScale
    },
    getDescription: function() {
        return "Slider"
    },
    _createCloneInstance: function() {
        return new ccui.Slider
    },
    _copySpecialProperties: function(a) {
        this._prevIgnoreSize = a._prevIgnoreSize;
        this.setScale9Enabled(a._scale9Enabled);
        this.loadBarTexture(a._textureFile, a._barTexType);
        this.loadProgressBarTexture(a._progressBarTextureFile, a._progressBarTexType);
        this.loadSlidBallTextureNormal(a._slidBallNormalTextureFile, a._ballNTexType);
        this.loadSlidBallTexturePressed(a._slidBallPressedTextureFile, a._ballPTexType);
        this.loadSlidBallTextureDisabled(a._slidBallDisabledTextureFile, a._ballDTexType);
        this.setPercent(a.getPercent());
        this._sliderEventListener = a._sliderEventListener;
        this._sliderEventSelector = a._sliderEventSelector;
        this._zoomScale = a._zoomScale;
        this._ccEventCallback = a._ccEventCallback
    }
});
_p = ccui.Slider.prototype;
cc.defineGetterSetter(_p, "percent", _p.getPercent, _p.setPercent);
_p = null;
ccui.Slider.create = function(a, b, c) {
    return new ccui.Slider(a, b, c)
};
ccui.Slider.EVENT_PERCENT_CHANGED = 0;
ccui.Slider.BASEBAR_RENDERER_ZORDER = -3;
ccui.Slider.PROGRESSBAR_RENDERER_ZORDER = -2;
ccui.Slider.BALL_RENDERER_ZORDER = -1;
ccui.Text = ccui.Widget.extend({
    _touchScaleChangeEnabled: !1,
    _normalScaleValueX: 1,
    _normalScaleValueY: 1,
    _fontName: "Thonburi",
    _fontSize: 10,
    _onSelectedScaleOffset: 0.5,
    _labelRenderer: "",
    _textAreaSize: null,
    _textVerticalAlignment: 0,
    _textHorizontalAlignment: 0,
    _className: "Text",
    _type: null,
    _labelRendererAdaptDirty: !0,
    ctor: function(a, b, c) {
        this._type = ccui.Text.Type.SYSTEM;
        this._textAreaSize = cc.size(0, 0);
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== c && this.init(a, b, c)
    },
    init: function(a, b, c) {
        return ccui.Widget.prototype.init.call(this) ?
            (0 < arguments.length ? (this.setFontName(b), this.setFontSize(c), this.setString(a)) : this.setFontName(this._fontName), !0) : !1
    },
    _initRenderer: function() {
        this._labelRenderer = new cc.LabelTTF;
        this.addProtectedChild(this._labelRenderer, ccui.Text.RENDERER_ZORDER, -1)
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        a !== this._labelRenderer.getString() && (this._labelRenderer.setString(a), this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize()), this._labelRendererAdaptDirty = !0)
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this._labelRenderer.getString()
    },
    getString: function() {
        return this._labelRenderer.getString()
    },
    getStringLength: function() {
        return this._labelRenderer.getStringLength()
    },
    setFontSize: function(a) {
        this._labelRenderer.setFontSize(a);
        this._fontSize = a;
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._fontName =
            a;
        this._labelRenderer.setFontName(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getFontName: function() {
        return this._fontName
    },
    _setFont: function(a) {
        var b = cc.LabelTTF._fontStyleRE.exec(a);
        b && (this._fontSize = parseInt(b[1]), this._fontName = b[2], this._labelRenderer._setFont(a), this._labelScaleChangedWithSize())
    },
    _getFont: function() {
        return this._labelRenderer._getFont()
    },
    getType: function() {
        return this._type
    },
    setTextAreaSize: function(a) {
        this._labelRenderer.setDimensions(a);
        this._ignoreSize || (this._customSize = a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextAreaSize: function() {
        return this._labelRenderer.getDimensions()
    },
    setTextHorizontalAlignment: function(a) {
        this._labelRenderer.setHorizontalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextHorizontalAlignment: function() {
        return this._labelRenderer.getHorizontalAlignment()
    },
    setTextVerticalAlignment: function(a) {
        this._labelRenderer.setVerticalAlignment(a);
        this._updateContentSizeWithTextureSize(this._labelRenderer.getContentSize());
        this._labelRendererAdaptDirty = !0
    },
    getTextVerticalAlignment: function() {
        return this._labelRenderer.getVerticalAlignment()
    },
    setTouchScaleChangeEnabled: function(a) {
        this._touchScaleChangeEnabled = a
    },
    isTouchScaleChangeEnabled: function() {
        return this._touchScaleChangeEnabled
    },
    _onPressStateChangedToNormal: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX),
            this._labelRenderer.setScaleY(this._normalScaleValueY))
    },
    _onPressStateChangedToPressed: function() {
        this._touchScaleChangeEnabled && (this._labelRenderer.setScaleX(this._normalScaleValueX + this._onSelectedScaleOffset), this._labelRenderer.setScaleY(this._normalScaleValueY + this._onSelectedScaleOffset))
    },
    _onPressStateChangedToDisabled: function() {},
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelRendererAdaptDirty &&
            (this._labelScaleChangedWithSize(), this._labelRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelRenderer
    },
    getAutoRenderSize: function() {
        var a = this._labelRenderer.getContentSize();
        this._ignoreSize || (this._labelRenderer.setDimensions(0, 0), a = this._labelRenderer.getContentSize(), this._labelRenderer.setDimensions(this._contentSize.width, this._contentSize.height));
        return a
    },
    _labelScaleChangedWithSize: function() {
        var a =
            this._contentSize;
        if (this._ignoreSize) this._labelRenderer.setDimensions(0, 0), this._labelRenderer.setScale(1), this._normalScaleValueX = this._normalScaleValueY = 1;
        else {
            this._labelRenderer.setDimensions(cc.size(a.width, a.height));
            var b = this._labelRenderer.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                this._labelRenderer.setScale(1);
                return
            }
            var c = a.width / b.width,
                b = a.height / b.height;
            this._labelRenderer.setScaleX(c);
            this._labelRenderer.setScaleY(b);
            this._normalScaleValueX = c;
            this._normalScaleValueY = b
        }
        this._labelRenderer.setPosition(a.width /
            2, a.height / 2)
    },
    getDescription: function() {
        return "Label"
    },
    enableShadow: function(a, b, c) {
        this._labelRenderer.enableShadow(a, b, c)
    },
    enableOutline: function(a, b) {
        this._labelRenderer.enableStroke(a, b)
    },
    enableGlow: function(a) {
        this._type === ccui.Text.Type.TTF && this._labelRenderer.enableGlow(a)
    },
    disableEffect: function() {
        this._labelRenderer.disableEffect && this._labelRenderer.disableEffect()
    },
    _createCloneInstance: function() {
        return new ccui.Text
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.Text && (this.setFontName(a._fontName),
            this.setFontSize(a.getFontSize()), this.setString(a.getString()), this.setTouchScaleChangeEnabled(a.touchScaleEnabled), this.setTextAreaSize(a._textAreaSize), this.setTextHorizontalAlignment(a._labelRenderer.getHorizontalAlignment()), this.setTextVerticalAlignment(a._labelRenderer.getVerticalAlignment()), this.setContentSize(a.getContentSize()), this.setTextColor(a.getTextColor()))
    },
    _setBoundingWidth: function(a) {
        this._textAreaSize.width = a;
        this._labelRenderer._setBoundingWidth(a);
        this._labelScaleChangedWithSize()
    },
    _setBoundingHeight: function(a) {
        this._textAreaSize.height = a;
        this._labelRenderer._setBoundingHeight(a);
        this._labelScaleChangedWithSize()
    },
    _getBoundingWidth: function() {
        return this._textAreaSize.width
    },
    _getBoundingHeight: function() {
        return this._textAreaSize.height
    },
    _changePosition: function() {
        this._adaptRenderers()
    },
    setColor: function(a) {
        cc.ProtectedNode.prototype.setColor.call(this, a);
        this._labelRenderer.setColor(a)
    },
    setTextColor: function(a) {
        this._labelRenderer.setFontFillColor(a)
    },
    getTextColor: function() {
        return this._labelRenderer._getFillStyle()
    }
});
_p = ccui.Text.prototype;
cc.defineGetterSetter(_p, "boundingWidth", _p._getBoundingWidth, _p._setBoundingWidth);
cc.defineGetterSetter(_p, "boundingHeight", _p._getBoundingHeight, _p._setBoundingHeight);
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "stringLength", _p.getStringLength);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "textAlign", _p.getTextHorizontalAlignment, _p.setTextHorizontalAlignment);
cc.defineGetterSetter(_p, "verticalAlign", _p.getTextVerticalAlignment, _p.setTextVerticalAlignment);
_p = null;
ccui.Label = ccui.Text.create = function(a, b, c) {
    return new ccui.Text(a, b, c)
};
ccui.Text.RENDERER_ZORDER = -1;
ccui.Text.Type = {
    SYSTEM: 0,
    TTF: 1
};
ccui.TextAtlas = ccui.Widget.extend({
    _labelAtlasRenderer: null,
    _stringValue: "",
    _charMapFileName: "",
    _itemWidth: 0,
    _itemHeight: 0,
    _startCharMap: "",
    _className: "TextAtlas",
    _labelAtlasRendererAdaptDirty: null,
    ctor: function(a, b, c, d, e) {
        ccui.Widget.prototype.ctor.call(this);
        void 0 !== e && this.setProperty(a, b, c, d, e)
    },
    _initRenderer: function() {
        this._labelAtlasRenderer = new cc.LabelAtlas;
        this._labelAtlasRenderer.setAnchorPoint(cc.p(0.5, 0.5));
        this.addProtectedChild(this._labelAtlasRenderer, ccui.TextAtlas.RENDERER_ZORDER, -1)
    },
    setProperty: function(a, b, c, d, e) {
        this._stringValue = a;
        this._charMapFileName = b;
        this._itemWidth = c;
        this._itemHeight = d;
        this._startCharMap = e;
        this._labelAtlasRenderer.initWithString(a, this._charMapFileName, this._itemWidth, this._itemHeight, this._startCharMap[0]);
        this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize());
        this._labelAtlasRendererAdaptDirty = !0
    },
    setString: function(a) {
        a !== this._labelAtlasRenderer.getString() && (this._stringValue = a, this._labelAtlasRenderer.setString(a),
            this._updateContentSizeWithTextureSize(this._labelAtlasRenderer.getContentSize()), this._labelAtlasRendererAdaptDirty = !0)
    },
    setStringValue: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this.getString()
    },
    getString: function() {
        return this._labelAtlasRenderer.getString()
    },
    getStringLength: function() {
        return this._labelAtlasRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelAtlasRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelAtlasRendererAdaptDirty && (this._labelAtlasScaleChangedWithSize(), this._labelAtlasRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelAtlasRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelAtlasRenderer
    },
    _labelAtlasScaleChangedWithSize: function() {
        var a = this._labelAtlasRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var b = a.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                a.setScale(1);
                return
            }
            a.setScaleX(this._contentSize.width / b.width);
            a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "LabelAtlas"
    },
    _copySpecialProperties: function(a) {
        a && this.setProperty(a._stringValue, a._charMapFileName, a._itemWidth, a._itemHeight, a._startCharMap)
    },
    _createCloneInstance: function() {
        return new ccui.TextAtlas
    }
});
_p = ccui.TextAtlas.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextAtlas.create = function(a, b, c, d, e) {
    return new ccui.TextAtlas(a, b, c, d, e)
};
ccui.TextAtlas.RENDERER_ZORDER = -1;
ccui.LabelBMFont = ccui.TextBMFont = ccui.Widget.extend({
    _labelBMFontRenderer: null,
    _fntFileHasInit: !1,
    _fntFileName: "",
    _stringValue: "",
    _className: "TextBMFont",
    _labelBMFontRendererAdaptDirty: !0,
    ctor: function(a, b) {
        ccui.Widget.prototype.ctor.call(this);
        void 0 != b && (this.setFntFile(b), this.setString(a))
    },
    _initRenderer: function() {
        this._labelBMFontRenderer = new cc.LabelBMFont;
        this.addProtectedChild(this._labelBMFontRenderer, ccui.TextBMFont.RENDERER_ZORDER, -1)
    },
    setFntFile: function(a) {
        if (a) {
            this._fntFileName = a;
            this._fntFileHasInit = !0;
            this._labelBMFontRenderer.initWithString(this._stringValue, a);
            this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize());
            this._labelBMFontRendererAdaptDirty = !0;
            var b = this;
            a = b._labelBMFontRenderer;
            a._textureLoaded || a.addEventListener("load", function() {
                b.setFntFile(b._fntFileName)
            })
        }
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        a !== this._labelBMFontRenderer.getString() && (this._stringValue = a, this._labelBMFontRenderer.setString(a),
            this._fntFileHasInit && (this._updateContentSizeWithTextureSize(this._labelBMFontRenderer.getContentSize()), this._labelBMFontRendererAdaptDirty = !0))
    },
    getString: function() {
        return this._stringValue
    },
    getStringLength: function() {
        return this._labelBMFontRenderer.getStringLength()
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._labelBMFontRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._labelBMFontRendererAdaptDirty && (this._labelBMFontScaleChangedWithSize(), this._labelBMFontRendererAdaptDirty = !1)
    },
    getVirtualRendererSize: function() {
        return this._labelBMFontRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._labelBMFontRenderer
    },
    _labelBMFontScaleChangedWithSize: function() {
        var a = this._labelBMFontRenderer;
        if (this._ignoreSize) a.setScale(1);
        else {
            var b = a.getContentSize();
            if (0 >= b.width || 0 >= b.height) {
                a.setScale(1);
                return
            }
            a.setScaleX(this._contentSize.width / b.width);
            a.setScaleY(this._contentSize.height / b.height)
        }
        a.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getDescription: function() {
        return "TextBMFont"
    },
    _createCloneInstance: function() {
        return new ccui.TextBMFont
    },
    _copySpecialProperties: function(a) {
        this.setFntFile(a._fntFileName);
        this.setString(a._stringValue)
    }
});
_p = ccui.TextBMFont.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
_p = null;
ccui.TextBMFont.create = function(a, b) {
    return new ccui.TextBMFont(a, b)
};
ccui.TextBMFont.RENDERER_ZORDER = -1;
ccui._TextFieldRenderer = cc.TextFieldTTF.extend({
    _maxLengthEnabled: !1,
    _maxLength: 0,
    _passwordEnabled: !1,
    _passwordStyleText: "",
    _attachWithIME: !1,
    _detachWithIME: !1,
    _insertText: !1,
    _deleteBackward: !1,
    _className: "_TextFieldRenderer",
    ctor: function() {
        cc.TextFieldTTF.prototype.ctor.call(this);
        this._maxLengthEnabled = !1;
        this._maxLength = 0;
        this._passwordEnabled = !1;
        this._passwordStyleText = "*";
        this._deleteBackward = this._insertText = this._detachWithIME = this._attachWithIME = !1
    },
    onEnter: function() {
        cc.TextFieldTTF.prototype.onEnter.call(this);
        cc.TextFieldTTF.prototype.setDelegate.call(this, this)
    },
    onTextFieldAttachWithIME: function(a) {
        this.setAttachWithIME(!0);
        return !1
    },
    onTextFieldInsertText: function(a, b, c) {
        if (1 === c && "\n" === b) return !1;
        this.setInsertText(!0);
        return this._maxLengthEnabled && cc.TextFieldTTF.prototype.getCharCount.call(this) >= this._maxLength
    },
    onTextFieldDeleteBackward: function(a, b, c) {
        this.setDeleteBackward(!0);
        return !1
    },
    onTextFieldDetachWithIME: function(a) {
        this.setDetachWithIME(!0);
        return !1
    },
    insertText: function(a, b) {
        "\n" !== a &&
            this._maxLengthEnabled && this.getString().length >= this._maxLength ? this._passwordEnabled && this.setPasswordText(this.getString()) : (cc.TextFieldTTF.prototype.insertText.call(this, a, b), this._passwordEnabled && 0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this.setPasswordText(this.getString()))
    },
    deleteBackward: function() {
        cc.TextFieldTTF.prototype.deleteBackward.call(this);
        0 < cc.TextFieldTTF.prototype.getCharCount.call(this) && this._passwordEnabled && this.setPasswordText(this._inputText)
    },
    openIME: function() {
        cc.TextFieldTTF.prototype.attachWithIME.call(this)
    },
    closeIME: function() {
        cc.TextFieldTTF.prototype.detachWithIME.call(this)
    },
    setMaxLengthEnabled: function(a) {
        this._maxLengthEnabled = a
    },
    isMaxLengthEnabled: function() {
        return this._maxLengthEnabled
    },
    setMaxLength: function(a) {
        this._maxLength = a
    },
    getMaxLength: function() {
        return this._maxLength
    },
    getCharCount: function() {
        return cc.TextFieldTTF.prototype.getCharCount.call(this)
    },
    setPasswordEnabled: function(a) {
        this._passwordEnabled = a
    },
    isPasswordEnabled: function() {
        return this._passwordEnabled
    },
    setPasswordStyleText: function(a) {
        if (!(1 <
                a.length)) {
            var b = a.charCodeAt(0);
            33 > b || 126 < b || (this._passwordStyleText = a)
        }
    },
    setPasswordText: function(a) {
        var b = "",
            c = a.length;
        a = c;
        this._maxLengthEnabled && c > this._maxLength && (a = this._maxLength);
        for (c = 0; c < a; ++c) b += this._passwordStyleText;
        cc.LabelTTF.prototype.setString.call(this, b)
    },
    setAttachWithIME: function(a) {
        this._attachWithIME = a
    },
    getAttachWithIME: function() {
        return this._attachWithIME
    },
    setDetachWithIME: function(a) {
        this._detachWithIME = a
    },
    getDetachWithIME: function() {
        return this._detachWithIME
    },
    setInsertText: function(a) {
        this._insertText =
            a
    },
    getInsertText: function() {
        return this._insertText
    },
    setDeleteBackward: function(a) {
        this._deleteBackward = a
    },
    getDeleteBackward: function() {
        return this._deleteBackward
    },
    onDraw: function(a) {
        return !1
    }
});
ccui._TextFieldRenderer.create = function(a, b, c) {
    var d = new ccui._TextFieldRenderer;
    return d && d.initWithString("", b, c) ? (a && d.setPlaceHolder(a), d) : null
};
ccui.TextField = ccui.Widget.extend({
    _textFieldRenderer: null,
    _touchWidth: 0,
    _touchHeight: 0,
    _useTouchArea: !1,
    _textFieldEventListener: null,
    _textFieldEventSelector: null,
    _passwordStyleText: "",
    _textFieldRendererAdaptDirty: !0,
    _fontName: "",
    _fontSize: 12,
    _ccEventCallback: null,
    ctor: function(a, b, c) {
        ccui.Widget.prototype.ctor.call(this);
        b && this.setFontName(b);
        c && this.setFontSize(c);
        a && this.setPlaceHolder(a)
    },
    init: function() {
        return ccui.Widget.prototype.init.call(this) ? (this.setTouchEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    _initRenderer: function() {
        this._textFieldRenderer = ccui._TextFieldRenderer.create("input words here", "Thonburi", 20);
        this.addProtectedChild(this._textFieldRenderer, ccui.TextField.RENDERER_ZORDER, -1)
    },
    setTouchSize: function(a) {
        this._touchWidth = a.width;
        this._touchHeight = a.height
    },
    setTouchAreaEnabled: function(a) {
        this._useTouchArea = a
    },
    hitTest: function(a) {
        if (this._useTouchArea) {
            a = this.convertToNodeSpace(a);
            var b = cc.rect(-this._touchWidth * this._anchorPoint.x, -this._touchHeight * this._anchorPoint.y,
                this._touchWidth, this._touchHeight);
            return a.x >= b.x && a.x <= b.x + b.width && a.y >= b.y && a.y <= b.y + b.height
        }
        return ccui.Widget.prototype.hitTest.call(this, a)
    },
    getTouchSize: function() {
        return cc.size(this._touchWidth, this._touchHeight)
    },
    setText: function(a) {
        cc.log("Please use the setString");
        this.setString(a)
    },
    setString: function(a) {
        null != a && (a = String(a), this.isMaxLengthEnabled() && (a = a.substr(0, this.getMaxLength())), this.isPasswordEnabled() ? (this._textFieldRenderer.setPasswordText(a), this._textFieldRenderer.setString(""),
            this._textFieldRenderer.insertText(a, a.length)) : this._textFieldRenderer.setString(a), this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()))
    },
    setPlaceHolder: function(a) {
        this._textFieldRenderer.setPlaceHolder(a);
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getPlaceHolder: function() {
        return this._textFieldRenderer.getPlaceHolder()
    },
    getPlaceHolderColor: function() {
        return this._textFieldRenderer.getPlaceHolderColor()
    },
    setPlaceHolderColor: function(a) {
        this._textFieldRenderer.setColorSpaceHolder(a)
    },
    setTextColor: function(a) {
        this._textFieldRenderer.setTextColor(a)
    },
    setFontSize: function(a) {
        this._textFieldRenderer.setFontSize(a);
        this._fontSize = a;
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontSize: function() {
        return this._fontSize
    },
    setFontName: function(a) {
        this._textFieldRenderer.setFontName(a);
        this._fontName = a;
        this._textFieldRendererAdaptDirty = !0;
        this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize())
    },
    getFontName: function() {
        return this._fontName
    },
    didNotSelectSelf: function() {
        this._textFieldRenderer.detachWithIME()
    },
    getStringValue: function() {
        cc.log("Please use the getString");
        return this.getString()
    },
    getString: function() {
        return this._textFieldRenderer.getString()
    },
    getStringLength: function() {
        return this._textFieldRenderer.getStringLength()
    },
    onTouchBegan: function(a, b) {
        var c = this,
            d = ccui.Widget.prototype.onTouchBegan.call(c,
                a, b);
        c._hit ? setTimeout(function() {
            c._textFieldRenderer.attachWithIME()
        }, 0) : setTimeout(function() {
            c._textFieldRenderer.detachWithIME()
        }, 0);
        return d
    },
    setMaxLengthEnabled: function(a) {
        this._textFieldRenderer.setMaxLengthEnabled(a)
    },
    isMaxLengthEnabled: function() {
        return this._textFieldRenderer.isMaxLengthEnabled()
    },
    setMaxLength: function(a) {
        this._textFieldRenderer.setMaxLength(a);
        this.setString(this.getString())
    },
    getMaxLength: function() {
        return this._textFieldRenderer.getMaxLength()
    },
    setPasswordEnabled: function(a) {
        this._textFieldRenderer.setPasswordEnabled(a)
    },
    isPasswordEnabled: function() {
        return this._textFieldRenderer.isPasswordEnabled()
    },
    setPasswordStyleText: function(a) {
        this._textFieldRenderer.setPasswordStyleText(a);
        this._passwordStyleText = a;
        this.setString(this.getString())
    },
    getPasswordStyleText: function() {
        return this._passwordStyleText
    },
    update: function(a) {
        this.getDetachWithIME() && (this._detachWithIMEEvent(), this.setDetachWithIME(!1));
        this.getAttachWithIME() && (this._attachWithIMEEvent(), this.setAttachWithIME(!1));
        this.getInsertText() && (this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()), this._insertTextEvent(), this.setInsertText(!1));
        this.getDeleteBackward() && (this._textFieldRendererAdaptDirty = !0, this._updateContentSizeWithTextureSize(this._textFieldRenderer.getContentSize()), this._deleteBackwardEvent(), this.setDeleteBackward(!1))
    },
    getAttachWithIME: function() {
        return this._textFieldRenderer.getAttachWithIME()
    },
    setAttachWithIME: function(a) {
        this._textFieldRenderer.setAttachWithIME(a)
    },
    getDetachWithIME: function() {
        return this._textFieldRenderer.getDetachWithIME()
    },
    setDetachWithIME: function(a) {
        this._textFieldRenderer.setDetachWithIME(a)
    },
    getInsertText: function() {
        return this._textFieldRenderer.getInsertText()
    },
    setInsertText: function(a) {
        this._textFieldRenderer.setInsertText(a)
    },
    getDeleteBackward: function() {
        return this._textFieldRenderer.getDeleteBackward()
    },
    setDeleteBackward: function(a) {
        this._textFieldRenderer.setDeleteBackward(a)
    },
    _attachWithIMEEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener,
            this, ccui.TextField.EVENT_ATTACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_ATTACH_WITH_IME));
        this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_ATTACH_WITH_IME)
    },
    _detachWithIMEEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_DETACH_WITH_IME) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DETACH_WITH_IME));
        this._ccEventCallback && this._ccEventCallback(this,
            ccui.TextField.EVENT_DETACH_WITH_IME)
    },
    _insertTextEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener, this, ccui.TextField.EVENT_INSERT_TEXT) : this._textFieldEventSelector(this, ccui.TextField.EVENT_INSERT_TEXT));
        this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_INSERT_TEXT)
    },
    _deleteBackwardEvent: function() {
        this._textFieldEventSelector && (this._textFieldEventListener ? this._textFieldEventSelector.call(this._textFieldEventListener,
            this, ccui.TextField.EVENT_DELETE_BACKWARD) : this._textFieldEventSelector(this, ccui.TextField.EVENT_DELETE_BACKWARD));
        this._ccEventCallback && this._ccEventCallback(this, ccui.TextField.EVENT_DELETE_BACKWARD)
    },
    addEventListenerTextField: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._textFieldEventSelector = a;
        this._textFieldEventListener = b
    },
    _onSizeChanged: function() {
        ccui.Widget.prototype._onSizeChanged.call(this);
        this._textFieldRendererAdaptDirty = !0
    },
    _adaptRenderers: function() {
        this._textFieldRendererAdaptDirty &&
            (this._textfieldRendererScaleChangedWithSize(), this._textFieldRendererAdaptDirty = !1)
    },
    _textfieldRendererScaleChangedWithSize: function() {
        this._ignoreSize || this._textFieldRenderer.setDimensions(this._contentSize);
        this._textFieldRenderer.setPosition(this._contentSize.width / 2, this._contentSize.height / 2)
    },
    getAutoRenderSize: function() {
        var a = this._textFieldRenderer.getContentSize();
        this._ignoreSize || (this._textFieldRenderer.setDimensions(0, 0), a = this._textFieldRenderer.getContentSize(), this._textFieldRenderer.setDimensions(this._contentSize.width,
            this._contentSize.height));
        return a
    },
    getVirtualRendererSize: function() {
        return this._textFieldRenderer.getContentSize()
    },
    getVirtualRenderer: function() {
        return this._textFieldRenderer
    },
    getDescription: function() {
        return "TextField"
    },
    attachWithIME: function() {
        this._textFieldRenderer.attachWithIME()
    },
    _createCloneInstance: function() {
        return new ccui.TextField
    },
    _copySpecialProperties: function(a) {
        this.setString(a._textFieldRenderer.getString());
        this.setPlaceHolder(a.getString());
        this.setFontSize(a._textFieldRenderer.getFontSize());
        this.setFontName(a._textFieldRenderer.getFontName());
        this.setMaxLengthEnabled(a.isMaxLengthEnabled());
        this.setMaxLength(a.getMaxLength());
        this.setPasswordEnabled(a.isPasswordEnabled());
        this.setPasswordStyleText(a._passwordStyleText);
        this.setAttachWithIME(a.getAttachWithIME());
        this.setDetachWithIME(a.getDetachWithIME());
        this.setInsertText(a.getInsertText());
        this.setDeleteBackward(a.getDeleteBackward());
        this._ccEventCallback = a._ccEventCallback;
        this._textFieldEventListener = a._textFieldEventListener;
        this._textFieldEventSelector = a._textFieldEventSelector
    },
    setTextAreaSize: function(a) {
        this.setContentSize(a)
    },
    setTextHorizontalAlignment: function(a) {
        this._textFieldRenderer.setHorizontalAlignment(a)
    },
    setTextVerticalAlignment: function(a) {
        this._textFieldRenderer.setVerticalAlignment(a)
    },
    _setFont: function(a) {
        this._textFieldRenderer._setFont(a);
        this._textFieldRendererAdaptDirty = !0
    },
    _getFont: function() {
        return this._textFieldRenderer._getFont()
    },
    _changePosition: function() {
        this._adaptRenderers()
    }
});
ccui.TextField.create = function(a, b, c) {
    return new ccui.TextField(a, b, c)
};
_p = ccui.TextField.prototype;
cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
cc.defineGetterSetter(_p, "placeHolder", _p.getPlaceHolder, _p.setPlaceHolder);
cc.defineGetterSetter(_p, "font", _p._getFont, _p._setFont);
cc.defineGetterSetter(_p, "fontSize", _p.getFontSize, _p.setFontSize);
cc.defineGetterSetter(_p, "fontName", _p.getFontName, _p.setFontName);
cc.defineGetterSetter(_p, "maxLengthEnabled", _p.isMaxLengthEnabled, _p.setMaxLengthEnabled);
cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
cc.defineGetterSetter(_p, "passwordEnabled", _p.isPasswordEnabled, _p.setPasswordEnabled);
_p = null;
ccui.TextField.EVENT_ATTACH_WITH_IME = 0;
ccui.TextField.EVENT_DETACH_WITH_IME = 1;
ccui.TextField.EVENT_INSERT_TEXT = 2;
ccui.TextField.EVENT_DELETE_BACKWARD = 3;
ccui.TextField.RENDERER_ZORDER = -1;
ccui.VideoPlayer = ccui.Widget.extend({
    _played: !1,
    _playing: !1,
    _stopped: !0,
    ctor: function(a) {
        ccui.Widget.prototype.ctor.call(this);
        this._EventList = {};
        a && this.setURL(a)
    },
    _createRenderCmd: function() {
        return new ccui.VideoPlayer.RenderCmd(this)
    },
    setURL: function(a) {
        this._renderCmd.updateURL(a)
    },
    getURL: function() {
        return this._renderCmd._url
    },
    play: function() {
        var a = this,
            b = this._renderCmd._video;
        if (b) {
            this._played = !0;
            b.pause();
            if (!1 !== this._stopped || !1 !== this._playing || !0 !== this._played) b.currentTime = 0;
            ccui.VideoPlayer._polyfill.autoplayAfterOperation ?
                setTimeout(function() {
                    b.play();
                    a._playing = !0;
                    a._stopped = !1
                }, 20) : (b.play(), this._playing = !0, this._stopped = !1)
        }
    },
    pause: function() {
        var a = this._renderCmd._video;
        a && !0 === this._playing && !1 === this._stopped && (a.pause(), this._playing = !1)
    },
    resume: function() {
        !1 === this._stopped && !1 === this._playing && !0 === this._played && this.play()
    },
    stop: function() {
        var a = this,
            b = this._renderCmd._video;
        b && (b.pause(), b.currentTime = 0, this._playing = !1, this._stopped = !0);
        setTimeout(function() {
                a._dispatchEvent(ccui.VideoPlayer.EventType.STOPPED)
            },
            0)
    },
    seekTo: function(a) {
        var b = this._renderCmd._video;
        b && (b.currentTime = a, ccui.VideoPlayer._polyfill.autoplayAfterOperation && this.isPlaying() && setTimeout(function() {
            b.play()
        }, 20))
    },
    isPlaying: function() {
        ccui.VideoPlayer._polyfill.autoplayAfterOperation && this._playing && setTimeout(function() {
            video.play()
        }, 20);
        return this._playing
    },
    setKeepAspectRatioEnabled: function(a) {
        cc.log("On the web is always keep the aspect ratio")
    },
    isKeepAspectRatioEnabled: function() {
        return !1
    },
    setFullScreenEnabled: function(a) {
        var b =
            this._renderCmd._video;
        b && (a ? cc.screen.requestFullScreen(b) : cc.screen.exitFullScreen(b))
    },
    isFullScreenEnabled: function() {
        cc.log("Can't know status")
    },
    setEventListener: function(a, b) {
        this._EventList[a] = b
    },
    removeEventListener: function(a) {
        this._EventList[a] = null
    },
    _dispatchEvent: function(a) {
        (a = this._EventList[a]) && a.call(this, this, this._renderCmd._video.src)
    },
    onPlayEvent: function() {
        var a = this._EventList[ccui.VideoPlayer.EventType.PLAYING];
        if (a)
            for (var b = 0; b < a.length; b++) a[b].call(this, this, this._renderCmd._video.src)
    },
    setContentSize: function(a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b);
        void 0 === b && (b = a.height, a = a.width);
        this._renderCmd.changeSize(a, b)
    },
    cleanup: function() {
        this._renderCmd.removeDom();
        this.stopAllActions();
        this.unscheduleAllCallbacks()
    },
    onEnter: function() {
        ccui.Widget.prototype.onEnter.call(this);
        var a = ccui.VideoPlayer.elements; - 1 === a.indexOf(this) && a.push(this)
    },
    onExit: function() {
        ccui.Widget.prototype.onExit.call(this);
        var a = ccui.VideoPlayer.elements,
            b = a.indexOf(this); - 1 !== b && a.splice(b,
            1)
    }
});
ccui.VideoPlayer.elements = [];
ccui.VideoPlayer.pauseElements = [];
cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {
    for (var a = ccui.VideoPlayer.elements, b, c = 0; c < a.length; c++) b = a[c], a[c]._playing && (b.pause(), ccui.VideoPlayer.pauseElements.push(b))
});
cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {
    for (var a = ccui.VideoPlayer.pauseElements, b = a.pop(); b;) b.play(), b = a.pop()
});
ccui.VideoPlayer.EventType = {
    PLAYING: "play",
    PAUSED: "pause",
    STOPPED: "stop",
    COMPLETED: "complete"
};
(function(a) {
    a._polyfill = {
        devicePixelRatio: !1,
        event: "canplay",
        canPlayType: []
    };
    var b = document.createElement("video");
    b.canPlayType("video/ogg") && (a._polyfill.canPlayType.push(".ogg"), a._polyfill.canPlayType.push(".ogv"));
    b.canPlayType("video/mp4") && a._polyfill.canPlayType.push(".mp4");
    b.canPlayType("video/webm") && a._polyfill.canPlayType.push(".webm");
    cc.sys.OS_IOS === cc.sys.os && (a._polyfill.devicePixelRatio = !0, a._polyfill.event = "progress");
    cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (a._polyfill.autoplayAfterOperation = !0);
    a = document.createElement("style");
    a.innerHTML = ".cocosVideo:-moz-full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:-webkit-full-screen{transform:matrix(1,0,0,1,0,0) !important;}";
    document.head.appendChild(a)
})(ccui.VideoPlayer);
(function(a) {
    ccui.VideoPlayer.RenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._listener = null;
        this._url = "";
        this.initStyle()
    };
    var b = ccui.VideoPlayer.RenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    b.constructor = ccui.VideoPlayer.RenderCmd;
    b.visit = function() {
        var a = this,
            b = cc.container,
            e = cc.eventManager;
        if (this._node._visible) b.appendChild(this._video), null === this._listener && (this._listener = cc.eventManager.addCustomListener(cc.game.EVENT_RESIZE, function() {
            a.resize()
        }));
        else {
            var f = !1;
            (f = "contains" in b ? b.contains(this._video) : b.compareDocumentPosition(this._video) % 16) && b.removeChild(this._video);
            e.removeListener(this._listener);
            this._listener = null
        }
        this.updateStatus()
    };
    b.updateStatus = function() {
        a.devicePixelRatio = cc.view.isRetinaEnabled();
        this._dirtyFlag & cc.Node._dirtyFlags.transformDirty && (this.transform(this.getParentRenderCmd(), !0), this.updateMatrix(this._worldTransform, cc.view._scaleX, cc.view._scaleY), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    };
    b.resize = function(a) {
        a = a || cc.view;
        var b = this._node,
            e = cc.eventManager;
        b._parent && b._visible ? this.updateMatrix(this._worldTransform, a._scaleX, a._scaleY) : (e.removeListener(this._listener), this._listener = null)
    };
    b.updateMatrix = function(b, d, e) {
        var f = this._node;
        if (a.devicePixelRatio) {
            var g = window.devicePixelRatio;
            d /= g;
            e /= g
        }
        if (!1 !== this._loaded) {
            var g = f._contentSize.width,
                h = f._contentSize.height;
            b = "matrix(" + b.a * d + "," + b.b + "," + b.c + "," + b.d * e + "," + (b.tx * d - g / 2 + g * f._scaleX / 2 * d) + "," + -(b.ty * e - h / 2 + h * f._scaleY / 2 * e) +
                ")";
            this._video.style.transform = b;
            this._video.style["-webkit-transform"] = b
        }
    };
    b.updateURL = function(b) {
        var d, e, f, g = this._node;
        if (this._url != b) {
            this._url = b;
            cc.loader.resPath && !/^http/.test(b) && (b = cc.path.join(cc.loader.resPath, b));
            d = !1;
            f = cc.container;
            (d = "contains" in f ? f.contains(this._video) : f.compareDocumentPosition(this._video) % 16) && f.removeChild(this._video);
            e = this._video = document.createElement("video");
            this.bindEvent();
            var h = this,
                k = function() {
                    !0 != h._loaded && (h._loaded = !0, h.changeSize(), h.setDirtyFlag(cc.Node._dirtyFlags.transformDirty),
                        e.removeEventListener(a.event, k), e.currentTime = 0, e.style.visibility = "visible", e.play(), g._played || (e.pause(), e.currentTime = 0))
                };
            e.addEventListener(a.event, k);
            e.preload = "metadata";
            e.style.visibility = "hidden";
            this._loaded = !1;
            g._played = !1;
            g._playing = !1;
            g._stopped = !0;
            this.initStyle();
            this.visit();
            d = document.createElement("source");
            d.src = b;
            e.appendChild(d);
            f = cc.path.extname(b);
            for (var m = 0; m < a.canPlayType.length; m++) f !== a.canPlayType[m] && (d = document.createElement("source"), d.src = b.replace(f, a.canPlayType[m]),
                e.appendChild(d))
        }
    };
    b.bindEvent = function() {
        var a = this,
            b = this._node,
            e = this._video;
        e.addEventListener("ended", function() {
            b._renderCmd.updateMatrix(a._worldTransform, cc.view._scaleX, cc.view._scaleY);
            b._playing = !1;
            b._dispatchEvent(ccui.VideoPlayer.EventType.COMPLETED)
        });
        e.addEventListener("play", function() {
            b._dispatchEvent(ccui.VideoPlayer.EventType.PLAYING)
        });
        e.addEventListener("pause", function() {
            b._dispatchEvent(ccui.VideoPlayer.EventType.PAUSED)
        })
    };
    b.initStyle = function() {
        if (this._video) {
            var a = this._video;
            a.style.position = "absolute";
            a.style.bottom = "0px";
            a.style.left = "0px";
            a.className = "cocosVideo"
        }
    };
    b.changeSize = function(a, b) {
        var e = this._node._contentSize;
        a = a || e.width;
        b = b || e.height;
        if (e = this._video) 0 !== a && (e.width = a), 0 !== b && (e.height = b)
    };
    b.removeDom = function() {
        var a = this._video;
        if (a) {
            var b = !1;
            (b = "contains" in cc.container ? cc.container.contains(a) : cc.container.compareDocumentPosition(a) % 16) && cc.container.removeChild(a)
        }
    }
})(ccui.VideoPlayer._polyfill);
ccui.RichElement = ccui.Class.extend({
    _type: 0,
    _tag: 0,
    _color: null,
    _opacity: 0,
    ctor: function() {
        this._tag = this._type = 0;
        this._color = cc.color(255, 255, 255, 255)
    },
    init: function(a, b, c) {
        this._tag = a;
        this._color.r = b.r;
        this._color.g = b.g;
        this._color.b = b.b;
        this._opacity = c;
        this._color.a = void 0 === c ? b.a : c
    }
});
ccui.RichElementText = ccui.RichElement.extend({
    _text: "",
    _fontName: "",
    _fontSize: 0,
    _fontDefinition: null,
    ctor: function(a, b, c, d, e, f) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.TEXT;
        this._fontName = this._text = "";
        this._fontSize = 0;
        b && b instanceof cc.FontDefinition ? this.initWithStringAndTextDefinition(a, d, b, c) : f && this.init(a, b, c, d, e, f)
    },
    init: function(a, b, c, d, e, f) {
        ccui.RichElement.prototype.init.call(this, a, b, c);
        this._text = d;
        this._fontName = e;
        this._fontSize = f
    },
    initWithStringAndTextDefinition: function(a,
        b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, c.fillStyle, d);
        this._fontDefinition = c;
        this._text = b;
        this._fontName = c.fontName;
        this._fontSize = c.fontSize
    }
});
ccui.RichElementText.create = function(a, b, c, d, e, f) {
    return new ccui.RichElementText(a, b, c, d, e, f)
};
ccui.RichElementImage = ccui.RichElement.extend({
    _filePath: "",
    _textureRect: null,
    _textureType: 0,
    ctor: function(a, b, c, d) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.IMAGE;
        this._filePath = "";
        this._textureRect = cc.rect(0, 0, 0, 0);
        this._textureType = 0;
        void 0 !== d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, b, c);
        this._filePath = d
    }
});
ccui.RichElementImage.create = function(a, b, c, d) {
    return new ccui.RichElementImage(a, b, c, d)
};
ccui.RichElementCustomNode = ccui.RichElement.extend({
    _customNode: null,
    ctor: function(a, b, c, d) {
        ccui.RichElement.prototype.ctor.call(this);
        this._type = ccui.RichElement.CUSTOM;
        this._customNode = null;
        void 0 !== d && this.init(a, b, c, d)
    },
    init: function(a, b, c, d) {
        ccui.RichElement.prototype.init.call(this, a, b, c);
        this._customNode = d
    }
});
ccui.RichElementCustomNode.create = function(a, b, c, d) {
    return new ccui.RichElementCustomNode(a, b, c, d)
};
ccui.RichText = ccui.Widget.extend({
    _formatTextDirty: !1,
    _richElements: null,
    _elementRenders: null,
    _leftSpaceWidth: 0,
    _verticalSpace: 0,
    _elementRenderersContainer: null,
    _lineBreakOnSpace: !1,
    _textHorizontalAlignment: null,
    _textVerticalAlignment: null,
    ctor: function() {
        ccui.Widget.prototype.ctor.call(this);
        this._formatTextDirty = !1;
        this._richElements = [];
        this._elementRenders = [];
        this._verticalSpace = this._leftSpaceWidth = 0;
        this._textHorizontalAlignment = cc.TEXT_ALIGNMENT_LEFT;
        this._textVerticalAlignment = cc.VERTICAL_TEXT_ALIGNMENT_TOP
    },
    _initRenderer: function() {
        this._elementRenderersContainer = new cc.Node;
        this._elementRenderersContainer.setAnchorPoint(0.5, 0.5);
        this.addProtectedChild(this._elementRenderersContainer, 0, -1)
    },
    insertElement: function(a, b) {
        this._richElements.splice(b, 0, a);
        this._formatTextDirty = !0
    },
    pushBackElement: function(a) {
        this._richElements.push(a);
        this._formatTextDirty = !0
    },
    removeElement: function(a) {
        cc.isNumber(a) ? this._richElements.splice(a, 1) : cc.arrayRemoveObject(this._richElements, a);
        this._formatTextDirty = !0
    },
    formatText: function() {
        if (this._formatTextDirty) {
            this._elementRenderersContainer.removeAllChildren();
            this._elementRenders.length = 0;
            var a, b, c = this._richElements;
            if (this._ignoreSize)
                for (this._addNewLine(), a = 0; a < c.length; a++) {
                    b = c[a];
                    var d = null;
                    switch (b._type) {
                        case ccui.RichElement.TEXT:
                            d = b._fontDefinition ? new cc.LabelTTF(b._text, b._fontDefinition) : new cc.LabelTTF(b._text, b._fontName, b._fontSize);
                            break;
                        case ccui.RichElement.IMAGE:
                            d = new cc.Sprite(b._filePath);
                            break;
                        case ccui.RichElement.CUSTOM:
                            d = b._customNode
                    }
                    d.setColor(b._color);
                    d.setOpacity(b._color.a);
                    this._pushToContainer(d)
                } else
                    for (this._addNewLine(),
                        a = 0; a < c.length; a++) switch (b = c[a], b._type) {
                        case ccui.RichElement.TEXT:
                            b._fontDefinition ? this._handleTextRenderer(b._text, b._fontDefinition, b._fontDefinition.fontSize, b._fontDefinition.fillStyle) : this._handleTextRenderer(b._text, b._fontName, b._fontSize, b._color);
                            break;
                        case ccui.RichElement.IMAGE:
                            this._handleImageRenderer(b._filePath, b._color, b._color.a);
                            break;
                        case ccui.RichElement.CUSTOM:
                            this._handleCustomRenderer(b._customNode)
                    }
            this.formatRenderers();
            this._formatTextDirty = !1
        }
    },
    _handleTextRenderer: function(a,
        b, c, d) {
        if ("" !== a)
            if ("\n" === a) this._addNewLine();
            else {
                var e = b instanceof cc.FontDefinition ? new cc.LabelTTF(a, b) : new cc.LabelTTF(a, b, c),
                    f = e.getContentSize().width;
                this._leftSpaceWidth -= f;
                if (0 > this._leftSpaceWidth) {
                    var e = a.length * (1 - -this._leftSpaceWidth / f),
                        f = a.substr(0, e),
                        g = a.substr(e, a.length - 1),
                        h = 0 < e;
                    this._lineBreakOnSpace && (g = f.lastIndexOf(" "), e = -1 === g ? e : g + 1, g = a.substr(e, a.length - 1), h = 0 < e && " " !== g);
                    h && (a = null, b instanceof cc.FontDefinition ? (a = new cc.LabelTTF(f.substr(0, e), b), a.setOpacity(b.fillStyle.a)) :
                        (a = new cc.LabelTTF(f.substr(0, e), b, c), a.setColor(d), a.setOpacity(d.a)), this._pushToContainer(a));
                    this._addNewLine();
                    this._handleTextRenderer(g, b, c, d)
                } else b instanceof cc.FontDefinition ? e.setOpacity(b.fillStyle.a) : (e.setColor(d), e.setOpacity(d.a)), this._pushToContainer(e)
            }
    },
    _handleImageRenderer: function(a, b, c) {
        a = new cc.Sprite(a);
        this._handleCustomRenderer(a)
    },
    _handleCustomRenderer: function(a) {
        var b = a.getContentSize();
        this._leftSpaceWidth -= b.width;
        0 > this._leftSpaceWidth ? (this._addNewLine(), this._pushToContainer(a),
            this._leftSpaceWidth -= b.width) : this._pushToContainer(a)
    },
    _addNewLine: function() {
        this._leftSpaceWidth = this._customSize.width;
        this._elementRenders.push([])
    },
    formatRenderers: function() {
        var a = 0,
            b = this._elementRenderersContainer,
            c = this._elementRenders,
            d, e, f, g, h, k;
        if (this._ignoreSize) {
            d = 0;
            f = c[0];
            for (e = g = 0; e < f.length; e++) h = f[e], h.setAnchorPoint(cc.p(0, 0)), h.setPosition(g, 0), b.addChild(h, 1, e), k = h.getLineHeight ? h.getLineHeight() : a, h = h.getContentSize(), d += h.width, a = Math.max(Math.min(a, k), h.height), g += h.width;
            if (this._textHorizontalAlignment !== cc.TEXT_ALIGNMENT_LEFT)
                for (k = 0, this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_RIGHT ? k = this._contentSize.width - g : this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_CENTER && (k = (this._contentSize.width - g) / 2), e = 0; e < f.length; e++) f[e].x += k;
            b.setContentSize(d, a)
        } else {
            var m = [];
            for (d = 0; d < c.length; d++) {
                f = c[d];
                for (e = g = 0; e < f.length; e++) h = f[e], k = h.getLineHeight ? h.getLineHeight() : h.getContentSize().height, g = Math.max(Math.min(h.getContentSize().height, k), g);
                m[d] = g;
                a += m[d]
            }
            var n =
                this._customSize.height;
            for (d = 0; d < c.length; d++) {
                f = c[d];
                g = 0;
                n -= m[d] + this._verticalSpace;
                for (e = 0; e < f.length; e++) h = f[e], h.setAnchorPoint(cc.p(0, 0)), h.setPosition(cc.p(g, n)), b.addChild(h, 1), g += h.getContentSize().width;
                if (this._textHorizontalAlignment !== cc.TEXT_ALIGNMENT_LEFT || this._textVerticalAlignment !== cc.VERTICAL_TEXT_ALIGNMENT_TOP)
                    for (k = 0, this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_RIGHT ? k = this._contentSize.width - g : this._textHorizontalAlignment === cc.TEXT_ALIGNMENT_CENTER && (k = (this._contentSize.width -
                            g) / 2), g = 0, this._textVerticalAlignment === cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM ? g = this._customSize.height - a : this._textVerticalAlignment === cc.VERTICAL_TEXT_ALIGNMENT_CENTER && (g = (this._customSize.height - a) / 2), e = 0; e < f.length; e++) h = f[e], h.x += k, h.y -= g
            }
            b.setContentSize(this._contentSize)
        }
        a = c.length;
        for (d = 0; d < a; d++) c[d].length = 0;
        this._elementRenders.length = 0;
        this.setContentSize(this._ignoreSize ? this.getVirtualRendererSize() : this._customSize);
        this._updateContentSizeWithTextureSize(this._contentSize);
        b.setPosition(0.5 *
            this._contentSize.width, 0.5 * this._contentSize.height)
    },
    _pushToContainer: function(a) {
        0 >= this._elementRenders.length || this._elementRenders[this._elementRenders.length - 1].push(a)
    },
    _adaptRenderers: function() {
        this.formatText()
    },
    setVerticalSpace: function(a) {
        this._verticalSpace = a
    },
    setAnchorPoint: function(a) {
        ccui.Widget.prototype.setAnchorPoint.call(this, a);
        this._elementRenderersContainer.setAnchorPoint(a)
    },
    _setAnchorX: function(a) {
        ccui.Widget.prototype._setAnchorX.call(this, a);
        this._elementRenderersContainer._setAnchorX(a)
    },
    _setAnchorY: function(a) {
        ccui.Widget.prototype._setAnchorY.call(this, a);
        this._elementRenderersContainer._setAnchorY(a)
    },
    getVirtualRendererSize: function() {
        return this._elementRenderersContainer.getContentSize()
    },
    ignoreContentAdaptWithSize: function(a) {
        this._ignoreSize !== a && (this._formatTextDirty = !0, ccui.Widget.prototype.ignoreContentAdaptWithSize.call(this, a))
    },
    getContentSize: function() {
        this.formatText();
        return cc.Node.prototype.getContentSize.call(this)
    },
    _getWidth: function() {
        this.formatText();
        return cc.Node.prototype._getWidth.call(this)
    },
    _getHeight: function() {
        this.formatText();
        return cc.Node.prototype._getHeight.call(this)
    },
    setContentSize: function(a, b) {
        ccui.Widget.prototype.setContentSize.call(this, void 0 === b ? a.width : a, void 0 === b ? a.height : b);
        this._formatTextDirty = !0
    },
    getDescription: function() {
        return "RichText"
    },
    setCascadeOpacityEnabled: function(a) {
        this._super(a);
        this._elementRenderersContainer.setCascadeOpacityEnabled(a)
    },
    setLineBreakOnSpace: function(a) {
        this._lineBreakOnSpace = a;
        this._formatTextDirty = !0;
        this.formatText()
    },
    setTextHorizontalAlignment: function(a) {
        a !==
            this._textHorizontalAlignment && (this._textHorizontalAlignment = a, this.formatText())
    },
    setTextVerticalAlignment: function(a) {
        a !== this._textVerticalAlignment && (this._textVerticalAlignment = a, this.formatText())
    }
});
ccui.RichText.create = function() {
    return new ccui.RichText
};
ccui.RichElement.TEXT = 0;
ccui.RichElement.IMAGE = 1;
ccui.RichElement.CUSTOM = 2;
ccui.WebView = ccui.Widget.extend({
    ctor: function(a) {
        ccui.Widget.prototype.ctor.call(this);
        this._EventList = {};
        a && this.loadURL(a)
    },
    setJavascriptInterfaceScheme: function(a) {},
    loadData: function(a, b, c, d) {},
    loadHTMLString: function(a, b) {},
    loadURL: function(a) {
        this._renderCmd.updateURL(a);
        this._dispatchEvent(ccui.WebView.EventType.LOADING)
    },
    stopLoading: function() {
        cc.log("Web does not support loading")
    },
    reload: function() {
        var a = this._renderCmd._iframe;
        a && (a = a.contentWindow) && a.location && a.location.reload()
    },
    canGoBack: function() {
        cc.log("Web does not support query history");
        return !0
    },
    canGoForward: function() {
        cc.log("Web does not support query history");
        return !0
    },
    goBack: function() {
        try {
            if (ccui.WebView._polyfill.closeHistory) return cc.log("The current browser does not support the GoBack");
            var a = this._renderCmd._iframe;
            if (a) {
                var b = a.contentWindow;
                b && b.location && b.history.back.call(b)
            }
        } catch (c) {
            cc.log(c)
        }
    },
    goForward: function() {
        try {
            if (ccui.WebView._polyfill.closeHistory) return cc.log("The current browser does not support the GoForward");
            var a = this._renderCmd._iframe;
            if (a) {
                var b =
                    a.contentWindow;
                b && b.location && b.history.forward.call(b)
            }
        } catch (c) {
            cc.log(c)
        }
    },
    evaluateJS: function(a) {
        var b = this._renderCmd._iframe;
        if (b) {
            b = b.contentWindow;
            try {
                b.eval(a), this._dispatchEvent(ccui.WebView.EventType.JS_EVALUATED)
            } catch (c) {
                console.error(c)
            }
        }
    },
    setScalesPageToFit: function() {
        cc.log("Web does not support zoom")
    },
    setEventListener: function(a, b) {
        this._EventList[a] = b
    },
    removeEventListener: function(a) {
        this._EventList[a] = null
    },
    _dispatchEvent: function(a) {
        (a = this._EventList[a]) && a.call(this, this,
            this._renderCmd._iframe.src)
    },
    _createRenderCmd: function() {
        return new ccui.WebView.RenderCmd(this)
    },
    setContentSize: function(a, b) {
        ccui.Widget.prototype.setContentSize.call(this, a, b);
        void 0 === b && (b = a.height, a = a.width);
        this._renderCmd.changeSize(a, b)
    },
    cleanup: function() {
        this._renderCmd.removeDom();
        this.stopAllActions();
        this.unscheduleAllCallbacks()
    }
});
ccui.WebView.EventType = {
    LOADING: "loading",
    LOADED: "load",
    ERROR: "error",
    JS_EVALUATED: "js"
};
(function() {
    var a = ccui.WebView._polyfill = {
        devicePixelRatio: !1,
        enableDiv: !1
    };
    cc.sys.os === cc.sys.OS_IOS && (a.enableDiv = !0);
    cc.sys.isMobile ? cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (a.enableBG = !0) : cc.sys.browserType === cc.sys.BROWSER_TYPE_IE && (a.closeHistory = !0)
})();
(function(a) {
    ccui.WebView.RenderCmd = function(b) {
        cc.Node.CanvasRenderCmd.call(this, b);
        this._iframe = this._div = null;
        a.enableDiv ? (this._div = document.createElement("div"), this._div.style["-webkit-overflow"] = "auto", this._div.style["-webkit-overflow-scrolling"] = "touch", this._iframe = document.createElement("iframe"), this._div.appendChild(this._iframe)) : this._div = this._iframe = document.createElement("iframe");
        a.enableBG && (this._div.style.background = "#FFF");
        this._iframe.addEventListener("load", function() {
            b._dispatchEvent(ccui.WebView.EventType.LOADED)
        });
        this._iframe.addEventListener("error", function() {
            b._dispatchEvent(ccui.WebView.EventType.ERROR)
        });
        this._div.style.background = "#FFF";
        this._div.style.height = "200px";
        this._div.style.width = "300px";
        this._div.style.overflow = "scroll";
        this._listener = null;
        this.initStyle()
    };
    var b = ccui.WebView.RenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    b.constructor = ccui.WebView.RenderCmd;
    b.updateStatus = function() {
        a.devicePixelRatio = cc.view.isRetinaEnabled();
        this._dirtyFlag & cc.Node._dirtyFlags.transformDirty &&
            (this.transform(this.getParentRenderCmd(), !0), this.updateMatrix(this._worldTransform, cc.view._scaleX, cc.view._scaleY), this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty)
    };
    b.visit = function() {
        var a = this,
            b = cc.container,
            e = cc.eventManager;
        if (this._node._visible) b.appendChild(this._div), null === this._listener && (this._listener = e.addCustomListener(cc.game.EVENT_RESIZE, function() {
            a.resize()
        }));
        else {
            var f = !1;
            (f = "contains" in b ? b.contains(this._div) : b.compareDocumentPosition(this._div) % 16) && b.removeChild(this._div);
            b = e._listenersMap[cc.game.EVENT_RESIZE].getFixedPriorityListeners();
            e._removeListenerInVector(b, this._listener);
            this._listener = null
        }
        this.updateStatus();
        this.resize(cc.view)
    };
    b.resize = function(a) {
        a = a || cc.view;
        var b = this._node,
            e = cc.eventManager;
        b._parent && b._visible ? this.updateMatrix(this._worldTransform, a._scaleX, a._scaleY) : (a = e._listenersMap[cc.game.EVENT_RESIZE].getFixedPriorityListeners(), e._removeListenerInVector(a, this._listener), this._listener = null)
    };
    b.updateMatrix = function(b, d, e) {
        var f = this._node;
        if (a.devicePixelRatio && 1 !== d && 1 !== d) {
            var g = window.devicePixelRatio;
            d /= g;
            e /= g
        }
        if (!1 !== this._loaded) {
            var g = f._contentSize.width,
                h = f._contentSize.height;
            b = "matrix(" + b.a * d + "," + b.b + "," + b.c + "," + b.d * e + "," + (b.tx * d - g / 2 + g * f._scaleX / 2 * d) + "," + -(b.ty * e - h / 2 + h * f._scaleY / 2 * e) + ")";
            this._div.style.transform = b;
            this._div.style["-webkit-transform"] = b
        }
    };
    b.initStyle = function() {
        if (this._div) {
            var a = this._div;
            a.style.position = "absolute";
            a.style.bottom = "0px";
            a.style.left = "0px"
        }
    };
    b.updateURL = function(a) {
        var b = this._iframe;
        b.src =
            a;
        var e = this,
            f = function() {
                e._loaded = !0;
                b.removeEventListener("load", f)
            };
        b.addEventListener("load", f)
    };
    b.changeSize = function(a, b) {
        var e = this._div;
        e && (e.style.width = a + "px", e.style.height = b + "px")
    };
    b.removeDom = function() {
        var a = this._div;
        if (a) {
            var b = !1;
            (b = "contains" in cc.container ? cc.container.contains(a) : cc.container.compareDocumentPosition(a) % 16) && cc.container.removeChild(a)
        }
    }
})(ccui.WebView._polyfill);
ccui.ScrollView = ccui.Layout.extend({
    _innerContainer: null,
    direction: null,
    _autoScrollDir: null,
    _topBoundary: 0,
    _bottomBoundary: 0,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _bounceTopBoundary: 0,
    _bounceBottomBoundary: 0,
    _bounceLeftBoundary: 0,
    _bounceRightBoundary: 0,
    _autoScroll: !1,
    _autoScrollAddUpTime: 0,
    _autoScrollOriginalSpeed: 0,
    _autoScrollAcceleration: 0,
    _isAutoScrollSpeedAttenuated: !1,
    _needCheckAutoScrollDestination: !1,
    _autoScrollDestination: null,
    _bePressed: !1,
    _slidTime: 0,
    _moveChildPoint: null,
    _childFocusCancelOffset: 0,
    _leftBounceNeeded: !1,
    _topBounceNeeded: !1,
    _rightBounceNeeded: !1,
    _bottomBounceNeeded: !1,
    bounceEnabled: !1,
    _bouncing: !1,
    _bounceDir: null,
    _bounceOriginalSpeed: 0,
    inertiaScrollEnabled: !1,
    _scrollViewEventListener: null,
    _scrollViewEventSelector: null,
    _className: "ScrollView",
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this);
        this.direction = ccui.ScrollView.DIR_NONE;
        this._autoScrollDir = cc.p(0, 0);
        this._autoScrollAcceleration = -1E3;
        this._autoScrollDestination = cc.p(0, 0);
        this._slidTime = 0;
        this._moveChildPoint = cc.p(0,
            0);
        this._childFocusCancelOffset = 5;
        this._bounceDir = cc.p(0, 0);
        this._bounceOriginalSpeed = 0;
        this.inertiaScrollEnabled = !0;
        this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), this._innerContainer.setTouchEnabled(!1), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this);
        this.scheduleUpdate(!0)
    },
    findNextFocusedWidget: function(a, b) {
        return this.getLayoutType() === ccui.Layout.LINEAR_VERTICAL || this.getLayoutType() === ccui.Layout.LINEAR_HORIZONTAL ?
            this._innerContainer.findNextFocusedWidget(a, b) : ccui.Widget.prototype.findNextFocusedWidget.call(this, a, b)
    },
    _initRenderer: function() {
        ccui.Layout.prototype._initRenderer.call(this);
        this._innerContainer = new ccui.Layout;
        this._innerContainer.setColor(cc.color(255, 255, 255));
        this._innerContainer.setOpacity(255);
        this._innerContainer.setCascadeColorEnabled(!0);
        this._innerContainer.setCascadeOpacityEnabled(!0);
        this.addProtectedChild(this._innerContainer, 1, 1)
    },
    _createRenderCmd: function() {
        return cc._renderType ===
            cc.game.RENDER_TYPE_WEBGL ? new ccui.ScrollView.WebGLRenderCmd(this) : new ccui.ScrollView.CanvasRenderCmd(this)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this);
        var a = this._contentSize;
        this._topBoundary = a.height;
        this._rightBoundary = a.width;
        var b = a.width / 3,
            c = a.height / 3;
        this._bounceTopBoundary = a.height - c;
        this._bounceBottomBoundary = c;
        this._bounceLeftBoundary = b;
        this._bounceRightBoundary = a.width - b;
        b = this._innerContainer.getContentSize();
        this._innerContainer.setContentSize(cc.size(Math.max(b.width,
            a.width), Math.max(b.height, a.height)));
        this._innerContainer.setPosition(0, a.height - this._innerContainer.getContentSize().height)
    },
    setInnerContainerSize: function(a) {
        var b = this._innerContainer,
            c = this._contentSize,
            d = c.width,
            e = c.height,
            f = b.getContentSize(),
            g = this._renderCmd;
        a.width < c.width ? cc.log("Inner width \x3c\x3d ScrollView width, it will be force sized!") : d = a.width;
        a.height < c.height ? cc.log("Inner height \x3c\x3d ScrollView height, it will be force sized!") : e = a.height;
        b.setContentSize(cc.size(d,
            e));
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                d = b.getContentSize();
                f = f.height - d.height;
                g.transform(g.getParentRenderCmd(), !0);
                this._scrollChildren(0, f);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                b.getRightBoundary() <= c.width && (d = b.getContentSize(), f = f.width - d.width, g.transform(g.getParentRenderCmd(), !0), this._scrollChildren(f, 0));
                break;
            case ccui.ScrollView.DIR_BOTH:
                d = b.getContentSize(), a = f.height - d.height, f = b.getRightBoundary() <= c.width ? f.width - d.width : 0, g.transform(g.getParentRenderCmd(), !0), this._scrollChildren(f, a)
        }
        g = b.getContentSize();
        f = b.getPosition();
        a = b.getAnchorPoint();
        0 < b.getLeftBoundary() && b.setPosition(a.x * g.width, f.y);
        b.getRightBoundary() < c.width && b.setPosition(c.width - (1 - a.x) * g.width, f.y);
        0 < f.y && b.setPosition(f.x, a.y * g.height);
        b.getTopBoundary() < c.height && b.setPosition(f.x, c.height - (1 - a.y) * g.height)
    },
    _setInnerWidth: function(a) {
        var b = this._contentSize.width,
            c = b,
            d = this._innerContainer,
            e = d.width;
        a < b ? cc.log("Inner width \x3c\x3d scrollview width, it will be force sized!") :
            c = a;
        d.width = c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_HORIZONTAL:
            case ccui.ScrollView.DIR_BOTH:
                d.getRightBoundary() <= b && this._scrollChildren(e - d.width, 0)
        }
        a = d.anchorX;
        0 < d.getLeftBoundary() && (d.x = a * c);
        d.getRightBoundary() < b && (d.x = b - (1 - a) * c)
    },
    _setInnerHeight: function(a) {
        var b = this._contentSize.height,
            c = b,
            d = this._innerContainer,
            e = d.height;
        a < b ? cc.log("Inner height \x3c\x3d scrollview height, it will be force sized!") : c = a;
        d.height = c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(0,
                    e - c)
        }
        a = d.anchorY;
        0 < d.getLeftBoundary() && (d.y = a * c);
        d.getRightBoundary() < b && (d.y = b - (1 - a) * c)
    },
    getInnerContainerSize: function() {
        return this._innerContainer.getContentSize()
    },
    _getInnerWidth: function() {
        return this._innerContainer.width
    },
    _getInnerHeight: function() {
        return this._innerContainer.height
    },
    _isInContainer: function(a) {
        if (!this._clippingEnabled) return !0;
        var b = a._position,
            c = a._contentSize;
        a = a._anchorPoint;
        var d = this._customSize,
            e = this._innerContainer._position,
            f = 0,
            g = 0;
        return (f = b.y - a.y * c.height) >= d.height -
            e.y || f + c.height <= -e.y || (g = b.x - a.x * c.width) >= d.width - e.x || g + c.width <= -e.x ? !1 : !0
    },
    updateChildren: function() {
        var a, b, c, d = this._innerContainer._children;
        b = 0;
        for (c = d.length; b < c; b++) a = d[b], !0 === a._inViewRect && !1 === this._isInContainer(a) ? a._inViewRect = !1 : !1 === a._inViewRect && !0 === this._isInContainer(a) && (a._inViewRect = !0)
    },
    addChild: function(a, b, c) {
        if (!a) return !1;
        !1 === this._isInContainer(a) && (a._inViewRect = !1);
        b = b || a.getLocalZOrder();
        c = c || a.getTag();
        return this._innerContainer.addChild(a, b, c)
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        this._innerContainer.removeAllChildrenWithCleanup(a)
    },
    removeChild: function(a, b) {
        return this._innerContainer.removeChild(a, b)
    },
    getChildren: function() {
        return this._innerContainer.getChildren()
    },
    getChildrenCount: function() {
        return this._innerContainer.getChildrenCount()
    },
    getChildByTag: function(a) {
        return this._innerContainer.getChildByTag(a)
    },
    getChildByName: function(a) {
        return this._innerContainer.getChildByName(a)
    },
    _moveChildren: function(a, b) {
        var c = this._innerContainer;
        this._moveChildPoint.x = c.x + a;
        this._moveChildPoint.y = c.y + b;
        this._innerContainer.setPosition(this._moveChildPoint);
        0 !== this._innerContainer._children.length && this.updateChildren()
    },
    _autoScrollChildren: function(a) {
        var b = this._autoScrollAddUpTime;
        this._autoScrollAddUpTime += a;
        if (this._isAutoScrollSpeedAttenuated) 0 >= this._autoScrollOriginalSpeed + this._autoScrollAcceleration * this._autoScrollAddUpTime ? (this._stopAutoScrollChildren(), this._checkNeedBounce()) : (b = (this._autoScrollOriginalSpeed + this._autoScrollAcceleration *
            (2 * b + a) * 0.5) * a, this._scrollChildren(b * this._autoScrollDir.x, b * this._autoScrollDir.y) || (this._stopAutoScrollChildren(), this._checkNeedBounce()));
        else if (this._needCheckAutoScrollDestination) {
            var b = this._autoScrollDir.x * a * this._autoScrollOriginalSpeed,
                c = this._autoScrollDir.y * a * this._autoScrollOriginalSpeed;
            a = this._checkCustomScrollDestination(b, c);
            b = this._scrollChildren(b, c);
            a && b || (this._stopAutoScrollChildren(), this._checkNeedBounce())
        } else this._scrollChildren(this._autoScrollDir.x * a * this._autoScrollOriginalSpeed,
            this._autoScrollDir.y * a * this._autoScrollOriginalSpeed) || (this._stopAutoScrollChildren(), this._checkNeedBounce())
    },
    _bounceChildren: function(a) {
        var b = this._bounceOriginalSpeed,
            c = this._bounceDir;
        0 >= b && this._stopBounceChildren();
        this._bounceScrollChildren(c.x * a * b, c.y * a * b) || this._stopBounceChildren()
    },
    _checkNeedBounce: function() {
        if (!this.bounceEnabled) return !1;
        this._checkBounceBoundary();
        var a = this._topBounceNeeded,
            b = this._bottomBounceNeeded,
            c = this._leftBounceNeeded,
            d = this._rightBounceNeeded;
        if (a || b ||
            c || d) {
            var e = this._contentSize,
                f = this._innerContainer;
            a && c ? (a = cc.pSub(cc.p(0, e.height), cc.p(f.getLeftBoundary(), f.getTopBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : a && d ? (a = cc.pSub(cc.p(e.width, e.height), cc.p(f.getRightBoundary(), f.getTopBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : b && c ? (a = cc.pSub(cc.p(0, 0), cc.p(f.getLeftBoundary(), f.getBottomBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a),
                this._startBounceChildren(b)) : b && d ? (a = cc.pSub(cc.p(e.width, 0), cc.p(f.getRightBoundary(), f.getBottomBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : a ? (a = cc.pSub(cc.p(0, e.height), cc.p(0, f.getTopBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : b ? (a = cc.pSub(cc.p(0, 0), cc.p(0, f.getBottomBoundary())), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : c ? (a = cc.pSub(cc.p(0, 0), cc.p(f.getLeftBoundary(),
                0)), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b)) : d && (a = cc.pSub(cc.p(e.width, 0), cc.p(f.getRightBoundary(), 0)), b = cc.pLength(a) / 0.2, this._bounceDir = cc.pNormalize(a), this._startBounceChildren(b));
            return !0
        }
        return !1
    },
    _checkBounceBoundary: function() {
        var a = this._innerContainer;
        a.getBottomBoundary() > this._bottomBoundary ? (this._scrollToBottomEvent(), this._bottomBounceNeeded = !0) : this._bottomBounceNeeded = !1;
        a.getTopBoundary() < this._topBoundary ? (this._scrollToTopEvent(), this._topBounceNeeded = !0) : this._topBounceNeeded = !1;
        a.getRightBoundary() < this._rightBoundary ? (this._scrollToRightEvent(), this._rightBounceNeeded = !0) : this._rightBounceNeeded = !1;
        a.getLeftBoundary() > this._leftBoundary ? (this._scrollToLeftEvent(), this._leftBounceNeeded = !0) : this._leftBounceNeeded = !1
    },
    _startBounceChildren: function(a) {
        this._bounceOriginalSpeed = a;
        this._bouncing = !0
    },
    _stopBounceChildren: function() {
        this._bouncing = !1;
        this._bounceOriginalSpeed = 0;
        this._bottomBounceNeeded = this._topBounceNeeded = this._rightBounceNeeded =
            this._leftBounceNeeded = !1
    },
    _startAutoScrollChildrenWithOriginalSpeed: function(a, b, c, d) {
        this._stopAutoScrollChildren();
        this._autoScrollDir.x = a.x;
        this._autoScrollDir.y = a.y;
        this._isAutoScrollSpeedAttenuated = c;
        this._autoScrollOriginalSpeed = b;
        this._autoScroll = !0;
        this._autoScrollAcceleration = d
    },
    _startAutoScrollChildrenWithDestination: function(a, b, c) {
        this._needCheckAutoScrollDestination = !1;
        this._autoScrollDestination = a;
        var d = cc.pSub(a, this._innerContainer.getPosition());
        a = cc.pNormalize(d);
        var e = 0,
            f = -1E3,
            d = cc.pLength(d);
        c ? (f = -(2 * d) / (b * b), e = 2 * d / b) : (this._needCheckAutoScrollDestination = !0, e = d / b);
        this._startAutoScrollChildrenWithOriginalSpeed(a, e, c, f)
    },
    _jumpToDestination: function(a, b) {
        void 0 !== a.x && (b = a.y, a = a.x);
        var c = a,
            d = b;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 >= a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 >= b && (d = Math.max(b, this._contentSize.height - this._innerContainer.getContentSize().height)), 0 >= a && (c = Math.max(a, this._contentSize.width - this._innerContainer.getContentSize().width))
        }
        this._innerContainer.setPosition(c, d)
    },
    _stopAutoScrollChildren: function() {
        this._autoScroll = !1;
        this._autoScrollAddUpTime = this._autoScrollOriginalSpeed = 0
    },
    _bounceScrollChildren: function(a, b) {
        var c = !0,
            d, e, f, g;
        g = this._innerContainer;
        0 < a && 0 < b ? (d = a, e = b, f = g.getRightBoundary(), f + d >= this._rightBoundary &&
            (d = this._rightBoundary - f, this._bounceRightEvent(), c = !1), g = g.getTopBoundary(), g + b >= this._topBoundary && (e = this._topBoundary - g, this._bounceTopEvent(), c = !1), this._moveChildren(d, e)) : 0 > a && 0 < b ? (d = a, e = b, f = g.getLeftBoundary(), f + d <= this._leftBoundary && (d = this._leftBoundary - f, this._bounceLeftEvent(), c = !1), g = g.getTopBoundary(), g + b >= this._topBoundary && (e = this._topBoundary - g, this._bounceTopEvent(), c = !1), this._moveChildren(d, e)) : 0 > a && 0 > b ? (d = a, e = b, f = g.getLeftBoundary(), f + d <= this._leftBoundary && (d = this._leftBoundary -
            f, this._bounceLeftEvent(), c = !1), g = g.getBottomBoundary(), g + b <= this._bottomBoundary && (e = this._bottomBoundary - g, this._bounceBottomEvent(), c = !1), this._moveChildren(d, e)) : 0 < a && 0 > b ? (d = a, e = b, f = g.getRightBoundary(), f + d >= this._rightBoundary && (d = this._rightBoundary - f, this._bounceRightEvent(), c = !1), g = g.getBottomBoundary(), g + b <= this._bottomBoundary && (e = this._bottomBoundary - g, this._bounceBottomEvent(), c = !1), this._moveChildren(d, e)) : 0 === a && 0 < b ? (e = b, g = g.getTopBoundary(), g + b >= this._topBoundary && (e = this._topBoundary -
            g, this._bounceTopEvent(), c = !1), this._moveChildren(0, e)) : 0 === a && 0 > b ? (e = b, g = g.getBottomBoundary(), g + b <= this._bottomBoundary && (e = this._bottomBoundary - g, this._bounceBottomEvent(), c = !1), this._moveChildren(0, e)) : 0 < a && 0 === b ? (d = a, f = g.getRightBoundary(), f + d >= this._rightBoundary && (d = this._rightBoundary - f, this._bounceRightEvent(), c = !1), this._moveChildren(d, 0)) : 0 > a && 0 === b && (d = a, e = g.getLeftBoundary(), e + d <= this._leftBoundary && (d = this._leftBoundary - e, this._bounceLeftEvent(), c = !1), this._moveChildren(d, 0));
        return c
    },
    _checkCustomScrollDestination: function(a, b) {
        var c = !0,
            d, e;
        d = this._innerContainer;
        var f = this._autoScrollDestination;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                0 < this._autoScrollDir.y ? (d = d.getBottomBoundary(), d + b >= f.y && (c = !1)) : (d = d.getBottomBoundary(), d + b <= f.y && (c = !1));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                0 < this._autoScrollDir.x ? (e = d.getLeftBoundary(), e + a >= f.x && (c = !1)) : (e = d.getLeftBoundary(), e + a <= f.x && (c = !1));
                break;
            case ccui.ScrollView.DIR_BOTH:
                0 < a && 0 < b ? (e = d.getLeftBoundary(), e + a >=
                    f.x && (c = !1), d = d.getBottomBoundary(), d + b >= f.y && (c = !1)) : 0 > a && 0 < b ? (e = d.getRightBoundary(), e + a <= f.x && (c = !1), d = d.getBottomBoundary(), d + b >= f.y && (c = !1)) : 0 > a && 0 > b ? (e = d.getRightBoundary(), e + a <= f.x && (c = !1), d = d.getTopBoundary(), d + b <= f.y && (c = !1)) : 0 < a && 0 > b ? (e = d.getLeftBoundary(), e + a >= f.x && (c = !1), d = d.getTopBoundary(), d + b <= f.y && (c = !1)) : 0 === a && 0 < b ? (d = d.getBottomBoundary(), d + b >= f.y && (c = !1)) : 0 > a && 0 === b ? (e = d.getRightBoundary(), e + a <= f.x && (c = !1)) : 0 === a && 0 > b ? (d = d.getTopBoundary(), d + b <= f.y && (c = !1)) : 0 < a && 0 === b && (e = d.getLeftBoundary(),
                    e + a >= f.x && (c = !1))
        }
        return c
    },
    _scrollChildren: function(a, b) {
        var c = !0;
        this._scrollingEvent();
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                c = this._scrollChildrenVertical(a, b);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                c = this._scrollChildrenHorizontal(a, b);
                break;
            case ccui.ScrollView.DIR_BOTH:
                c = this._scrollChildrenBoth(a, b)
        }
        return c
    },
    _scrollChildrenVertical: function(a, b) {
        var c = b,
            d = !0,
            e, f = this._innerContainer;
        this.bounceEnabled ? (e = f.getBottomBoundary(), e + b >= this._bounceBottomBoundary && (c = this._bounceBottomBoundary -
            e, this._scrollToBottomEvent(), d = !1), e = f.getTopBoundary(), e + b <= this._bounceTopBoundary && (c = this._bounceTopBoundary - e, this._scrollToTopEvent(), d = !1)) : (e = f.getBottomBoundary(), e + b >= this._bottomBoundary && (c = this._bottomBoundary - e, this._scrollToBottomEvent(), d = !1), e = f.getTopBoundary(), e + b <= this._topBoundary && (c = this._topBoundary - e, this._scrollToTopEvent(), d = !1));
        this._moveChildren(0, c);
        return d
    },
    _scrollChildrenHorizontal: function(a, b) {
        var c = !0,
            d = a,
            e, f = this._innerContainer;
        this.bounceEnabled ? (e = f.getRightBoundary(),
            e + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - e, this._scrollToRightEvent(), c = !1), e = f.getLeftBoundary(), e + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - e, this._scrollToLeftEvent(), c = !1)) : (e = f.getRightBoundary(), e + a <= this._rightBoundary && (d = this._rightBoundary - e, this._scrollToRightEvent(), c = !1), e = f.getLeftBoundary(), e + a >= this._leftBoundary && (d = this._leftBoundary - e, this._scrollToLeftEvent(), c = !1));
        this._moveChildren(d, 0);
        return c
    },
    _scrollChildrenBoth: function(a, b) {
        var c = !0,
            d = a,
            e = b,
            f, g;
        g = this._innerContainer;
        this.bounceEnabled ? 0 < a && 0 < b ? (f = g.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - f, this._scrollToLeftEvent(), c = !1), g = g.getBottomBoundary(), g + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 < b ? (f = g.getRightBoundary(), f + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - f, this._scrollToRightEvent(), c = !1), g = g.getBottomBoundary(), g + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary -
            g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 > b ? (f = g.getRightBoundary(), f + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - f, this._scrollToRightEvent(), c = !1), g = g.getTopBoundary(), g + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 < a && 0 > b ? (f = g.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - f, this._scrollToLeftEvent(), c = !1), g = g.getTopBoundary(), g + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - g, this._scrollToTopEvent(),
            c = !1)) : 0 === a && 0 < b ? (g = g.getBottomBoundary(), g + b >= this._bounceBottomBoundary && (e = this._bounceBottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 === b ? (f = g.getRightBoundary(), f + a <= this._bounceRightBoundary && (d = this._bounceRightBoundary - f, this._scrollToRightEvent(), c = !1)) : 0 === a && 0 > b ? (g = g.getTopBoundary(), g + b <= this._bounceTopBoundary && (e = this._bounceTopBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 < a && 0 === b && (f = g.getLeftBoundary(), f + a >= this._bounceLeftBoundary && (d = this._bounceLeftBoundary - f, this._scrollToLeftEvent(),
            c = !1)) : 0 < a && 0 < b ? (f = g.getLeftBoundary(), f + a >= this._leftBoundary && (d = this._leftBoundary - f, this._scrollToLeftEvent(), c = !1), g = g.getBottomBoundary(), g + b >= this._bottomBoundary && (e = this._bottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 < b ? (f = g.getRightBoundary(), f + a <= this._rightBoundary && (d = this._rightBoundary - f, this._scrollToRightEvent(), c = !1), g = g.getBottomBoundary(), g + b >= this._bottomBoundary && (e = this._bottomBoundary - g, this._scrollToBottomEvent(), c = !1)) : 0 > a && 0 > b ? (f = g.getRightBoundary(), f + a <= this._rightBoundary &&
            (d = this._rightBoundary - f, this._scrollToRightEvent(), c = !1), g = g.getTopBoundary(), g + b <= this._topBoundary && (e = this._topBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 < a && 0 > b ? (f = g.getLeftBoundary(), f + a >= this._leftBoundary && (d = this._leftBoundary - f, this._scrollToLeftEvent(), c = !1), g = this._innerContainer.getTopBoundary(), g + b <= this._topBoundary && (e = this._topBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 === a && 0 < b ? (g = this._innerContainer.getBottomBoundary(), g + b >= this._bottomBoundary && (e = this._bottomBoundary - g, this._scrollToBottomEvent(),
            c = !1)) : 0 > a && 0 === b ? (f = this._innerContainer.getRightBoundary(), f + a <= this._rightBoundary && (d = this._rightBoundary - f, this._scrollToRightEvent(), c = !1)) : 0 === a && 0 > b ? (g = this._innerContainer.getTopBoundary(), g + b <= this._topBoundary && (e = this._topBoundary - g, this._scrollToTopEvent(), c = !1)) : 0 < a && 0 === b && (f = this._innerContainer.getLeftBoundary(), f + a >= this._leftBoundary && (d = this._leftBoundary - f, this._scrollToLeftEvent(), c = !1));
        this._moveChildren(d, e);
        return c
    },
    scrollToBottom: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(),
            0), a, b)
    },
    scrollToTop: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToLeft: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(0, this._innerContainer.getPositionY()), a, b)
    },
    scrollToRight: function(a, b) {
        this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, this._innerContainer.getPositionY()),
            a, b)
    },
    scrollToTopLeft: function(a, b) {
        this.direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(0, this._contentSize.height - this._innerContainer.getContentSize().height), a, b)
    },
    scrollToTopRight: function(a, b) {
        if (this.direction !== ccui.ScrollView.DIR_BOTH) cc.log("Scroll direction is not both!");
        else {
            var c = this._innerContainer.getContentSize();
            this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - c.width, this._contentSize.height -
                c.height), a, b)
        }
    },
    scrollToBottomLeft: function(a, b) {
        this.direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(0, 0), a, b)
    },
    scrollToBottomRight: function(a, b) {
        this.direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._startAutoScrollChildrenWithDestination(cc.p(this._contentSize.width - this._innerContainer.getContentSize().width, 0), a, b)
    },
    scrollToPercentVertical: function(a, b, c) {
        var d = this._contentSize.height -
            this._innerContainer.getContentSize().height,
            e = -d;
        this._startAutoScrollChildrenWithDestination(cc.p(this._innerContainer.getPositionX(), d + a * e / 100), b, c)
    },
    scrollToPercentHorizontal: function(a, b, c) {
        var d = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._startAutoScrollChildrenWithDestination(cc.p(-(a * d / 100), this._innerContainer.getPositionY()), b, c)
    },
    scrollToPercentBothDirection: function(a, b, c) {
        if (this.direction === ccui.ScrollView.DIR_BOTH) {
            var d = this._contentSize.height - this._innerContainer.getContentSize().height,
                e = -d,
                f = this._innerContainer.getContentSize().width - this._contentSize.width;
            this._startAutoScrollChildrenWithDestination(cc.p(-(a.x * f / 100), d + a.y * e / 100), b, c)
        }
    },
    jumpToBottom: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), 0)
    },
    jumpToTop: function() {
        this._jumpToDestination(this._innerContainer.getPositionX(), this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToLeft: function() {
        this._jumpToDestination(0, this._innerContainer.getPositionY())
    },
    jumpToRight: function() {
        this._jumpToDestination(this._contentSize.width -
            this._innerContainer.getContentSize().width, this._innerContainer.getPositionY())
    },
    jumpToTopLeft: function() {
        this.direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(0, this._contentSize.height - this._innerContainer.getContentSize().height)
    },
    jumpToTopRight: function() {
        if (this.direction !== ccui.ScrollView.DIR_BOTH) cc.log("Scroll direction is not both!");
        else {
            var a = this._innerContainer.getContentSize();
            this._jumpToDestination(this._contentSize.width - a.width,
                this._contentSize.height - a.height)
        }
    },
    jumpToBottomLeft: function() {
        this.direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(0, 0)
    },
    jumpToBottomRight: function() {
        this.direction !== ccui.ScrollView.DIR_BOTH ? cc.log("Scroll direction is not both!") : this._jumpToDestination(this._contentSize.width - this._innerContainer.getContentSize().width, 0)
    },
    jumpToPercentVertical: function(a) {
        var b = this._contentSize.height - this._innerContainer.getContentSize().height,
            c = -b;
        this._jumpToDestination(this._innerContainer.getPositionX(),
            b + a * c / 100)
    },
    jumpToPercentHorizontal: function(a) {
        var b = this._innerContainer.getContentSize().width - this._contentSize.width;
        this._jumpToDestination(-(a * b / 100), this._innerContainer.getPositionY())
    },
    jumpToPercentBothDirection: function(a) {
        if (this.direction === ccui.ScrollView.DIR_BOTH) {
            var b = this._innerContainer.getContentSize(),
                c = this._contentSize.height - b.height;
            this._jumpToDestination(-(a.x * (b.width - this._contentSize.width) / 100), c + a.y * -c / 100)
        }
    },
    _startRecordSlidAction: function() {
        this._autoScroll && this._stopAutoScrollChildren();
        this._bouncing && this._stopBounceChildren();
        this._slidTime = 0
    },
    _endRecordSlidAction: function() {
        if (!this._checkNeedBounce() && this.inertiaScrollEnabled && !(0.016 >= this._slidTime)) {
            var a = 0,
                b;
            b = this.convertToNodeSpace(this._touchEndPosition);
            var c = this.convertToNodeSpace(this._touchBeganPosition);
            switch (this.direction) {
                case ccui.ScrollView.DIR_VERTICAL:
                    a = b.y - c.y;
                    b = 0 > a ? ccui.ScrollView.SCROLLDIR_DOWN : ccui.ScrollView.SCROLLDIR_UP;
                    break;
                case ccui.ScrollView.DIR_HORIZONTAL:
                    a = b.x - c.x;
                    b = 0 > a ? ccui.ScrollView.SCROLLDIR_LEFT :
                        ccui.ScrollView.SCROLLDIR_RIGHT;
                    break;
                case ccui.ScrollView.DIR_BOTH:
                    b = cc.pSub(b, c);
                    a = cc.pLength(b);
                    b = cc.pNormalize(b);
                    break;
                default:
                    b = cc.p(0, 0)
            }
            a = Math.min(Math.abs(a) / this._slidTime, ccui.ScrollView.AUTO_SCROLL_MAX_SPEED);
            this._startAutoScrollChildrenWithOriginalSpeed(b, a, !0, -1E3);
            this._slidTime = 0
        }
    },
    _handlePressLogic: function(a) {
        this._startRecordSlidAction();
        this._bePressed = !0
    },
    _handleMoveLogic: function(a) {
        var b = this.convertToNodeSpace(a.getLocation());
        a = this.convertToNodeSpace(a.getPreviousLocation());
        b = cc.pSub(b, a);
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this._scrollChildren(0, b.y);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._scrollChildren(b.x, 0);
                break;
            case ccui.ScrollView.DIR_BOTH:
                this._scrollChildren(b.x, b.y)
        }
    },
    _handleReleaseLogic: function(a) {
        this._endRecordSlidAction();
        this._bePressed = !1
    },
    onTouchBegan: function(a, b) {
        var c = ccui.Layout.prototype.onTouchBegan.call(this, a, b);
        this._isInterceptTouch || this._hit && this._handlePressLogic(a);
        return c
    },
    onTouchMoved: function(a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this,
            a, b);
        this._isInterceptTouch || this._handleMoveLogic(a)
    },
    onTouchEnded: function(a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b);
        this._isInterceptTouch || this._handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    onTouchCancelled: function(a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b);
        this._isInterceptTouch || this.handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    update: function(a) {
        this._autoScroll && this._autoScrollChildren(a);
        this._bouncing && this._bounceChildren(a);
        this._recordSlidTime(a)
    },
    _recordSlidTime: function(a) {
        this._bePressed && (this._slidTime += a)
    },
    interceptTouchEvent: function(a, b, c) {
        if (this._touchEnabled) {
            var d = c.getLocation();
            switch (a) {
                case ccui.Widget.TOUCH_BEGAN:
                    this._isInterceptTouch = !0;
                    this._touchBeganPosition.x = d.x;
                    this._touchBeganPosition.y = d.y;
                    this._handlePressLogic(c);
                    break;
                case ccui.Widget.TOUCH_MOVED:
                    a = cc.pLength(cc.pSub(b.getTouchBeganPosition(), d));
                    this._touchMovePosition.x = d.x;
                    this._touchMovePosition.y = d.y;
                    a > this._childFocusCancelOffset && (b.setHighlighted(!1), this._handleMoveLogic(c));
                    break;
                case ccui.Widget.TOUCH_CANCELED:
                case ccui.Widget.TOUCH_ENDED:
                    this._touchEndPosition.x = d.x, this._touchEndPosition.y = d.y, this._handleReleaseLogic(c), b.isSwallowTouches() && (this._isInterceptTouch = !1)
            }
        } else ccui.Layout.prototype.interceptTouchEvent.call(this, a, b, c)
    },
    _scrollToTopEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_TOP) : this._scrollViewEventSelector(this,
            ccui.ScrollView.EVENT_SCROLL_TO_TOP));
        this._ccEventCallback && this._ccEventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_TOP)
    },
    _scrollToBottomEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM));
        this._ccEventCallback && this._ccEventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM)
    },
    _scrollToLeftEvent: function() {
        this._scrollViewEventSelector &&
            (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT));
        this._ccEventCallback && this._ccEventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_LEFT)
    },
    _scrollToRightEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT) :
            this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT));
        this._ccEventCallback && this._ccEventCallback(this, ccui.ScrollView.EVENT_SCROLL_TO_RIGHT)
    },
    _scrollingEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_SCROLLING) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_SCROLLING));
        this._ccEventCallback && this._ccEventCallback(this, ccui.ScrollView.EVENT_SCROLLING)
    },
    _bounceTopEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_TOP) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_TOP));
        this._ccEventCallback && this._ccEventCallback(this, ccui.ScrollView.EVENT_BOUNCE_TOP)
    },
    _bounceBottomEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener,
            this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM));
        this._ccEventCallback && this._ccEventCallback(this, ccui.ScrollView.EVENT_BOUNCE_BOTTOM)
    },
    _bounceLeftEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_LEFT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_LEFT));
        this._ccEventCallback && this._ccEventCallback(this,
            ccui.ScrollView.EVENT_BOUNCE_LEFT)
    },
    _bounceRightEvent: function() {
        this._scrollViewEventSelector && (this._scrollViewEventListener ? this._scrollViewEventSelector.call(this._scrollViewEventListener, this, ccui.ScrollView.EVENT_BOUNCE_RIGHT) : this._scrollViewEventSelector(this, ccui.ScrollView.EVENT_BOUNCE_RIGHT));
        this._ccEventCallback && this._ccEventCallback(this, ccui.ScrollView.EVENT_BOUNCE_RIGHT)
    },
    addEventListenerScrollView: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._scrollViewEventSelector =
            a;
        this._scrollViewEventListener = b
    },
    setDirection: function(a) {
        this.direction = a
    },
    getDirection: function() {
        return this.direction
    },
    setBounceEnabled: function(a) {
        this.bounceEnabled = a
    },
    isBounceEnabled: function() {
        return this.bounceEnabled
    },
    setInertiaScrollEnabled: function(a) {
        this.inertiaScrollEnabled = a
    },
    isInertiaScrollEnabled: function() {
        return this.inertiaScrollEnabled
    },
    getInnerContainer: function() {
        return this._innerContainer
    },
    setLayoutType: function(a) {
        this._innerContainer.setLayoutType(a)
    },
    getLayoutType: function() {
        return this._innerContainer.getLayoutType()
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._doLayoutDirty = !1)
    },
    getDescription: function() {
        return "ScrollView"
    },
    _createCloneInstance: function() {
        return new ccui.ScrollView
    },
    _copyClonedWidgetChildren: function(a) {
        ccui.Layout.prototype._copyClonedWidgetChildren.call(this, a)
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ScrollView && (ccui.Layout.prototype._copySpecialProperties.call(this, a), this.setInnerContainerSize(a.getInnerContainerSize()), this.setDirection(a.direction), this.setBounceEnabled(a.bounceEnabled),
            this.setInertiaScrollEnabled(a.inertiaScrollEnabled), this._scrollViewEventListener = a._scrollViewEventListener, this._scrollViewEventSelector = a._scrollViewEventSelector, this._ccEventCallback = a._ccEventCallback)
    },
    getNodeByTag: function(a) {
        return this._innerContainer.getNodeByTag(a)
    },
    getNodes: function() {
        return this._innerContainer.getNodes()
    },
    removeNode: function(a) {
        this._innerContainer.removeNode(a)
    },
    removeNodeByTag: function(a) {
        this._innerContainer.removeNodeByTag(a)
    },
    removeAllNodes: function() {
        this._innerContainer.removeAllNodes()
    },
    addNode: function(a, b, c) {
        this._innerContainer.addNode(a, b, c)
    }
});
_p = ccui.ScrollView.prototype;
cc.defineGetterSetter(_p, "innerWidth", _p._getInnerWidth, _p._setInnerWidth);
cc.defineGetterSetter(_p, "innerHeight", _p._getInnerHeight, _p._setInnerHeight);
_p = null;
ccui.ScrollView.create = function() {
    return new ccui.ScrollView
};
ccui.ScrollView.DIR_NONE = 0;
ccui.ScrollView.DIR_VERTICAL = 1;
ccui.ScrollView.DIR_HORIZONTAL = 2;
ccui.ScrollView.DIR_BOTH = 3;
ccui.ScrollView.EVENT_SCROLL_TO_TOP = 0;
ccui.ScrollView.EVENT_SCROLL_TO_BOTTOM = 1;
ccui.ScrollView.EVENT_SCROLL_TO_LEFT = 2;
ccui.ScrollView.EVENT_SCROLL_TO_RIGHT = 3;
ccui.ScrollView.EVENT_SCROLLING = 4;
ccui.ScrollView.EVENT_BOUNCE_TOP = 5;
ccui.ScrollView.EVENT_BOUNCE_BOTTOM = 6;
ccui.ScrollView.EVENT_BOUNCE_LEFT = 7;
ccui.ScrollView.EVENT_BOUNCE_RIGHT = 8;
ccui.ScrollView.AUTO_SCROLL_MAX_SPEED = 1E3;
ccui.ScrollView.SCROLLDIR_UP = cc.p(0, 1);
ccui.ScrollView.SCROLLDIR_DOWN = cc.p(0, -1);
ccui.ScrollView.SCROLLDIR_LEFT = cc.p(-1, 0);
ccui.ScrollView.SCROLLDIR_RIGHT = cc.p(1, 0);
ccui.ListView = ccui.ScrollView.extend({
    _model: null,
    _items: null,
    _gravity: null,
    _itemsMargin: 0,
    _curSelectedIndex: 0,
    _refreshViewDirty: !0,
    _listViewEventListener: null,
    _listViewEventSelector: null,
    ctor: function() {
        ccui.ScrollView.prototype.ctor.call(this);
        this._items = [];
        this._gravity = ccui.ListView.GRAVITY_CENTER_VERTICAL;
        this.setTouchEnabled(!0);
        this.init()
    },
    init: function() {
        return ccui.ScrollView.prototype.init.call(this) ? (this.setLayoutType(ccui.Layout.LINEAR_VERTICAL), !0) : !1
    },
    setItemModel: function(a) {
        a ? this._model =
            a : cc.log("Can't set a null to item model!")
    },
    _updateInnerContainerSize: function() {
        var a = this._items,
            b, c;
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                b = a.length;
                var d = (b - 1) * this._itemsMargin;
                for (c = 0; c < b; c++) d += a[c].getContentSize().height;
                this.setInnerContainerSize(cc.size(this._contentSize.width, d));
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                b = a.length;
                d = (b - 1) * this._itemsMargin;
                for (c = 0; c < b; c++) d += a[c].getContentSize().width;
                this.setInnerContainerSize(cc.size(d, this._contentSize.height))
        }
    },
    _remedyLayoutParameter: function(a) {
        cc.assert(null != a, "ListView Item can't be nil!");
        var b = a.getLayoutParameter(),
            c = !0;
        b || (b = new ccui.LinearLayoutParameter, c = !1);
        var d = this.getIndex(a);
        switch (this.direction) {
            case ccui.ScrollView.DIR_VERTICAL:
                this._remedyVerticalLayoutParameter(b, d);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this._remedyHorizontalLayoutParameter(b, d)
        }
        c || a.setLayoutParameter(b)
    },
    _remedyVerticalLayoutParameter: function(a, b) {
        cc.assert(null != a, "Layout parameter can't be nil!");
        switch (this._gravity) {
            case ccui.ListView.GRAVITY_LEFT:
                a.setGravity(ccui.LinearLayoutParameter.LEFT);
                break;
            case ccui.ListView.GRAVITY_RIGHT:
                a.setGravity(ccui.LinearLayoutParameter.RIGHT);
                break;
            case ccui.ListView.GRAVITY_CENTER_HORIZONTAL:
                a.setGravity(ccui.LinearLayoutParameter.CENTER_HORIZONTAL)
        }
        0 === b ? a.setMargin(ccui.MarginZero()) : a.setMargin(new ccui.Margin(0, this._itemsMargin, 0, 0))
    },
    _remedyHorizontalLayoutParameter: function(a, b) {
        cc.assert(null != a, "Layout parameter can't be nil!");
        switch (this._gravity) {
            case ccui.ListView.GRAVITY_TOP:
                a.setGravity(ccui.LinearLayoutParameter.TOP);
                break;
            case ccui.ListView.GRAVITY_BOTTOM:
                a.setGravity(ccui.LinearLayoutParameter.BOTTOM);
                break;
            case ccui.ListView.GRAVITY_CENTER_VERTICAL:
                a.setGravity(ccui.LinearLayoutParameter.CENTER_VERTICAL)
        }
        0 === b ? a.setMargin(ccui.MarginZero()) : a.setMargin(new ccui.Margin(this._itemsMargin, 0, 0, 0))
    },
    pushBackDefaultItem: function() {
        if (null != this._model) {
            var a = this._model.clone();
            this._remedyLayoutParameter(a);
            this.addChild(a);
            this._refreshViewDirty = !0
        }
    },
    insertDefaultItem: function(a) {
        if (null != this._model) {
            var b = this._model.clone();
            this._items.splice(a, 0, b);
            ccui.ScrollView.prototype.addChild.call(this,
                b);
            this._remedyLayoutParameter(b);
            this._refreshViewDirty = !0
        }
    },
    pushBackCustomItem: function(a) {
        this._remedyLayoutParameter(a);
        this.addChild(a);
        this._refreshViewDirty = !0
    },
    addChild: function(a, b, c) {
        a && (b = b || a.getLocalZOrder(), c = c || a.getName(), ccui.ScrollView.prototype.addChild.call(this, a, b, c), a instanceof ccui.Widget && this._items.push(a))
    },
    removeChild: function(a, b) {
        if (a) {
            var c = this._items.indexOf(a); - 1 < c && this._items.splice(c, 1);
            ccui.ScrollView.prototype.removeChild.call(this, a, b)
        }
    },
    removeAllChildren: function() {
        this.removeAllChildrenWithCleanup(!0)
    },
    removeAllChildrenWithCleanup: function(a) {
        ccui.ScrollView.prototype.removeAllChildrenWithCleanup.call(this, a);
        this._items = []
    },
    insertCustomItem: function(a, b) {
        this._items.splice(b, 0, a);
        ccui.ScrollView.prototype.addChild.call(this, a);
        this._remedyLayoutParameter(a);
        this._refreshViewDirty = !0
    },
    removeItem: function(a) {
        a = this.getItem(a);
        null != a && (this.removeChild(a, !0), this._refreshViewDirty = !0)
    },
    removeLastItem: function() {
        this.removeItem(this._items.length - 1)
    },
    removeAllItems: function() {
        this.removeAllChildren()
    },
    getItem: function(a) {
        return 0 > a || a >= this._items.length ? null : this._items[a]
    },
    getItems: function() {
        return this._items
    },
    getIndex: function(a) {
        return null == a ? -1 : this._items.indexOf(a)
    },
    setGravity: function(a) {
        this._gravity !== a && (this._gravity = a, this._refreshViewDirty = !0)
    },
    setItemsMargin: function(a) {
        this._itemsMargin !== a && (this._itemsMargin = a, this._refreshViewDirty = !0)
    },
    getItemsMargin: function() {
        return this._itemsMargin
    },
    setDirection: function(a) {
        switch (a) {
            case ccui.ScrollView.DIR_VERTICAL:
                this.setLayoutType(ccui.Layout.LINEAR_VERTICAL);
                break;
            case ccui.ScrollView.DIR_HORIZONTAL:
                this.setLayoutType(ccui.Layout.LINEAR_HORIZONTAL);
                break;
            case ccui.ScrollView.DIR_BOTH:
                return;
            default:
                return
        }
        ccui.ScrollView.prototype.setDirection.call(this, a)
    },
    requestRefreshView: function() {
        this._refreshViewDirty = !0
    },
    refreshView: function() {
        for (var a = this._items, b = 0; b < a.length; b++) {
            var c = a[b];
            c.setLocalZOrder(b);
            this._remedyLayoutParameter(c)
        }
        this._updateInnerContainerSize()
    },
    doLayout: function() {
        this._doLayout()
    },
    _doLayout: function() {
        ccui.Layout.prototype._doLayout.call(this);
        this._refreshViewDirty && (this.refreshView(), this._refreshViewDirty = !1)
    },
    addEventListenerListView: function(a, b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._listViewEventListener = b;
        this._listViewEventSelector = a
    },
    _selectedItemEvent: function(a) {
        a = a === ccui.Widget.TOUCH_BEGAN ? ccui.ListView.ON_SELECTED_ITEM_START : ccui.ListView.ON_SELECTED_ITEM_END;
        this._listViewEventSelector && (this._listViewEventListener ? this._listViewEventSelector.call(this._listViewEventListener, this, a) : this._listViewEventSelector(this,
            a));
        this._ccEventCallback && this._ccEventCallback(this, a)
    },
    interceptTouchEvent: function(a, b, c) {
        ccui.ScrollView.prototype.interceptTouchEvent.call(this, a, b, c);
        if (this._touchEnabled && a !== ccui.Widget.TOUCH_MOVED) {
            for (c = b; c;) {
                if (c && c.getParent() === this._innerContainer) {
                    this._curSelectedIndex = this.getIndex(c);
                    break
                }
                c = c.getParent()
            }
            b.isHighlighted() && this._selectedItemEvent(a)
        }
    },
    getCurSelectedIndex: function() {
        return this._curSelectedIndex
    },
    _onSizeChanged: function() {
        ccui.ScrollView.prototype._onSizeChanged.call(this);
        this._refreshViewDirty = !0
    },
    getDescription: function() {
        return "ListView"
    },
    _createCloneInstance: function() {
        return new ccui.ListView
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getItems();
        for (var b = 0; b < a.length; b++) this.pushBackCustomItem(a[b].clone())
    },
    _copySpecialProperties: function(a) {
        a instanceof ccui.ListView && (ccui.ScrollView.prototype._copySpecialProperties.call(this, a), this.setItemModel(a._model), this.setItemsMargin(a._itemsMargin), this.setGravity(a._gravity), this._listViewEventListener = a._listViewEventListener,
            this._listViewEventSelector = a._listViewEventSelector)
    },
    forceDoLayout: function() {
        this._refreshViewDirty && (this.refreshView(), this._refreshViewDirty = !1);
        this._innerContainer.forceDoLayout()
    }
});
ccui.ListView.create = function() {
    return new ccui.ListView
};
ccui.ListView.EVENT_SELECTED_ITEM = 0;
ccui.ListView.ON_SELECTED_ITEM_START = 0;
ccui.ListView.ON_SELECTED_ITEM_END = 1;
ccui.ListView.GRAVITY_LEFT = 0;
ccui.ListView.GRAVITY_RIGHT = 1;
ccui.ListView.GRAVITY_CENTER_HORIZONTAL = 2;
ccui.ListView.GRAVITY_TOP = 3;
ccui.ListView.GRAVITY_BOTTOM = 4;
ccui.ListView.GRAVITY_CENTER_VERTICAL = 5;
ccui.PageView = ccui.Layout.extend({
    _curPageIdx: 0,
    _pages: null,
    _touchMoveDirection: null,
    _touchStartLocation: 0,
    _touchMoveStartLocation: 0,
    _movePagePoint: null,
    _leftBoundaryChild: null,
    _rightBoundaryChild: null,
    _leftBoundary: 0,
    _rightBoundary: 0,
    _isAutoScrolling: !1,
    _autoScrollDistance: 0,
    _autoScrollSpeed: 0,
    _autoScrollDirection: 0,
    _childFocusCancelOffset: 0,
    _pageViewEventListener: null,
    _pageViewEventSelector: null,
    _className: "PageView",
    _customScrollThreshold: 0,
    _usingCustomScrollThreshold: !1,
    ctor: function() {
        ccui.Layout.prototype.ctor.call(this);
        this._pages = [];
        this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT;
        this._rightBoundaryChild = this._leftBoundaryChild = this._movePagePoint = null;
        this._childFocusCancelOffset = 5;
        this._pageViewEventSelector = this._pageViewEventListener = null;
        this.setTouchEnabled(!0)
    },
    init: function() {
        return ccui.Layout.prototype.init.call(this) ? (this.setClippingEnabled(!0), !0) : !1
    },
    onEnter: function() {
        ccui.Layout.prototype.onEnter.call(this);
        this.scheduleUpdate(!0)
    },
    addWidgetToPage: function(a, b, c) {
        if (a && !(0 > b)) {
            var d = this._getPageCount();
            0 > b || b >= d ? c && (b > d && cc.log("pageIdx is %d, it will be added as page id [%d]", b, d), b = this._createPage(), b.addChild(a), this.addPage(b)) : (b = this._pages[b]) && b.addChild(a)
        }
    },
    _createPage: function() {
        var a = new ccui.Layout;
        a.setContentSize(this.getContentSize());
        return a
    },
    addPage: function(a) {
        a && -1 === this._pages.indexOf(a) && (this.addChild(a), this._pages.push(a), this._doLayoutDirty = !0)
    },
    insertPage: function(a, b) {
        if (!(0 > b) && a && -1 === this._pages.indexOf(a)) {
            var c = this._getPageCount();
            b >= c ? this.addPage(a) : (this._pages[b] =
                a, this.addChild(a));
            this._doLayoutDirty = !0
        }
    },
    removePage: function(a) {
        a && (this.removeChild(a), a = this._pages.indexOf(a), -1 < a && this._pages.splice(a, 1), this._doLayoutDirty = !0)
    },
    removePageAtIndex: function(a) {
        0 > a || a >= this._pages.length || (a = this._pages[a]) && this.removePage(a)
    },
    removeAllPages: function() {
        for (var a = this._pages, b = 0, c = a.length; b < c; b++) this.removeChild(a[b]);
        this._pages.length = 0
    },
    _updateBoundaryPages: function() {
        var a = this._pages;
        0 >= a.length ? this._rightBoundaryChild = this._leftBoundaryChild = null :
            (this._leftBoundaryChild = a[0], this._rightBoundaryChild = a[a.length - 1])
    },
    _getPageCount: function() {
        return this._pages.length
    },
    _getPositionXByIndex: function(a) {
        return this.getContentSize().width * (a - this._curPageIdx)
    },
    _onSizeChanged: function() {
        ccui.Layout.prototype._onSizeChanged.call(this);
        this._rightBoundary = this.getContentSize().width;
        this._doLayoutDirty = !0
    },
    _updateAllPagesSize: function() {
        for (var a = this.getContentSize(), b = this._pages, c = 0, d = b.length; c < d; c++) b[c].setContentSize(a)
    },
    _updateAllPagesPosition: function() {
        var a =
            this._getPageCount();
        if (0 >= a) this._curPageIdx = 0;
        else {
            this._curPageIdx >= a && (this._curPageIdx = a - 1);
            for (var b = this.getContentSize().width, c = this._pages, d = 0; d < a; d++) c[d].setPosition(cc.p((d - this._curPageIdx) * b, 0))
        }
    },
    scrollToPage: function(a) {
        0 > a || a >= this._pages.length || (this._curPageIdx = a, this._autoScrollDistance = -this._pages[a].getPosition().x, this._autoScrollSpeed = Math.abs(this._autoScrollDistance) / 0.2, this._autoScrollDirection = 0 < this._autoScrollDistance ? ccui.PageView.DIRECTION_RIGHT : ccui.PageView.DIRECTION_LEFT,
            this._isAutoScrolling = !0)
    },
    update: function(a) {
        this._isAutoScrolling && this._autoScroll(a)
    },
    setLayoutType: function(a) {},
    getLayoutType: function() {
        return ccui.Layout.ABSOLUTE
    },
    _autoScroll: function(a) {
        switch (this._autoScrollDirection) {
            case ccui.PageView.DIRECTION_LEFT:
                a *= this._autoScrollSpeed;
                0 <= this._autoScrollDistance + a ? (a = -this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance += a;
                this._scrollPages(-a);
                this._isAutoScrolling || this._pageTurningEvent();
                break;
            case ccui.PageView.DIRECTION_RIGHT:
                a *= this._autoScrollSpeed, 0 >= this._autoScrollDistance - a ? (a = this._autoScrollDistance, this._autoScrollDistance = 0, this._isAutoScrolling = !1) : this._autoScrollDistance -= a, this._scrollPages(a), this._isAutoScrolling || this._pageTurningEvent()
        }
    },
    onTouchMoved: function(a, b) {
        ccui.Layout.prototype.onTouchMoved.call(this, a, b);
        this._isInterceptTouch || this._handleMoveLogic(a)
    },
    onTouchEnded: function(a, b) {
        ccui.Layout.prototype.onTouchEnded.call(this, a, b);
        this._isInterceptTouch || this._handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    onTouchCancelled: function(a, b) {
        ccui.Layout.prototype.onTouchCancelled.call(this, a, b);
        this._isInterceptTouch || this._handleReleaseLogic(a);
        this._isInterceptTouch = !1
    },
    _doLayout: function() {
        this._doLayoutDirty && (this._updateAllPagesPosition(), this._updateAllPagesSize(), this._updateBoundaryPages(), this._doLayoutDirty = !1)
    },
    _movePages: function(a) {
        for (var b = this._pages, c = b.length, d = 0; d < c; d++) {
            var e = b[d];
            e.setPositionX(e.getPositionX() + a)
        }
    },
    _scrollPages: function(a) {
        if (0 >= this._pages.length ||
            !this._leftBoundaryChild || !this._rightBoundaryChild) return !1;
        var b = a;
        switch (this._touchMoveDirection) {
            case ccui.PageView.TOUCH_DIR_LEFT:
                var c = this._rightBoundaryChild.getRightBoundary();
                if (c + a <= this._rightBoundary) return b = this._rightBoundary - c, this._movePages(b), !1;
                break;
            case ccui.PageView.TOUCH_DIR_RIGHT:
                if (c = this._leftBoundaryChild.getLeftBoundary(), c + a >= this._leftBoundary) return b = this._leftBoundary - c, this._movePages(b), !1
        }
        this._movePages(b);
        return !0
    },
    _handleMoveLogic: function(a) {
        a = a.getLocation().x -
            a.getPreviousLocation().x;
        0 > a ? this._touchMoveDirection = ccui.PageView.TOUCH_DIR_LEFT : 0 < a && (this._touchMoveDirection = ccui.PageView.TOUCH_DIR_RIGHT);
        this._scrollPages(a)
    },
    setCustomScrollThreshold: function(a) {
        cc.assert(0 < a, "Invalid threshold!");
        this._customScrollThreshold = a;
        this.setUsingCustomScrollThreshold(!0)
    },
    getCustomScrollThreshold: function() {
        return this._customScrollThreshold
    },
    setUsingCustomScrollThreshold: function(a) {
        this._usingCustomScrollThreshold = a
    },
    isUsingCustomScrollThreshold: function() {
        return this._usingCustomScrollThreshold
    },
    _handleReleaseLogic: function(a) {
        if (!(0 >= this._pages.length) && (a = this._pages[this._curPageIdx])) {
            var b = a.getPosition();
            a = this._pages.length;
            var b = b.x,
                c = this.getSize().width;
            this._usingCustomScrollThreshold || (this._customScrollThreshold = c / 2);
            c = this._customScrollThreshold;
            b <= -c ? this._curPageIdx >= a - 1 ? this._scrollPages(-b) : this.scrollToPage(this._curPageIdx + 1) : b >= c ? 0 >= this._curPageIdx ? this._scrollPages(-b) : this.scrollToPage(this._curPageIdx - 1) : this.scrollToPage(this._curPageIdx)
        }
    },
    interceptTouchEvent: function(a,
        b, c) {
        if (this._touchEnabled) {
            var d = c.getLocation();
            switch (a) {
                case ccui.Widget.TOUCH_BEGAN:
                    this._touchBeganPosition.x = d.x;
                    this._touchBeganPosition.y = d.y;
                    this._isInterceptTouch = !0;
                    break;
                case ccui.Widget.TOUCH_MOVED:
                    this._touchMovePosition.x = d.x;
                    this._touchMovePosition.y = d.y;
                    a = 0;
                    a = Math.abs(b.getTouchBeganPosition().x - d.x);
                    a > this._childFocusCancelOffset && (b.setHighlighted(!1), this._handleMoveLogic(c));
                    break;
                case ccui.Widget.TOUCH_ENDED:
                case ccui.Widget.TOUCH_CANCELED:
                    this._touchEndPosition.x = d.x, this._touchEndPosition.y =
                        d.y, this._handleReleaseLogic(c), b.isSwallowTouches() && (this._isInterceptTouch = !1)
            }
        } else ccui.Layout.prototype.interceptTouchEvent.call(this, a, b, c)
    },
    _pageTurningEvent: function() {
        this._pageViewEventSelector && (this._pageViewEventListener ? this._pageViewEventSelector.call(this._pageViewEventListener, this, ccui.PageView.EVENT_TURNING) : this._pageViewEventSelector(this, ccui.PageView.EVENT_TURNING));
        this._ccEventCallback && this._ccEventCallback(this, ccui.PageView.EVENT_TURNING)
    },
    addEventListenerPageView: function(a,
        b) {
        this.addEventListener(a, b)
    },
    addEventListener: function(a, b) {
        this._pageViewEventSelector = a;
        this._pageViewEventListener = b
    },
    getCurPageIndex: function() {
        return this._curPageIdx
    },
    getPages: function() {
        return this._pages
    },
    getPage: function(a) {
        return 0 > a || a >= this._pages.length ? null : this._pages[a]
    },
    getDescription: function() {
        return "PageView"
    },
    _createCloneInstance: function() {
        return new ccui.PageView
    },
    _copyClonedWidgetChildren: function(a) {
        a = a.getPages();
        for (var b = 0; b < a.length; b++) this.addPage(a[b].clone())
    },
    _copySpecialProperties: function(a) {
        ccui.Layout.prototype._copySpecialProperties.call(this,
            a);
        this._ccEventCallback = a._ccEventCallback;
        this._pageViewEventListener = a._pageViewEventListener;
        this._pageViewEventSelector = a._pageViewEventSelector;
        this._usingCustomScrollThreshold = a._usingCustomScrollThreshold;
        this._customScrollThreshold = a._customScrollThreshold
    }
});
ccui.PageView.create = function() {
    return new ccui.PageView
};
ccui.PageView.EVENT_TURNING = 0;
ccui.PageView.TOUCH_DIR_LEFT = 0;
ccui.PageView.TOUCH_DIR_RIGHT = 1;
ccui.PageView.DIRECTION_LEFT = 0;
ccui.PageView.DIRECTION_RIGHT = 1;
(function() {
    if (ccui.ProtectedNode.CanvasRenderCmd) {
        ccui.ScrollView.CanvasRenderCmd = function(a) {
            ccui.Layout.CanvasRenderCmd.call(this, a);
            this._needDraw = !0;
            this._dirty = !1
        };
        var a = ccui.ScrollView.CanvasRenderCmd.prototype = Object.create(ccui.Layout.CanvasRenderCmd.prototype);
        a.constructor = ccui.ScrollView.CanvasRenderCmd;
        a.visit = function(a) {
            var c = this._node;
            c._visible && (c = c.__instanceId, cc.renderer.pushRenderCommand(this), cc.renderer._turnToCacheMode(c), ccui.Layout.CanvasRenderCmd.prototype.visit.call(this,
                a), this._dirtyFlag = 0, cc.renderer._turnToNormalMode())
        };
        a.rendering = function(a) {
            var c = cc.renderer._cacheToCanvasCmds[this._node.__instanceId],
                d, e = cc.view.getScaleX(),
                f = cc.view.getScaleY(),
                g = a || cc._renderContext;
            g.computeRealOffsetY();
            a = 0;
            for (d = c.length; a < d; a++) {
                var h = c[a]._node;
                h instanceof ccui.ScrollView || h && h._parent && !1 === h._parent._inViewRect || c[a].rendering(g, e, f)
            }
        }
    }
})();
(function() {
    if (ccui.ProtectedNode.WebGLRenderCmd) {
        ccui.ScrollView.WebGLRenderCmd = function(a) {
            ccui.Layout.WebGLRenderCmd.call(this, a);
            this._needDraw = !0;
            this._dirty = !1
        };
        var a = ccui.ScrollView.WebGLRenderCmd.prototype = Object.create(ccui.Layout.WebGLRenderCmd.prototype);
        a.constructor = ccui.ScrollView.WebGLRenderCmd;
        a.visit = function(a) {
            var c = this._node;
            if (c._visible) {
                var d = this._node.__instanceId;
                cc.renderer.pushRenderCommand(this);
                cc.renderer._turnToCacheMode(d);
                ccui.Layout.WebGLRenderCmd.prototype.visit.call(this,
                    a);
                c.updateChildren();
                this._dirtyFlag = 0;
                cc.renderer._turnToNormalMode()
            }
        };
        a.rendering = function(a) {
            var c = cc.renderer._cacheToBufferCmds[this._node.__instanceId],
                d, e = a || cc._renderContext;
            a = 0;
            for (d = c.length; a < d; a++) {
                var f = c[a]._node;
                f instanceof ccui.ScrollView || f && f._parent && !1 === f._parent._inViewRect || c[a].rendering(e)
            }
        }
    }
})();
cc.Component = cc.Class.extend({
    _owner: null,
    _name: "",
    _enabled: !0,
    ctor: function() {
        this._owner = null;
        this._name = "";
        this._enabled = !0
    },
    init: function() {
        return !0
    },
    onEnter: function() {},
    onExit: function() {},
    update: function(a) {},
    serialize: function(a) {},
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    },
    getName: function() {
        return this._name
    },
    setName: function(a) {
        this._name = a
    },
    setOwner: function(a) {
        this._owner = a
    },
    getOwner: function() {
        return this._owner
    }
});
cc.Component.create = function() {
    return new cc.Component
};
cc.ComponentContainer = cc.Class.extend({
    _components: null,
    _owner: null,
    ctor: function(a) {
        this._components = null;
        this._owner = a
    },
    getComponent: function(a) {
        if (!a) throw Error("cc.ComponentContainer.getComponent(): name should be non-null");
        a = a.trim();
        this._components || (this._components = {});
        return this._components[a]
    },
    add: function(a) {
        if (!a) throw Error("cc.ComponentContainer.add(): component should be non-null");
        if (a.getOwner()) return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
        null == this._components && (this._components = {}, this._owner.scheduleUpdate());
        if (this._components[a.getName()]) return cc.log("cc.ComponentContainer.add(): Component already added. It can't be added again"), !1;
        a.setOwner(this._owner);
        this._components[a.getName()] = a;
        a.onEnter();
        return !0
    },
    remove: function(a) {
        if (!a) throw Error("cc.ComponentContainer.remove(): name should be non-null");
        if (!this._components) return !1;
        if (a instanceof cc.Component) return this._removeByComponent(a);
        a = a.trim();
        return this._removeByComponent(this._components[a])
    },
    _removeByComponent: function(a) {
        if (!a) return !1;
        a.onExit();
        a.setOwner(null);
        delete this._components[a.getName()];
        return !0
    },
    removeAll: function() {
        if (this._components) {
            var a = this._components,
                b;
            for (b in a) {
                var c = a[b];
                c.onExit();
                c.setOwner(null);
                delete a[b]
            }
            this._owner.unscheduleUpdate();
            this._components = null
        }
    },
    _alloc: function() {
        this._components = {}
    },
    visit: function(a) {
        if (this._components) {
            var b = this._components,
                c;
            for (c in b) b[c].update(a)
        }
    },
    isEmpty: function() {
        return this._components ? 0 === this._components.length :
            !0
    }
});
ccui.LayoutComponent_ReferencePoint = {
    BOTTOM_LEFT: 0,
    TOP_LEFT: 1,
    BOTTOM_RIGHT: 2,
    TOP_RIGHT: 3
};
ccui.LayoutComponent_PositionType = {
    Position: 0,
    RelativePosition: 1,
    PreRelativePosition: 2,
    PreRelativePositionEnable: 3
};
ccui.LayoutComponent_SizeType = {
    Size: 0,
    PreSize: 1,
    PreSizeEnable: 2
};
ccui.LayoutComponent = cc.Component.extend({
    _horizontalEdge: 0,
    _verticalEdge: 0,
    _leftMargin: 0,
    _rightMargin: 0,
    _bottomMargin: 0,
    _topMargin: 0,
    _usingPositionPercentX: !1,
    _positionPercentX: 0,
    _usingPositionPercentY: !1,
    _positionPercentY: 0,
    _usingStretchWidth: !1,
    _usingStretchHeight: !1,
    _percentWidth: 0,
    _usingPercentWidth: !1,
    _percentHeight: 0,
    _usingPercentHeight: !1,
    _actived: !0,
    _isPercentOnly: !1,
    ctor: function() {
        this._name = ccui.LayoutComponent.NAME
    },
    init: function() {
        return cc.Component.prototype.init.call(this) ? !0 : !1
    },
    getPercentContentSize: function() {
        return cc.p(this._percentWidth, this._percentHeight)
    },
    setPercentContentSize: function(a) {
        this.setPercentWidth(a.x);
        this.setPercentHeight(a.y)
    },
    setUsingPercentContentSize: function(a) {
        this._usingPercentWidth = this._usingPercentHeight = a
    },
    SetActiveEnable: function(a) {
        this._actived = a
    },
    getUsingPercentContentSize: function() {
        return this._usingPercentWidth && this._usingPercentHeight
    },
    getAnchorPosition: function() {
        return this._owner.getAnchorPoint()
    },
    setAnchorPosition: function(a,
        b) {
        var c = this._owner.getBoundingBox();
        this._owner.setAnchorPoint(a, b);
        var d = this._owner.getBoundingBox(),
            e = c.x - d.x,
            c = c.y - d.y,
            d = this._owner.getPosition();
        d.x += e;
        d.y += c;
        this.setPosition(d)
    },
    getPosition: function() {
        return this._owner.getPosition()
    },
    setPosition: function(a, b) {
        var c = this._getOwnerParent(),
            d;
        null != c ? (void 0 === b ? (d = a.x, b = a.y) : d = a, c = c.getContentSize(), 0 !== c.width ? this._positionPercentX = d / c.width : (this._positionPercentX = 0, this._usingPositionPercentX && (d = 0)), 0 !== c.height ? this._positionPercentY =
            b / c.height : (this._positionPercentY = 0, this._usingPositionPercentY && (b = 0)), this._owner.setPosition(d, b), this._refreshHorizontalMargin(), this._refreshVerticalMargin()) : this._owner.setPosition(a, b)
    },
    isPositionPercentXEnabled: function() {
        return this._usingPositionPercentX
    },
    setPositionPercentXEnabled: function(a) {
        if (this._usingPositionPercentX = a) this._horizontalEdge = ccui.LayoutComponent.horizontalEdge.NONE
    },
    getPositionPercentX: function() {
        return this._positionPercentX
    },
    setPositionPercentX: function(a) {
        this._positionPercentX =
            a;
        a = this._getOwnerParent();
        null !== a && (this._owner.setPositionX(a.width * this._positionPercentX), this._refreshHorizontalMargin())
    },
    isPositionPercentYEnabled: function() {
        return this._usingPositionPercentY
    },
    setPositionPercentYEnabled: function(a) {
        if (this._usingPositionPercentY = a) this._verticalEdge = ccui.LayoutComponent.verticalEdge.NONE
    },
    getPositionPercentY: function() {
        return this._positionPercentY
    },
    setPositionPercentY: function(a) {
        this._positionPercentY = a;
        a = this._getOwnerParent();
        null !== a && (this._owner.setPositionY(a.height *
            this._positionPercentY), this._refreshVerticalMargin())
    },
    getHorizontalEdge: function() {
        return this._horizontalEdge
    },
    setHorizontalEdge: function(a) {
        this._horizontalEdge = a;
        this._horizontalEdge !== ccui.LayoutComponent.horizontalEdge.NONE && (this._usingPositionPercentX = !1);
        var b = this._getOwnerParent();
        null !== b && (a = this._owner.getPosition(), b = b.getContentSize(), 0 !== b.width ? this._positionPercentX = a.x / b.width : (this._positionPercentX = 0, a.x = 0, this._usingPositionPercentX && this._owner.setPosition(a)), this._refreshHorizontalMargin())
    },
    getVerticalEdge: function() {
        return this._verticalEdge
    },
    setVerticalEdge: function(a) {
        this._verticalEdge = a;
        this._verticalEdge !== ccui.LayoutComponent.verticalEdge.NONE && (this._usingPositionPercentY = !1);
        var b = this._getOwnerParent();
        null !== b && (a = this._owner.getPosition(), b = b.getContentSize(), 0 !== b.height ? this._positionPercentY = a.y / b.height : (this._positionPercentY = 0, a.y = 0, this._usingPositionPercentY && this._owner.setPosition(a)), this._refreshVerticalMargin())
    },
    getLeftMargin: function() {
        return this._leftMargin
    },
    setLeftMargin: function(a) {
        this._leftMargin = a
    },
    getRightMargin: function() {
        return this._rightMargin
    },
    setRightMargin: function(a) {
        this._rightMargin = a
    },
    getTopMargin: function() {
        return this._topMargin
    },
    setTopMargin: function(a) {
        this._topMargin = a
    },
    getBottomMargin: function() {
        return this._bottomMargin
    },
    setBottomMargin: function(a) {
        this._bottomMargin = a
    },
    getSize: function() {
        return this.getOwner().getContentSize()
    },
    setSize: function(a) {
        var b = this._getOwnerParent();
        null !== b ? (b = b.getContentSize(), 0 !== b.width ? this._percentWidth =
            a.width / b.width : (this._percentWidth = 0, this._usingPercentWidth && (a.width = 0)), 0 !== b.height ? this._percentHeight = a.height / b.height : (this._percentHeight = 0, this._usingPercentHeight && (a.height = 0)), this._owner.setContentSize(a), this._refreshHorizontalMargin(), this._refreshVerticalMargin()) : this._owner.setContentSize(a)
    },
    isPercentWidthEnabled: function() {
        return this._usingPercentWidth
    },
    setPercentWidthEnabled: function(a) {
        if (this._usingPercentWidth = a) this._usingStretchWidth = !1
    },
    getSizeWidth: function() {
        return this._owner.width
    },
    setSizeWidth: function(a) {
        var b = this._owner.getContentSize();
        b.width = a;
        a = this._getOwnerParent();
        null !== a ? (a = a.getContentSize(), 0 !== a.width ? this._percentWidth = b.width / a.width : (this._percentWidth = 0, this._usingPercentWidth && (b.width = 0)), this._owner.setContentSize(b), this._refreshHorizontalMargin()) : this._owner.setContentSize(b)
    },
    getPercentWidth: function() {
        return this._percentWidth
    },
    setPercentWidth: function(a) {
        this._percentWidth = a;
        a = this._getOwnerParent();
        if (null !== a) {
            var b = this._owner.getContentSize();
            b.width = a.width * this._percentWidth;
            this._owner.setContentSize(b);
            this._refreshHorizontalMargin()
        }
    },
    isPercentHeightEnabled: function() {
        return this._usingPercentHeight
    },
    setPercentHeightEnabled: function(a) {
        if (this._usingPercentHeight = a) this._usingStretchHeight = !1
    },
    getSizeHeight: function() {
        return this._owner.height
    },
    setSizeHeight: function(a) {
        var b = this._owner.getContentSize();
        b.height = a;
        a = this._getOwnerParent();
        null !== a ? (a = a.getContentSize(), 0 !== a.height ? this._percentHeight = b.height / a.height : (this._percentHeight =
            0, this._usingPercentHeight && (b.height = 0)), this._owner.setContentSize(b), this._refreshVerticalMargin()) : this._owner.setContentSize(b)
    },
    getPercentHeight: function() {
        return this._percentHeight
    },
    setPercentHeight: function(a) {
        this._percentHeight = a;
        a = this._getOwnerParent();
        if (null !== a) {
            var b = this._owner.getContentSize();
            b.height = a.height * this._percentHeight;
            this._owner.setContentSize(b);
            this._refreshVerticalMargin()
        }
    },
    isStretchWidthEnabled: function() {
        return this._usingStretchWidth
    },
    setStretchWidthEnabled: function(a) {
        if (this._usingStretchWidth =
            a) this._usingPercentWidth = !1
    },
    isStretchHeightEnabled: function() {
        return this._usingStretchHeight
    },
    setStretchHeightEnabled: function(a) {
        if (this._usingStretchHeight = a) this._usingPercentHeight = !1
    },
    setPercentOnlyEnabled: function(a) {
        this._isPercentOnly = a
    },
    setActiveEnabled: function(a) {
        this._actived = a
    },
    refreshLayout: function() {
        if (this._actived) {
            var a = this._getOwnerParent();
            if (null !== a) {
                var a = a.getContentSize(),
                    b = this._owner,
                    c = b.getAnchorPoint(),
                    d = b.getContentSize(),
                    e = b.getPosition();
                switch (this._horizontalEdge) {
                    case ccui.LayoutComponent.horizontalEdge.NONE:
                        this._usingStretchWidth &&
                            !this._isPercentOnly ? (d.width = a.width * this._percentWidth, e.x = this._leftMargin + c.x * d.width) : (this._usingPositionPercentX && (e.x = a.width * this._positionPercentX), this._usingPercentWidth && (d.width = a.width * this._percentWidth));
                        break;
                    case ccui.LayoutComponent.horizontalEdge.LEFT:
                        if (this._isPercentOnly) break;
                        if (this._usingPercentWidth || this._usingStretchWidth) d.width = a.width * this._percentWidth;
                        e.x = this._leftMargin + c.x * d.width;
                        break;
                    case ccui.LayoutComponent.horizontalEdge.RIGHT:
                        if (this._isPercentOnly) break;
                        if (this._usingPercentWidth || this._usingStretchWidth) d.width = a.width * this._percentWidth;
                        e.x = a.width - (this._rightMargin + (1 - c.x) * d.width);
                        break;
                    case ccui.LayoutComponent.horizontalEdge.CENTER:
                        if (this._isPercentOnly) break;
                        this._usingStretchWidth ? (d.width = a.width - this._leftMargin - this._rightMargin, 0 > d.width && (d.width = 0), e.x = this._leftMargin + c.x * d.width) : (this._usingPercentWidth && (d.width = a.width * this._percentWidth), e.x = a.width * this._positionPercentX)
                }
                switch (this._verticalEdge) {
                    case ccui.LayoutComponent.verticalEdge.NONE:
                        this._usingStretchHeight &&
                            !this._isPercentOnly ? (d.height = a.height * this._percentHeight, e.y = this._bottomMargin + c.y * d.height) : (this._usingPositionPercentY && (e.y = a.height * this._positionPercentY), this._usingPercentHeight && (d.height = a.height * this._percentHeight));
                        break;
                    case ccui.LayoutComponent.verticalEdge.BOTTOM:
                        if (this._isPercentOnly) break;
                        if (this._usingPercentHeight || this._usingStretchHeight) d.height = a.height * this._percentHeight;
                        e.y = this._bottomMargin + c.y * d.height;
                        break;
                    case ccui.LayoutComponent.verticalEdge.TOP:
                        if (this._isPercentOnly) break;
                        if (this._usingPercentHeight || this._usingStretchHeight) d.height = a.height * this._percentHeight;
                        e.y = a.height - (this._topMargin + (1 - c.y) * d.height);
                        break;
                    case ccui.LayoutComponent.verticalEdge.CENTER:
                        if (this._isPercentOnly) break;
                        this._usingStretchHeight ? (d.height = a.height - this._topMargin - this._bottomMargin, 0 > d.height && (d.height = 0), e.y = this._bottomMargin + c.y * d.height) : (this._usingPercentHeight && (d.height = a.height * this._percentHeight), e.y = a.height * this._positionPercentY)
                }
                b.setPosition(e);
                b.setContentSize(d);
                if (b instanceof ccui.PageView)
                    for (b.forceDoLayout(), a = b.getPages(), b = 0; b < a.length; b++) ccui.helper.doLayout(a[b]);
                else ccui.helper.doLayout(b)
            }
        }
    },
    _getOwnerParent: function() {
        return this._owner ? this._owner.getParent() : null
    },
    _refreshHorizontalMargin: function() {
        var a = this._getOwnerParent();
        if (null !== a) {
            var b = this._owner.getPosition(),
                c = this._owner.getAnchorPoint(),
                d = this._owner.getContentSize(),
                a = a.getContentSize();
            this._leftMargin = b.x - c.x * d.width;
            this._rightMargin = a.width - (b.x + (1 - c.x) * d.width)
        }
    },
    _refreshVerticalMargin: function() {
        var a =
            this._getOwnerParent();
        if (null !== a) {
            var b = this._owner.getPosition(),
                c = this._owner.getAnchorPoint(),
                d = this._owner.getContentSize(),
                a = a.getContentSize();
            this._bottomMargin = b.y - c.y * d.height;
            this._topMargin = a.height - (b.y + (1 - c.y) * d.height)
        }
    }
});
ccui.LayoutComponent.horizontalEdge = {
    NONE: 0,
    LEFT: 1,
    RIGHT: 2,
    CENTER: 3
};
ccui.LayoutComponent.verticalEdge = {
    NONE: 0,
    BOTTOM: 1,
    TOP: 2,
    CENTER: 3
};
ccui.LayoutComponent.NAME = "__ui_layout";
ccui.LayoutComponent.bindLayoutComponent = function(a) {
    var b = a.getComponent(ccui.LayoutComponent.NAME);
    return void 0 !== b ? b : (b = new ccui.LayoutComponent) && b.init() ? (a.addComponent(b), b) : null
};
var ccs = ccs || {};
ccs.Class = ccs.Class || cc.Class;
ccs.Class.extend = ccs.Class.extend || cc.Class.extend;
ccs.Node = ccs.Node || cc.Node;
ccs.Node.extend = ccs.Node.extend || cc.Node.extend;
ccs.Sprite = ccs.Sprite || cc.Sprite;
ccs.Sprite.extend = ccs.Sprite.extend || cc.Sprite.extend;
ccs.Component = ccs.Component || cc.Component;
ccs.Component.extend = ccs.Component.extend || cc.Component.extend;
ccs.cocostudioVersion = "v1.3.0.0";
ccs.VERSION_COMBINED = 0.3;
ccs.VERSION_CHANGE_ROTATION_RANGE = 1;
ccs.VERSION_COLOR_READING = 1.1;
ccs.MAX_VERTEXZ_VALUE = 5E6;
ccs.ARMATURE_MAX_CHILD = 50;
ccs.ARMATURE_MAX_ZORDER = 100;
ccs.ARMATURE_MAX_COUNT = ccs.MAX_VERTEXZ_VALUE / ccs.ARMATURE_MAX_CHILD / ccs.ARMATURE_MAX_ZORDER;
ccs.AUTO_ADD_SPRITE_FRAME_NAME_PREFIX = !1;
ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT = !1;
ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX = !1;
ccs.armatureVersion = function() {
    return "v1.1.0.0"
};
ccs.CONST_VERSION = "version";
ccs.CONST_VERSION_2_0 = 2;
ccs.CONST_VERSION_COMBINED = 0.3;
ccs.CONST_ARMATURES = "armatures";
ccs.CONST_ARMATURE = "armature";
ccs.CONST_BONE = "b";
ccs.CONST_DISPLAY = "d";
ccs.CONST_ANIMATIONS = "animations";
ccs.CONST_ANIMATION = "animation";
ccs.CONST_MOVEMENT = "mov";
ccs.CONST_FRAME = "f";
ccs.CONST_TEXTURE_ATLAS = "TextureAtlas";
ccs.CONST_SUB_TEXTURE = "SubTexture";
ccs.CONST_SKELETON = "skeleton";
ccs.CONST_A_NAME = "name";
ccs.CONST_A_DURATION = "dr";
ccs.CONST_A_FRAME_INDEX = "fi";
ccs.CONST_A_DURATION_TO = "to";
ccs.CONST_A_DURATION_TWEEN = "drTW";
ccs.CONST_A_LOOP = "lp";
ccs.CONST_A_MOVEMENT_SCALE = "sc";
ccs.CONST_A_MOVEMENT_DELAY = "dl";
ccs.CONST_A_DISPLAY_INDEX = "dI";
ccs.CONST_A_PLIST = "plist";
ccs.CONST_A_PARENT = "parent";
ccs.CONST_A_SKEW_X = "kX";
ccs.CONST_A_SKEW_Y = "kY";
ccs.CONST_A_SCALE_X = "cX";
ccs.CONST_A_SCALE_Y = "cY";
ccs.CONST_A_Z = "z";
ccs.CONST_A_EVENT = "evt";
ccs.CONST_A_SOUND = "sd";
ccs.CONST_A_SOUND_EFFECT = "sdE";
ccs.CONST_A_TWEEN_EASING = "twE";
ccs.CONST_A_EASING_PARAM = "twEP";
ccs.CONST_A_TWEEN_ROTATE = "twR";
ccs.CONST_A_IS_ARMATURE = "isArmature";
ccs.CONST_A_DISPLAY_TYPE = "displayType";
ccs.CONST_A_MOVEMENT = "mov";
ccs.CONST_A_X = "x";
ccs.CONST_A_Y = "y";
ccs.CONST_A_COCOS2DX_X = "cocos2d_x";
ccs.CONST_A_COCOS2DX_Y = "cocos2d_y";
ccs.CONST_A_WIDTH = "width";
ccs.CONST_A_HEIGHT = "height";
ccs.CONST_A_PIVOT_X = "pX";
ccs.CONST_A_PIVOT_Y = "pY";
ccs.CONST_A_COCOS2D_PIVOT_X = "cocos2d_pX";
ccs.CONST_A_COCOS2D_PIVOT_Y = "cocos2d_pY";
ccs.CONST_A_BLEND_TYPE = "bd";
ccs.CONST_A_BLEND_SRC = "bd_src";
ccs.CONST_A_BLEND_DST = "bd_dst";
ccs.CONST_A_ALPHA = "a";
ccs.CONST_A_RED = "r";
ccs.CONST_A_GREEN = "g";
ccs.CONST_A_BLUE = "b";
ccs.CONST_A_ALPHA_OFFSET = "aM";
ccs.CONST_A_RED_OFFSET = "rM";
ccs.CONST_A_GREEN_OFFSET = "gM";
ccs.CONST_A_BLUE_OFFSET = "bM";
ccs.CONST_A_COLOR_TRANSFORM = "colorTransform";
ccs.CONST_A_TWEEN_FRAME = "tweenFrame";
ccs.CONST_CONTOUR = "con";
ccs.CONST_CONTOUR_VERTEX = "con_vt";
ccs.CONST_FL_NAN = "NaN";
ccs.CONST_FRAME_DATA = "frame_data";
ccs.CONST_MOVEMENT_BONE_DATA = "mov_bone_data";
ccs.CONST_MOVEMENT_DATA = "mov_data";
ccs.CONST_ANIMATION_DATA = "animation_data";
ccs.CONST_DISPLAY_DATA = "display_data";
ccs.CONST_SKIN_DATA = "skin_data";
ccs.CONST_BONE_DATA = "bone_data";
ccs.CONST_ARMATURE_DATA = "armature_data";
ccs.CONST_CONTOUR_DATA = "contour_data";
ccs.CONST_TEXTURE_DATA = "texture_data";
ccs.CONST_VERTEX_POINT = "vertex";
ccs.CONST_COLOR_INFO = "color";
ccs.CONST_CONFIG_FILE_PATH = "config_file_path";
ccs.CONST_CONTENT_SCALE = "content_scale";
ccs.DataInfo = function() {
    this.asyncStruct = null;
    this.configFileQueue = [];
    this.contentScale = 1;
    this.baseFilePath = this.filename = "";
    this.cocoStudioVersion = this.flashToolVersion = 0
};
ccs.dataReaderHelper = {
    ConfigType: {
        DragonBone_XML: 0,
        CocoStudio_JSON: 1,
        CocoStudio_Binary: 2
    },
    _configFileList: [],
    _flashToolVersion: ccs.CONST_VERSION_2_0,
    _positionReadScale: 1,
    _asyncRefCount: 0,
    _asyncRefTotalCount: 0,
    _dataQueue: null,
    setPositionReadScale: function(a) {
        this._positionReadScale = a
    },
    getPositionReadScale: function() {
        return this._positionReadScale
    },
    addDataFromFile: function(a) {
        if (-1 === this._configFileList.indexOf(a)) {
            this._configFileList.push(a);
            var b = this._initBaseFilePath(a),
                c = cc.path.extname(a).toLowerCase(),
                d = new ccs.DataInfo;
            d.filename = a;
            d.basefilePath = b;
            ".xml" === c ? ccs.dataReaderHelper.addDataFromXML(a, d) : ".json" === c || ".exportjson" === c ? ccs.dataReaderHelper.addDataFromJson(a, d) : ".csb" === c && ccs.dataReaderHelper.addDataFromBinaryCache(a, d)
        }
    },
    addDataFromFileAsync: function(a, b, c, d, e) {
        if (-1 !== this._configFileList.indexOf(c)) e && d && (0 === this._asyncRefTotalCount && 0 === this._asyncRefCount ? this._asyncCallBack(d, e, 1) : this._asyncCallBack(d, e, (this._asyncRefTotalCount - this._asyncRefCount) / this._asyncRefTotalCount));
        else {
            this._asyncRefTotalCount++;
            this._asyncRefCount++;
            var f = this;
            cc.director.getScheduler().schedule(function() {
                f.addDataFromFile(c);
                f._asyncRefCount--;
                f._asyncCallBack(d, e, (f._asyncRefTotalCount - f._asyncRefCount) / f._asyncRefTotalCount)
            }, this, 0.1, !1, 0, !1, "armatrueDataHelper")
        }
    },
    removeConfigFile: function(a) {
        for (var b = this._configFileList, c = b.length, d = b[c], e = 0; e < c; e++) b[e] === a && (d = e);
        d !== b[c] && cc.arrayRemoveObject(b, a)
    },
    addDataFromCache: function(a, b) {
        if (a) {
            b.flashToolVersion = parseFloat(a.getAttribute(ccs.CONST_VERSION));
            var c = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ARMATURES + " \x3e  " + ccs.CONST_ARMATURE + ""),
                d = ccs.armatureDataManager,
                e;
            for (e = 0; e < c.length; e++) {
                var f = this.decodeArmature(c[e], b);
                d.addArmatureData(f.name, f, b.filename)
            }
            c = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_ANIMATIONS + " \x3e  " + ccs.CONST_ANIMATION + "");
            for (e = 0; e < c.length; e++) f = this.decodeAnimation(c[e], b), d.addAnimationData(f.name, f, b.filename);
            c = a.querySelectorAll(ccs.CONST_SKELETON + " \x3e " + ccs.CONST_TEXTURE_ATLAS +
                " \x3e  " + ccs.CONST_SUB_TEXTURE + "");
            for (e = 0; e < c.length; e++) f = this.decodeTexture(c[e], b), d.addTextureData(f.name, f, b.filename)
        } else cc.log("XML error  or  XML is empty.")
    },
    decodeArmature: function(a, b) {
        var c = new ccs.ArmatureData;
        c.init();
        c.name = a.getAttribute(ccs.CONST_A_NAME);
        for (var d = a.querySelectorAll(ccs.CONST_ARMATURE + " \x3e " + ccs.CONST_BONE), e = 0; e < d.length; e++) {
            var f = d[e],
                g = f.getAttribute(ccs.CONST_A_PARENT),
                h = null;
            if (g)
                for (var k = 0; k < d.length && (h = d[k], g != d[k].getAttribute(ccs.CONST_A_NAME)); k++);
            f = this.decodeBone(f, h, b);
            c.addBoneData(f)
        }
        return c
    },
    decodeArmatureFromJSON: function(a, b) {
        var c = new ccs.ArmatureData;
        c.init();
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        b.cocoStudioVersion = c.dataVersion = a[ccs.CONST_VERSION] || 0.1;
        for (var d = a[ccs.CONST_BONE_DATA], e = 0; e < d.length; e++) {
            var f = this.decodeBoneFromJson(d[e], b);
            c.addBoneData(f)
        }
        return c
    },
    decodeBone: function(a, b, c) {
        b = new ccs.BoneData;
        b.init();
        b.name = a.getAttribute(ccs.CONST_A_NAME);
        b.parentName = a.getAttribute(ccs.CONST_A_PARENT) || "";
        b.zOrder = parseInt(a.getAttribute(ccs.CONST_A_Z)) ||
            0;
        a = a.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_DISPLAY);
        for (var d = 0; d < a.length; d++) {
            var e = this.decodeBoneDisplay(a[d], c);
            b.addDisplayData(e)
        }
        return b
    },
    decodeBoneFromJson: function(a, b) {
        var c = new ccs.BoneData;
        c.init();
        this.decodeNodeFromJson(c, a, b);
        c.name = a[ccs.CONST_A_NAME] || "";
        c.parentName = a[ccs.CONST_A_PARENT] || "";
        for (var d = a[ccs.CONST_DISPLAY_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeBoneDisplayFromJson(d[e], b);
            c.addDisplayData(f)
        }
        return c
    },
    decodeBoneDisplay: function(a, b) {
        var c = null;
        1 === (parseFloat(a.getAttribute(ccs.CONST_A_IS_ARMATURE)) || 0) ? (c = new ccs.ArmatureDisplayData, c.displayType = ccs.DISPLAY_TYPE_ARMATURE) : (c = new ccs.SpriteDisplayData, c.displayType = ccs.DISPLAY_TYPE_SPRITE);
        var d = a.getAttribute(ccs.CONST_A_NAME) || "";
        d && (c.displayName = d);
        return c
    },
    decodeBoneDisplayFromJson: function(a, b) {
        var c = a[ccs.CONST_A_DISPLAY_TYPE] || ccs.DISPLAY_TYPE_SPRITE,
            d = null;
        switch (c) {
            case ccs.DISPLAY_TYPE_SPRITE:
                var d = new ccs.SpriteDisplayData,
                    e = a[ccs.CONST_A_NAME];
                null != e && (d.displayName = e);
                if (e = (a[ccs.CONST_SKIN_DATA] || [])[0]) {
                    var f = d.skinData;
                    f.x = e[ccs.CONST_A_X] * this._positionReadScale;
                    f.y = e[ccs.CONST_A_Y] * this._positionReadScale;
                    f.scaleX = null == e[ccs.CONST_A_SCALE_X] ? 1 : e[ccs.CONST_A_SCALE_X];
                    f.scaleY = null == e[ccs.CONST_A_SCALE_Y] ? 1 : e[ccs.CONST_A_SCALE_Y];
                    f.skewX = null == e[ccs.CONST_A_SKEW_X] ? 1 : e[ccs.CONST_A_SKEW_X];
                    f.skewY = null == e[ccs.CONST_A_SKEW_Y] ? 1 : e[ccs.CONST_A_SKEW_Y];
                    f.x *= b.contentScale;
                    f.y *= b.contentScale
                }
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                d = new ccs.ArmatureDisplayData;
                e = a[ccs.CONST_A_NAME];
                null != e && (d.displayName = a[ccs.CONST_A_NAME]);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                d = new ccs.ParticleDisplayData;
                e = a[ccs.CONST_A_PLIST];
                null != e && (d.displayName = b.asyncStruct ? b.asyncStruct.basefilePath + e : b.basefilePath + e);
                break;
            default:
                d = new ccs.SpriteDisplayData
        }
        d.displayType = c;
        return d
    },
    decodeAnimation: function(a, b) {
        var c = new ccs.AnimationData,
            d = a.getAttribute(ccs.CONST_A_NAME),
            e = ccs.armatureDataManager.getArmatureData(d);
        c.name = d;
        for (var d = a.querySelectorAll(ccs.CONST_ANIMATION + " \x3e " + ccs.CONST_MOVEMENT),
                f = null, g = 0; g < d.length; g++) f = d[g], f = this.decodeMovement(f, e, b), c.addMovement(f);
        return c
    },
    decodeAnimationFromJson: function(a, b) {
        var c = new ccs.AnimationData;
        a[ccs.CONST_A_NAME] && (c.name = a[ccs.CONST_A_NAME]);
        for (var d = a[ccs.CONST_MOVEMENT_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeMovementFromJson(d[e], b);
            c.addMovement(f)
        }
        return c
    },
    decodeMovement: function(a, b, c) {
        var d = new ccs.MovementData;
        d.name = a.getAttribute(ccs.CONST_A_NAME);
        var e;
        e = 0;
        e = a.getAttribute(ccs.CONST_A_DURATION);
        d.duration = null == e ?
            0 : parseFloat(e);
        e = a.getAttribute(ccs.CONST_A_DURATION_TO);
        d.durationTo = null == e ? 0 : parseFloat(e);
        e = a.getAttribute(ccs.CONST_A_DURATION_TWEEN);
        d.durationTween = null == e ? 0 : parseFloat(e);
        e = a.getAttribute(ccs.CONST_A_LOOP);
        d.loop = e ? Boolean(parseFloat(e)) : !0;
        if (e = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) e != ccs.CONST_FL_NAN ? (e = null == e ? 0 : parseFloat(e), d.tweenEasing = 2 === e ? ccs.TweenType.SINE_EASEINOUT : e) : d.tweenEasing = ccs.TweenType.LINEAR;
        a = a.querySelectorAll(ccs.CONST_MOVEMENT + " \x3e " + ccs.CONST_BONE);
        var f =
            null;
        for (e = 0; e < a.length; e++) {
            var f = a[e],
                g = f.getAttribute(ccs.CONST_A_NAME);
            if (!d.getMovementBoneData(g)) {
                var g = b.getBoneData(g),
                    h = g.parentName,
                    k = null;
                if ("" !== h)
                    for (var m = 0; m < a.length && (k = a[m], h !== k.getAttribute(ccs.CONST_A_NAME)); m++);
                f = this.decodeMovementBone(f, k, g, c);
                d.addMovementBoneData(f)
            }
        }
        return d
    },
    decodeMovementFromJson: function(a, b) {
        var c = new ccs.MovementData;
        c.loop = null == a[ccs.CONST_A_LOOP] ? !1 : a[ccs.CONST_A_LOOP];
        c.durationTween = a[ccs.CONST_A_DURATION_TWEEN] || 0;
        c.durationTo = a[ccs.CONST_A_DURATION_TO] ||
            0;
        c.duration = a[ccs.CONST_A_DURATION] || 0;
        c.scale = null == a[ccs.CONST_A_DURATION] ? 1 : null == a[ccs.CONST_A_MOVEMENT_SCALE] ? 1 : a[ccs.CONST_A_MOVEMENT_SCALE];
        c.tweenEasing = null == a[ccs.CONST_A_TWEEN_EASING] ? ccs.TweenType.LINEAR : a[ccs.CONST_A_TWEEN_EASING];
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        for (var d = a[ccs.CONST_MOVEMENT_BONE_DATA] || [], e = 0; e < d.length; e++) {
            var f = this.decodeMovementBoneFromJson(d[e], b);
            c.addMovementBoneData(f)
        }
        return c
    },
    decodeMovementBone: function(a, b, c, d) {
        var e = new ccs.MovementBoneData;
        e.init();
        var f;
        a && (f = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_SCALE)) || 0, e.scale = f, f = parseFloat(a.getAttribute(ccs.CONST_A_MOVEMENT_DELAY)) || 0, 0 < f && (f -= 1), e.delay = f);
        var g = 0,
            h = f = 0,
            k = null,
            m = [];
        if (null != b) {
            for (var n = b.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME), g = 0; g < n.length; g++) m.push(n[g]);
            g = m.length
        }
        e.name = a.getAttribute(ccs.CONST_A_NAME);
        a = a.querySelectorAll(ccs.CONST_BONE + " \x3e " + ccs.CONST_FRAME);
        for (var p = n = 0, s = 0; s < a.length; s++) {
            var r = a[s];
            if (b)
                for (; n < g && (k ? p < f || p >= f + h : 1);) k = m[n],
                    f += h, h = parseFloat(k.getAttribute(ccs.CONST_A_DURATION)), n++;
            r = this.decodeFrame(r, k, c, d);
            e.addFrameData(r);
            r.frameID = p;
            p += r.duration;
            e.duration = p
        }
        b = e.frameList;
        c = Math.PI;
        for (g = b.length - 1; 0 <= g; g--)
            if (0 < g) {
                d = b[g].skewX - b[g - 1].skewX;
                f = b[g].skewY - b[g - 1].skewY;
                if (d < -c || d > c) b[g - 1].skewX = 0 > d ? b[g - 1].skewX - 2 * c : b[g - 1].skewX + 2 * c;
                if (f < -c || f > c) b[g - 1].skewY = 0 > f ? b[g - 1].skewY - 2 * c : b[g - 1].skewY + 2 * c
            }
        b = new ccs.FrameData;
        b.copy(e.frameList[e.frameList.length - 1]);
        b.frameID = e.duration;
        e.addFrameData(b);
        return e
    },
    decodeMovementBoneFromJson: function(a,
        b) {
        var c = new ccs.MovementBoneData;
        c.init();
        c.delay = a[ccs.CONST_A_MOVEMENT_DELAY] || 0;
        var d = a[ccs.CONST_A_NAME];
        d && (c.name = d);
        for (var e = (a[ccs.CONST_FRAME_DATA] || []).length, d = 0; d < e; d++) {
            var f = this.decodeFrameFromJson(a[ccs.CONST_FRAME_DATA][d], b);
            c.addFrameData(f);
            b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && (f.frameID = c.duration, c.duration += f.duration)
        }
        if (b.cocoStudioVersion < ccs.VERSION_CHANGE_ROTATION_RANGE)
            for (e = c.frameList, f = Math.PI, d = e.length - 1; 0 <= d; d--)
                if (0 < d) {
                    var g = e[d].skewX - e[d - 1].skewX,
                        h = e[d].skewY - e[d - 1].skewY;
                    if (g < -f || g > f) e[d - 1].skewX = 0 > g ? e[d - 1].skewX - 2 * f : e[d - 1].skewX + 2 * f;
                    if (h < -f || h > f) e[d - 1].skewY = 0 > h ? e[d - 1].skewY - 2 * f : e[d - 1].skewY + 2 * f
                }
        b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED && 0 < c.frameList.length && (f = new ccs.FrameData, f.copy(c.frameList[c.frameList.length - 1]), c.addFrameData(f), f.frameID = c.duration);
        return c
    },
    decodeFrame: function(a, b, c, d) {
        var e = 0,
            e = e = e = e = e = e = e = e = e = e = e = 0;
        c = new ccs.FrameData;
        c.strMovement = a.getAttribute(ccs.CONST_A_MOVEMENT) || "";
        c.movement = c.strMovement;
        c.strEvent =
            a.getAttribute(ccs.CONST_A_EVENT) || "";
        c.event = c.strEvent;
        c.strSound = a.getAttribute(ccs.CONST_A_SOUND) || "";
        c.sound = c.strSound;
        c.strSoundEffect = a.getAttribute(ccs.CONST_A_SOUND_EFFECT) || "";
        c.soundEffect = c.strSoundEffect;
        e = a.getAttribute(ccs.CONST_A_TWEEN_FRAME);
        c.isTween = !(void 0 != e && "false" === e);
        if (d.flashToolVersion >= ccs.CONST_VERSION_2_0) {
            if (e = a.getAttribute(ccs.CONST_A_COCOS2DX_X)) c.x = parseFloat(e), c.x *= this._positionReadScale;
            e = a.getAttribute(ccs.CONST_A_COCOS2DX_Y)
        } else {
            if (e = a.getAttribute(ccs.CONST_A_X)) c.x =
                parseFloat(e), c.x *= this._positionReadScale;
            e = a.getAttribute(ccs.CONST_A_Y)
        }
        e && (c.y = -parseFloat(e), c.y *= this._positionReadScale);
        e = a.getAttribute(ccs.CONST_A_SCALE_X);
        null != e && (c.scaleX = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_SCALE_Y);
        null != e && (c.scaleY = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_SKEW_X);
        null != e && (c.skewX = cc.degreesToRadians(parseFloat(e)));
        e = a.getAttribute(ccs.CONST_A_SKEW_Y);
        null != e && (c.skewY = cc.degreesToRadians(-parseFloat(e)));
        e = a.getAttribute(ccs.CONST_A_DURATION);
        null != e &&
            (c.duration = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_DISPLAY_INDEX);
        null != e && (c.displayIndex = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_Z);
        null != e && (c.zOrder = parseInt(e));
        e = a.getAttribute(ccs.CONST_A_TWEEN_ROTATE);
        null != e && (c.tweenRotate = parseFloat(e));
        e = a.getAttribute(ccs.CONST_A_BLEND_TYPE);
        if (null != e) {
            var f = c.blendFunc;
            switch (e) {
                case ccs.BLEND_TYPE_NORMAL:
                    f.src = cc.BLEND_SRC;
                    f.dst = cc.BLEND_DST;
                    break;
                case ccs.BLEND_TYPE_ADD:
                    f.src = cc.SRC_ALPHA;
                    f.dst = cc.ONE;
                    break;
                case ccs.BLEND_TYPE_MULTIPLY:
                    f.src =
                        cc.DST_COLOR;
                    f.dst = cc.ONE_MINUS_SRC_ALPHA;
                    break;
                case ccs.BLEND_TYPE_SCREEN:
                    f.src = cc.ONE;
                    f.dst = cc.ONE_MINUS_DST_COLOR;
                    break;
                default:
                    c.blendFunc.src = cc.BLEND_SRC, c.blendFunc.dst = cc.BLEND_DST
            }
        }
        var g = a.querySelectorAll(ccs.CONST_FRAME + " \x3e " + ccs.CONST_A_COLOR_TRANSFORM);
        if (g && 0 < g.length) {
            var g = g[0],
                h, k, m, n, p, e = parseFloat(g.getAttribute(ccs.CONST_A_ALPHA)) || 0,
                f = parseFloat(g.getAttribute(ccs.CONST_A_RED)) || 0;
            h = parseFloat(g.getAttribute(ccs.CONST_A_GREEN)) || 0;
            k = parseFloat(g.getAttribute(ccs.CONST_A_BLUE)) ||
                0;
            m = parseFloat(g.getAttribute(ccs.CONST_A_ALPHA_OFFSET)) || 0;
            n = parseFloat(g.getAttribute(ccs.CONST_A_RED_OFFSET)) || 0;
            p = parseFloat(g.getAttribute(ccs.CONST_A_GREEN_OFFSET)) || 0;
            g = parseFloat(g.getAttribute(ccs.CONST_A_BLUE_OFFSET)) || 0;
            c.a = 2.55 * m + e;
            c.r = 2.55 * n + f;
            c.g = 2.55 * p + h;
            c.b = 2.55 * g + k;
            c.isUseColorInfo = !0
        }
        e = a.getAttribute(ccs.CONST_A_TWEEN_EASING);
        null != e && (e != ccs.CONST_FL_NAN ? (e = a.getAttribute(ccs.CONST_A_TWEEN_EASING)) && (c.tweenEasing = 2 === e ? ccs.TweenType.SINE_EASEINOUT : e) : c.tweenEasing = ccs.TweenType.LINEAR);
        b && (a = new ccs.BaseData, d.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (a.x = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_X)), a.y = parseFloat(b.getAttribute(ccs.CONST_A_COCOS2DX_Y))) : (a.x = parseFloat(b.getAttribute(ccs.CONST_A_X)), a.y = parseFloat(b.getAttribute(ccs.CONST_A_Y))), a.skewX = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_X)), a.skewY = parseFloat(b.getAttribute(ccs.CONST_A_SKEW_Y)), a.y = -a.y, a.skewX = cc.degreesToRadians(a.skewX), a.skewY = cc.degreesToRadians(-a.skewY), ccs.TransformHelp.transformFromParent(c,
            a));
        return c
    },
    decodeFrameFromJson: function(a, b) {
        var c = new ccs.FrameData;
        this.decodeNodeFromJson(c, a, b);
        c.tweenEasing = a[ccs.CONST_A_TWEEN_EASING] || ccs.TweenType.LINEAR;
        c.displayIndex = a[ccs.CONST_A_DISPLAY_INDEX];
        var d = null == a[ccs.CONST_A_BLEND_DST] ? cc.BLEND_DST : a[ccs.CONST_A_BLEND_DST];
        c.blendFunc.src = null == a[ccs.CONST_A_BLEND_SRC] ? cc.BLEND_SRC : a[ccs.CONST_A_BLEND_SRC];
        c.blendFunc.dst = d;
        c.isTween = null == a[ccs.CONST_A_TWEEN_FRAME] ? !0 : a[ccs.CONST_A_TWEEN_FRAME];
        d = a[ccs.CONST_A_EVENT];
        null != d && (c.strEvent =
            d, c.event = d);
        b.cocoStudioVersion < ccs.CONST_VERSION_COMBINED ? c.duration = null == a[ccs.CONST_A_DURATION] ? 1 : a[ccs.CONST_A_DURATION] : c.frameID = a[ccs.CONST_A_FRAME_INDEX];
        for (var d = a[ccs.CONST_A_EASING_PARAM] || [], e = 0; e < d.length; e++) c.easingParams[e] = d[e];
        return c
    },
    decodeTexture: function(a, b) {
        var c = new ccs.TextureData;
        c.init();
        a.getAttribute(ccs.CONST_A_NAME) && (c.name = a.getAttribute(ccs.CONST_A_NAME));
        var d, e;
        b.flashToolVersion >= ccs.CONST_VERSION_2_0 ? (d = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_X)) ||
            0, e = parseFloat(a.getAttribute(ccs.CONST_A_COCOS2D_PIVOT_Y)) || 0) : (d = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_X)) || 0, e = parseFloat(a.getAttribute(ccs.CONST_A_PIVOT_Y)) || 0);
        var f = parseFloat(a.getAttribute(ccs.CONST_A_WIDTH)) || 0,
            g = parseFloat(a.getAttribute(ccs.CONST_A_HEIGHT)) || 0;
        c.pivotX = d / f;
        c.pivotY = (g - e) / g;
        d = a.querySelectorAll(ccs.CONST_SUB_TEXTURE + " \x3e " + ccs.CONST_CONTOUR);
        for (e = 0; e < d.length; e++) c.addContourData(this.decodeContour(d[e], b));
        return c
    },
    decodeTextureFromJson: function(a) {
        var b = new ccs.TextureData;
        b.init();
        var c = a[ccs.CONST_A_NAME];
        null != c && (b.name = c);
        b.width = a[ccs.CONST_A_WIDTH] || 0;
        b.height = a[ccs.CONST_A_HEIGHT] || 0;
        b.pivotX = a[ccs.CONST_A_PIVOT_X] || 0;
        b.pivotY = a[ccs.CONST_A_PIVOT_Y] || 0;
        a = a[ccs.CONST_CONTOUR_DATA] || [];
        for (c = 0; c < a.length; c++) b.contourDataList.push(this.decodeContourFromJson(a[c]));
        return b
    },
    decodeContour: function(a, b) {
        var c = new ccs.ContourData;
        c.init();
        for (var d = a.querySelectorAll(ccs.CONST_CONTOUR + " \x3e " + ccs.CONST_CONTOUR_VERTEX), e, f = 0; f < d.length; f++) {
            e = d[f];
            var g = cc.p(0, 0);
            g.x = parseFloat(e.getAttribute(ccs.CONST_A_X)) || 0;
            g.y = parseFloat(e.getAttribute(ccs.CONST_A_Y)) || 0;
            g.y = -g.y;
            c.vertexList.push(g)
        }
        return c
    },
    decodeContourFromJson: function(a) {
        var b = new ccs.ContourData;
        b.init();
        a = a[ccs.CONST_VERTEX_POINT] || [];
        for (var c = a.length, d = 0; d < c; d++) {
            var e = a[d],
                f = cc.p(0, 0);
            f.x = e[ccs.CONST_A_X] || 0;
            f.y = e[ccs.CONST_A_Y] || 0;
            b.vertexList.push(f)
        }
        return b
    },
    addDataFromJsonCache: function(a, b) {
        b.contentScale = null == a[ccs.CONST_CONTENT_SCALE] ? 1 : a[ccs.CONST_CONTENT_SCALE];
        var c = a[ccs.CONST_ARMATURE_DATA] || [],
            d, e;
        for (d = 0; d < c.length; d++) e = this.decodeArmatureFromJSON(c[d], b), ccs.armatureDataManager.addArmatureData(e.name, e, b.filename);
        c = a[ccs.CONST_ANIMATION_DATA] || [];
        for (d = 0; d < c.length; d++) e = this.decodeAnimationFromJson(c[d], b), ccs.armatureDataManager.addAnimationData(e.name, e, b.filename);
        c = a[ccs.CONST_TEXTURE_DATA] || [];
        for (d = 0; d < c.length; d++) e = this.decodeTextureFromJson(c[d], b), ccs.armatureDataManager.addTextureData(e.name, e, b.filename);
        if (null == b.asyncStruct ? ccs.armatureDataManager.isAutoLoadSpriteFile() :
            b.asyncStruct.autoLoadSpriteFile) {
            var c = a[ccs.CONST_CONFIG_FILE_PATH] || [],
                f;
            for (d = 0; d < c.length; d++) e = c[d], f = e.lastIndexOf("."), e = e.substring(0, f), f = b.basefilePath + e + ".plist", e = b.basefilePath + e + ".png", ccs.armatureDataManager.addSpriteFrameFromFile(f, e, b.filename)
        }
    },
    decodeNodeFromJson: function(a, b, c) {
        a.x = b[ccs.CONST_A_X] * this._positionReadScale;
        a.y = b[ccs.CONST_A_Y] * this._positionReadScale;
        a.x *= c.contentScale;
        a.y *= c.contentScale;
        a.zOrder = b[ccs.CONST_A_Z];
        a.skewX = b[ccs.CONST_A_SKEW_X] || 0;
        a.skewY = b[ccs.CONST_A_SKEW_Y] ||
            0;
        a.scaleX = null == b[ccs.CONST_A_SCALE_X] ? 1 : b[ccs.CONST_A_SCALE_X];
        a.scaleY = null == b[ccs.CONST_A_SCALE_Y] ? 1 : b[ccs.CONST_A_SCALE_Y];
        if (b = c.cocoStudioVersion < ccs.VERSION_COLOR_READING ? b[0] : b[ccs.CONST_COLOR_INFO] || null) a.a = null == b[ccs.CONST_A_ALPHA] ? 255 : b[ccs.CONST_A_ALPHA], a.r = null == b[ccs.CONST_A_RED] ? 255 : b[ccs.CONST_A_RED], a.g = null == b[ccs.CONST_A_GREEN] ? 255 : b[ccs.CONST_A_GREEN], a.b = null == b[ccs.CONST_A_BLUE] ? 255 : b[ccs.CONST_A_BLUE], a.isUseColorInfo = !0
    },
    clear: function() {
        this._configFileList = [];
        this._asyncRefTotalCount =
            this._asyncRefCount = 0
    },
    _asyncCallBack: function(a, b, c) {
        a && cc.isFunction(a) && a.call(b, c);
        if (b && a && "string" === typeof a) b[a](c)
    },
    _initBaseFilePath: function(a) {
        var b = a.lastIndexOf("/");
        return a = -1 < b ? a.substr(0, b + 1) : ""
    },
    addDataFromXML: function(a, b) {
        var c = cc.loader.getRes(a);
        if (!c) throw Error("Please load the resource first : " + a);
        (c = cc.saxParser.parse(c).documentElement) && this.addDataFromCache(c, b)
    },
    addDataFromJson: function(a, b) {
        var c = cc.loader.getRes(a);
        this.addDataFromJsonCache(c, b)
    }
};
ccs.spriteFrameCacheHelper = {
    _textureAtlasDic: {},
    _imagePaths: [],
    addSpriteFrameFromFile: function(a, b) {
        cc.spriteFrameCache.addSpriteFrames(a, b)
    },
    getTextureAtlasWithTexture: function(a) {
        return null
    },
    clear: function() {
        this._textureAtlasDic = {};
        this._imagePaths = []
    }
};
ccs.TransformHelp = ccs.TransformHelp || ccs.Class.extend({});
ccs.TransformHelp.helpMatrix1 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpMatrix2 = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
ccs.TransformHelp.helpPoint1 = cc.p(0, 0);
ccs.TransformHelp.helpPoint2 = cc.p(0, 0);
ccs.TransformHelp.helpParentNode = {};
ccs.TransformHelp.transformFromParent = function(a, b) {
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(b, this.helpMatrix2);
    this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformToParent = function(a, b) {
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(b, this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformFromParentWithoutScale = function(a, b) {
    for (var c in b) this.helpParentNode[c] = b[c];
    this.helpParentNode.scaleX = 1;
    this.helpParentNode.scaleY = 1;
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(this.helpParentNode, this.helpMatrix2);
    this.helpMatrix2 = cc.affineTransformInvert(this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.transformToParentWithoutScale = function(a, b) {
    for (var c in b) this.helpParentNode[c] = b[c];
    this.helpParentNode.scaleX = 1;
    this.helpParentNode.scaleY = 1;
    this.nodeToMatrix(a, this.helpMatrix1);
    this.nodeToMatrix(this.helpParentNode, this.helpMatrix2);
    this.helpMatrix1 = cc.affineTransformConcat(this.helpMatrix1, this.helpMatrix2);
    this.matrixToNode(this.helpMatrix1, a)
};
ccs.TransformHelp.nodeToMatrix = function(a, b) {
    if (a.skewX === -a.skewY) {
        var c = Math.sin(a.skewX),
            d = Math.cos(a.skewX);
        b.a = a.scaleX * d;
        b.b = a.scaleX * -c;
        b.c = a.scaleY * c;
        b.d = a.scaleY * d
    } else b.a = a.scaleX * Math.cos(a.skewY), b.b = a.scaleX * Math.sin(a.skewY), b.c = a.scaleY * Math.sin(a.skewX), b.d = a.scaleY * Math.cos(a.skewX);
    b.tx = a.x;
    b.ty = a.y
};
ccs.TransformHelp.matrixToNode = function(a, b) {
    this.helpPoint1.x = 0;
    this.helpPoint1.y = 1;
    this.helpPoint1 = cc.pointApplyAffineTransform(this.helpPoint1, a);
    this.helpPoint1.x -= a.tx;
    this.helpPoint1.y -= a.ty;
    this.helpPoint2.x = 1;
    this.helpPoint2.y = 0;
    this.helpPoint2 = cc.pointApplyAffineTransform(this.helpPoint2, a);
    this.helpPoint2.x -= a.tx;
    this.helpPoint2.y -= a.ty;
    b.skewX = -(Math.atan2(this.helpPoint1.y, this.helpPoint1.x) - 1.5707964);
    b.skewY = Math.atan2(this.helpPoint2.y, this.helpPoint2.x);
    b.scaleX = Math.sqrt(a.a * a.a +
        a.b * a.b);
    b.scaleY = Math.sqrt(a.c * a.c + a.d * a.d);
    b.x = a.tx;
    b.y = a.ty
};
ccs.TransformHelp.nodeConcat = function(a, b) {
    a.x += b.x;
    a.y += b.y;
    a.skewX += b.skewX;
    a.skewY += b.skewY;
    a.scaleX += b.scaleX;
    a.scaleY += b.scaleY
};
ccs.TransformHelp.nodeSub = function(a, b) {
    a.x -= b.x;
    a.y -= b.y;
    a.skewX -= b.skewX;
    a.skewY -= b.skewY;
    a.scaleX -= b.scaleX;
    a.scaleY -= b.scaleY
};
ccs.TweenType = {
    CUSTOM_EASING: -1,
    LINEAR: 0,
    SINE_EASEIN: 1,
    SINE_EASEOUT: 2,
    SINE_EASEINOUT: 3,
    QUAD_EASEIN: 4,
    QUAD_EASEOUT: 5,
    QUAD_EASEINOUT: 6,
    CUBIC_EASEIN: 7,
    CUBIC_EASEOUT: 8,
    CUBIC_EASEINOUT: 9,
    QUART_EASEIN: 10,
    QUART_EASEOUT: 11,
    QUART_EASEINOUT: 12,
    QUINT_EASEIN: 13,
    QUINT_EASEOUT: 14,
    QUINT_EASEINOUT: 15,
    EXPO_EASEIN: 16,
    EXPO_EASEOUT: 17,
    EXPO_EASEINOUT: 18,
    CIRC_EASEIN: 19,
    CIRC_EASEOUT: 20,
    CIRC_EASEINOUT: 21,
    ELASTIC_EASEIN: 22,
    ELASTIC_EASEOUT: 23,
    ELASTIC_EASEINOUT: 24,
    BACK_EASEIN: 25,
    BACK_EASEOUT: 26,
    BACK_EASEINOUT: 27,
    BOUNCE_EASEIN: 28,
    BOUNCE_EASEOUT: 29,
    BOUNCE_EASEINOUT: 30,
    TWEEN_EASING_MAX: 1E4
};
ccs.TweenFunction = ccs.TweenFunction || ccs.Class.extend({});
ccs.DOUBLE_PI = ccs.M_PI_X_2 = 2 * Math.PI;
ccs.HALF_PI = ccs.M_PI_2 = Math.PI / 2;
ccs.M_PI = Math.PI;
ccs.TweenFunction.tweenTo = function(a, b, c) {
    var d = 0;
    switch (b) {
        case ccs.TweenType.CUSTOM_EASING:
            d = this.customEase(a, c);
            break;
        case ccs.TweenType.LINEAR:
            d = this.linear(a);
            break;
        case ccs.TweenType.SINE_EASEIN:
            d = this.sineEaseIn(a);
            break;
        case ccs.TweenType.SINE_EASEOUT:
            d = this.sineEaseOut(a);
            break;
        case ccs.TweenType.SINE_EASEINOUT:
            d = this.sineEaseInOut(a);
            break;
        case ccs.TweenType.QUAD_EASEIN:
            d = this.quadEaseIn(a);
            break;
        case ccs.TweenType.QUAD_EASEOUT:
            d = this.quadEaseOut(a);
            break;
        case ccs.TweenType.QUAD_EASEINOUT:
            d =
                this.quadEaseInOut(a);
            break;
        case ccs.TweenType.CUBIC_EASEIN:
            d = this.cubicEaseIn(a);
            break;
        case ccs.TweenType.CUBIC_EASEOUT:
            d = this.cubicEaseOut(a);
            break;
        case ccs.TweenType.CUBIC_EASEINOUT:
            d = this.cubicEaseInOut(a);
            break;
        case ccs.TweenType.QUART_EASEIN:
            d = this.quartEaseIn(a);
            break;
        case ccs.TweenType.QUART_EASEOUT:
            d = this.quartEaseOut(a);
            break;
        case ccs.TweenType.QUART_EASEINOUT:
            d = this.quartEaseInOut(a);
            break;
        case ccs.TweenType.QUINT_EASEIN:
            d = this.quintEaseIn(a);
            break;
        case ccs.TweenType.QUINT_EASEOUT:
            d = this.quintEaseOut(a);
            break;
        case ccs.TweenType.QUINT_EASEINOUT:
            d = this.quintEaseInOut(a);
            break;
        case ccs.TweenType.EXPO_EASEIN:
            d = this.expoEaseIn(a);
            break;
        case ccs.TweenType.EXPO_EASEOUT:
            d = this.expoEaseOut(a);
            break;
        case ccs.TweenType.EXPO_EASEINOUT:
            d = this.expoEaseInOut(a);
            break;
        case ccs.TweenType.CIRC_EASEIN:
            d = this.circEaseIn(a);
            break;
        case ccs.TweenType.CIRC_EASEOUT:
            d = this.circEaseOut(a);
            break;
        case ccs.TweenType.CIRC_EASEINOUT:
            d = this.circEaseInOut(a);
            break;
        case ccs.TweenType.ELASTIC_EASEIN:
            b = 0.3;
            null != c && 0 < c.length && (b = c[0]);
            d = this.elasticEaseIn(a, b);
            break;
        case ccs.TweenType.ELASTIC_EASEOUT:
            b = 0.3;
            null != c && 0 < c.length && (b = c[0]);
            d = this.elasticEaseOut(a, b);
            break;
        case ccs.TweenType.ELASTIC_EASEINOUT:
            b = 0.3;
            null != c && 0 < c.length && (b = c[0]);
            d = this.elasticEaseInOut(a, b);
            break;
        case ccs.TweenType.BACK_EASEIN:
            d = this.backEaseIn(a);
            break;
        case ccs.TweenType.BACK_EASEOUT:
            d = this.backEaseOut(a);
            break;
        case ccs.TweenType.BACK_EASEINOUT:
            d = this.backEaseInOut(a);
            break;
        case ccs.TweenType.BOUNCE_EASEIN:
            d = this.bounceEaseIn(a);
            break;
        case ccs.TweenType.BOUNCE_EASEOUT:
            d =
                this.bounceEaseOut(a);
            break;
        case ccs.TweenType.BOUNCE_EASEINOUT:
            d = this.bounceEaseInOut(a);
            break;
        default:
            d = this.sineEaseInOut(a)
    }
    return d
};
ccs.TweenFunction.linear = function(a) {
    return a
};
ccs.TweenFunction.sineEaseIn = function(a) {
    return -1 * Math.cos(a * ccs.HALF_PI) + 1
};
ccs.TweenFunction.sineEaseOut = function(a) {
    return Math.sin(a * ccs.HALF_PI)
};
ccs.TweenFunction.sineEaseInOut = function(a) {
    return -0.5 * (Math.cos(ccs.M_PI * a) - 1)
};
ccs.TweenFunction.quadEaseIn = function(a) {
    return a * a
};
ccs.TweenFunction.quadEaseOut = function(a) {
    return -1 * a * (a - 2)
};
ccs.TweenFunction.quadEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a;
    --a;
    return -0.5 * (a * (a - 2) - 1)
};
ccs.TweenFunction.cubicEaseIn = function(a) {
    return a * a * a
};
ccs.TweenFunction.cubicEaseOut = function(a) {
    a -= 1;
    return a * a * a + 1
};
ccs.TweenFunction.cubicEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a;
    a -= 2;
    return 0.5 * (a * a * a + 2)
};
ccs.TweenFunction.quartEaseIn = function(a) {
    return a * a * a * a
};
ccs.TweenFunction.quartEaseOut = function(a) {
    a -= 1;
    return -(a * a * a * a - 1)
};
ccs.TweenFunction.quartEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a * a;
    a -= 2;
    return -0.5 * (a * a * a * a - 2)
};
ccs.TweenFunction.quintEaseIn = function(a) {
    return a * a * a * a * a
};
ccs.TweenFunction.quintEaseOut = function(a) {
    a -= 1;
    return a * a * a * a * a + 1
};
ccs.TweenFunction.quintEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return 0.5 * a * a * a * a * a;
    a -= 2;
    return 0.5 * (a * a * a * a * a + 2)
};
ccs.TweenFunction.expoEaseIn = function(a) {
    return 0 === a ? 0 : Math.pow(2, 10 * (a - 1)) - 0.001
};
ccs.TweenFunction.expoEaseOut = function(a) {
    return 1 === a ? 1 : -Math.pow(2, -10 * a) + 1
};
ccs.TweenFunction.expoEaseInOut = function(a) {
    a /= 0.5;
    return a = 1 > a ? 0.5 * Math.pow(2, 10 * (a - 1)) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2)
};
ccs.TweenFunction.circEaseIn = function(a) {
    return -1 * (Math.sqrt(1 - a * a) - 1)
};
ccs.TweenFunction.circEaseOut = function(a) {
    a -= 1;
    return Math.sqrt(1 - a * a)
};
ccs.TweenFunction.circEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return -0.5 * (Math.sqrt(1 - a * a) - 1);
    a -= 2;
    return 0.5 * (Math.sqrt(1 - a * a) + 1)
};
ccs.TweenFunction.elasticEaseIn = function(a, b) {
    var c = 0.3;
    0 < b.length && (c = b[0]);
    var d = 0;
    0 === a || 1 === a ? d = a : (d = c / 4, a -= 1, d = -Math.pow(2, 10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c));
    return d
};
ccs.TweenFunction.elasticEaseOut = function(a, b) {
    var c = 0.3;
    0 < b.length && (c = b[0]);
    var d = 0;
    0 === a || 1 === a ? d = a : (d = c / 4, d = Math.pow(2, -10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) + 1);
    return d
};
ccs.TweenFunction.elasticEaseInOut = function(a, b) {
    var c = 0.3;
    0 < b.length && (c = b[0]);
    var d = 0;
    0 === a || 1 === a ? d = a : (c || (c = 0.3 * 1.5), d = c / 4, a = 2 * a - 1, d = 0 > a ? -0.5 * Math.pow(2, 10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) : Math.pow(2, -10 * a) * Math.sin((a - d) * ccs.DOUBLE_PI / c) * 0.5 + 1);
    return d
};
ccs.TweenFunction.backEaseIn = function(a) {
    return a * a * (2.70158 * a - 1.70158)
};
ccs.TweenFunction.backEaseOut = function(a) {
    a -= 1;
    return a * a * (2.70158 * a + 1.70158) + 1
};
ccs.TweenFunction.backEaseInOut = function(a) {
    a *= 2;
    if (1 > a) return a * a * (3.5949095 * a - 2.5949095) / 2;
    a -= 2;
    return a * a * (3.5949095 * a + 2.5949095) / 2 + 1
};
ccs.bounceTime = function(a) {
    if (a < 1 / 2.75) return 7.5625 * a * a;
    if (a < 2 / 2.75) return a -= 1.5 / 2.75, 7.5625 * a * a + 0.75;
    if (a < 2.5 / 2.75) return a -= 2.25 / 2.75, 7.5625 * a * a + 0.9375;
    a -= 2.625 / 2.75;
    return 7.5625 * a * a + 0.984375
};
ccs.TweenFunction.bounceEaseIn = function(a) {
    return 1 - ccs.bounceTime(1 - a)
};
ccs.TweenFunction.bounceEaseOut = function(a) {
    return ccs.bounceTime(a)
};
ccs.TweenFunction.bounceEaseInOut = function(a) {
    var b = 0;
    return b = 0.5 > a ? 0.5 * (1 - ccs.bounceTime(1 - 2 * a)) : 0.5 * ccs.bounceTime(2 * a - 1) + 0.5
};
ccs.TweenFunction.customEase = function(a, b) {
    if (0 < b.length) {
        var c = 1 - a;
        return b[1] * c * c * c + 3 * b[3] * a * c * c + 3 * b[5] * a * a * c + b[7] * a * a * a
    }
    return a
};
ccs.TweenFunction.easeIn = function(a, b) {
    return Math.pow(a, b)
};
ccs.TweenFunction.easeOut = function(a, b) {
    return Math.pow(a, 1 / b)
};
ccs.TweenFunction.easeInOut = function(a, b) {
    a *= 2;
    return 1 > a ? 0.5 * Math.pow(a, b) : 1 - 0.5 * Math.pow(2 - a, b)
};
ccs.TweenFunction.quadraticIn = function(a) {
    return Math.pow(a, 2)
};
ccs.TweenFunction.quadraticOut = function(a) {
    return -a * (a - 2)
};
ccs.TweenFunction.bezieratFunction = function(a, b, c, d, e) {
    return Math.pow(1 - e, 3) * a + 3 * e * Math.pow(1 - e, 2) * b + 3 * Math.pow(e, 2) * (1 - e) * c + Math.pow(e, 3) * d
};
var ENABLE_PHYSICS_DETECT = !1;
ccs.fmodf = function(a, b) {
    for (; a > b;) a -= b;
    return a
};
var CC_SAFE_RELEASE = function(a) {
    a && a.release && a.release()
};
ccs.isSpriteContainPoint = function(a, b, c) {
    b = a.convertToNodeSpace(b);
    c && (c.x = b.x, c.y = b.y);
    a = a.getContentSize();
    return cc.rectContainsPoint(cc.rect(0, 0, a.width, a.height), b)
};
ccs.SPRITE_CONTAIN_POINT = ccs.isSpriteContainPoint;
ccs.SPRITE_CONTAIN_POINT_WITH_RETURN = ccs.isSpriteContainPoint;
ccs.extBezierTo = function(a, b, c, d, e) {
    var f = cc.p(0, 0);
    d && !e && (f.x = Math.pow(1 - a, 2) * b.x + 2 * a * (1 - a) * c.x + Math.pow(a, 2) * d.x, f.y = Math.pow(1 - a, 2) * b.y + 2 * a * (1 - a) * c.y + Math.pow(a, 2) * d.y);
    e && (f.x = b.x * Math.pow(1 - a, 3) + 3 * a * c.x * Math.pow(1 - a, 2) + 3 * d.x * Math.pow(a, 2) * (1 - a) + e.x * Math.pow(a, 3), f.y = b.y * Math.pow(1 - a, 3) + 3 * a * c.y * Math.pow(1 - a, 2) + 3 * d.y * Math.pow(a, 2) * (1 - a) + e.y * Math.pow(a, 3));
    return f
};
ccs.extCircleTo = function(a, b, c, d, e) {
    var f = cc.p(0, 0);
    f.x = b.x + c * Math.cos(d + e * a);
    f.y = b.y + c * Math.sin(d + e * a);
    return f
};
ccs.RelativeData = function() {
    this.plistFiles = [];
    this.armatures = [];
    this.animations = [];
    this.textures = []
};
ccs.armatureDataManager = {
    _animationDatas: {},
    _armatureDatas: {},
    _textureDatas: {},
    _autoLoadSpriteFile: !1,
    _relativeDatas: {},
    s_sharedArmatureDataManager: null,
    removeArmatureFileInfo: function(a) {
        var b = this.getRelativeData(a);
        if (b) {
            var c, d;
            for (c = 0; c < b.armatures.length; c++) d = b.armatures[c], this.removeArmatureData(d);
            for (c = 0; c < b.animations.length; c++) d = b.animations[c], this.removeAnimationData(d);
            for (c = 0; c < b.textures.length; c++) d = b.textures[c], this.removeTextureData(d);
            for (c = 0; c < b.plistFiles.length; c++) d = b.plistFiles[c],
                cc.spriteFrameCache.removeSpriteFramesFromFile(d);
            delete this._relativeDatas[a];
            ccs.dataReaderHelper.removeConfigFile(a)
        }
    },
    addArmatureData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.armatures.push(a);
        this._armatureDatas[a] = b
    },
    getArmatureData: function(a) {
        var b = null;
        this._armatureDatas && (b = this._armatureDatas[a]);
        return b
    },
    removeArmatureData: function(a) {
        this._armatureDatas[a] && delete this._armatureDatas[a]
    },
    addAnimationData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.animations.push(a);
        this._animationDatas[a] =
            b
    },
    getAnimationData: function(a) {
        var b = null;
        this._animationDatas[a] && (b = this._animationDatas[a]);
        return b
    },
    removeAnimationData: function(a) {
        this._animationDatas[a] && delete this._animationDatas[a]
    },
    addTextureData: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.textures.push(a);
        this._textureDatas[a] = b
    },
    getTextureData: function(a) {
        var b = null;
        this._textureDatas && (b = this._textureDatas[a]);
        return b
    },
    removeTextureData: function(a) {
        this._textureDatas[a] && delete this._textureDatas[a]
    },
    addArmatureFileInfo: function() {
        var a,
            b, c;
        switch (arguments.length) {
            case 1:
                c = arguments[0];
                this.addRelativeData(c);
                this._autoLoadSpriteFile = !0;
                ccs.dataReaderHelper.addDataFromFile(c);
                break;
            case 3:
                a = arguments[0], b = arguments[1], c = arguments[2], this.addRelativeData(c), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFile(c), this.addSpriteFrameFromFile(b, a)
        }
    },
    addArmatureFileInfoAsync: function() {
        var a, b, c, d, e;
        switch (arguments.length) {
            case 3:
                c = arguments[0];
                d = arguments[2];
                e = arguments[1];
                this.addRelativeData(c);
                this._autoLoadSpriteFile = !0;
                ccs.dataReaderHelper.addDataFromFileAsync("", "", c, e, d);
                break;
            case 5:
                a = arguments[0], b = arguments[1], c = arguments[2], d = arguments[4], e = arguments[3], this.addRelativeData(c), this._autoLoadSpriteFile = !1, ccs.dataReaderHelper.addDataFromFileAsync(a, b, c, e, d), this.addSpriteFrameFromFile(b, a)
        }
    },
    addSpriteFrameFromFile: function(a, b, c) {
        (c = this.getRelativeData(c)) && c.plistFiles.push(a);
        ccs.spriteFrameCacheHelper.addSpriteFrameFromFile(a, b)
    },
    isAutoLoadSpriteFile: function() {
        return this._autoLoadSpriteFile
    },
    getArmatureDatas: function() {
        return this._armatureDatas
    },
    getAnimationDatas: function() {
        return this._animationDatas
    },
    getTextureDatas: function() {
        return this._textureDatas
    },
    addRelativeData: function(a) {
        this._relativeDatas[a] || (this._relativeDatas[a] = new ccs.RelativeData)
    },
    getRelativeData: function(a) {
        return this._relativeDatas[a]
    },
    clear: function() {
        this._animationDatas = {};
        this._armatureDatas = {};
        this._textureDatas = {};
        ccs.spriteFrameCacheHelper.clear();
        ccs.dataReaderHelper.clear()
    }
};
ccs.BLEND_TYPE_NORMAL = 0;
ccs.BLEND_TYPE_LAYER = 1;
ccs.BLEND_TYPE_DARKEN = 2;
ccs.BLEND_TYPE_MULTIPLY = 3;
ccs.BLEND_TYPE_LIGHTEN = 4;
ccs.BLEND_TYPE_SCREEN = 5;
ccs.BLEND_TYPE_OVERLAY = 6;
ccs.BLEND_TYPE_HIGHLIGHT = 7;
ccs.BLEND_TYPE_ADD = 8;
ccs.BLEND_TYPE_SUBTRACT = 9;
ccs.BLEND_TYPE_DIFFERENCE = 10;
ccs.BLEND_TYPE_INVERT = 11;
ccs.BLEND_TYPE_ALPHA = 12;
ccs.BLEND_TYPE_ERASE = 13;
ccs.DISPLAY_TYPE_SPRITE = 0;
ccs.DISPLAY_TYPE_ARMATURE = 1;
ccs.DISPLAY_TYPE_PARTICLE = 2;
ccs.DISPLAY_TYPE_MAX = 3;
ccs.BaseData = ccs.Class.extend({
    x: 0,
    y: 0,
    zOrder: 0,
    skewX: 0,
    skewY: 0,
    scaleX: 1,
    scaleY: 1,
    tweenRotate: 0,
    isUseColorInfo: !1,
    r: 255,
    g: 255,
    b: 255,
    a: 255,
    ctor: function() {
        this.skewY = this.skewX = this.zOrder = this.y = this.x = 0;
        this.scaleY = this.scaleX = 1;
        this.tweenRotate = 0;
        this.isUseColorInfo = !1;
        this.a = this.b = this.g = this.r = 255
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        this.zOrder = a.zOrder;
        this.scaleX = a.scaleX;
        this.scaleY = a.scaleY;
        this.skewX = a.skewX;
        this.skewY = a.skewY;
        this.tweenRotate = a.tweenRotate;
        this.isUseColorInfo = a.isUseColorInfo;
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a
    },
    setColor: function(a) {
        this.r = a.r;
        this.g = a.g;
        this.b = a.b;
        this.a = a.a
    },
    getColor: function() {
        return cc.color(this.r, this.g, this.b, this.a)
    },
    subtract: function(a, b, c) {
        this.x = b.x - a.x;
        this.y = b.y - a.y;
        this.scaleX = b.scaleX - a.scaleX;
        this.scaleY = b.scaleY - a.scaleY;
        this.skewX = b.skewX - a.skewX;
        this.skewY = b.skewY - a.skewY;
        this.isUseColorInfo || a.isUseColorInfo || b.isUseColorInfo ? (this.a = b.a - a.a, this.r = b.r - a.r, this.g = b.g - a.g, this.b = b.b - a.b, this.isUseColorInfo = !0) : (this.a = this.r =
            this.g = this.b = 0, this.isUseColorInfo = !1);
        c && (this.skewX > ccs.M_PI && (this.skewX -= ccs.DOUBLE_PI), this.skewX < -ccs.M_PI && (this.skewX += ccs.DOUBLE_PI), this.skewY > ccs.M_PI && (this.skewY -= ccs.DOUBLE_PI), this.skewY < -ccs.M_PI && (this.skewY += ccs.DOUBLE_PI));
        b.tweenRotate && (this.skewX += b.tweenRotate * ccs.PI * 2, this.skewY -= b.tweenRotate * ccs.PI * 2)
    }
});
ccs.DisplayData = ccs.Class.extend({
    displayType: ccs.DISPLAY_TYPE_MAX,
    displayName: "",
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_MAX
    },
    changeDisplayToTexture: function(a) {
        var b = a.lastIndexOf("."); - 1 !== b && (a = a.substring(0, b));
        return a
    },
    copy: function(a) {
        this.displayName = a.displayName;
        this.displayType = a.displayType
    }
});
ccs.SpriteDisplayData = ccs.DisplayData.extend({
    skinData: null,
    ctor: function() {
        this.skinData = new ccs.BaseData;
        this.displayType = ccs.DISPLAY_TYPE_SPRITE
    },
    copy: function(a) {
        ccs.DisplayData.prototype.copy.call(this, a);
        this.skinData = a.skinData
    }
});
ccs.ArmatureDisplayData = ccs.DisplayData.extend({
    ctor: function() {
        this.displayName = "";
        this.displayType = ccs.DISPLAY_TYPE_ARMATURE
    }
});
ccs.ParticleDisplayData = ccs.DisplayData.extend({
    ctor: function() {
        this.displayType = ccs.DISPLAY_TYPE_PARTICLE
    }
});
ccs.BoneData = ccs.BaseData.extend({
    displayDataList: null,
    name: "",
    parentName: "",
    boneDataTransform: null,
    ctor: function() {
        this.displayDataList = [];
        this.parentName = this.name = "";
        this.boneDataTransform = null
    },
    init: function() {
        this.displayDataList.length = 0;
        return !0
    },
    addDisplayData: function(a) {
        this.displayDataList.push(a)
    },
    getDisplayData: function(a) {
        return this.displayDataList[a]
    }
});
ccs.ArmatureData = ccs.Class.extend({
    boneDataDic: null,
    name: "",
    dataVersion: 0.1,
    ctor: function() {
        this.boneDataDic = {};
        this.name = "";
        this.dataVersion = 0.1
    },
    init: function() {
        return !0
    },
    addBoneData: function(a) {
        this.boneDataDic[a.name] = a
    },
    getBoneDataDic: function() {
        return this.boneDataDic
    },
    getBoneData: function(a) {
        return this.boneDataDic[a]
    }
});
ccs.FrameData = ccs.BaseData.extend({
    duration: 0,
    tweenEasing: 0,
    easingParamNumber: 0,
    easingParams: null,
    displayIndex: -1,
    movement: "",
    event: "",
    sound: "",
    soundEffect: "",
    blendFunc: null,
    frameID: 0,
    isTween: !0,
    ctor: function() {
        ccs.BaseData.prototype.ctor.call(this);
        this.duration = 1;
        this.tweenEasing = ccs.TweenType.LINEAR;
        this.easingParamNumber = 0;
        this.easingParams = [];
        this.displayIndex = 0;
        this.soundEffect = this.sound = this.event = this.movement = "";
        this.blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.frameID = 0;
        this.isTween = !0
    },
    copy: function(a) {
        ccs.BaseData.prototype.copy.call(this, a);
        this.duration = a.duration;
        this.displayIndex = a.displayIndex;
        this.tweenEasing = a.tweenEasing;
        this.easingParamNumber = a.easingParamNumber;
        if (0 !== this.easingParamNumber)
            for (var b = this.easingParams.length = 0; b < this.easingParamNumber; b++) this.easingParams[b] = a.easingParams[b];
        this.blendFunc = a.blendFunc;
        this.isTween = a.isTween
    }
});
ccs.MovementBoneData = ccs.Class.extend({
    delay: 0,
    scale: 1,
    duration: 0,
    frameList: null,
    name: "",
    ctor: function() {
        this.delay = 0;
        this.scale = 1;
        this.duration = 0;
        this.frameList = [];
        this.name = ""
    },
    init: function() {
        return !0
    },
    addFrameData: function(a) {
        this.frameList.push(a)
    },
    getFrameData: function(a) {
        return this.frameList[a]
    }
});
ccs.MovementData = function() {
    this.name = "";
    this.duration = 0;
    this.scale = 1;
    this.durationTween = this.durationTo = 0;
    this.loop = !0;
    this.tweenEasing = ccs.TweenType.LINEAR;
    this.movBoneDataDic = {}
};
ccs.MovementData.prototype.addMovementBoneData = function(a) {
    this.movBoneDataDic[a.name] = a
};
ccs.MovementData.prototype.getMovementBoneData = function(a) {
    return this.movBoneDataDic[a]
};
ccs.AnimationData = function() {
    this.movementDataDic = {};
    this.movementNames = [];
    this.name = ""
};
ccs.AnimationData.prototype.addMovement = function(a) {
    this.movementDataDic[a.name] = a;
    this.movementNames.push(a.name)
};
ccs.AnimationData.prototype.getMovement = function(a) {
    return this.movementDataDic[a]
};
ccs.AnimationData.prototype.getMovementCount = function() {
    return Object.keys(this.movementDataDic).length
};
ccs.ContourVertex2 = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
};
ccs.ContourData = function() {
    this.vertexList = []
};
ccs.ContourData.prototype.init = function() {
    this.vertexList.length = 0;
    return !0
};
ccs.ContourData.prototype.addVertex = function(a) {
    this.vertexList.push(a)
};
ccs.TextureData = function() {
    this.width = this.height = 0;
    this.pivotY = this.pivotX = 0.5;
    this.name = "";
    this.contourDataList = []
};
ccs.TextureData.prototype.init = function() {
    this.contourDataList.length = 0
};
ccs.TextureData.prototype.addContourData = function(a) {
    this.contourDataList.push(a)
};
ccs.TextureData.prototype.getContourData = function(a) {
    return this.contourDataList[a]
};
ccs.DecorativeDisplay = ccs.Class.extend({
    _display: null,
    _colliderDetector: null,
    _displayData: null,
    ctor: function() {
        this._displayData = this._colliderDetector = this._display = null
    },
    init: function() {
        return !0
    },
    setDisplay: function(a) {
        a._parent && (a._parent.removeChild(a), delete a._parent);
        this._display = a
    },
    getDisplay: function() {
        return this._display
    },
    setColliderDetector: function(a) {
        this._colliderDetector = a
    },
    getColliderDetector: function() {
        return this._colliderDetector
    },
    setDisplayData: function(a) {
        this._displayData =
            a
    },
    getDisplayData: function() {
        return this._displayData
    },
    release: function() {
        this._colliderDetector = this._displayData = this._display = null
    }
});
ccs.DecorativeDisplay.create = function() {
    return new ccs.DecorativeDisplay
};
ccs.displayFactory = {
    addDisplay: function(a, b, c) {
        switch (c.displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.addSpriteDisplay(a, b, c);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.addParticleDisplay(a, b, c);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.addArmatureDisplay(a, b, c)
        }
    },
    createDisplay: function(a, b) {
        switch (b.getDisplayData().displayType) {
            case ccs.DISPLAY_TYPE_SPRITE:
                this.createSpriteDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_PARTICLE:
                this.createParticleDisplay(a, b);
                break;
            case ccs.DISPLAY_TYPE_ARMATURE:
                this.createArmatureDisplay(a,
                    b)
        }
    },
    _helpTransform: {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
    },
    updateDisplay: function(a, b, c) {
        var d = a.getDisplayRenderNode();
        if (d) {
            switch (a.getDisplayRenderNodeType()) {
                case ccs.DISPLAY_TYPE_SPRITE:
                    c && d.updateArmatureTransform();
                    break;
                case ccs.DISPLAY_TYPE_PARTICLE:
                    this.updateParticleDisplay(a, d, b);
                    break;
                case ccs.DISPLAY_TYPE_ARMATURE:
                    this.updateArmatureDisplay(a, d, b);
                    break;
                default:
                    b = a.getNodeToArmatureTransform(), d.setAdditionalTransform(b)
            }
            if ((ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) &&
                c && (d = a.getDisplayManager().getCurrentDecorativeDisplay(), c = d.getColliderDetector())) {
                b = d.getDisplay();
                var e = b.getNodeToParentTransform(),
                    d = this._helpTransform;
                d.a = e.a;
                d.b = e.b;
                d.c = e.c;
                d.d = e.d;
                d.tx = e.tx;
                d.ty = e.ty;
                b = cc.pointApplyAffineTransform(b.getAnchorPointInPoints(), d);
                d.tx = b.x;
                d.ty = b.y;
                a = cc.affineTransformConcat(d, a.getArmature().getNodeToParentTransform());
                c.updateTransform(a)
            }
        }
    },
    addSpriteDisplay: function(a, b, c) {
        var d = new ccs.SpriteDisplayData;
        d.copy(c);
        b.setDisplayData(d);
        this.createSpriteDisplay(a,
            b)
    },
    createSpriteDisplay: function(a, b) {
        var c = null,
            d = b.getDisplayData(),
            c = d.displayName,
            e = c.lastIndexOf("."); - 1 !== e && (c = c.substring(0, e));
        c = "" === c ? new ccs.Skin : new ccs.Skin("#" + c + ".png");
        b.setDisplay(c);
        c.setBone(a);
        this.initSpriteDisplay(a, b, d.displayName, c);
        (e = a.getArmature()) && (e.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? c.setSkinData(d.skinData) : c.setSkinData(a.boneData))
    },
    initSpriteDisplay: function(a, b, c, d) {
        var e = c.lastIndexOf("."); - 1 !== e && (c = c.substring(0, e));
        (c = ccs.armatureDataManager.getTextureData(c)) &&
        d.setAnchorPoint(cc.p(c.pivotX, c.pivotY));
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && c && 0 < c.contourDataList.length && (a = new ccs.ColliderDetector(a), a.addContourDataList(c.contourDataList), b.setColliderDetector(a))
    },
    addArmatureDisplay: function(a, b, c) {
        var d = new ccs.ArmatureDisplayData;
        d.copy(c);
        b.setDisplayData(d);
        this.createArmatureDisplay(a, b)
    },
    createArmatureDisplay: function(a, b) {
        var c = b.getDisplayData(),
            c = new ccs.Armature(c.displayName, a);
        b.setDisplay(c)
    },
    updateArmatureDisplay: function(a,
        b, c) {
        b && (b.sortAllChildren(), b.update(c))
    },
    addParticleDisplay: function(a, b, c) {
        var d = new ccs.ParticleDisplayData;
        d.copy(c);
        b.setDisplayData(d);
        this.createParticleDisplay(a, b)
    },
    createParticleDisplay: function(a, b) {
        var c = b.getDisplayData(),
            c = new cc.ParticleSystem(c.displayName);
        c.removeFromParent();
        c.cleanup();
        a.getArmature() && c.setParent(a.getArmature());
        b.setDisplay(c)
    },
    updateParticleDisplay: function(a, b, c) {
        var d = new ccs.BaseData;
        ccs.TransformHelp.matrixToNode(a.nodeToArmatureTransform(), d);
        b.setPosition(d.x,
            d.y);
        b.setScaleX(d.scaleX);
        b.setScaleY(d.scaleY);
        b.update(c)
    }
};
ccs.DisplayManager = ccs.Class.extend({
    _decoDisplayList: null,
    _currentDecoDisplay: null,
    _displayRenderNode: null,
    _displayIndex: null,
    _forceChangeDisplay: !1,
    _bone: null,
    _visible: !0,
    _displayType: null,
    ctor: function(a) {
        this._decoDisplayList = [];
        this._displayIndex = this._displayRenderNode = this._currentDecoDisplay = null;
        this._forceChangeDisplay = !1;
        this._bone = null;
        this._visible = !0;
        this._displayType = ccs.DISPLAY_TYPE_MAX;
        a && ccs.DisplayManager.prototype.init.call(this, a)
    },
    init: function(a) {
        this._bone = a;
        this.initDisplayList(a.getBoneData());
        return !0
    },
    addDisplay: function(a, b) {
        var c, d = this._decoDisplayList;
        0 <= b && b < d.length ? c = d[b] : (c = new ccs.DecorativeDisplay, d.push(c));
        if (a instanceof ccs.DisplayData) ccs.displayFactory.addDisplay(this._bone, c, a);
        else {
            var e = null;
            if (a instanceof ccs.Skin) {
                a.setBone(this._bone);
                e = new ccs.SpriteDisplayData;
                ccs.displayFactory.initSpriteDisplay(this._bone, c, a.getDisplayName(), a);
                var f = c.getDisplayData();
                if (f instanceof ccs.SpriteDisplayData) a.setSkinData(f.skinData), e.skinData = f.skinData;
                else {
                    for (var f = !1, g =
                            d.length - 2; 0 <= g; g--) {
                        var h = d[g].getDisplayData();
                        if (h instanceof ccs.SpriteDisplayData) {
                            f = !0;
                            a.setSkinData(h.skinData);
                            e.skinData = h.skinData;
                            break
                        }
                    }
                    f || a.setSkinData(new ccs.BaseData)
                }
            } else a instanceof cc.ParticleSystem ? (e = new ccs.ParticleDisplayData, a.removeFromParent(), a.cleanup(), (d = this._bone.getArmature()) && a.setParent(d)) : a instanceof ccs.Armature ? (e = new ccs.ArmatureDisplayData, e.displayName = a.getName(), a.setParentBone(this._bone)) : e = new ccs.DisplayData;
            c.setDisplay(a);
            c.setDisplayData(e)
        }
        b ===
            this._displayIndex && (this._displayIndex = -1, this.changeDisplayWithIndex(b, !1))
    },
    _addDisplayOther: function(a, b) {
        var c = null;
        if (b instanceof ccs.Skin) {
            b.setBone(this._bone);
            c = new ccs.SpriteDisplayData;
            c.displayName = b.getDisplayName();
            ccs.displayFactory.initSpriteDisplay(this._bone, a, b.getDisplayName(), b);
            var d = a.getDisplayData();
            if (d instanceof ccs.SpriteDisplayData) b.setSkinData(d.skinData);
            else {
                for (var d = !1, e = this._decoDisplayList.length - 2; 0 <= e; e--) {
                    var f = this._decoDisplayList[e].getDisplayData();
                    if (f) {
                        d = !0;
                        b.setSkinData(f.skinData);
                        c.skinData = f.skinData;
                        break
                    }
                }
                d || b.setSkinData(new ccs.BaseData);
                b.setSkinData(new ccs.BaseData)
            }
        } else b instanceof cc.ParticleSystem ? (c = new ccs.ParticleDisplayData, c.displayName = b._plistFile) : b instanceof ccs.Armature ? (c = new ccs.ArmatureDisplayData, c.displayName = b.getName(), b.setParentBone(this._bone)) : c = new ccs.DisplayData;
        a.setDisplay(b);
        a.setDisplayData(c)
    },
    removeDisplay: function(a) {
        this._decoDisplayList.splice(a, 1);
        a === this._displayIndex && (this.setCurrentDecorativeDisplay(null),
            this._displayIndex = -1)
    },
    getDecorativeDisplayList: function() {
        return this._decoDisplayList
    },
    changeDisplayWithIndex: function(a, b) {
        a >= this._decoDisplayList.length ? cc.log("the index value is out of range") : (this._forceChangeDisplay = b, this._displayIndex !== a && (this._displayIndex = a, 0 > a ? this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this.setCurrentDecorativeDisplay(null)) : this.setCurrentDecorativeDisplay(this._decoDisplayList[a])))
    },
    changeDisplayWithName: function(a, b) {
        for (var c = this._decoDisplayList,
                d = 0; d < c.length; d++)
            if (c[d].getDisplayData().displayName === a) {
                this.changeDisplayWithIndex(d, b);
                break
            }
    },
    setCurrentDecorativeDisplay: function(a) {
        var b = this._currentDecoDisplay;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!1);
        b = this._currentDecoDisplay = a;
        (ccs.ENABLE_PHYSICS_CHIPMUNK_DETECT || ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) && b && b.getColliderDetector() && b.getColliderDetector().setActive(!0);
        a = b ? b.getDisplay() :
            null;
        var b = this._displayRenderNode,
            c = this._bone;
        b && (b instanceof ccs.Armature && c.setChildArmature(null), b.removeFromParent(!0));
        (this._displayRenderNode = a) ? (a instanceof ccs.Armature ? (this._bone.setChildArmature(a), a.setParentBone(this._bone)) : a instanceof cc.ParticleSystem && (a instanceof ccs.Armature ? (c.setChildArmature(a), a.setParentBone(c)) : a instanceof cc.ParticleSystem && a.resetSystem()), a.setColor(c.getDisplayedColor()), a.setOpacity(c.getDisplayedOpacity()), this._displayRenderNode.setVisible(this._visible),
            this._displayType = this._currentDecoDisplay.getDisplayData().displayType) : this._displayType = ccs.DISPLAY_TYPE_MAX;
        cc.renderer.childrenOrderDirty = !0
    },
    getDisplayRenderNode: function() {
        return this._displayRenderNode
    },
    getDisplayRenderNodeType: function() {
        return this._displayType
    },
    getCurrentDisplayIndex: function() {
        return this._displayIndex
    },
    getCurrentDecorativeDisplay: function() {
        return this._currentDecoDisplay
    },
    getDecorativeDisplayByIndex: function(a) {
        return this._decoDisplayList[a]
    },
    initDisplayList: function(a) {
        this._decoDisplayList.length =
            0;
        if (a) {
            a = a.displayDataList;
            for (var b = this._decoDisplayList, c = this._bone, d = 0; d < a.length; d++) {
                var e = a[d],
                    f = new ccs.DecorativeDisplay;
                f.setDisplayData(e);
                ccs.displayFactory.createDisplay(c, f);
                b.push(f)
            }
        }
    },
    containPoint: function(a, b) {
        if (!this._visible || 0 > this._displayIndex) return !1;
        void 0 !== b && (a = cc.p(a, b));
        if (this._currentDecoDisplay.getDisplayData().displayType === ccs.DISPLAY_TYPE_SPRITE) {
            var c = this._currentDecoDisplay.getDisplay(),
                c = c.getChildByTag(0);
            return ccs.SPRITE_CONTAIN_POINT_WITH_RETURN(c, a)
        }
        return !1
    },
    setVisible: function(a) {
        this._displayRenderNode && (this._visible = a, this._displayRenderNode.setVisible(a))
    },
    isVisible: function() {
        return this._visible
    },
    getContentSize: function() {
        return this._displayRenderNode ? this._displayRenderNode.getContentSize() : cc.size(0, 0)
    },
    getBoundingBox: function() {
        return this._displayRenderNode ? this._displayRenderNode.getBoundingBox() : cc.rect(0, 0, 0, 0)
    },
    getAnchorPoint: function() {
        return this._displayRenderNode ? this._displayRenderNode.getAnchorPoint() : cc.p(0, 0)
    },
    getAnchorPointInPoints: function() {
        return this._displayRenderNode ?
            this._displayRenderNode.getAnchorPointInPoints() : cc.p(0, 0)
    },
    getForceChangeDisplay: function() {
        return this._forceChangeDisplay
    },
    release: function() {
        this._decoDisplayList = null;
        this._displayRenderNode && (this._displayRenderNode.removeFromParent(!0), this._displayRenderNode = null)
    }
});
ccs.DisplayManager.create = function(a) {
    return new ccs.DisplayManager(a)
};
ccs.Skin = ccs.Sprite.extend({
    _skinData: null,
    bone: null,
    _skinTransform: null,
    _displayName: "",
    _armature: null,
    _className: "Skin",
    ctor: function(a, b) {
        cc.Sprite.prototype.ctor.call(this);
        this.bone = this._skinData = null;
        this._displayName = "";
        this._skinTransform = cc.affineTransformIdentity();
        this._armature = null;
        null == a || "" === a ? ccs.Skin.prototype.init.call(this) : "#" === a[0] ? ccs.Skin.prototype.initWithSpriteFrameName.call(this, a.substr(1)) : ccs.Skin.prototype.initWithFile.call(this, a, b)
    },
    initWithSpriteFrameName: function(a) {
        if ("" ===
            a) return !1;
        var b = cc.spriteFrameCache.getSpriteFrame(a),
            c = !0;
        b ? this.initWithSpriteFrame(b) : (cc.log("Can't find CCSpriteFrame with %s. Please check your .plist file", a), c = !1);
        this._displayName = a;
        return c
    },
    initWithFile: function(a, b) {
        var c = b ? cc.Sprite.prototype.initWithFile.call(this, a, b) : cc.Sprite.prototype.initWithFile.call(this, a);
        this._displayName = a;
        return c
    },
    setSkinData: function(a) {
        this._skinData = a;
        this.setScaleX(a.scaleX);
        this.setScaleY(a.scaleY);
        this.setRotationX(cc.radiansToDegrees(a.skewX));
        this.setRotationY(cc.radiansToDegrees(-a.skewY));
        this.setPosition(a.x, a.y);
        a = this.getNodeToParentTransform ? this.getNodeToParentTransform() : this.nodeToParentTransform();
        var b = this._skinTransform;
        b.a = a.a;
        b.b = a.b;
        b.c = a.c;
        b.d = a.d;
        b.tx = a.tx;
        b.ty = a.ty;
        this.updateArmatureTransform()
    },
    getSkinData: function() {
        return this._skinData
    },
    updateArmatureTransform: function() {
        this._renderCmd.updateArmatureTransform()
    },
    getNodeToWorldTransform: function() {
        return this._renderCmd.getNodeToWorldTransform()
    },
    getNodeToWorldTransformAR: function() {
        return this._renderCmd.getNodeToWorldTransformAR()
    },
    setBone: function(a) {
        this.bone = a;
        if (a = this.bone.getArmature()) this._armature = a
    },
    getBone: function() {
        return this.bone
    },
    getDisplayName: function() {
        return this._displayName
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Skin.CanvasRenderCmd(this) : new ccs.Skin.WebGLRenderCmd(this)
    }
});
_p = ccs.Skin.prototype;
cc.defineGetterSetter(_p, "skinData", _p.getSkinData, _p.setSkinData);
cc.defineGetterSetter(_p, "displayName", _p.getDisplayName);
_p = null;
ccs.Skin.create = function(a, b) {
    return new ccs.Skin(a, b)
};
ccs.Skin.createWithSpriteFrameName = function(a) {
    return new ccs.Skin("#" + a)
};
(function() {
    ccs.Skin.RenderCmd = {
        updateArmatureTransform: function() {
            var a = this._node;
            this._transform = cc.affineTransformConcat(a._skinTransform, a.bone.getNodeToArmatureTransform());
            this._dirtyFlag ^= this._dirtyFlag & cc.Node._dirtyFlags.transformDirty
        },
        getNodeToWorldTransform: function() {
            return cc.affineTransformConcat(this._transform, this._node.bone.getArmature().getNodeToWorldTransform())
        },
        getNodeToWorldTransformAR: function() {
            var a = this._transform,
                c = this._node;
            this._anchorPointInPoints = cc.pointApplyAffineTransform(this._anchorPointInPoints,
                a);
            a.tx = this._anchorPointInPoints.x;
            a.ty = this._anchorPointInPoints.y;
            return cc.affineTransformConcat(a, c.bone.getArmature().getNodeToWorldTransform())
        }
    };
    ccs.Skin.CanvasRenderCmd = function(a) {
        cc.Sprite.CanvasRenderCmd.call(this, a);
        this._needDraw = !0
    };
    var a = ccs.Skin.CanvasRenderCmd.prototype = Object.create(cc.Sprite.CanvasRenderCmd.prototype);
    cc.inject(ccs.Skin.RenderCmd, a);
    a.constructor = ccs.Skin.CanvasRenderCmd
})();
(function() {
    ccs.Skin.WebGLRenderCmd = function(a) {
        cc.Sprite.WebGLRenderCmd.call(this, a)
    };
    var a = ccs.Skin.WebGLRenderCmd.prototype = Object.create(cc.Sprite.WebGLRenderCmd.prototype);
    cc.inject(ccs.Skin.RenderCmd, a);
    a.constructor = ccs.Skin.WebGLRenderCmd;
    a.updateTransform = function() {
        var a = this._node,
            c = this._quad;
        if (a._visible) {
            var d = this.getNodeToParentTransform(),
                e = a._rect,
                f = a._offsetPosition.x,
                g = a._offsetPosition.y,
                h = f + e.width,
                k = g + e.height,
                m = d.tx,
                n = d.ty,
                p = d.a,
                s = d.b,
                r = d.d,
                u = -d.c,
                d = f * p - g * u + m,
                e = f * s + g * r + n,
                t = h * p - g * u + m,
                g = h * s + g * r + n,
                v = h * p - k * u + m,
                h = h * s + k * r + n,
                m = f * p - k * u + m,
                f = f * s + k * r + n,
                k = a._vertexZ;
            cc.SPRITEBATCHNODE_RENDER_SUBPIXEL || (d |= 0, e |= 0, t |= 0, g |= 0, v |= 0, h |= 0, m |= 0, f |= 0);
            this.SET_VERTEX3F(c.bl.vertices, d, e, k);
            this.SET_VERTEX3F(c.br.vertices, t, g, k);
            this.SET_VERTEX3F(c.tl.vertices, m, f, k);
            this.SET_VERTEX3F(c.tr.vertices, v, h, k)
        } else c.br.vertices = c.tl.vertices = c.tr.vertices = c.bl.vertices = {
            x: 0,
            y: 0,
            z: 0
        };
        a.textureAtlas && a.textureAtlas.updateQuad(c, a.textureAtlas.getTotalQuads());
        this._quadDirty = !0
    };
    a.SET_VERTEX3F =
        function(a, c, d, e) {
            a.x = c;
            a.y = d;
            a.z = e
        };
    a.rendering = function(a) {
        var c = this._node;
        if (c._textureLoaded) {
            a = a || cc._renderContext;
            var d = c._texture;
            d && d._textureLoaded && (this._shaderProgram.use(), this._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4(), cc.glBlendFunc(c._blendFunc.src, c._blendFunc.dst), cc.glBindTexture2DN(0, d), cc.glEnableVertexAttribs(cc.VERTEX_ATTRIB_FLAG_POS_COLOR_TEX), a.bindBuffer(a.ARRAY_BUFFER, this._quadWebBuffer), this._quadDirty && (a.bufferData(a.ARRAY_BUFFER, this._quad.arrayBuffer,
                a.DYNAMIC_DRAW), this._quadDirty = !1), a.vertexAttribPointer(0, 3, a.FLOAT, !1, 24, 0), a.vertexAttribPointer(1, 4, a.UNSIGNED_BYTE, !0, 24, 12), a.vertexAttribPointer(2, 2, a.FLOAT, !1, 24, 16), a.drawArrays(a.TRIANGLE_STRIP, 0, 4));
            cc.g_NumberOfDraws++;
            if (0 !== cc.SPRITE_DEBUG_DRAW || c._showNode) 1 === cc.SPRITE_DEBUG_DRAW || c._showNode ? (c = this._quad, c = [cc.p(c.tl.vertices.x, c.tl.vertices.y), cc.p(c.bl.vertices.x, c.bl.vertices.y), cc.p(c.br.vertices.x, c.br.vertices.y), cc.p(c.tr.vertices.x, c.tr.vertices.y)], cc._drawingUtil.drawPoly(c,
                4, !0)) : 2 === cc.SPRITE_DEBUG_DRAW && (a = c.getTextureRect(), c = c.getOffsetPosition(), c = [cc.p(c.x, c.y), cc.p(c.x + a.width, c.y), cc.p(c.x + a.width, c.y + a.height), cc.p(c.x, c.y + a.height)], cc._drawingUtil.drawPoly(c, 4, !0))
        }
    }
})();
ccs.ANIMATION_TYPE_SINGLE_FRAME = -4;
ccs.ANIMATION_TYPE_NO_LOOP = -3;
ccs.ANIMATION_TYPE_TO_LOOP_FRONT = -2;
ccs.ANIMATION_TYPE_TO_LOOP_BACK = -1;
ccs.ANIMATION_TYPE_LOOP_FRONT = 0;
ccs.ANIMATION_TYPE_LOOP_BACK = 1;
ccs.ANIMATION_TYPE_MAX = 2;
ccs.ProcessBase = ccs.Class.extend({
    _processScale: 1,
    _isComplete: !0,
    _isPause: !0,
    _isPlaying: !1,
    _currentPercent: 0,
    _rawDuration: 0,
    _loopType: 0,
    _tweenEasing: 0,
    animationInternal: null,
    _currentFrame: 0,
    _durationTween: 0,
    _nextFrameIndex: 0,
    _curFrameIndex: null,
    _isLoopBack: !1,
    ctor: function() {
        this._processScale = 1;
        this._isPause = this._isComplete = !0;
        this._isPlaying = !1;
        this._rawDuration = this._durationTween = this._currentPercent = this._currentFrame = 0;
        this._loopType = ccs.ANIMATION_TYPE_LOOP_BACK;
        this._tweenEasing = ccs.TweenType.LINEAR;
        this.animationInternal = 1 / 60;
        this._durationTween = this._curFrameIndex = 0;
        this._isLoopBack = !1
    },
    pause: function() {
        this._isPause = !0;
        this._isPlaying = !1
    },
    resume: function() {
        this._isPause = !1;
        this._isPlaying = !0
    },
    stop: function() {
        this._isComplete = !0;
        this._isPlaying = !1
    },
    play: function(a, b, c, d) {
        this._isPause = this._isComplete = !1;
        this._isPlaying = !0;
        this._currentFrame = 0;
        this._nextFrameIndex = a;
        this._tweenEasing = d
    },
    update: function(a) {
        if (!(this._isComplete || this._isPause || 0 >= this._rawDuration || 1 < a)) {
            var b = void 0 === this._nextFrameIndex ?
                0 : this._nextFrameIndex,
                c = this._currentFrame;
            0 >= b ? (this._currentPercent = 1, c = 0) : (c += a / this.animationInternal * this._processScale, this._currentPercent = c / b, c = ccs.fmodf(c, b));
            this._currentFrame = c;
            this.updateHandler()
        }
    },
    gotoFrame: function(a) {
        var b = this._loopType;
        b === ccs.ANIMATION_TYPE_NO_LOOP ? b = ccs.ANIMATION_TYPE_MAX : b === ccs.ANIMATION_TYPE_TO_LOOP_FRONT && (b = ccs.ANIMATION_TYPE_LOOP_FRONT);
        this._loopType = b;
        this._curFrameIndex = a;
        this._nextFrameIndex = this._durationTween
    },
    getCurrentFrameIndex: function() {
        return this._curFrameIndex =
            (this._rawDuration - 1) * this._currentPercent
    },
    updateHandler: function() {},
    isPause: function() {
        return this._isPause
    },
    isComplete: function() {
        return this._isComplete
    },
    getCurrentPercent: function() {
        return this._currentPercent
    },
    getRawDuration: function() {
        return this._rawDuration
    },
    getLoop: function() {
        return this._loopType
    },
    getTweenEasing: function() {
        return this._tweenEasing
    },
    getAnimationInternal: function() {
        return this.animationInternal
    },
    setAnimationInternal: function(a) {
        this.animationInternal = a
    },
    getProcessScale: function() {
        return this._processScale
    },
    setProcessScale: function(a) {
        this._processScale = a
    },
    isPlaying: function() {
        return this._isPlaying
    }
});
_p = ccs.ProcessBase.prototype;
cc.defineGetterSetter(_p, "currentFrameIndex", _p.getCurrentFrameIndex);
cc.defineGetterSetter(_p, "paused", _p.isPause);
cc.defineGetterSetter(_p, "completed", _p.isComplete);
cc.defineGetterSetter(_p, "currentPercent", _p.getCurrentPercent);
cc.defineGetterSetter(_p, "rawDuration", _p.getRawDuration);
cc.defineGetterSetter(_p, "loop", _p.getLoop);
cc.defineGetterSetter(_p, "tweenEasing", _p.getTweenEasing);
cc.defineGetterSetter(_p, "playing", _p.isPlaying);
_p = null;
ccs.MovementEventType = {
    start: 0,
    complete: 1,
    loopComplete: 2
};
ccs.AnimationEvent = ccs.Class.extend({
    _arguments: null,
    _callFunc: null,
    _selectorTarget: null,
    ctor: function(a, b, c) {
        this._data = c;
        this._callFunc = a;
        this._selectorTarget = b
    },
    call: function() {
        this._callFunc && this._callFunc.apply(this._selectorTarget, this._arguments)
    },
    setArguments: function(a) {
        this._arguments = a
    }
});
ccs.MovementEvent = function() {
    this.armature = null;
    this.movementType = ccs.MovementEventType.start;
    this.movementID = ""
};
ccs.FrameEvent = function() {
    this.bone = null;
    this.frameEventName = "";
    this.currentFrameIndex = this.originFrameIndex = 0
};
ccs.ArmatureAnimation = ccs.ProcessBase.extend({
    _animationData: null,
    _movementData: null,
    _armature: null,
    _movementID: "",
    _toIndex: 0,
    _tweenList: null,
    _speedScale: 1,
    _ignoreFrameEvent: !1,
    _frameEventQueue: null,
    _movementEventQueue: null,
    _movementList: null,
    _onMovementList: !1,
    _movementListLoop: !1,
    _movementIndex: 0,
    _movementListDurationTo: -1,
    _movementEventCallFunc: null,
    _frameEventCallFunc: null,
    _movementEventTarget: null,
    _frameEventTarget: null,
    _movementEventListener: null,
    _frameEventListener: null,
    ctor: function(a) {
        ccs.ProcessBase.prototype.ctor.call(this);
        this._tweenList = [];
        this._movementList = [];
        this._frameEventQueue = [];
        this._movementEventQueue = [];
        this._armature = null;
        a && ccs.ArmatureAnimation.prototype.init.call(this, a)
    },
    init: function(a) {
        this._armature = a;
        this._tweenList.length = 0;
        return !0
    },
    pause: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].pause();
        ccs.ProcessBase.prototype.pause.call(this)
    },
    resume: function() {
        for (var a = this._tweenList, b = 0; b < a.length; b++) a[b].resume();
        ccs.ProcessBase.prototype.resume.call(this)
    },
    stop: function() {
        for (var a =
                this._tweenList, b = 0; b < a.length; b++) a[b].stop();
        a.length = 0;
        ccs.ProcessBase.prototype.stop.call(this)
    },
    setAnimationScale: function(a) {
        this.setSpeedScale(a)
    },
    getAnimationScale: function() {
        return this.getSpeedScale()
    },
    setSpeedScale: function(a) {
        if (a !== this._speedScale) {
            this._speedScale = a;
            this._processScale = this._movementData ? this._speedScale * this._movementData.scale : this._speedScale;
            a = this._armature.getBoneDic();
            for (var b in a) {
                var c = a[b];
                c.getTween().setProcessScale(this._processScale);
                c.getChildArmature() &&
                    c.getChildArmature().getAnimation().setSpeedScale(this._processScale)
            }
        }
    },
    getSpeedScale: function() {
        return this._speedScale
    },
    play: function(a, b, c) {
        cc.assert(this._animationData, "this.animationData can not be null");
        this._movementData = this._animationData.getMovement(a);
        cc.assert(this._movementData, "this._movementData can not be null");
        b = void 0 === b ? -1 : b;
        c = void 0 === c ? -1 : c;
        this._rawDuration = this._movementData.duration;
        this._movementID = a;
        this._processScale = this._speedScale * this._movementData.scale;
        b = -1 ===
            b ? this._movementData.durationTo : b;
        a = 0 === this._movementData.durationTween ? this._rawDuration : this._movementData.durationTween;
        var d = this._movementData.tweenEasing;
        c = 0 > c ? this._movementData.loop : c;
        this._onMovementList = !1;
        ccs.ProcessBase.prototype.play.call(this, b, a, c, d);
        0 === this._rawDuration ? this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME : (this._loopType = c ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP, this._durationTween = a);
        this._tweenList.length = 0;
        var e, f = this._armature.getBoneDic(),
            g;
        for (g in f) {
            var h =
                f[g];
            e = this._movementData.movBoneDataDic[h.getName()];
            var k = h.getTween();
            e && 0 < e.frameList.length ? (this._tweenList.push(k), e.duration = this._movementData.duration, k.play(e, b, a, c, d), k.setProcessScale(this._processScale), h.getChildArmature() && h.getChildArmature().getAnimation().setSpeedScale(this._processScale)) : h.isIgnoreMovementBoneData() || (h.getDisplayManager().changeDisplayWithIndex(-1, !1), k.stop())
        }
        this._armature.update(0)
    },
    playByIndex: function(a, b, c, d, e) {
        cc.log("playByIndex is deprecated. Use playWithIndex instead.");
        this.playWithIndex(a, b, d)
    },
    playWithIndex: function(a, b, c) {
        var d = this._animationData.movementNames;
        cc.assert(-1 < a && a < d.length);
        this.play(d[a], b, c)
    },
    playWithNames: function(a, b, c) {
        this._movementListLoop = void 0 === c ? !0 : c;
        this._movementListDurationTo = void 0 === b ? -1 : b;
        this._onMovementList = !0;
        this._movementIndex = 0;
        a instanceof Array ? this._movementList = a : this._movementList.length = 0;
        this.updateMovementList()
    },
    playWithIndexes: function(a, b, c) {
        this._movementList.length = 0;
        this._movementListLoop = void 0 === c ? !0 : c;
        this._movementListDurationTo =
            void 0 === b ? -1 : b;
        this._onMovementList = !0;
        this._movementIndex = 0;
        b = this._animationData.movementNames;
        for (c = 0; c < a.length; c++) this._movementList.push(b[a[c]]);
        this.updateMovementList()
    },
    gotoAndPlay: function(a) {
        if (!this._movementData || 0 > a || a >= this._movementData.duration) cc.log("Please ensure you have played a movement, and the frameIndex is in the range.");
        else {
            var b = this._ignoreFrameEvent;
            this._isPlaying = this._ignoreFrameEvent = !0;
            this._isComplete = this._isPause = !1;
            ccs.ProcessBase.prototype.gotoFrame.call(this,
                a);
            this._currentPercent = this._curFrameIndex / (this._movementData.duration - 1);
            this._currentFrame = this._nextFrameIndex * this._currentPercent;
            for (var c = this._tweenList, d = 0; d < c.length; d++) c[d].gotoAndPlay(a);
            this._armature.update(0);
            this._ignoreFrameEvent = b
        }
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a);
        this.pause()
    },
    getMovementCount: function() {
        return this._animationData.getMovementCount()
    },
    update: function(a) {
        ccs.ProcessBase.prototype.update.call(this, a);
        for (var b = this._tweenList, c = 0; c < b.length; c++) b[c].update(a);
        for (b = this._frameEventQueue; 0 < b.length;) a = b.shift(), this._ignoreFrameEvent = !0, this._frameEventCallFunc && this._frameEventCallFunc.call(this._frameEventTarget, a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._frameEventListener && this._frameEventListener(a.bone, a.frameEventName, a.originFrameIndex, a.currentFrameIndex), this._ignoreFrameEvent = !1;
        for (b = this._movementEventQueue; 0 < b.length;) a = b.shift(), this._movementEventCallFunc && this._movementEventCallFunc.call(this._movementEventTarget,
            a.armature, a.movementType, a.movementID), this._movementEventListener && this._movementEventListener(a.armature, a.movementType, a.movementID)
    },
    updateHandler: function() {
        var a = this._currentPercent;
        if (1 <= a) {
            switch (this._loopType) {
                case ccs.ANIMATION_TYPE_NO_LOOP:
                    this._loopType = ccs.ANIMATION_TYPE_MAX;
                    this._currentFrame = (a - 1) * this._nextFrameIndex;
                    a = this._currentFrame / this._durationTween;
                    if (1 > a) {
                        this._nextFrameIndex = this._durationTween;
                        this.movementEvent(this._armature, ccs.MovementEventType.start, this._movementID);
                        break
                    }
                    break;
                case ccs.ANIMATION_TYPE_MAX:
                case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                    a = 1;
                    this._isComplete = !0;
                    this._isPlaying = !1;
                    this.movementEvent(this._armature, ccs.MovementEventType.complete, this._movementID);
                    this.updateMovementList();
                    break;
                case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                    this._loopType = ccs.ANIMATION_TYPE_LOOP_FRONT;
                    a = ccs.fmodf(a, 1);
                    this._currentFrame = 0 === this._nextFrameIndex ? 0 : ccs.fmodf(this._currentFrame, this._nextFrameIndex);
                    this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1;
                    this.movementEvent(this,
                        ccs.MovementEventType.start, this._movementID);
                    break;
                default:
                    this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex), this._toIndex = 0, this.movementEvent(this._armature, ccs.MovementEventType.loopComplete, this._movementID)
            }
            this._currentPercent = a
        }
    },
    getCurrentMovementID: function() {
        return this._isComplete ? "" : this._movementID
    },
    setMovementEventCallFunc: function(a, b) {
        1 === arguments.length ? this._movementEventListener = a : 2 === arguments.length && (this._movementEventTarget = b, this._movementEventCallFunc =
            a)
    },
    setFrameEventCallFunc: function(a, b) {
        1 === arguments.length ? this._frameEventListener = a : 2 === arguments.length && (this._frameEventTarget = b, this._frameEventCallFunc = a)
    },
    setUserObject: function(a) {
        this._userObject = a
    },
    frameEvent: function(a, b, c, d) {
        if (this._frameEventTarget && this._frameEventCallFunc || this._frameEventListener) {
            var e = new ccs.FrameEvent;
            e.bone = a;
            e.frameEventName = b;
            e.originFrameIndex = c;
            e.currentFrameIndex = d;
            this._frameEventQueue.push(e)
        }
    },
    movementEvent: function(a, b, c) {
        if (this._movementEventTarget &&
            this._movementEventCallFunc || this._movementEventListener) {
            var d = new ccs.MovementEvent;
            d.armature = a;
            d.movementType = b;
            d.movementID = c;
            this._movementEventQueue.push(d)
        }
    },
    updateMovementList: function() {
        if (this._onMovementList) {
            var a, b = this._movementList;
            this._movementListLoop ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++, this._movementIndex >= b.length && (this._movementIndex = 0)) : this._movementIndex < b.length ? (a = b[this._movementIndex], this.play(a, a.durationTo, 0), this._movementIndex++) :
                this._onMovementList = !1;
            this._onMovementList = !0
        }
    },
    setAnimationData: function(a) {
        this._animationData !== a && (this._animationData = a)
    },
    getAnimationData: function() {
        return this._animationData
    },
    getUserObject: function() {
        return this._userObject
    },
    isIgnoreFrameEvent: function() {
        return this._ignoreFrameEvent
    }
});
_p = ccs.ArmatureAnimation.prototype;
cc.defineGetterSetter(_p, "speedScale", _p.getSpeedScale, _p.setSpeedScale);
cc.defineGetterSetter(_p, "animationScale", _p.getAnimationScale, _p.setAnimationScale);
_p = null;
ccs.ArmatureAnimation.create = function(a) {
    return new ccs.ArmatureAnimation(a)
};
ccs.Tween = ccs.ProcessBase.extend({
    _tweenData: null,
    _to: null,
    _from: null,
    _between: null,
    _movementBoneData: null,
    _bone: null,
    _frameTweenEasing: 0,
    _betweenDuration: 0,
    _totalDuration: 0,
    _toIndex: 0,
    _fromIndex: 0,
    _animation: null,
    _passLastFrame: !1,
    ctor: function(a) {
        ccs.ProcessBase.prototype.ctor.call(this);
        this._frameTweenEasing = ccs.TweenType.LINEAR;
        ccs.Tween.prototype.init.call(this, a)
    },
    init: function(a) {
        this._from = new ccs.FrameData;
        this._between = new ccs.FrameData;
        this._bone = a;
        this._tweenData = this._bone.getTweenData();
        this._tweenData.displayIndex = -1;
        this._animation = null !== this._bone && null !== this._bone.getArmature() ? this._bone.getArmature().getAnimation() : null;
        return !0
    },
    play: function(a, b, c, d, e) {
        ccs.ProcessBase.prototype.play.call(this, b, c, d, e);
        this._loopType = d ? ccs.ANIMATION_TYPE_TO_LOOP_FRONT : ccs.ANIMATION_TYPE_NO_LOOP;
        this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
        e = a !== this._movementBoneData;
        this.setMovementBoneData(a);
        this._rawDuration = this._movementBoneData.duration;
        a = this._movementBoneData.getFrameData(0);
        this._tweenData.displayIndex = a.displayIndex;
        this._bone.getArmature().getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeSub(this._tweenData, this._bone.getBoneData()), this._tweenData.scaleX += 1, this._tweenData.scaleY += 1);
        0 === this._rawDuration ? (this._loopType = ccs.ANIMATION_TYPE_SINGLE_FRAME, 0 === b ? this.setBetween(a, a) : this.setBetween(this._tweenData, a), this._frameTweenEasing = ccs.TweenType.LINEAR) : 1 < this._movementBoneData.frameList.length && (this._durationTween = c * this._movementBoneData.scale,
            d && 0 !== this._movementBoneData.delay ? this.setBetween(this._tweenData, this.tweenNodeTo(this.updateFrameData(1 - this._movementBoneData.delay), this._between)) : e && 0 !== b ? this.setBetween(this._tweenData, a) : this.setBetween(a, a));
        this.tweenNodeTo(0)
    },
    gotoAndPlay: function(a) {
        ccs.ProcessBase.prototype.gotoFrame.call(this, a);
        this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0;
        this._isPlaying = !0;
        this._isComplete = this._isPause = !1;
        this._currentPercent = this._curFrameIndex / (this._rawDuration -
            1);
        this._currentFrame = this._nextFrameIndex * this._currentPercent
    },
    gotoAndPause: function(a) {
        this.gotoAndPlay(a);
        this.pause()
    },
    updateHandler: function() {
        var a = null == this._currentPercent ? 1 : this._currentPercent,
            b = this._loopType;
        if (1 <= a) switch (b) {
            case ccs.ANIMATION_TYPE_SINGLE_FRAME:
                a = 1;
                this._isComplete = !0;
                this._isPlaying = !1;
                break;
            case ccs.ANIMATION_TYPE_NO_LOOP:
                b = ccs.ANIMATION_TYPE_MAX;
                a = 0 >= this._durationTween ? 1 : (a - 1) * this._nextFrameIndex / this._durationTween;
                1 <= a ? (a = 1, this._isComplete = !0, this._isPlaying = !1) : (this._nextFrameIndex = this._durationTween, this._currentFrame = a * this._nextFrameIndex, this._fromIndex = this._toIndex = this._betweenDuration = this._totalDuration = 0);
                break;
            case ccs.ANIMATION_TYPE_TO_LOOP_FRONT:
                b = ccs.ANIMATION_TYPE_LOOP_FRONT;
                this._nextFrameIndex = 0 < this._durationTween ? this._durationTween : 1;
                0 !== this._movementBoneData.delay ? (this._currentFrame = (1 - this._movementBoneData.delay) * this._nextFrameIndex, a = this._currentFrame / this._nextFrameIndex) : this._currentFrame = a = 0;
                this._fromIndex = this._toIndex =
                    this._betweenDuration = this._totalDuration = 0;
                break;
            case ccs.ANIMATION_TYPE_MAX:
                a = 1;
                this._isComplete = !0;
                this._isPlaying = !1;
                break;
            default:
                this._currentFrame = ccs.fmodf(this._currentFrame, this._nextFrameIndex)
        }
        1 > a && b < ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = Math.sin(a * cc.PI / 2));
        this._currentPercent = a;
        this._loopType = b;
        b > ccs.ANIMATION_TYPE_TO_LOOP_BACK && (a = this.updateFrameData(a));
        this._frameTweenEasing !== ccs.TweenType.TWEEN_EASING_MAX && this.tweenNodeTo(a)
    },
    setBetween: function(a, b, c) {
        void 0 === c && (c = !0);
        0 > a.displayIndex &&
            0 <= b.displayIndex ? (this._from.copy(b), this._between.subtract(b, b, c)) : 0 > b.displayIndex && 0 <= a.displayIndex ? (this._from.copy(a), this._between.subtract(b, b, c)) : (this._from.copy(a), this._between.subtract(a, b, c));
        a.isTween || (this._tweenData.copy(a), this._tweenData.isTween = !0);
        this.arriveKeyFrame(a)
    },
    arriveKeyFrame: function(a) {
        if (a) {
            var b = this._bone,
                c = b.getDisplayManager(),
                d = a.displayIndex;
            c.getForceChangeDisplay() || c.changeDisplayWithIndex(d, !1);
            this._tweenData.zOrder = a.zOrder;
            b.updateZOrder();
            this._bone.setBlendFunc(a.blendFunc);
            (b = b.getChildArmature()) && "" !== a.movement && b.getAnimation().play(a.movement)
        }
    },
    tweenNodeTo: function(a, b) {
        b || (b = this._tweenData);
        var c = this._from,
            d = this._between;
        c.isTween || (a = 0);
        b.x = c.x + a * d.x;
        b.y = c.y + a * d.y;
        b.scaleX = c.scaleX + a * d.scaleX;
        b.scaleY = c.scaleY + a * d.scaleY;
        b.skewX = c.skewX + a * d.skewX;
        b.skewY = c.skewY + a * d.skewY;
        this._bone.setTransformDirty(!0);
        b && d.isUseColorInfo && this.tweenColorTo(a, b);
        return b
    },
    tweenColorTo: function(a, b) {
        var c = this._from,
            d = this._between;
        b.a = c.a + a * d.a;
        b.r = c.r + a * d.r;
        b.g = c.g + a *
            d.g;
        b.b = c.b + a * d.b;
        this._bone.updateColor()
    },
    updateFrameData: function(a) {
        1 < a && 0 !== this._movementBoneData.delay && (a = ccs.fmodf(a, 1));
        a *= this._rawDuration - 1;
        var b, c, d = this._totalDuration,
            e = this._betweenDuration,
            f = this._toIndex;
        if (a < d || a >= d + e) {
            var e = this._movementBoneData.frameList,
                g = e.length;
            if (a < e[0].frameID) return b = c = e[0], this.setBetween(b, c), this._currentPercent;
            if (a >= e[g - 1].frameID) {
                if (this._passLastFrame) return b = c = e[g - 1], this.setBetween(b, c), this._currentPercent;
                this._passLastFrame = !0
            } else this._passLastFrame = !1;
            do
                if (this._fromIndex = f, b = e[this._fromIndex], d = b.frameID, f = this._fromIndex + 1, f >= g && (f = 0), c = e[f], b.strEvent && !this._animation.isIgnoreFrameEvent() && this._animation.frameEvent(this._bone, b.strEvent, b.frameID, a), a === b.frameID || this._passLastFrame && this._fromIndex === g - 1) break; while (a < b.frameID || a >= c.frameID);
            e = c.frameID - b.frameID;
            this._frameTweenEasing = b.tweenEasing;
            this.setBetween(b, c, !1);
            this._totalDuration = d;
            this._betweenDuration = e;
            this._toIndex = f
        }
        a = 0 === e ? 0 : (a - this._totalDuration) / this._betweenDuration;
        b = this._frameTweenEasing !== ccs.TweenType.LINEAR ? this._frameTweenEasing : this._tweenEasing;
        b === ccs.TweenType.TWEEN_EASING_MAX || b === ccs.TweenType.LINEAR || this._passLastFrame || (a = ccs.TweenFunction.tweenTo(a, b, this._from.easingParams));
        return a
    },
    setAnimation: function(a) {
        this._animation = a
    },
    getAnimation: function() {
        return this._animation
    },
    setMovementBoneData: function(a) {
        this._movementBoneData = a
    }
});
_p = ccs.Tween.prototype;
cc.defineGetterSetter(_p, "animation", _p.getAnimation, _p.setAnimation);
_p = null;
ccs.Tween.create = function(a) {
    return new ccs.Tween(a)
};
ccs.PT_RATIO = 32;
ccs.ColliderFilter = ccs.Class.extend({
    _collisionType: 0,
    _group: 0,
    _categoryBits: 0,
    _groupIndex: 0,
    _maskBits: 0,
    ctor: function(a, b) {
        this._collisionType = a || 0;
        this._group = b || 0
    },
    updateShape: function(a) {
        if (a instanceof cp.Shape) a.collision_type = this._collisionType, a.group = this._group;
        else if (a instanceof Box2D.b2FilterData) {
            var b = new Box2D.b2FilterData;
            b.categoryBits = this._categoryBits;
            b.groupIndex = this._groupIndex;
            b.maskBits = this._maskBits;
            a.SetFilterData(b)
        }
    }
});
ccs.ColliderBody = ccs.Class.extend({
    shape: null,
    coutourData: null,
    colliderFilter: null,
    _calculatedVertexList: null,
    ctor: function(a) {
        this.shape = null;
        this.coutourData = a;
        this.colliderFilter = new ccs.ColliderFilter;
        ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX && (this._calculatedVertexList = [])
    },
    getContourData: function() {
        return this.coutourData
    },
    setColliderFilter: function(a) {
        this.colliderFilter = a
    },
    getCalculatedVertexList: function() {
        return this._calculatedVertexList
    },
    setB2Fixture: function(a) {
        this._fixture = a
    },
    getB2Fixture: function() {
        return this._fixture
    },
    setShape: function(a) {
        this.shape = a
    },
    getShape: function() {
        return this.shape
    },
    setContourData: function(a) {
        this.coutourData = a
    },
    getColliderFilter: function() {
        return this.colliderFilter
    }
});
ccs.ColliderDetector = ccs.Class.extend({
    _colliderBodyList: null,
    _bone: null,
    _body: null,
    _active: !1,
    _filter: null,
    helpPoint: cc.p(0, 0),
    ctor: function(a) {
        this._colliderBodyList = [];
        this._body = this._bone = null;
        this._active = !1;
        this._filter = null;
        ccs.ColliderDetector.prototype.init.call(this, a)
    },
    init: function(a) {
        this._colliderBodyList.length = 0;
        a && (this._bone = a);
        this._filter = new ccs.ColliderFilter;
        return !0
    },
    addContourData: function(a) {
        var b = new ccs.ColliderBody(a);
        this._colliderBodyList.push(b);
        if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
            b =
                b.getCalculatedVertexList();
            a = a.vertexList;
            for (var c = 0; c < a.length; c++) {
                var d = new ccs.ContourVertex2(0, 0);
                b.push(d)
            }
        }
    },
    addContourDataList: function(a) {
        for (var b = 0; b < a.length; b++) this.addContourData(a[b])
    },
    removeContourData: function(a) {
        var b = [],
            c, d = this._colliderBodyList;
        for (c = 0; c < d.length; c++) {
            var e = d[c];
            e && e.getContourData() === a && b.push(e)
        }
        for (c = 0; c < b.length; c++) cc.arrayRemoveObject(d, b[c])
    },
    removeAll: function() {
        this._colliderBodyList.length = 0
    },
    setActive: function(a) {
        if (this._active !== a) {
            this._active =
                a;
            a = this._body;
            var b;
            if (a)
                if (b = null, this._active)
                    for (var c = 0; c < this._colliderBodyList.length; c++) b = this._colliderBodyList[c], b = b.getShape(), a.space.addShape(b);
                else
                    for (c = 0; c < this._colliderBodyList.length; c++) b = this._colliderBodyList[c], b = b.getShape(), a.space.removeShape(b)
        }
    },
    getActive: function() {
        return this._active
    },
    getColliderBodyList: function() {
        return this._colliderBodyList
    },
    setColliderFilter: function(a) {
        this._filter = a;
        for (var b = this._colliderBodyList, c = 0; c < b.length; c++) {
            var d = b[c];
            d.setColliderFilter(a);
            d.getShape() && d.getColliderFilter().updateShape(d.getShape())
        }
    },
    getColliderFilter: function() {
        return this._filter
    },
    updateTransform: function(a) {
        if (this._active)
            for (var b = null, c = this._body, d = this.helpPoint, e = 0; e < this._colliderBodyList.length; e++) {
                var b = this._colliderBodyList[e],
                    f = b.getContourData(),
                    g = null;
                c && (g = b.getShape());
                for (var f = f.vertexList, h = b.getCalculatedVertexList(), b = 0; b < f.length; b++) {
                    d.x = f[b].x;
                    d.y = f[b].y;
                    d = cc.pointApplyAffineTransform(d, a);
                    if (ccs.ENABLE_PHYSICS_SAVE_CALCULATED_VERTEX) {
                        var k =
                            cc.p(0, 0);
                        k.x = d.x;
                        k.y = d.y;
                        h[b] = k
                    }
                    g && (g.verts[2 * b] = d.x, g.verts[2 * b + 1] = d.y)
                }
                if (g)
                    for (b = 0; b < f.length; b++) h = cp.v.normalize(cp.v.perp(cp.v.sub(g.verts[(b + 1) % g.verts.length], g.verts[b]))), g.planes && (g.planes[b].n = h, g.planes[b].d = cp.v.dot(h, g.verts[b]))
            }
    },
    setBody: function(a) {
        this._body = a;
        for (var b = this._colliderBodyList, c = 0; c < b.length; c++) {
            a = b[c];
            for (var d = [], e = a.getContourData().vertexList, f = 0; f < e.length; f++) {
                var g = e[f];
                d.push(g.x);
                d.push(g.y)
            }
            d = new cp.PolyShape(this._body, d, cp.vzero);
            d.sensor = !0;
            d.data =
                this._bone;
            this._active && this._body.space.addShape(d);
            a.setShape(d);
            a.getColliderFilter().updateShape(d)
        }
    },
    getBody: function() {
        return this._body
    }
});
_p = ccs.ColliderDetector.prototype;
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
cc.defineGetterSetter(_p, "active", _p.getActive, _p.setActive);
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
_p = null;
ccs.ColliderDetector.create = function(a) {
    return new ccs.ColliderDetector(a)
};
ccs.Armature = ccs.Node.extend({
    animation: null,
    armatureData: null,
    batchNode: null,
    _textureAtlas: null,
    _parentBone: null,
    _boneDic: null,
    _topBoneList: null,
    _armatureIndexDic: null,
    _offsetPoint: null,
    version: 0,
    _armatureTransformDirty: !0,
    _body: null,
    _blendFunc: null,
    _className: "Armature",
    ctor: function(a, b) {
        cc.Node.prototype.ctor.call(this);
        this._name = "";
        this._topBoneList = [];
        this._armatureIndexDic = {};
        this._offsetPoint = cc.p(0, 0);
        this._armatureTransformDirty = !0;
        this._blendFunc = {
            src: cc.BLEND_SRC,
            dst: cc.BLEND_DST
        };
        a &&
            ccs.Armature.prototype.init.call(this, a, b)
    },
    init: function(a, b) {
        cc.Node.prototype.init.call(this);
        b && (this._parentBone = b);
        this.removeAllChildren();
        this.animation = new ccs.ArmatureAnimation;
        this.animation.init(this);
        this._boneDic = {};
        this._topBoneList.length = 0;
        var c = ccs.armatureDataManager,
            d;
        if ("" !== a) {
            d = c.getAnimationData(a);
            cc.assert(d, "AnimationData not exist!");
            this.animation.setAnimationData(d);
            c = c.getArmatureData(a);
            cc.assert(c, "ArmatureData not exist!");
            this.armatureData = c;
            var c = c.getBoneDataDic(),
                e;
            for (e in c) {
                var c = this.createBone(String(e)),
                    f = d.getMovement(d.movementNames[0]);
                f && (f = f.getMovementBoneData(c.getName())) && !(0 >= f.frameList.length) && (f = f.getFrameData(0)) && (c.getTweenData().copy(f), c.changeDisplayWithIndex(f.displayIndex, !1))
            }
            this.update(0);
            this.updateOffsetPoint()
        } else a = "new_armature", this.armatureData = new ccs.ArmatureData, this.armatureData.name = a, d = new ccs.AnimationData, d.name = a, c.addArmatureData(a, this.armatureData), c.addAnimationData(a, d), this.animation.setAnimationData(d);
        this._renderCmd.initShaderCache();
        this.setCascadeOpacityEnabled(!0);
        this.setCascadeColorEnabled(!0);
        return !0
    },
    addChild: function(a, b, c) {
        a instanceof ccui.Widget ? cc.log("Armature doesn't support to add Widget as its child, it will be fix soon.") : cc.Node.prototype.addChild.call(this, a, b, c)
    },
    createBone: function(a) {
        var b = this.getBone(a);
        if (b) return b;
        var b = this.armatureData.getBoneData(a),
            c = b.parentName,
            d = null;
        c ? (this.createBone(c), d = new ccs.Bone(a), this.addBone(d, c)) : (d = new ccs.Bone(a), this.addBone(d,
            ""));
        d.setBoneData(b);
        d.getDisplayManager().changeDisplayWithIndex(-1, !1);
        return d
    },
    addBone: function(a, b) {
        cc.assert(a, "Argument must be non-nil");
        var c = this._boneDic;
        a.getName() && cc.assert(!c[a.getName()], "bone already added. It can't be added again");
        if (b) {
            var d = c[b];
            d ? d.addChildBone(a) : this._topBoneList.push(a)
        } else this._topBoneList.push(a);
        a.setArmature(this);
        c[a.getName()] = a;
        this.addChild(a)
    },
    removeBone: function(a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        a.setArmature(null);
        a.removeFromParent(b);
        cc.arrayRemoveObject(this._topBoneList, a);
        delete this._boneDic[a.getName()];
        this.removeChild(a, !0)
    },
    getBone: function(a) {
        return this._boneDic[a]
    },
    changeBoneParent: function(a, b) {
        cc.assert(a, "bone must be added to the bone dictionary!");
        var c = a.getParentBone();
        c && (cc.arrayRemoveObject(c.getChildren(), a), a.setParentBone(null));
        b && ((c = this._boneDic[b]) ? (c.addChildBone(a), cc.arrayRemoveObject(this._topBoneList, a)) : this._topBoneList.push(a))
    },
    getBoneDic: function() {
        return this._boneDic
    },
    updateOffsetPoint: function() {
        var a = this.getBoundingBox();
        this.setContentSize(a);
        var b = this._offsetPoint;
        b.x = -a.x;
        b.y = -a.y;
        0 !== a.width && 0 !== a.height && this.setAnchorPoint(b.x / a.width, b.y / a.height)
    },
    getOffsetPoints: function() {
        return {
            x: this._offsetPoint.x,
            y: this._offsetPoint.y
        }
    },
    setAnimation: function(a) {
        this.animation = a
    },
    getAnimation: function() {
        return this.animation
    },
    getArmatureTransformDirty: function() {
        return this._armatureTransformDirty
    },
    update: function(a) {
        this.animation.update(a);
        for (var b = this._topBoneList,
                c = 0; c < b.length; c++) b[c].update(a);
        this._armatureTransformDirty = !1
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.scheduleUpdate()
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this.unscheduleUpdate()
    },
    getBoundingBox: function() {
        for (var a, b, c, d = 0, e = !0, f = cc.rect(0, 0, 0, 0), g = this._children, h = g.length, k = 0; k < h; k++)
            if (a = g[k])
                if (d = a.getDisplayManager().getBoundingBox(), 0 !== d.x || 0 !== d.y || 0 !== d.width || 0 !== d.height) e ? (a = d.x, b = d.y, c = d.x + d.width, d = d.y + d.height, e = !1) : (a = d.x < f.x ? d.x : f.x, b =
                    d.y < f.y ? d.y : f.y, c = d.x + d.width > f.x + f.width ? d.x + d.width : f.x + f.width, d = d.y + d.height > f.y + f.height ? d.y + d.height : f.y + f.height), f.x = a, f.y = b, f.width = c - a, f.height = d - b;
        return cc.rectApplyAffineTransform(f, this.getNodeToParentTransform())
    },
    getBoneAtPoint: function(a, b) {
        for (var c = this._children, d = c.length - 1; 0 <= d; d--) {
            var e = c[d];
            if (e instanceof ccs.Bone && e.getDisplayManager().containPoint(a, b)) return e
        }
        return null
    },
    setParentBone: function(a) {
        this._parentBone = a;
        a = this._boneDic;
        for (var b in a) a[b].setArmature(this)
    },
    getParentBone: function() {
        return this._parentBone
    },
    drawContour: function() {
        cc._drawingUtil.setDrawColor(255, 255, 255, 255);
        cc._drawingUtil.setLineWidth(1);
        var a = this._boneDic,
            b;
        for (b in a) {
            var c = a[b].getColliderDetector();
            if (c)
                for (var c = c.getColliderBodyList(), d = 0; d < c.length; d++) {
                    var e = c[d].getCalculatedVertexList();
                    cc._drawingUtil.drawPoly(e, e.length, !0)
                }
        }
    },
    setBody: function(a) {
        if (this._body !== a) {
            this._body = a;
            this._body.data = this;
            var b, c;
            a = this._children;
            for (var d = 0; d < a.length; d++)
                if (b = a[d], b instanceof ccs.Bone) {
                    b = b.getDisplayManager().getDecorativeDisplayList();
                    for (var e = 0; e < b.length; e++) c = b[e], (c = c.getColliderDetector()) && c.setBody(this._body)
                }
        }
    },
    getShapeList: function() {
        return this._body ? this._body.shapeList : null
    },
    getBody: function() {
        return this._body
    },
    setBlendFunc: function(a, b) {
        void 0 === b ? (this._blendFunc.src = a.src, this._blendFunc.dst = a.dst) : (this._blendFunc.src = a, this._blendFunc.dst = b)
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    setColliderFilter: function(a) {
        var b =
            this._boneDic,
            c;
        for (c in b) b[c].setColliderFilter(a)
    },
    getArmatureData: function() {
        return this.armatureData
    },
    setArmatureData: function(a) {
        this.armatureData = a
    },
    getBatchNode: function() {
        return this.batchNode
    },
    setBatchNode: function(a) {
        this.batchNode = a
    },
    getVersion: function() {
        return this.version
    },
    setVersion: function(a) {
        this.version = a
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Armature.CanvasRenderCmd(this) : new ccs.Armature.WebGLRenderCmd(this)
    }
});
_p = ccs.Armature.prototype;
cc.defineGetterSetter(_p, "parentBone", _p.getParentBone, _p.setParentBone);
cc.defineGetterSetter(_p, "body", _p.getBody, _p.setBody);
cc.defineGetterSetter(_p, "colliderFilter", null, _p.setColliderFilter);
_p = null;
ccs.Armature.create = function(a, b) {
    return new ccs.Armature(a, b)
};
(function() {
    ccs.Armature.RenderCmd = {
        _updateAnchorPointInPoint: function() {
            var a = this._node,
                b = a._contentSize,
                c = a._anchorPoint,
                a = a._offsetPoint;
            this._anchorPointInPoints.x = b.width * c.x - a.x;
            this._anchorPointInPoints.y = b.height * c.y - a.y;
            this._realAnchorPointInPoints.x = b.width * c.x;
            this._realAnchorPointInPoints.y = b.height * c.y;
            this.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
        },
        getAnchorPointInPoints: function() {
            return cc.p(this._realAnchorPointInPoints)
        }
    }
})();
(function() {
    ccs.Armature.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !0;
        this._realAnchorPointInPoints = new cc.Point(0, 0);
        this._startRenderCmd = new cc.CustomRenderCmd(this, this._startCmdCallback);
        this._RestoreRenderCmd = new cc.CustomRenderCmd(this, this._RestoreCmdCallback)
    };
    var a = ccs.Armature.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    cc.inject(ccs.Armature.RenderCmd, a);
    a.constructor = ccs.Armature.CanvasRenderCmd;
    a._startCmdCallback = function(a,
        c, d) {
        var e = this._node._parent;
        this.transform(e ? e._renderCmd : null);
        a = a || cc._renderContext;
        a.save();
        a._switchToArmatureMode(!0, this._worldTransform, c, d)
    };
    a.transform = function(a, c) {
        ccs.Node.CanvasRenderCmd.prototype.transform.call(this, a, c);
        for (var d = this._node._children, e = 0, f = d.length; e < f; e++) {
            var g = d[e];
            if (g && g.getDisplayRenderNode) {
                var h = g.getDisplayRenderNode();
                if (h && h._renderCmd) {
                    h = h._renderCmd;
                    h.transform(null);
                    var k = g._renderCmd._displayedColor,
                        g = g._renderCmd._displayedOpacity,
                        m = cc.Node._dirtyFlags,
                        n = h._dirtyFlag,
                        p = n & m.opacityDirty;
                    n & m.colorDirty && h._updateDisplayColor(k);
                    p && h._updateDisplayOpacity(g)
                }
            }
        }
    };
    a._RestoreCmdCallback = function(a) {
        this._cacheDirty = !1;
        a._switchToArmatureMode(!1);
        a.restore()
    };
    a.initShaderCache = function() {};
    a.setShaderProgram = function() {};
    a.updateChildPosition = function(a, c, d, e, f) {
        a = this._node;
        var g = d.getBlendFunc();
        g.src !== e.src || g.dst !== e.dst ? c.setBlendFunc(d.getBlendFunc()) : a._blendFunc.src !== e.src || node_blendFunc.dst !== e.dst || c.getTexture().hasPremultipliedAlpha() ? c.setBlendFunc(a._blendFunc) :
            c.setBlendFunc(f);
        cc.renderer.pushRenderCommand(c._renderCmd)
    };
    a.rendering = function(a, c, d) {
        for (var e = this._node._children, f = cc.BlendFunc.ALPHA_PREMULTIPLIED, g = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, h = 0, k = e.length; h < k; h++) {
            var m = e[h];
            if (m && m.getDisplayRenderNode) {
                var n = m.getDisplayRenderNode();
                if (null !== n) switch (m.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        n instanceof ccs.Skin && this.updateChildPosition(a, n, m, f, g);
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        n._renderCmd.rendering(a, c, d);
                        break;
                    default:
                        n.visit(this)
                }
            } else m instanceof cc.Node && this._visitNormalChild(m)
        }
    };
    a._visitNormalChild = function(a) {
        if (null != a) {
            var c = a._renderCmd;
            if (a._visible) {
                c._curLevel = this._curLevel + 1;
                var d = a._children,
                    e;
                c._syncStatus(this);
                c.transform(null);
                var f = d.length;
                if (0 < f) {
                    a.sortAllChildren();
                    for (a = 0; a < f; a++)
                        if (e = d[a], 0 > e._localZOrder) e._renderCmd.visit(c);
                        else break;
                    for (cc.renderer.pushRenderCommand(c); a < f; a++) d[a]._renderCmd.visit(c)
                } else cc.renderer.pushRenderCommand(c);
                this._dirtyFlag = 0
            }
        }
    };
    a.visit = function(a) {
        var c =
            this._node;
        c._visible && (this.updateStatus(a), c.sortAllChildren(), cc.renderer.pushRenderCommand(this._startRenderCmd), this.rendering(), cc.renderer.pushRenderCommand(this._RestoreRenderCmd), this._cacheDirty = !1)
    }
})();
(function() {
    ccs.Armature.WebGLRenderCmd = function(a) {
        cc.Node.WebGLRenderCmd.call(this, a);
        this._needDraw = !0;
        this._realAnchorPointInPoints = new cc.Point(0, 0)
    };
    var a = ccs.Armature.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
    cc.inject(ccs.Armature.RenderCmd, a);
    a.constructor = ccs.Armature.WebGLRenderCmd;
    a.rendering = function(a, c) {
        var d = this._node;
        c || (cc.kmGLMatrixMode(cc.KM_GL_MODELVIEW), cc.kmGLPushMatrix(), cc.kmGLLoadMatrix(this._stackMatrix));
        for (var e = d._children, f = cc.BlendFunc.ALPHA_PREMULTIPLIED,
                g = cc.BlendFunc.ALPHA_NON_PREMULTIPLIED, h = 0, k = e.length; h < k; h++) {
            var m = e[h];
            if (m && m.getDisplayRenderNode) {
                var n = m.getDisplayRenderNode();
                if (null !== n) switch (n.setShaderProgram(this._shaderProgram), m.getDisplayRenderNodeType()) {
                    case ccs.DISPLAY_TYPE_SPRITE:
                        if (n instanceof ccs.Skin) {
                            this._updateColorAndOpacity(n._renderCmd, m);
                            n.updateTransform();
                            var p = m.getBlendFunc();
                            p.src !== f.src || p.dst !== f.dst ? n.setBlendFunc(m.getBlendFunc()) : d._blendFunc.src !== f.src || d._blendFunc.dst !== f.dst || n.getTexture().hasPremultipliedAlpha() ?
                                n.setBlendFunc(d._blendFunc) : n.setBlendFunc(g);
                            n._renderCmd.rendering(a)
                        }
                        break;
                    case ccs.DISPLAY_TYPE_ARMATURE:
                        n._renderCmd.rendering(a, !0);
                        break;
                    default:
                        n._renderCmd.transform(), n._renderCmd.rendering(a)
                }
            } else m instanceof cc.Node && (m.setShaderProgram(this._shaderProgram), m._renderCmd.transform(), m._renderCmd.rendering && m._renderCmd.rendering(a))
        }
        c || cc.kmGLPopMatrix()
    };
    a.initShaderCache = function() {
        this._shaderProgram = cc.shaderCache.programForKey(cc.SHADER_POSITION_TEXTURECOLOR)
    };
    a.setShaderProgram =
        function(a) {
            this._shaderProgram = a
        };
    a._updateColorAndOpacity = function(a, c) {
        var d = c._renderCmd._displayedColor,
            e = c._renderCmd._displayedOpacity,
            f = cc.Node._dirtyFlags,
            g = a._dirtyFlag,
            h = g & f.colorDirty,
            f = g & f.opacityDirty;
        h && a._updateDisplayColor(d);
        f && a._updateDisplayOpacity(e);
        (h || f) && a._updateColor()
    };
    a.updateChildPosition = function(a, c, d, e, f) {
        var g = this._node;
        c.updateTransform();
        var h = d.getBlendFunc();
        h.src !== e.src || h.dst !== e.dst ? c.setBlendFunc(d.getBlendFunc()) : g._blendFunc.src !== e.src || node_blendFunc.dst !==
            e.dst || c.getTexture().hasPremultipliedAlpha() ? c.setBlendFunc(g._blendFunc) : c.setBlendFunc(f);
        c.rendering(a)
    };
    a.updateStatus = function() {
        var a = cc.Node._dirtyFlags,
            c = this._dirtyFlag,
            d = c & a.colorDirty,
            a = c & a.opacityDirty;
        d && this._updateDisplayColor();
        a && this._updateDisplayOpacity();
        (d || a) && this._updateColor();
        this.transform(this.getParentRenderCmd(), !0)
    };
    a.visit = function(a) {
        var c = this._node;
        if (c._visible) {
            var d = cc.current_stack;
            d.stack.push(d.top);
            this.updateStatus(a);
            d.top = this._stackMatrix;
            c.sortAllChildren();
            cc.renderer.pushRenderCommand(this);
            this._dirtyFlag = 0;
            d.top = d.stack.pop()
        }
    }
})();
ccs.Bone = ccs.Node.extend({
    _boneData: null,
    _armature: null,
    _childArmature: null,
    _displayManager: null,
    ignoreMovementBoneData: !1,
    _tween: null,
    _tweenData: null,
    _parentBone: null,
    _boneTransformDirty: !1,
    _worldTransform: null,
    _blendFunc: null,
    blendDirty: !1,
    _worldInfo: null,
    _armatureParentBone: null,
    _dataVersion: 0,
    _className: "Bone",
    ctor: function(a) {
        cc.Node.prototype.ctor.call(this);
        this._displayManager = this._tween = this._boneData = this._childArmature = this._armature = this._parentBone = this._tweenData = null;
        this.ignoreMovementBoneData = !1;
        this._worldTransform = cc.affineTransformMake(1, 0, 0, 1, 0, 0);
        this._boneTransformDirty = !0;
        this._blendFunc = new cc.BlendFunc(cc.BLEND_SRC, cc.BLEND_DST);
        this.blendDirty = !1;
        this._armatureParentBone = this._worldInfo = null;
        this._dataVersion = 0;
        ccs.Bone.prototype.init.call(this, a)
    },
    init: function(a) {
        a && (this._name = a);
        this._tweenData = new ccs.FrameData;
        this._tween = new ccs.Tween(this);
        this._displayManager = new ccs.DisplayManager(this);
        this._worldInfo = new ccs.BaseData;
        this._boneData = new ccs.BaseData;
        return !0
    },
    setBoneData: function(a) {
        cc.assert(a,
            "_boneData must not be null");
        this._boneData !== a && (this._boneData = a);
        this.setName(this._boneData.name);
        this._localZOrder = this._boneData.zOrder;
        this._displayManager.initDisplayList(a)
    },
    getBoneData: function() {
        return this._boneData
    },
    setArmature: function(a) {
        (this._armature = a) ? (this._tween.setAnimation(this._armature.getAnimation()), this._dataVersion = this._armature.getArmatureData().dataVersion, this._armatureParentBone = this._armature.getParentBone()) : this._armatureParentBone = null
    },
    getArmature: function() {
        return this._armature
    },
    update: function(a) {
        this._parentBone && (this._boneTransformDirty = this._boneTransformDirty || this._parentBone.isTransformDirty());
        this._armatureParentBone && !this._boneTransformDirty && (this._boneTransformDirty = this._armatureParentBone.isTransformDirty());
        if (this._boneTransformDirty) {
            var b = this._tweenData;
            this._dataVersion >= ccs.CONST_VERSION_COMBINED && (ccs.TransformHelp.nodeConcat(b, this._boneData), b.scaleX -= 1, b.scaleY -= 1);
            var c = this._worldInfo;
            c.copy(b);
            c.x = b.x + this._position.x;
            c.y = b.y + this._position.y;
            c.scaleX = b.scaleX * this._scaleX;
            c.scaleY = b.scaleY * this._scaleY;
            c.skewX = b.skewX + this._skewX + cc.degreesToRadians(this._rotationX);
            c.skewY = b.skewY + this._skewY - cc.degreesToRadians(this._rotationY);
            this._parentBone ? this._applyParentTransform(this._parentBone) : this._armatureParentBone && this._applyParentTransform(this._armatureParentBone);
            ccs.TransformHelp.nodeToMatrix(c, this._worldTransform);
            this._armatureParentBone && (this._worldTransform = cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToParentTransform()))
        }
        ccs.displayFactory.updateDisplay(this,
            a, this._boneTransformDirty || this._armature.getArmatureTransformDirty());
        for (b = 0; b < this._children.length; b++) this._children[b].update(a);
        this._boneTransformDirty = !1
    },
    _applyParentTransform: function(a) {
        var b = this._worldInfo,
            c = a._worldTransform;
        a = a._worldInfo;
        var d = b.x,
            e = b.y;
        b.x = d * c.a + e * c.c + a.x;
        b.y = d * c.b + e * c.d + a.y;
        b.scaleX *= a.scaleX;
        b.scaleY *= a.scaleY;
        b.skewX += a.skewX;
        b.skewY += a.skewY
    },
    setBlendFunc: function(a, b) {
        var c = this._blendFunc,
            d, e;
        void 0 === b ? (d = a.src, e = a.dst) : (d = a, e = b);
        if (c.src !== d || c.dst !== e) c.src =
            d, c.dst = e, this.blendDirty = !0
    },
    updateColor: function() {
        var a = this._displayManager.getDisplayRenderNode();
        if (null !== a) {
            var b = this._renderCmd;
            a.setColor(cc.color(b._displayedColor.r * this._tweenData.r / 255, b._displayedColor.g * this._tweenData.g / 255, b._displayedColor.b * this._tweenData.b / 255));
            a.setOpacity(b._displayedOpacity * this._tweenData.a / 255)
        }
    },
    updateZOrder: function() {
        this._armature.getArmatureData().dataVersion >= ccs.CONST_VERSION_COMBINED ? this.setLocalZOrder(this._tweenData.zOrder + this._boneData.zOrder) :
            this.setLocalZOrder(this._tweenData.zOrder)
    },
    addChildBone: function(a) {
        cc.assert(a, "Argument must be non-nil");
        cc.assert(!a.parentBone, "child already added. It can't be added again");
        0 > this._children.indexOf(a) && (this._children.push(a), a.setParentBone(this))
    },
    removeChildBone: function(a, b) {
        if (0 < this._children.length && -1 !== this._children.getIndex(a)) {
            if (b)
                for (var c = a._children, d = 0; d < c.length; d++) a.removeChildBone(c[d], b);
            a.setParentBone(null);
            a.getDisplayManager().setCurrentDecorativeDisplay(null);
            cc.arrayRemoveObject(this._children,
                a)
        }
    },
    removeFromParent: function(a) {
        this._parentBone && this._parentBone.removeChildBone(this, a)
    },
    setParentBone: function(a) {
        this._parentBone = a
    },
    getParentBone: function() {
        return this._parentBone
    },
    setChildArmature: function(a) {
        this._childArmature !== a && (null == a && this._childArmature && this._childArmature.setParentBone(null), this._childArmature = a)
    },
    getChildArmature: function() {
        return this._childArmature
    },
    getTween: function() {
        return this._tween
    },
    setLocalZOrder: function(a) {
        this._localZOrder !== a && cc.Node.prototype.setLocalZOrder.call(this,
            a)
    },
    getNodeToArmatureTransform: function() {
        return this._worldTransform
    },
    getNodeToWorldTransform: function() {
        return cc.affineTransformConcat(this._worldTransform, this._armature.getNodeToWorldTransform())
    },
    getDisplayRenderNode: function() {
        return this._displayManager.getDisplayRenderNode()
    },
    getDisplayRenderNodeType: function() {
        return this._displayManager.getDisplayRenderNodeType()
    },
    addDisplay: function(a, b) {
        return this._displayManager.addDisplay(a, b || 0)
    },
    removeDisplay: function(a) {
        this._displayManager.removeDisplay(a)
    },
    changeDisplayByIndex: function(a, b) {
        cc.log("changeDisplayByIndex is deprecated. Use changeDisplayWithIndex instead.");
        this.changeDisplayWithIndex(a, b)
    },
    changeDisplayByName: function(a, b) {
        cc.log("changeDisplayByName is deprecated. Use changeDisplayWithName instead.");
        this.changeDisplayWithName(a, b)
    },
    changeDisplayWithIndex: function(a, b) {
        this._displayManager.changeDisplayWithIndex(a, b)
    },
    changeDisplayWithName: function(a, b) {
        this._displayManager.changeDisplayWithName(a, b)
    },
    getColliderDetector: function() {
        var a =
            this._displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a : null
    },
    setColliderFilter: function(a) {
        for (var b = this._displayManager.getDecorativeDisplayList(), c = 0; c < b.length; c++) {
            var d = b[c].getColliderDetector();
            d && d.setColliderFilter(a)
        }
    },
    getColliderFilter: function() {
        var a = this.displayManager.getCurrentDecorativeDisplay();
        return a && (a = a.getColliderDetector()) ? a.getColliderFilter() : null
    },
    setTransformDirty: function(a) {
        this._boneTransformDirty = a
    },
    isTransformDirty: function() {
        return this._boneTransformDirty
    },
    getDisplayManager: function() {
        return this._displayManager
    },
    setIgnoreMovementBoneData: function(a) {
        this._ignoreMovementBoneData = a
    },
    isIgnoreMovementBoneData: function() {
        return this._ignoreMovementBoneData
    },
    getBlendFunc: function() {
        return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst)
    },
    setBlendDirty: function(a) {
        this._blendDirty = a
    },
    isBlendDirty: function() {
        return this._blendDirty
    },
    getTweenData: function() {
        return this._tweenData
    },
    getWorldInfo: function() {
        return this._worldInfo
    },
    getChildrenBone: function() {
        return this._children
    },
    nodeToArmatureTransform: function() {
        return this.getNodeToArmatureTransform()
    },
    nodeToWorldTransform: function() {
        return this.getNodeToWorldTransform()
    },
    getColliderBodyList: function() {
        var a = this.getColliderDetector();
        return a ? a.getColliderBodyList() : null
    },
    getIgnoreMovementBoneData: function() {
        return this.isIgnoreMovementBoneData()
    },
    _createRenderCmd: function() {
        return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new ccs.Bone.CanvasRenderCmd(this) : new ccs.Bone.WebGLRenderCmd(this)
    }
});
_p = ccs.Bone.prototype;
cc.defineGetterSetter(_p, "boneData", _p.getBoneData, _p.setBoneData);
cc.defineGetterSetter(_p, "armature", _p.getArmature, _p.setArmature);
cc.defineGetterSetter(_p, "childArmature", _p.getChildArmature, _p.setChildArmature);
cc.defineGetterSetter(_p, "childrenBone", _p.getChildrenBone);
cc.defineGetterSetter(_p, "tween", _p.getTween);
cc.defineGetterSetter(_p, "tweenData", _p.getTweenData);
cc.defineGetterSetter(_p, "colliderFilter", _p.getColliderFilter, _p.setColliderFilter);
_p = null;
ccs.Bone.create = function(a) {
    return new ccs.Bone(a)
};
ccs.Bone.RenderCmd = {
    _updateColor: function() {
        var a = this._node,
            b = a._displayManager.getDisplayRenderNode();
        if (null !== b) {
            var c = b._renderCmd;
            b.setColor(cc.color(a._tweenData.r, a._tweenData.g, a._tweenData.g));
            b.setOpacity(a._tweenData.a);
            c._syncDisplayColor(this._displayedColor);
            c._syncDisplayOpacity(this._displayedOpacity);
            c._updateColor()
        }
    }
};
(function() {
    ccs.Bone.CanvasRenderCmd = function(a) {
        cc.Node.CanvasRenderCmd.call(this, a);
        this._needDraw = !1
    };
    var a = ccs.Bone.CanvasRenderCmd.prototype = Object.create(cc.Node.CanvasRenderCmd.prototype);
    cc.inject(ccs.Bone.RenderCmd, a);
    a.constructor = ccs.Bone.CanvasRenderCmd
})();
(function() {
    if (cc.Node.WebGLRenderCmd) {
        ccs.Bone.WebGLRenderCmd = function(a) {
            cc.Node.WebGLRenderCmd.call(this, a);
            this._needDraw = !1
        };
        var a = ccs.Bone.WebGLRenderCmd.prototype = Object.create(cc.Node.WebGLRenderCmd.prototype);
        cc.inject(ccs.Bone.RenderCmd, a);
        a.constructor = ccs.Bone.WebGLRenderCmd
    }
})();
ccs.FRAME_TYPE_MOVE = 0;
ccs.FRAME_TYPE_SCALE = 1;
ccs.FRAME_TYPE_ROTATE = 2;
ccs.FRAME_TYPE_TINT = 3;
ccs.FRAME_TYPE_FADE = 4;
ccs.FRAME_TYPE_MAX = 5;
ccs.FrameEaseType = {
    CUSTOM: -1,
    LINEAR: 0,
    SINE_EASEIN: 1,
    SINE_EASEOUT: 2,
    SINE_EASEINOUT: 3,
    QUAD_EASEIN: 4,
    QUAD_EASEOUT: 5,
    QUAD_EASEINOUT: 6,
    CUBIC_EASEIN: 7,
    CUBIC_EASEOUT: 8,
    CUBIC_EASEINOUT: 9,
    QUART_EASEIN: 10,
    QUART_EASEOUT: 11,
    QUART_EASEINOUT: 12,
    QUINT_EASEIN: 13,
    QUINT_EASEOUT: 14,
    QUINT_EASEINOUT: 15,
    EXPO_EASEIN: 16,
    EXPO_EASEOUT: 17,
    EXPO_EASEINOUT: 18,
    CIRC_EASEIN: 19,
    CIRC_EASEOUT: 20,
    CIRC_EASEINOUT: 21,
    ELASTIC_EASEIN: 22,
    ELASTIC_EASEOUT: 23,
    ELASTIC_EASEINOUT: 24,
    BACK_EASEIN: 25,
    BACK_EASEOUT: 26,
    BACK_EASEINOUT: 27,
    BOUNCE_EASEIN: 28,
    BOUNCE_EASEOUT: 29,
    BOUNCE_EASEINOUT: 30,
    TWEEN_EASING_MAX: 1E3
};
ccs.ActionFrame = ccs.Class.extend({
    frameType: 0,
    easingType: 0,
    frameIndex: 0,
    _Parameter: null,
    time: 0,
    ctor: function() {
        this.frameType = 0;
        this.easingType = ccs.FrameEaseType.LINEAR;
        this.time = this.frameIndex = 0
    },
    getAction: function(a, b) {
        cc.log("Need a definition of \x3cgetAction\x3e for ActionFrame");
        return null
    },
    _getEasingAction: function(a) {
        if (null === a) return console.error("Action cannot be null!"), null;
        var b;
        switch (this.easingType) {
            case ccs.FrameEaseType.LINEAR:
                b = a;
                break;
            case ccs.FrameEaseType.SINE_EASEIN:
                b = a.easing(cc.easeSineIn());
                break;
            case ccs.FrameEaseType.SINE_EASEOUT:
                b = a.easing(cc.easeSineOut());
                break;
            case ccs.FrameEaseType.SINE_EASEINOUT:
                b = a.easing(cc.easeSineInOut());
                break;
            case ccs.FrameEaseType.QUAD_EASEIN:
                b = a.easing(cc.easeQuadraticActionIn());
                break;
            case ccs.FrameEaseType.QUAD_EASEOUT:
                b = a.easing(cc.easeQuadraticActionOut());
                break;
            case ccs.FrameEaseType.QUAD_EASEINOUT:
                b = a.easing(cc.easeQuadraticActionInOut());
                break;
            case ccs.FrameEaseType.CUBIC_EASEIN:
                b = a.easing(cc.easeCubicActionIn());
                break;
            case ccs.FrameEaseType.CUBIC_EASEOUT:
                b =
                    a.easing(cc.easeCubicActionOut());
                break;
            case ccs.FrameEaseType.CUBIC_EASEINOUT:
                b = a.easing(cc.easeCubicActionInOut());
                break;
            case ccs.FrameEaseType.QUART_EASEIN:
                b = a.easing(cc.easeQuarticActionIn());
                break;
            case ccs.FrameEaseType.QUART_EASEOUT:
                b = a.easing(cc.easeQuarticActionOut());
                break;
            case ccs.FrameEaseType.QUART_EASEINOUT:
                b = a.easing(cc.easeQuarticActionInOut());
                break;
            case ccs.FrameEaseType.QUINT_EASEIN:
                b = a.easing(cc.easeQuinticActionIn());
                break;
            case ccs.FrameEaseType.QUINT_EASEOUT:
                b = a.easing(cc.easeQuinticActionOut());
                break;
            case ccs.FrameEaseType.QUINT_EASEINOUT:
                b = a.easing(cc.easeQuinticActionInOut());
                break;
            case ccs.FrameEaseType.EXPO_EASEIN:
                b = a.easing(cc.easeExponentialIn());
                break;
            case ccs.FrameEaseType.EXPO_EASEOUT:
                b = a.easing(cc.easeExponentialOut());
                break;
            case ccs.FrameEaseType.EXPO_EASEINOUT:
                b = a.easing(cc.easeExponentialInOut());
                break;
            case ccs.FrameEaseType.CIRC_EASEIN:
                b = a.easing(cc.easeCircleActionIn());
                break;
            case ccs.FrameEaseType.CIRC_EASEOUT:
                b = a.easing(cc.easeCircleActionOut());
                break;
            case ccs.FrameEaseType.CIRC_EASEINOUT:
                b =
                    a.easing(cc.easeCircleActionInOut());
                break;
            case ccs.FrameEaseType.ELASTIC_EASEIN:
                b = a.easing(cc.easeElasticIn());
                break;
            case ccs.FrameEaseType.ELASTIC_EASEOUT:
                b = a.easing(cc.easeElasticOut());
                break;
            case ccs.FrameEaseType.ELASTIC_EASEINOUT:
                b = a.easing(cc.easeElasticInOut());
                break;
            case ccs.FrameEaseType.BACK_EASEIN:
                b = a.easing(cc.easeBackIn());
                break;
            case ccs.FrameEaseType.BACK_EASEOUT:
                b = a.easing(cc.easeBackOut());
                break;
            case ccs.FrameEaseType.BACK_EASEINOUT:
                b = a.easing(cc.easeBackInOut());
                break;
            case ccs.FrameEaseType.BOUNCE_EASEIN:
                b =
                    a.easing(cc.easeBounceIn());
                break;
            case ccs.FrameEaseType.BOUNCE_EASEOUT:
                b = a.easing(cc.easeBounceOut());
                break;
            case ccs.FrameEaseType.BOUNCE_EASEINOUT:
                b = a.easing(cc.easeBounceInOut())
        }
        return b
    },
    setEasingParameter: function(a) {
        this._Parameter = [];
        for (var b = 0; b < a.length; b++) this._Parameter.push(a[b])
    },
    setEasingType: function(a) {
        this.easingType = a
    }
});
ccs.ActionMoveFrame = ccs.ActionFrame.extend({
    _position: null,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._position = cc.p(0, 0);
        this.frameType = ccs.FRAME_TYPE_MOVE
    },
    setPosition: function(a, b) {
        void 0 === b ? (this._position.x = a.x, this._position.y = a.y) : (this._position.x = a, this._position.y = b)
    },
    getPosition: function() {
        return this._position
    },
    getAction: function(a) {
        return this._getEasingAction(cc.moveTo(a, this._position))
    }
});
ccs.ActionScaleFrame = ccs.ActionFrame.extend({
    _scaleX: 1,
    _scaleY: 1,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._scaleY = this._scaleX = 1;
        this.frameType = ccs.FRAME_TYPE_SCALE
    },
    setScaleX: function(a) {
        this._scaleX = a
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleY: function(a) {
        this._scaleY = a
    },
    getScaleY: function() {
        return this._scaleY
    },
    getAction: function(a) {
        return this._getEasingAction(cc.scaleTo(a, this._scaleX, this._scaleY))
    }
});
ccs.ActionRotationFrame = ccs.ActionFrame.extend({
    _rotation: 0,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._rotation = 0;
        this.frameType = ccs.FRAME_TYPE_ROTATE
    },
    setRotation: function(a) {
        this._rotation = a
    },
    getRotation: function() {
        return this._rotation
    },
    getAction: function(a, b) {
        return void 0 === b ? this._getEasingAction(cc.rotateTo(a, this._rotation)) : b instanceof cc.ActionRotationFrame ? this._getEasingAction(cc.rotateBy(a, this._rotation - b._rotation)) : this.getAction(a)
    }
});
ccs.ActionFadeFrame = ccs.ActionFrame.extend({
    _opacity: 255,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._opacity = 255;
        this.frameType = ccs.FRAME_TYPE_FADE
    },
    setOpacity: function(a) {
        this._opacity = a
    },
    getOpacity: function() {
        return this._opacity
    },
    getAction: function(a) {
        return this._getEasingAction(cc.fadeTo(a, this._opacity))
    }
});
ccs.ActionTintFrame = ccs.ActionFrame.extend({
    _color: null,
    ctor: function() {
        ccs.ActionFrame.prototype.ctor.call(this);
        this._color = cc.color(255, 255, 255, 255);
        this.frameType = ccs.FRAME_TYPE_TINT
    },
    setColor: function(a) {
        var b = this._color;
        b.r = a.r;
        b.g = a.g;
        b.b = a.b
    },
    getColor: function() {
        var a = this._color;
        return cc.color(a.r, a.g, a.b, a.a)
    },
    getAction: function(a) {
        return this._getEasingAction(cc.tintTo(a, this._color.r, this._color.g, this._color.b))
    }
});
ccs.actionManager = {
    _actionDic: {},
    initWithDictionary: function(a, b, c) {
        var d = a.lastIndexOf("/");
        a = a.substr(d + 1, a.length);
        b = b.actionlist;
        for (var d = [], e = 0; e < b.length; e++) {
            var f = new ccs.ActionObject;
            f.initWithDictionary(b[e], c);
            d.push(f)
        }
        this._actionDic[a] = d
    },
    getActionByName: function(a, b) {
        var c = a.lastIndexOf("/"),
            c = a.substr(c + 1, a.length),
            c = this._actionDic[c];
        if (!c) return null;
        for (var d = 0; d < c.length; d++) {
            var e = c[d];
            if (b === e.getName()) return e
        }
        return null
    },
    playActionByName: function(a, b, c) {
        (a = this.getActionByName(a,
            b)) && a.play(c)
    },
    stopActionByName: function(a, b) {
        var c = this.getActionByName(a, b);
        c && c.stop()
    },
    releaseActions: function() {
        this._actionDic = {}
    },
    clear: function() {
        this._actionDic = {}
    }
};
ccs.ActionNode = ccs.Class.extend({
    _currentFrameIndex: 0,
    _destFrameIndex: 0,
    _unitTime: 0,
    _actionTag: 0,
    _object: null,
    _actionSpawn: null,
    _action: null,
    _frameArray: null,
    _frameArrayNum: 0,
    ctor: function() {
        this._destFrameIndex = this._currentFrameIndex = 0;
        this._unitTime = 0.1;
        this._actionTag = 0;
        this._action = this._actionSpawn = this._object = null;
        this._frameArray = [];
        this._frameArrayNum = ccs.FRAME_TYPE_MAX;
        for (var a = 0; a < this._frameArrayNum; a++) this._frameArray.push([])
    },
    initWithDictionary: function(a, b) {
        this.setActionTag(a.ActionTag);
        for (var c = a.actionframelist, d = 0; d < c.length; d++) {
            var e = c[d],
                f = e.frameid,
                g = e.tweenType;
            null == g && (g = 0);
            for (var h = e.tweenParameter, k = [], m = 0; m < h; m++) k.push(e.tweenParameter[m]);
            if (void 0 !== e.positionx) {
                var m = e.positionx,
                    n = e.positiony,
                    h = new ccs.ActionMoveFrame;
                h.frameIndex = f;
                h.setEasingType(g);
                h.setEasingParameter(k);
                h.setPosition(m, n);
                m = this._frameArray[ccs.FRAME_TYPE_MOVE];
                m.push(h)
            }
            void 0 !== e.scalex && (m = e.scalex, n = e.scaley, h = new ccs.ActionScaleFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(k),
                h.setScaleX(m), h.setScaleY(n), m = this._frameArray[ccs.FRAME_TYPE_SCALE], m.push(h));
            void 0 !== e.rotation && (m = e.rotation, h = new ccs.ActionRotationFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(k), h.setRotation(m), m = this._frameArray[ccs.FRAME_TYPE_ROTATE], m.push(h));
            void 0 !== e.opacity && (m = e.opacity, h = new ccs.ActionFadeFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(k), h.setOpacity(m), m = this._frameArray[ccs.FRAME_TYPE_FADE], m.push(h));
            void 0 !== e.colorr && (m = e.colorr, n = e.colorg,
                e = e.colorb, h = new ccs.ActionTintFrame, h.frameIndex = f, h.setEasingType(g), h.setEasingParameter(k), h.setColor(cc.color(m, n, e)), m = this._frameArray[ccs.FRAME_TYPE_TINT], m.push(h))
        }
        this._initActionNodeFromRoot(b)
    },
    _initActionNodeFromRoot: function(a) {
        a instanceof ccui.Widget && (a = ccui.helper.seekActionWidgetByActionTag(a, this.getActionTag())) && this.setObject(a)
    },
    setUnitTime: function(a) {
        this._unitTime = a;
        this._refreshActionProperty()
    },
    getUnitTime: function() {
        return this._unitTime
    },
    setActionTag: function(a) {
        this._actionTag =
            a
    },
    getActionTag: function() {
        return this._actionTag
    },
    setObject: function(a) {
        this._object = a
    },
    getObject: function() {
        return this._object
    },
    getActionNode: function() {
        return this._object instanceof cc.Node ? this._object : null
    },
    insertFrame: function(a, b) {
        null != b && this._frameArray[b.frameType].splice(a, 0, b)
    },
    addFrame: function(a) {
        a && this._frameArray[a.frameType].push(a)
    },
    deleteFrame: function(a) {
        null != a && cc.arrayRemoveObject(this._frameArray[a.frameType], a)
    },
    clearAllFrame: function() {
        for (var a = 0; a < this._frameArrayNum; a++) this._frameArray[a].length =
            0
    },
    _refreshActionProperty: function() {
        if (null === this._object) return null;
        for (var a = [], b = 0; b < this._frameArrayNum; b++) {
            var c = this._frameArray[b];
            if (!(0 >= c.length)) {
                for (var d = [], e = 0; e < c.length; e++) {
                    var f = c[e],
                        g = null;
                    0 !== e ? (g = (f.frameIndex - c[e - 1].frameIndex) * this.getUnitTime(), g = f.getAction(g)) : g = f.getAction(0);
                    g && d.push(g)
                }
                d && (c = cc.sequence(d), null !== c && a.push(c))
            }
        }
        this._action = null;
        return this._actionSpawn = cc.spawn(a)
    },
    playAction: function(a) {
        null !== this._object && null !== this._actionSpawn && (this._action =
            a ? cc.sequence(this._actionSpawn, a) : cc.sequence(this._actionSpawn), this._runAction())
    },
    _runAction: function() {
        var a = this.getActionNode();
        null !== a && null !== this._action && a.runAction(this._action)
    },
    stopAction: function() {
        var a = this.getActionNode();
        null !== a && null !== this._action && (this._action.isDone() || a.stopAction(this._action))
    },
    getFirstFrameIndex: function() {
        for (var a = 99999, b = !1, c = this._frameArray, d = 0, e = this._frameArrayNum; d < e; d++) {
            var f = c[d];
            0 >= f.length || (b = !0, f = f[0].frameIndex, a = a > f ? f : a)
        }
        b || (a = 0);
        return a
    },
    getLastFrameIndex: function() {
        for (var a = -1, b = !1, c = this._frameArray, d = 0, e = this._frameArrayNum; d < e; d++) {
            var f = c[d];
            0 >= f.length || (b = !0, f = f[f.length - 1].frameIndex, a = a < f ? f : a)
        }
        b || (a = 0);
        return a
    },
    updateActionToTimeLine: function(a) {
        for (var b = !1, c = this.getUnitTime(), d = 0; d < this._frameArrayNum; d++) {
            var e = this._frameArray[d];
            if (null !== e)
                for (var f = 0; f < e.length; f++) {
                    var g = e[f];
                    if (g.frameIndex * c === a) {
                        this._easingToFrame(1, 1, g);
                        b = !0;
                        break
                    } else if (g.frameIndex * c > a) {
                        0 === f ? (this._easingToFrame(1, 1, g), b = !1) : (b = e[f - 1],
                            e = (g.frameIndex - b.frameIndex) * c, f = a - b.frameIndex * c, this._easingToFrame(e, 1, b), this._easingToFrame(e, f / e, g), b = !0);
                        break
                    }
                }
        }
        return b
    },
    _easingToFrame: function(a, b, c) {
        a = c.getAction(a);
        c = this.getActionNode();
        null != a && null != c && (a.startWithTarget(c), a.update(b))
    },
    isActionDoneOnce: function() {
        return null === this._action ? !0 : this._action.isDone()
    }
});
ccs.ActionObject = ccs.Class.extend({
    _actionNodeList: null,
    _name: "",
    _loop: !1,
    _pause: !1,
    _playing: !1,
    _unitTime: 0,
    _currentTime: 0,
    _scheduler: null,
    _callback: null,
    _fTotalTime: 0,
    ctor: function() {
        this._actionNodeList = [];
        this._name = "";
        this._playing = this._pause = this._loop = !1;
        this._unitTime = 0.1;
        this._fTotalTime = this._currentTime = 0;
        this._scheduler = cc.director.getScheduler()
    },
    setName: function(a) {
        this._name = a
    },
    getName: function() {
        return this._name
    },
    setLoop: function(a) {
        this._loop = a
    },
    getLoop: function() {
        return this._loop
    },
    setUnitTime: function(a) {
        this._unitTime = a;
        a = this._actionNodeList.length;
        for (var b = 0; b < a; b++) this._actionNodeList[b].setUnitTime(this._unitTime)
    },
    getUnitTime: function() {
        return this._unitTime
    },
    getCurrentTime: function() {
        return this._currentTime
    },
    setCurrentTime: function(a) {
        this._currentTime = a
    },
    getTotalTime: function() {
        return this._fTotalTime
    },
    isPlaying: function() {
        return this._playing
    },
    initWithDictionary: function(a, b) {
        this.setName(a.name);
        this.setLoop(a.loop);
        this.setUnitTime(a.unittime);
        for (var c = a.actionnodelist,
                d = 0, e = 0; e < c.length; e++) {
            var f = new ccs.ActionNode;
            f.initWithDictionary(c[e], b);
            f.setUnitTime(this.getUnitTime());
            this._actionNodeList.push(f);
            f = f.getLastFrameIndex() - f.getFirstFrameIndex();
            f > d && (d = f)
        }
        this._fTotalTime = d * this._unitTime
    },
    addActionNode: function(a) {
        a && (this._actionNodeList.push(a), a.setUnitTime(this._unitTime))
    },
    removeActionNode: function(a) {
        null != a && cc.arrayRemoveObject(this._actionNodeList, a)
    },
    play: function(a) {
        this.stop();
        this.updateToFrameByTime(0);
        for (var b = this._actionNodeList, c = b.length,
                d = 0; d < c; d++) b[d].playAction(a);
        this._loop && this._scheduler.schedule(this.simulationActionUpdate, this, 0, cc.REPEAT_FOREVER, 0, !1, this.__instanceId + "");
        void 0 !== a && (this._callback = a)
    },
    pause: function() {
        this._pause = !0;
        this._playing = !1
    },
    stop: function() {
        for (var a = this._actionNodeList, b = 0; b < a.length; b++) a[b].stopAction();
        this._scheduler.unschedule(this.simulationActionUpdate, this);
        this._playing = this._pause = !1
    },
    updateToFrameByTime: function(a) {
        this._currentTime = a;
        for (var b = 0; b < this._actionNodeList.length; b++) this._actionNodeList[b].updateActionToTimeLine(a)
    },
    simulationActionUpdate: function(a) {
        a = !0;
        for (var b = this._actionNodeList, c = 0, d = b.length; c < d; c++)
            if (!b[c].isActionDoneOnce()) {
                a = !1;
                break
            }
        a && (null !== this._callback && this._callback.execute(), this._loop ? this.play() : (this._playing = !1, this._scheduler.unschedule(this.simulationActionUpdate, this)))
    }
});
ccs.ComAttribute = ccs.Component.extend({
    _jsonDict: null,
    _filePath: "",
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._jsonDict = {};
        this._filePath = "";
        this._name = "CCComAttribute";
        ccs.ComAttribute.prototype.init.call(this)
    },
    init: function() {
        this._jsonDict = {};
        return !0
    },
    setInt: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setDouble: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setFloat: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setBool: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setString: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    setObject: function(a, b) {
        a ? this._jsonDict[a] = b : cc.log("Argument must be non-nil")
    },
    getInt: function(a) {
        return parseInt(this._jsonDict[a] || 0)
    },
    getDouble: function(a) {
        return parseFloat(this._jsonDict[a] || 0)
    },
    getFloat: function(a) {
        return parseFloat(this._jsonDict[a] || 0)
    },
    getBool: function(a) {
        return Boolean(this._jsonDict[a] || !1)
    },
    getString: function(a) {
        return this._jsonDict[a] ||
            ""
    },
    getObject: function(a) {
        return this._jsonDict[a]
    },
    parse: function(a) {
        this._jsonDict = cc.loader.getRes(a)
    }
});
ccs.ComAttribute.create = function() {
    return new ccs.ComAttribute
};
ccs.ComAudio = ccs.Component.extend({
    _filePath: "",
    _loop: !1,
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._name = "Audio";
        ccs.ComAudio.prototype.init.call(this)
    },
    init: function() {
        return !0
    },
    onExit: function() {
        this.stopBackgroundMusic(!0);
        this.stopAllEffects()
    },
    end: function() {
        cc.audioEngine.end()
    },
    preloadBackgroundMusic: function(a) {
        cc.loader.load(a)
    },
    playBackgroundMusic: function(a, b) {
        a ? cc.audioEngine.playMusic(a, b) : cc.audioEngine.playMusic(this._filePath, this._loop)
    },
    stopBackgroundMusic: function(a) {
        cc.audioEngine.stopMusic(a)
    },
    pauseBackgroundMusic: function() {
        cc.audioEngine.pauseMusic()
    },
    resumeBackgroundMusic: function() {
        cc.audioEngine.resumeMusic()
    },
    rewindBackgroundMusic: function() {
        cc.audioEngine.rewindMusic()
    },
    willPlayBackgroundMusic: function() {
        return cc.audioEngine.willPlayMusic()
    },
    isBackgroundMusicPlaying: function() {
        return cc.audioEngine.isMusicPlaying()
    },
    getBackgroundMusicVolume: function() {
        return cc.audioEngine.getMusicVolume()
    },
    setBackgroundMusicVolume: function(a) {
        cc.audioEngine.setMusicVolume(a)
    },
    getEffectsVolume: function() {
        return cc.audioEngine.getEffectsVolume()
    },
    setEffectsVolume: function(a) {
        cc.audioEngine.setEffectsVolume(a)
    },
    playEffect: function(a, b) {
        return a ? cc.audioEngine.playEffect(a, b) : cc.audioEngine.playEffect(this._filePath, this._loop)
    },
    pauseEffect: function(a) {
        cc.audioEngine.pauseEffect(a)
    },
    pauseAllEffects: function() {
        cc.audioEngine.pauseAllEffects()
    },
    resumeEffect: function(a) {
        cc.audioEngine.resumeEffect(a)
    },
    resumeAllEffects: function() {
        cc.audioEngine.resumeAllEffects()
    },
    stopEffect: function(a) {
        cc.audioEngine.stopEffect(a)
    },
    stopAllEffects: function() {
        cc.audioEngine.stopAllEffects()
    },
    preloadEffect: function(a) {
        cc.loader.getRes(a);
        this.setFile(a);
        this.setLoop(!1)
    },
    unloadEffect: function(a) {
        cc.audioEngine.unloadEffect(a)
    },
    setFile: function(a) {
        this._filePath = a
    },
    setLoop: function(a) {
        this._loop = a
    },
    getFile: function() {
        return this._filePath
    },
    isLoop: function() {
        return this._loop
    }
});
ccs.ComAudio.create = function() {
    return new ccs.ComAudio
};
ccs.ComController = ccs.Component.extend({
    ctor: function() {
        cc.Component.prototype.ctor.call(this);
        this._name = "ComController";
        ccs.ComController.prototype.init.call(this)
    },
    onEnter: function() {
        null !== this._owner && this._owner.scheduleUpdate()
    },
    isEnabled: function() {
        return this._enabled
    },
    setEnabled: function(a) {
        this._enabled = a
    }
});
ccs.ComController.create = function() {
    return new ccs.ComController
};
ccs.ComRender = ccs.Component.extend({
    _render: null,
    ctor: function(a, b) {
        cc.Component.prototype.ctor.call(this);
        this._render = a;
        this._name = b;
        this.isRenderer = !0;
        ccs.ComRender.prototype.init.call(this)
    },
    onEnter: function() {
        this._owner && this._owner.addChild(this._render)
    },
    onExit: function() {
        this._owner && (this._owner.removeChild(this._render, !0), this._render = null)
    },
    getNode: function() {
        return this._render
    },
    setNode: function(a) {
        this._render = a
    }
});
ccs.ComRender.create = function(a, b) {
    return new ccs.ComRender(a, b)
};
ccs.objectFactory = {
    _typeMap: {},
    createObject: function(a) {
        var b = null;
        (a = this._typeMap[a]) && (b = cc.isFunction(a._fun) ? new a._fun : a._fun);
        return b
    },
    registerType: function(a) {
        this._typeMap[a._className] = a
    },
    createGUI: function(a) {
        var b = null;
        "Panel" === a ? a = "Layout" : "TextArea" === a ? a = "Label" : "TextButton" === a && (a = "Button");
        (a = this._typeMap[a]) && a._fun && (b = a._fun);
        return b
    },
    removeAll: function() {
        this._typeMap = {}
    }
};
ccs.TInfo = ccs.Class.extend({
    _className: "",
    _fun: null,
    ctor: function(a, b) {
        b ? (this._className = a, this._fun = b) : (this._className = a._className, this._fun = a._fun);
        ccs.objectFactory.registerType(this)
    }
});
ccs.sendEvent = function(a) {
    a = ccs.triggerManager.get(a);
    if (null != a)
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            null != c && c.detect() && c.done()
        }
};
ccs.registerTriggerClass = function(a, b) {
    new ccs.TInfo(a, b)
};
ccs.triggerManager = {
    _eventTriggers: {},
    _triggerObjs: {},
    _movementDispatches: [],
    parse: function(a) {
        for (var b = 0; b < a.length; ++b) {
            var c = a[b],
                d = new ccs.TriggerObj;
            d.serialize(c);
            for (var c = d.getEvents(), e = 0; e < c.length; e++) this.add(c[e], d);
            this._triggerObjs[d.getId()] = d
        }
    },
    get: function(a) {
        return this._eventTriggers[a]
    },
    getTriggerObj: function(a) {
        return this._triggerObjs[a]
    },
    add: function(a, b) {
        var c = this._eventTriggers[a];
        c || (c = []); - 1 === c.indexOf(b) && (c.push(b), this._eventTriggers[a] = c)
    },
    removeAll: function() {
        for (var a in this._eventTriggers)
            for (var b =
                    this._eventTriggers[a], c = 0; c < b.length; c++) b[c].removeAll();
        this._eventTriggers = {}
    },
    remove: function(a, b) {
        if (b) return this._removeObj(a, b);
        var c = !1,
            d = this._eventTriggers[a];
        if (d) {
            for (c = 0; c < d.length; c++) {
                var e = d[c];
                e && e.removeAll()
            }
            delete this._eventTriggers[a];
            c = !0
        }
        return c
    },
    _removeObj: function(a, b) {
        var c = !1;
        do {
            var d = this._eventTriggers[a];
            if (d) {
                for (c = 0; c < d.length; c++) {
                    var e = d[c];
                    if (e && e == b) {
                        e.removeAll();
                        d.splice(c, 1);
                        break
                    }
                }
                c = !0
            }
        } while (0);
        return c
    },
    removeTriggerObj: function(a) {
        a = this.getTriggerObj(a);
        if (!a) return !1;
        for (var b = a.getEvents(), c = 0; c < b.length; c++) this.remove(b[c], a);
        return !0
    },
    isEmpty: function() {
        return !this._eventTriggers || 0 >= this._eventTriggers.length
    },
    addArmatureMovementCallBack: function(a, b, c) {
        if (null != a && null != c && null != b) {
            for (var d, e = !1, f = 0; f < this._movementDispatches.length; f++)(d = this._movementDispatches[f]) && d[0] === a && (d.addAnimationEventCallBack(b, c), e = !0);
            e || (d = new ccs.ArmatureMovementDispatcher, a.getAnimation().setMovementEventCallFunc(d.animationEvent, d), d.addAnimationEventCallBack(b,
                c), this._movementDispatches.push([a, d]))
        }
    },
    removeArmatureMovementCallBack: function(a, b, c) {
        if (null != a && null != b && null != c)
            for (var d, e = 0; e < this._movementDispatches.length; e++)(d = this._movementDispatches[e]) && d[0] === a && d.removeAnimationEventCallBack(c, b)
    },
    removeArmatureAllMovementCallBack: function(a) {
        if (null != a)
            for (var b, c = 0; c < this._movementDispatches.length; c++)
                if ((b = this._movementDispatches[c]) && b[0] === a) {
                    this._movementDispatches.splice(c, 1);
                    break
                }
    },
    removeAllArmatureMovementCallBack: function() {
        this._movementDispatches.length =
            0
    },
    version: function() {
        return "1.2.0.0"
    }
};
ccs.ArmatureMovementDispatcher = ccs.Class.extend({
    _mapEventAnimation: null,
    ctor: function() {
        this._mapEventAnimation = []
    },
    animationEvent: function(a, b, c) {
        for (var d, e, f = 0; f < this._mapEventAnimation.length; f++) d = this._mapEventAnimation[f], e = d[0], (d = d[1]) && d.call(e, a, b, c)
    },
    addAnimationEventCallBack: function(a, b) {
        this._mapEventAnimation.push([b, a])
    },
    removeAnimationEventCallBack: function(a, b) {
        for (var c, d = 0; d < this._mapEventAnimation.length; d++) c = this._mapEventAnimation[d], c[0] === b && this._mapEventAnimation.splice(d,
            1)
    }
});
ccs.BaseTriggerCondition = ccs.Class.extend({
    ctor: function() {},
    init: function() {
        return !0
    },
    detect: function() {
        return !0
    },
    serialize: function(a) {},
    removeAll: function() {}
});
ccs.BaseTriggerAction = ccs.Class.extend({
    ctor: function() {},
    init: function() {
        return !0
    },
    done: function() {},
    serialize: function(a) {},
    removeAll: function() {}
});
ccs.TriggerObj = ccs.Class.extend({
    _cons: null,
    _acts: null,
    _id: 0,
    _enable: !0,
    _vInt: null,
    ctor: function() {
        this._id = 0;
        this._enable = !0;
        ccs.TriggerObj.prototype.init.call(this)
    },
    init: function() {
        this._cons = [];
        this._acts = [];
        this._vInt = [];
        return !0
    },
    detect: function() {
        if (!this._enable || 0 === this._cons.length) return !0;
        for (var a = !0, b = null, c = 0; c < this._cons.length; c++)(b = this._cons[c]) && b.detect && (a = a && b.detect());
        return a
    },
    done: function() {
        if (this._enable && 0 !== this._acts.length)
            for (var a, b = 0; b < this._acts.length; b++)(a =
                this._acts[b]) && a.done && a.done()
    },
    removeAll: function() {
        for (var a = null, b = 0; b < this._cons.length; b++)(a = this._cons[b]) && a.removeAll();
        this._cons = [];
        for (b = 0; b < this._acts.length; b++)(a = this._acts[b]) && a.removeAll();
        this._acts = []
    },
    serialize: function(a) {
        this._id = a.id || 0;
        for (var b = a.conditions || [], c = 0; c < b.length; c++) {
            var d = b[c],
                e = d.classname,
                f = ccs.objectFactory.createObject(e);
            f ? (f.serialize(d), f.init(), this._cons.push(f)) : cc.log("class named classname(" + e + ") can not implement!")
        }
        b = a.actions || [];
        for (c = 0; c <
            b.length; c++) d = b[c], e = d.classname, (f = ccs.objectFactory.createObject(e)) ? (f.serialize(d), f.init(), this._acts.push(f)) : cc.log("class named classname(" + e + ") can not implement!");
        a = a.events || [];
        for (c = 0; c < a.length; c++) d = a[c], d = d.id, 0 > d || this._vInt.push(d)
    },
    getId: function() {
        return this._id
    },
    setEnable: function(a) {
        this._enable = a
    },
    getEvents: function() {
        return this._vInt
    }
});
ccs.TriggerObj.create = function() {
    return new ccs.TriggerObj
};
ccs.ActionTimelineData = ccs.Class.extend({
    _actionTag: 0,
    ctor: function(a) {
        this._init(a)
    },
    _init: function(a) {
        this._actionTag = a;
        return !0
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    }
});
ccs.AnimationInfo = function(a, b, c) {
    this.name = a;
    this.startIndex = b;
    this.endIndex = c
};
ccs.ComExtensionData = ccs.Component.extend({
    _customProperty: null,
    _timelineData: null,
    _name: "ComExtensionData",
    ctor: function() {
        this._customProperty = "";
        this._timelineData = new ccs.ActionTimelineData(0);
        return !0
    },
    setActionTag: function(a) {
        this._timelineData.setActionTag(a)
    },
    getActionTag: function() {
        return this._timelineData.getActionTag()
    },
    setCustomProperty: function(a) {
        this._customProperty = a
    },
    getCustomProperty: function() {
        return this._customProperty
    }
});
ccs.ComExtensionData.create = function() {
    return new ccs.ComExtensionData
};
ccs.ActionTimelineData.create = function(a) {
    return new ccs.ActionTimelineData(a)
};
ccs.ActionTimeline = cc.Action.extend({
    _timelineMap: null,
    _timelineList: null,
    _duration: 0,
    _time: null,
    _timeSpeed: 1,
    _frameInternal: 1 / 60,
    _playing: !1,
    _currentFrame: 0,
    _startFrame: 0,
    _endFrame: 0,
    _loop: null,
    _frameEventListener: null,
    _animationInfos: null,
    _lastFrameListener: null,
    ctor: function() {
        cc.Action.prototype.ctor.call(this);
        this._timelineMap = {};
        this._timelineList = [];
        this._animationInfos = {};
        this.init()
    },
    _gotoFrame: function(a) {
        for (var b = this._timelineList.length, c = 0; c < b; c++) this._timelineList[c]._gotoFrame(a)
    },
    _stepToFrame: function(a) {
        for (var b = this._timelineList.length, c = 0; c < b; c++) this._timelineList[c]._stepToFrame(a)
    },
    _emitFrameEvent: function(a) {
        this._frameEventListener && this._frameEventListener(a)
    },
    init: function() {
        return !0
    },
    gotoFrameAndPlay: function(a, b, c, d) {
        var e = 0,
            f = arguments.length,
            g = [],
            h;
        for (e; e < f; e++) "boolean" === typeof arguments[e] ? h = arguments[e] : g.push(arguments[e]);
        a = g[0];
        b = void 0 !== g[1] ? g[1] : this._duration;
        c = g[2] || a;
        this._startFrame = a;
        this._endFrame = b;
        this._currentFrame = c;
        this._loop = null != h ?
            h : !0;
        this._time = this._currentFrame * this._frameInternal;
        this.resume();
        this._gotoFrame(this._currentFrame)
    },
    gotoFrameAndPause: function(a) {
        this._startFrame = this._currentFrame = a;
        this._time = this._currentFrame * this._frameInternal;
        this.pause();
        this._gotoFrame(this._currentFrame)
    },
    pause: function() {
        this._playing = !1
    },
    resume: function() {
        this._playing = !0
    },
    isPlaying: function() {
        return this._playing
    },
    setTimeSpeed: function(a) {
        this._timeSpeed = a
    },
    getTimeSpeed: function() {
        return this._timeSpeed
    },
    setDuration: function(a) {
        this._duration =
            a
    },
    getDuration: function() {
        return this._duration
    },
    getStartFrame: function() {
        return this._startFrame
    },
    getEndFrame: function() {
        return this._endFrame
    },
    setCurrentFrame: function(a) {
        a >= this._startFrame && a <= this._endFrame ? (this._currentFrame = a, this._time = this._currentFrame * this._frameInternal) : cc.log("frame index is not between start frame and end frame")
    },
    getCurrentFrame: function() {
        return this._currentFrame
    },
    addTimeline: function(a) {
        var b = a.getActionTag();
        this._timelineMap[b] || (this._timelineMap[b] = []); - 1 ===
            this._timelineMap[b].indexOf(a) && (this._timelineList.push(a), this._timelineMap[b].push(a), a.setActionTimeline(this))
    },
    removeTimeline: function(a) {
        var b = a.getActionTag();
        this._timelineMap[b] && this._timelineMap[b].some(function(b) {
            if (b === a) return !0
        }) && (cc.arrayRemoveObject(this._timelineMap[b], a), cc.arrayRemoveObject(this._timelineList, a), a.setActionTimeline(null))
    },
    getTimelines: function() {
        return this._timelineList
    },
    setFrameEventCallFunc: function(a) {
        this._frameEventListener = a
    },
    clearFrameEventCallFunc: function() {
        this._frameEventListener =
            null
    },
    clone: function() {
        var a = new ccs.ActionTimeline;
        a.setDuration(this._duration);
        a.setTimeSpeed(this._timeSpeed);
        for (var b in this._timelineMap) {
            var c = this._timelineMap[b],
                d;
            for (d in c) {
                var e = c[d].clone();
                a.addTimeline(e)
            }
        }
        return a
    },
    reverse: function() {
        return null
    },
    step: function(a) {
        this._playing && 0 !== this._timelineMap.length && 0 !== this._duration && (this._time += a * this._timeSpeed, a = this._time - this._endFrame * this._frameInternal, a < this._frameInternal ? (this._currentFrame = this._time / this._frameInternal, this._stepToFrame(this._currentFrame),
            0 <= a && this._lastFrameListener && this._lastFrameListener()) : (this._playing = this._loop) ? this.gotoFrameAndPlay(this._startFrame, this._endFrame, this._loop) : (this._time = this._endFrame * this._frameInternal, this._currentFrame != this._endFrame && (this._currentFrame = this._endFrame, this._stepToFrame(this._currentFrame), this._lastFrameListener && this._lastFrameListener())))
    },
    _foreachNodeDescendant: function(a, b) {
        b(a);
        for (var c = a.getChildren(), d = 0; d < c.length; d++) this._foreachNodeDescendant(c[d], b)
    },
    startWithTarget: function(a) {
        cc.Action.prototype.startWithTarget.call(this,
            a);
        var b = this;
        this._foreachNodeDescendant(a, function(a) {
            var d = a.getComponent("ComExtensionData");
            if (d && (d = d.getActionTag(), b._timelineMap[d]))
                for (var d = b._timelineMap[d], e = 0; e < d.length; e++) d[e].setNode(a)
        })
    },
    isDone: function() {
        return !1
    },
    play: function(a, b) {
        var c = this._animationInfos[a];
        if (!c) return cc.log("Can't find animation info for %s", a);
        this.gotoFrameAndPlay(c.startIndex, c.endIndex, b)
    },
    addAnimationInfo: function(a) {
        this._animationInfos[a.name] = a
    },
    removeAnimationInfo: function(a) {
        delete this._animationInfos[a]
    },
    isAnimationInfoExists: function(a) {
        return this._animationInfos[a]
    },
    getAnimationInfo: function(a) {
        return this._animationInfos[a]
    },
    setLastFrameCallFunc: function(a) {
        this._lastFrameListener = a
    },
    clearLastFrameCallFunc: function() {
        this._lastFrameListener = null
    }
});
ccs.ActionTimeline.create = function() {
    return new ccs.ActionTimeline
};
ccs.Frame = ccs.Class.extend({
    _frameIndex: null,
    _tween: null,
    _timeline: null,
    _node: null,
    _tweenType: null,
    _easingParam: null,
    _enterWhenPassed: null,
    ctor: function() {
        this._frameIndex = 0;
        this._tween = !0;
        this._node = this._timeline = null;
        this._enterWhenPassed = !1;
        this._easingParam = []
    },
    _emitEvent: function() {
        this._timeline && this._timeline.getActionTimeline()._emitFrameEvent(this)
    },
    _cloneProperty: function(a) {
        this._frameIndex = a.getFrameIndex();
        this._tween = a.isTween();
        this._tweenType = a.getTweenType();
        this.setEasingParams(a.getEasingParams())
    },
    setFrameIndex: function(a) {
        this._frameIndex = a
    },
    getFrameIndex: function() {
        return this._frameIndex
    },
    setTimeline: function(a) {
        this._timeline = a
    },
    getTimeline: function(a) {
        return this._timeline
    },
    setNode: function(a) {
        this._node = a
    },
    getNode: function() {
        return this._node
    },
    setTween: function(a) {
        this._tween = a
    },
    isTween: function() {
        return this._tween
    },
    onEnter: function(a) {},
    apply: function(a) {
        this._tween && (this._tweenType !== ccs.FrameEaseType.TWEEN_EASING_MAX && this._tweenType !== ccs.FrameEaseType.LINEAR && (a = this.tweenPercent(a)),
            this._onApply(a))
    },
    _onApply: function(a) {},
    clone: function() {},
    tweenPercent: function(a) {
        var b = ccs.Frame.tweenToMap[this._tweenType];
        return b ? b(a, this._easingParam) : a
    },
    setEasingParams: function(a) {
        if (a)
            for (var b = this._easingParam.length = 0; b < a.length; b++) this._easingParam[b] = a[b]
    },
    getEasingParams: function() {
        return this._easingParam
    },
    setTweenType: function(a) {
        this._tweenType = a
    },
    getTweenType: function() {
        return this._tweenType
    },
    isEnterWhenPassed: function() {
        return this._enterWhenPassed
    }
});
ccs.Frame.tweenToMap = {
    "-1": function(a, b) {
        if (b) {
            var c = 1 - a;
            return b[1] * c * c * c + 3 * b[3] * a * c * c + 3 * b[5] * a * a * c + b[7] * a * a * a
        }
        return a
    },
    1: cc._easeSineInObj.easing,
    2: cc._easeSineOutObj.easing,
    3: cc._easeSineInOutObj.easing,
    4: cc._easeQuadraticActionIn.easing,
    5: cc._easeQuadraticActionOut.easing,
    6: cc._easeQuadraticActionInOut.easing,
    7: cc._easeCubicActionIn.easing,
    8: cc._easeCubicActionOut.easing,
    9: cc._easeCubicActionInOut.easing,
    10: cc._easeCubicActionIn.easing,
    11: cc._easeCubicActionOut.easing,
    12: cc._easeCubicActionInOut.easing,
    13: cc._easeQuinticActionIn.easing,
    14: cc._easeQuinticActionOut.easing,
    15: cc._easeQuinticActionInOut.easing,
    16: cc._easeExponentialInObj.easing,
    17: cc._easeExponentialOutObj.easing,
    18: cc._easeExponentialInOutObj.easing,
    19: cc._easeCircleActionIn.easing,
    20: cc._easeCircleActionOut.easing,
    21: cc._easeCircleActionInOut.easing,
    22: function(a, b) {
        var c = 0.3;
        null != b && (c = b[0]);
        return cc.easeElasticIn(c).easing(a)
    },
    23: function(a, b) {
        var c = 0.3;
        null != b && (c = b[0]);
        return cc.easeElasticOut(c).easing(a)
    },
    24: function(a, b) {
        var c =
            0.3;
        null != b && (c = b[0]);
        return cc.easeElasticInOut(c).easing(a)
    },
    25: cc._easeBackInObj.easing,
    26: cc._easeBackOutObj.easing,
    27: cc._easeBackInOutObj.easing,
    28: cc._easeBounceInObj.easing,
    29: cc._easeBounceOutObj.easing,
    30: cc._easeBounceInOutObj.easing
};
ccs.VisibleFrame = ccs.Frame.extend({
    _visible: !0,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._visible = !0
    },
    onEnter: function(a) {
        this._node && this._node.setVisible(this._visible)
    },
    clone: function() {
        var a = new ccs.VisibleFrame;
        a.setVisible(this._visible);
        a._cloneProperty(this);
        return a
    },
    setVisible: function(a) {
        this._visible = a
    },
    isVisible: function() {
        return this._visible
    }
});
ccs.VisibleFrame.create = function() {
    return new ccs.VisibleFrame
};
ccs.TextureFrame = ccs.Frame.extend({
    _sprite: null,
    _textureName: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._textureName = ""
    },
    setNode: function(a) {
        ccs.Frame.prototype.setNode.call(this, a);
        this._sprite = a
    },
    onEnter: function(a) {
        if (this._sprite) {
            a = this._sprite.getBlendFunc();
            var b = cc.spriteFrameCache._spriteFrames[this._textureName];
            null != b ? this._sprite.setSpriteFrame(b) : this._sprite.setTexture(this._textureName);
            this._sprite.getBlendFunc() !== a && this._sprite.setBlendFunc(a)
        }
    },
    clone: function() {
        var a =
            new ccs.TextureFrame;
        a.setTextureName(this._textureName);
        a._cloneProperty(this);
        return a
    },
    setTextureName: function(a) {
        this._textureName = a
    },
    getTextureName: function() {
        return this._textureName
    }
});
ccs.TextureFrame.create = function() {
    return new ccs.TextureFrame
};
ccs.RotationFrame = ccs.Frame.extend({
    _rotation: null,
    _betwennRotation: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._rotation = 0
    },
    onEnter: function(a) {
        this._node && (this._node.setRotation(this._rotation), this._tween && (this._betwennRotation = a._rotation - this._rotation))
    },
    _onApply: function(a) {
        0 !== this._betwennRotation && this._node.setRotation(this._rotation + a * this._betwennRotation)
    },
    clone: function() {
        var a = new ccs.RotationFrame;
        a.setRotation(this._rotation);
        a._cloneProperty(this);
        return a
    },
    setRotation: function(a) {
        this._rotation = a
    },
    getRotation: function() {
        return this._rotation
    }
});
ccs.RotationFrame.create = function() {
    return new ccs.RotationFrame
};
ccs.SkewFrame = ccs.Frame.extend({
    _skewX: null,
    _skewY: null,
    _betweenSkewX: null,
    _betweenSkewY: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._skewY = this._skewX = 0
    },
    onEnter: function(a) {
        this._node && (this._node.setSkewX(this._skewX), this._node.setSkewY(this._skewY), this._tween && (this._betweenSkewX = a._skewX - this._skewX, this._betweenSkewY = a._skewY - this._skewY))
    },
    _onApply: function(a) {
        if (0 !== this._betweenSkewX || 0 !== this._betweenSkewY) {
            var b = this._skewY + a * this._betweenSkewY;
            this._node.setSkewX(this._skewX +
                a * this._betweenSkewX);
            this._node.setSkewY(b)
        }
    },
    clone: function() {
        var a = new ccs.SkewFrame;
        a.setSkewX(this._skewX);
        a.setSkewY(this._skewY);
        a._cloneProperty(this);
        return a
    },
    setSkewX: function(a) {
        this._skewX = a
    },
    getSkewX: function() {
        return this._skewX
    },
    setSkewY: function(a) {
        this._skewY = a
    },
    getSkewY: function() {
        return this._skewY
    }
});
ccs.SkewFrame.create = function() {
    return new ccs.SkewFrame
};
ccs.RotationSkewFrame = ccs.SkewFrame.extend({
    onEnter: function(a) {
        this._node && (this._node.setRotationX(this._skewX), this._node.setRotationY(this._skewY), this._tween && (this._betweenSkewX = a._skewX - this._skewX, this._betweenSkewY = a._skewY - this._skewY))
    },
    _onApply: function(a) {
        if (this._node && (0 !== this._betweenSkewX || 0 !== this._betweenSkewY)) {
            var b = this._skewY + a * this._betweenSkewY;
            this._node.setRotationX(this._skewX + a * this._betweenSkewX);
            this._node.setRotationY(b)
        }
    },
    clone: function() {
        var a = new ccs.RotationSkewFrame;
        a.setSkewX(this._skewX);
        a.setSkewY(this._skewY);
        a._cloneProperty(this);
        return a
    }
});
ccs.RotationSkewFrame.create = function() {
    return new ccs.RotationSkewFrame
};
ccs.PositionFrame = ccs.Frame.extend({
    _position: null,
    _betweenX: null,
    _betweenY: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._position = cc.p(0, 0)
    },
    onEnter: function(a) {
        this._node && (this._node.setPosition(this._position), this._tween && (this._betweenX = a._position.x - this._position.x, this._betweenY = a._position.y - this._position.y))
    },
    _onApply: function(a) {
        if (this._node && (0 !== this._betweenX || 0 !== this._betweenY)) {
            var b = cc.p(0, 0);
            b.x = this._position.x + this._betweenX * a;
            b.y = this._position.y + this._betweenY *
                a;
            this._node.setPosition(b)
        }
    },
    clone: function() {
        var a = new ccs.PositionFrame;
        a.setPosition(this._position);
        a._cloneProperty(this);
        return a
    },
    setPosition: function(a) {
        this._position = a
    },
    getPosition: function() {
        return this._position
    },
    setX: function(a) {
        this._position.x = a
    },
    getX: function() {
        return this._position.x
    },
    setY: function(a) {
        this._position.y = a
    },
    getY: function() {
        return this._position.y
    }
});
ccs.PositionFrame.create = function() {
    return new ccs.PositionFrame
};
ccs.ScaleFrame = ccs.Frame.extend({
    _scaleX: null,
    _scaleY: null,
    _betweenScaleX: null,
    _betweenScaleY: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._scaleY = this._scaleX = 1
    },
    onEnter: function(a) {
        this._node && (this._node.setScaleX(this._scaleX), this._node.setScaleY(this._scaleY), this._tween && (this._betweenScaleX = a._scaleX - this._scaleX, this._betweenScaleY = a._scaleY - this._scaleY))
    },
    _onApply: function(a) {
        if (this._node && (0 !== this._betweenScaleX || 0 !== this._betweenScaleY)) {
            var b = this._scaleY + this._betweenScaleY *
                a;
            this._node.setScaleX(this._scaleX + this._betweenScaleX * a);
            this._node.setScaleY(b)
        }
    },
    clone: function() {
        var a = new ccs.ScaleFrame;
        a.setScaleX(this._scaleX);
        a.setScaleY(this._scaleY);
        a._cloneProperty(this);
        return a
    },
    setScale: function(a) {
        this._scaleY = this._scaleX = a
    },
    setScaleX: function(a) {
        this._scaleX = a
    },
    getScaleX: function() {
        return this._scaleX
    },
    setScaleY: function(a) {
        this._scaleY = a
    },
    getScaleY: function() {
        return this._scaleY
    }
});
ccs.ScaleFrame.create = function() {
    return new ccs.ScaleFrame
};
ccs.AnchorPointFrame = ccs.Frame.extend({
    _anchorPoint: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._anchorPoint = cc.p(0, 0)
    },
    onEnter: function(a) {
        this._node && this._node.setAnchorPoint(this._anchorPoint)
    },
    clone: function() {
        var a = new ccs.AnchorPointFrame;
        a.setAnchorPoint(this._anchorPoint);
        a._cloneProperty(this);
        return a
    },
    setAnchorPoint: function(a) {
        this._anchorPoint = a
    },
    getAnchorPoint: function() {
        return this._anchorPoint
    }
});
ccs.AnchorPointFrame.create = function() {
    return new ccs.AnchorPointFrame
};
ccs.InnerActionType = {
    LoopAction: 0,
    NoLoopAction: 1,
    SingleFrame: 2
};
ccs.InnerActionFrame = ccs.Frame.extend({
    _innerActionType: null,
    _startFrameIndex: null,
    _endFrameIndex: 0,
    _singleFrameIndex: 0,
    _enterWithName: null,
    _animationName: "",
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._enterWithName = !1;
        this._innerActionType = ccs.InnerActionType.LoopAction;
        this._startFrameIndex = 0
    },
    onEnter: function(a) {
        if (this._node && (a = this._node.getActionByTag(this._node.getTag())))
            if (ccs.InnerActionType.SingleFrame === this._innerActionType) a.gotoFrameAndPause(this._singleFrameIndex);
            else {
                var b =
                    this._startFrameIndex,
                    c = this._endFrameIndex;
                this._enterWithName && ("-- ALL --" === this._animationName ? (b = 0, c = a.getDuration()) : a.isAnimationInfoExists(this._animationName) ? (c = a.getAnimationInfo(this._animationName), b = c.startIndex, c = c.endIndex) : cc.log("Animation %s not exists!", this._animationName));
                var d = this._timeline.getActionTimeline().getDuration() - this._frameIndex - c + b;
                0 > d && (c += d);
                ccs.InnerActionType.NoLoopAction === this._innerActionType ? a.gotoFrameAndPlay(b, c, !1) : ccs.InnerActionType.LoopAction ===
                    this._innerActionType && a.gotoFrameAndPlay(b, c, !0)
            }
    },
    setAnimationName: function(a) {
        this._animationName = a
    },
    setSingleFrameIndex: function(a) {
        this._singleFrameIndex = a
    },
    getSingleFrameIndex: function() {
        return this._startFrameIndex
    },
    setEnterWithName: function(a) {
        this._enterWithName = a
    },
    getEnterWithName: function() {
        return this._enterWithName
    },
    clone: function() {
        var a = new ccs.InnerActionFrame;
        a.setInnerActionType(this._innerActionType);
        a.setStartFrameIndex(this._startFrameIndex);
        a.setEnterWithName(this._enterWithName);
        a.setAnimationName(this._animationName);
        a.setSingleFrameIndex(this._singleFrameIndex);
        a._cloneProperty(this);
        return a
    },
    setInnerActionType: function(a) {
        this._innerActionType = a
    },
    getInnerActionType: function() {
        return this._innerActionType
    },
    setStartFrameIndex: function(a) {
        this._startFrameIndex = a
    },
    getStartFrameIndex: function() {
        return this._startFrameIndex
    }
});
ccs.InnerActionFrame.create = function() {
    return new ccs.InnerActionFrame
};
ccs.ColorFrame = ccs.Frame.extend({
    _alpha: null,
    _color: null,
    _betweenAlpha: null,
    _betweenRed: null,
    _betweenGreen: null,
    _betweenBlue: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._color = cc.color(255, 255, 255)
    },
    onEnter: function(a) {
        this._node && (this._node.setColor(this._color), this._tween && (a = a._color, this._betweenRed = a.r - this._color.r, this._betweenGreen = a.g - this._color.g, this._betweenBlue = a.b - this._color.b))
    },
    _onApply: function(a) {
        if (this._node && this._tween && (0 !== this._betweenAlpha || 0 !== this._betweenRed ||
                0 !== this._betweenGreen || 0 !== this._betweenBlue)) {
            var b = cc.color(255, 255, 255);
            b.r = this._color.r + this._betweenRed * a;
            b.g = this._color.g + this._betweenGreen * a;
            b.b = this._color.b + this._betweenBlue * a;
            this._node.setColor(b);
            null !== this._alpha && this._node.setOpacity(this._alpha + this._betweenAlpha * a)
        }
    },
    clone: function() {
        var a = new ccs.ColorFrame;
        a.setColor(this._color);
        a._cloneProperty(this);
        return a
    },
    setColor: function(a) {
        this._color = a
    },
    getColor: function() {
        return this._color
    }
});
ccs.ColorFrame.create = function() {
    return new ccs.ColorFrame
};
ccs.AlphaFrame = ccs.Frame.extend({
    _alpha: null,
    _betweenAlpha: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._alpha = 255
    },
    onEnter: function(a) {
        this._node && (this._node.setOpacity(this._alpha), this._tween && (this._betweenAlpha = a._alpha - this._alpha))
    },
    _onApply: function(a) {
        this._node && this._node.setOpacity(this._alpha + this._betweenAlpha * a)
    },
    setAlpha: function(a) {
        this._alpha = a
    },
    getAlpha: function() {
        return this._alpha
    },
    clone: function() {
        var a = new ccs.AlphaFrame;
        a.setAlpha(this._alpha);
        a._cloneProperty(this);
        return a
    }
});
ccs.EventFrame = ccs.Frame.extend({
    _event: null,
    ctor: function() {
        ccs.Frame.prototype.ctor.call(this);
        this._event = "";
        this._enterWhenPassed = !0
    },
    onEnter: function(a) {
        this._emitEvent()
    },
    clone: function() {
        var a = new ccs.EventFrame;
        a.setEvent(this._event);
        a._cloneProperty(this);
        return a
    },
    setEvent: function(a) {
        this._event = a
    },
    getEvent: function() {
        return this._event
    }
});
ccs.EventFrame.create = function() {
    return new ccs.EventFrame
};
ccs.ZOrderFrame = ccs.Frame.extend({
    _zorder: null,
    onEnter: function(a) {
        this._node && this._node.setLocalZOrder(this._zorder)
    },
    clone: function() {
        var a = new ccs.ZOrderFrame;
        a.setZOrder(this._zorder);
        a._cloneProperty(this);
        return a
    },
    setZOrder: function(a) {
        this._zorder = a
    },
    getZOrder: function() {
        return this._zorder
    }
});
ccs.ZOrderFrame.create = function() {
    return new ccs.ZOrderFrame
};
ccs.BlendFuncFrame = ccs.Frame.extend({
    onEnter: function(a, b) {
        this._node && void 0 != this._blendFunc && this._node.setBlendFunc(this._blendFunc)
    },
    clone: function() {
        var a = new ccs.BlendFuncFrame;
        a.setBlendFunc(this._blendFunc);
        a._cloneProperty(this);
        return a
    },
    setBlendFunc: function(a) {
        this._blendFunc = a
    },
    getBlendFunc: function() {
        return this._blendFunc
    }
});
ccs.BlendFuncFrame.create = function() {
    return new ccs.BlendFuncFrame
};
ccs.Timeline = ccs.Class.extend({
    _frames: null,
    _currentKeyFrame: null,
    _currentKeyFrameIndex: null,
    _fromIndex: null,
    _toIndex: null,
    _betweenDuration: null,
    _actionTag: null,
    _ActionTimeline: null,
    _node: null,
    ctor: function() {
        this._frames = [];
        this._currentKeyFrame = null;
        this._actionTag = this._betweenDuration = this._toIndex = this._fromIndex = this._currentKeyFrameIndex = 0;
        this._node = this._ActionTimeline = null
    },
    _gotoFrame: function(a) {
        0 !== this._frames.length && (this._binarySearchKeyFrame(a), this._apply(a))
    },
    _stepToFrame: function(a) {
        0 !==
            this._frames.length && (this._updateCurrentKeyFrame(a), this._apply(a))
    },
    getFrames: function() {
        return this._frames
    },
    addFrame: function(a) {
        this._frames.push(a);
        a.setTimeline(this)
    },
    insertFrame: function(a, b) {
        this._frames.splice(b, 0, a);
        a.setTimeline(this)
    },
    removeFrame: function(a) {
        cc.arrayRemoveObject(this._frames, a);
        a.setTimeline(null)
    },
    setActionTag: function(a) {
        this._actionTag = a
    },
    getActionTag: function() {
        return this._actionTag
    },
    setNode: function(a) {
        for (var b = 0; b < this._frames.length; b++) this._frames[b].setNode(a)
    },
    getNode: function() {
        return this._node
    },
    setActionTimeline: function(a) {
        this._ActionTimeline = a
    },
    getActionTimeline: function() {
        return this._ActionTimeline
    },
    clone: function() {
        var a = new ccs.Timeline;
        a._actionTag = this._actionTag;
        for (var b = 0; b < this._frames.length; b++) {
            var c = this._frames[b].clone();
            a.addFrame(c)
        }
        return a
    },
    _apply: function(a) {
        this._currentKeyFrame && this._currentKeyFrame.apply(0 >= this._betweenDuration ? 0 : (a - this._currentKeyFrameIndex) / this._betweenDuration)
    },
    _binarySearchKeyFrame: function(a) {
        var b =
            null,
            c = null,
            d = this._frames.length,
            e = !1;
        do
            if (a < this._frames[0].getFrameIndex()) this._currentKeyFrameIndex >= this._frames[0].getFrameIndex() && (e = !0), this._toIndex = this._fromIndex = 0, b = c = this._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = this._frames[0].getFrameIndex();
            else if (a >= this._frames[d - 1].getFrameIndex()) this._fromIndex = d - 1, this._toIndex = 0, b = c = this._frames[d - 1], this._currentKeyFrameIndex = this._frames[d - 1].getFrameIndex(), this._betweenDuration = 0;
        else {
            for (var f = -1, b = 0, c = d - 1, g = 0; b <=
                c;) {
                g = Math.ceil((b + c) / 2);
                if (a >= this._frames[g].getFrameIndex() && a < this._frames[g + 1].getFrameIndex()) {
                    f = g;
                    break
                }
                this._frames[g].getFrameIndex() > a ? c = g - 1 : b = g + 1
            }
            this._fromIndex = f;
            this._toIndex = 1 < d ? f + 1 | 0 : f | 0;
            b = this._frames[f];
            c = this._frames[f + 1];
            0 === f && this._currentKeyFrameIndex < b.getFrameIndex() && (e = !0);
            this._currentKeyFrameIndex = b.getFrameIndex();
            this._betweenDuration = c.getFrameIndex() - b.getFrameIndex()
        }
        while (0);
        if (e || this._currentKeyFrame != b) this._currentKeyFrame = b, this._currentKeyFrame.onEnter(c)
    },
    _updateCurrentKeyFrame: function(a) {
        if (a < this._currentKeyFrameIndex || a >= this._currentKeyFrameIndex + this._betweenDuration) {
            var b = null,
                c = null;
            do {
                var d = this._frames.length;
                if (a < this._frames[0].getFrameIndex()) b = c = this._frames[0], this._currentKeyFrameIndex = 0, this._betweenDuration = this._frames[0].getFrameIndex();
                else {
                    if (a >= this._frames[d - 1].getFrameIndex() && (a = this._frames[d - 1].getFrameIndex(), this._currentKeyFrameIndex >= a)) return;
                    do {
                        this._fromIndex = this._toIndex;
                        b = this._frames[this._fromIndex];
                        this._currentKeyFrameIndex =
                            b.getFrameIndex();
                        this._toIndex = this._fromIndex + 1;
                        this._toIndex >= d && (this._toIndex = 0);
                        c = this._frames[this._toIndex];
                        if (a === b.getFrameIndex()) break;
                        if (a > b.getFrameIndex() && a < c.getFrameIndex()) break;
                        if (b.isEnterWhenPassed()) b.onEnter(c)
                    } while (1);
                    this._betweenDuration = c.getFrameIndex() - b.getFrameIndex()
                }
            } while (0);
            this._currentKeyFrame = b;
            this._currentKeyFrame.onEnter(c)
        }
    }
});
ccs.Timeline.create = function() {
    return new ccs.Timeline
};
ccs.SkinNode = function() {
    var a = cc.Node.extend({});
    a.create = function() {};
    return a
}();
ccs.BoneNode = function() {
    var a = cc.Node,
        b = ccs.SkinNode,
        c = cc.BlendFunc,
        d = {
            p: cc.p,
            size: cc.size,
            rect: cc.rect
        },
        e = {
            log: cc.log,
            assert: cc.assert
        },
        f = a.extend({
            _customCommand: null,
            _blendFunc: null,
            _rackColor: null,
            _rackLength: null,
            _rackWidth: null,
            _childBones: null,
            _boneSkins: null,
            _rootSkeleton: null,
            _squareVertices: null,
            _squareColors: null,
            _noMVPVertices: null,
            ctor: function(b) {
                a.prototype.ctor.call(this);
                null === this._squareVertices && (this._squareVertices = [{
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }]);
                this._rackColor =
                    cc.color.WHITE;
                this._blendFunc = c.ALPHA_NON_PREMULTIPLIED;
                this._childBones = [];
                this._boneSkins = [];
                this._rackLength = void 0 === b ? 50 : b;
                this._rackWidth = 20;
                this._updateVertices()
            },
            addSkin: function(b, c, d) {
                var f = this._boneSkins;
                e.assert(null != b, "Argument must be non-nil");
                if (d)
                    for (d = 0; d < f.length; d++) f[d].setVisible(!1);
                a.prototype.addChild.call(this, b);
                this._boneSkins.push(b);
                b.setVisible(c)
            },
            getChildBones: function() {
                return this._childBones
            },
            getSkins: function() {
                return this._boneSkins
            },
            displaySkin: function(a,
                b) {
                var c = this._boneSkins,
                    d, e;
                if ("string" === typeof a)
                    for (e = 0; e < c.length; e++) d = c[e], a == d.getName() ? d.setVisible(!0) : b && d.setVisible(!1);
                else
                    for (e = 0; e < c.length; e++) d = c[e], d == a ? d.setVisible(!0) : b && d.setVisible(!1)
            },
            getVisibleSkins: function() {
                for (var a = [], b = this._boneSkins, c, d = 0; d < b.length; d++) c = b[d], c.isVisible() && a.push(c);
                return a
            },
            getRootSkeletonNode: function() {
                return this._rootSkeleton
            },
            getAllSubBones: function() {
                for (var a = [], b = [], c = this._childBones, d = 0; d < c.length; d++) b.push(c[d]);
                for (; 0 < b.length;)
                    for (c =
                        b.pop(), a.push(c), c = c.getChildBones(), d = 0; d < c; d++) b.push(c[d]);
                return a
            },
            getAllSubSkins: function() {
                for (var a = this.getAllSubBones(), b = [], c = 0; c < a.length; c++)
                    for (var d = a[c].getSkins(), e = 0; e < d.length; e++) b.push(d[c]);
                return b
            },
            addChild: function(b, c, d) {
                a.prototype.addChild.call(this, b, c, d);
                this._addToChildrenListHelper(b)
            },
            removeChild: function(b, c) {
                -1 !== this._children.indexOf(b) && (a.prototype.removeChild.call(this, b, c), this._removeFromChildrenListHelper(b))
            },
            setBlendFunc: function(a) {
                var b = this._blendFunc;
                if (a && b.src !== a.src && b.dst !== a.dst) {
                    this._blendFunc = a;
                    for (var b = this._boneSkins, c, d = 0; d < b.length; d++) c = b[d], c.setBlendFunc(a)
                }
            },
            getBlendFunc: function() {
                return this._blendFunc
            },
            setDebugDrawLength: function(a) {
                this._rackLength = a;
                this._updateVertices()
            },
            getDebugDrawLength: function() {
                return this._rackLength
            },
            setDebugDrawWidth: function(a) {
                this._rackWidth = a;
                this._updateVertices()
            },
            getDebugDrawWidth: function() {
                return this._rackWidth
            },
            setDebugDrawEnabled: function(a) {
                var b = this._renderCmd;
                b._debug !== a && (b._debug =
                    a, cc.renderer.childrenOrderDirty = !0, this._visible && null != this._rootSkeleton && (this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0))
            },
            isDebugDrawEnabled: function() {
                return this._renderCmd._debug
            },
            setDebugDrawColor: function(a) {
                this._rackColor = a
            },
            getDebugDrawColor: function() {
                return this._rackColor
            },
            getVisibleSkinsRect: function() {
                var a, b, c, e = 0;
                a = b = c = e;
                var f = !0,
                    g = d.rect(0, 0, 0, 0);
                this._renderCmd._debug && null != this._rootSkeleton && this._rootSkeleton._renderCmd._debug && (c = this._rackWidth,
                    e = this._rackLength, f = !1);
                for (var h = this._boneSkins, t, v = 0; v < h.length; v++) {
                    t = h[v];
                    var w = t.getBoundingBox();
                    !t.isVisible() || 0 === w.x && 0 === w.y && 0 === w.width && 0 === w.height || (f ? (a = cc.rectGetMinX(w), b = cc.rectGetMinY(w), c = cc.rectGetMaxX(w), e = cc.rectGetMaxY(w), f = !1) : (a = Math.min(cc.rectGetMinX(w), a), b = Math.min(cc.rectGetMinY(w), b), c = Math.max(cc.rectGetMaxX(w), c), e = Math.max(cc.rectGetMaxY(w), e)), g.setRect(a, b, c - a, e - b))
                }
                return g
            },
            getBoundingBox: function() {
                var a = this.getVisibleSkinsRect();
                return cc.rectApplyAffineTransform(a,
                    this.getNodeToParentAffineTransform())
            },
            batchBoneDrawToSkeleton: function(a) {},
            setLocalZOrder: function(b) {
                a.prototype.setLocalZOrder.call(this, b);
                null != this._rootSkeleton && (this._rootSkeleton._subBonesOrderDirty = !0)
            },
            setName: function(b) {
                var c = this._rootSkeleton,
                    d = this.getName();
                a.prototype.setName.call(this, b);
                if (null != c) {
                    var d = c._subBonesMap[d],
                        e = c._subBonesMap[b];
                    d && !e && (delete c._subBonesMap[d], c._subBonesMap[b] = d)
                }
            },
            setContentSize: function(b) {
                a.prototype.setContentSize.call(this, b);
                this._updateVertices()
            },
            setAnchorPoint: function(b) {
                a.prototype.setAnchorPoint.call(this, b);
                this._updateVertices()
            },
            setVisible: function(b) {
                this._visible != b && (a.prototype.setVisible.call(this, b), null != this._rootSkeleton && (this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0))
            },
            _addToChildrenListHelper: function(a) {
                a instanceof f ? this._addToBoneList(a) : this._addToSkinList(a)
            },
            _removeFromChildrenListHelper: function(a) {
                a instanceof f ? this._removeFromBoneList(a) : a instanceof b && this._removeFromSkinList(skin)
            },
            _removeFromBoneList: function(a) {
                if (null != this._rootSkeleton && a instanceof ccs.SkeletonNode && a._rootSkeleton === this._rootSkeleton) {
                    a._rootSkeleton = null;
                    var b = a.getAllSubBones();
                    b.push(a);
                    for (var c, d = 0; d < b.length; d++) c = b[d], c._rootSkeleton = null, delete this._rootSkeleton._subBonesMap[c.getName()], this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0
                } else this._rootSkeleton._subBonesDirty = !0, this._rootSkeleton._subBonesOrderDirty = !0;
                cc.arrayRemoveObject(this._childBones, a)
            },
            _setRootSkeleton: function(a) {
                this._rootSkeleton =
                    a;
                a = this.getAllSubBones();
                for (var b = 0; b < a.length; b++) this._addToBoneList(a[b])
            },
            _addToBoneList: function(a) {
                -1 === this._childBones.indexOf(a) && this._childBones.push(a);
                if (null != this._rootSkeleton && !(a instanceof b || a._rootSkeleton)) {
                    var c = a.getAllSubBones();
                    c.push(a);
                    for (var d = 0; d < c.length; d++) {
                        a = c[d];
                        a._setRootSkeleton(this._rootSkeleton);
                        var e = a.getName();
                        this._rootSkeleton._subBonesMap[e] ? cc.log("already has a bone named %s in skeleton %s", e, this._rootSkeleton.getName()) : this._rootSkeleton._subBonesMap[a.getName()] =
                            a;
                        this._rootSkeleton._subBonesDirty = !0;
                        this._rootSkeleton._subBonesOrderDirty = !0
                    }
                }
            },
            _visitSkins: function() {
                var a = this._renderCmd;
                if (this._visible) {
                    var b = a.getParentRenderCmd();
                    b && (a._curLevel = b._curLevel + 1);
                    var c = this._boneSkins,
                        d;
                    a._syncStatus(b);
                    var e = c.length;
                    if (0 < e) {
                        this.sortAllChildren();
                        for (b = 0; b < e; b++)
                            if (d = c[b], 0 > d._localZOrder) d._renderCmd.visit(a);
                            else break;
                        for (; b < e; b++) c[b]._renderCmd.visit(a)
                    }
                    a._dirtyFlag = 0
                }
            },
            _addToSkinList: function(a) {
                this._boneSkins.push(a);
                if (a.getBlendFunc) {
                    var b =
                        a.getBlendFunc();
                    this._blendFunc.src !== b.src && this._blendFunc.dst !== b.dst && a.setBlendFunc(this._blendFunc)
                }
            },
            _removeFromSkinList: function(a) {
                cc.arrayRemoveObject(this._boneSkins, a)
            },
            sortAllChildren: function() {
                this._sortArray(this._childBones);
                this._sortArray(this._boneSkins);
                a.prototype.sortAllChildren.call(this)
            },
            _sortArray: function(a) {
                if (a) {
                    var b = a.length,
                        c, d, e;
                    for (c = 1; c < b; c++) {
                        e = a[c];
                        for (d = c - 1; 0 <= d;) {
                            if (e._localZOrder < a[d]._localZOrder) a[d + 1] = a[d];
                            else if (e._localZOrder === a[d]._localZOrder && e.arrivalOrder <
                                a[d].arrivalOrder) a[d + 1] = a[d];
                            else break;
                            d--
                        }
                        a[d + 1] = e
                    }
                }
            },
            _updateVertices: function() {
                var a = this._squareVertices,
                    b = this._renderCmd._anchorPointInPoints;
                if (this._rackLength != a[2].x - b.x || a[3].y != this._rackWidth / 2 - b.y) {
                    a[1].x = a[1].y = a[3].y = 0;
                    a[0].x = a[2].x = 0.1 * this._rackLength;
                    a[2].y = 0.5 * this._rackWidth;
                    a[0].y = -a[2].y;
                    a[3].x = this._rackLength;
                    for (var c = 0; c < a.length; c++) a[c].x += b.x, a[c].y += b.y;
                    this._renderCmd.updateDebugPoint(a)
                }
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ?
                    new g(this) : new h(this)
            }
        });
    f.create = function(a, b) {
        return new ccui.BoneNode(a, b)
    };
    var g = function() {
            var b = function(b) {
                    a.CanvasRenderCmd.call(this, b);
                    this._debug = !1;
                    this._color = cc.color.WHITE;
                    this._drawNode = new cc.DrawNode
                },
                c = b.prototype = Object.create(a.CanvasRenderCmd.prototype);
            c.constructor = b;
            c.visit = function(a) {
                var b = this._node;
                b._visit && b._visit(a)
            };
            c.updateDebugPoint = function(a) {
                this._drawNode.clear();
                this._drawNode.drawPoly(a, this._color, 0, this._color)
            };
            c.transform = function(b, c) {
                var d = this._node._rootSkeleton;
                a.CanvasRenderCmd.prototype.transform.call(this, b, c);
                d && d._renderCmd._debug && this._drawNode._renderCmd.transform(this)
            };
            return b
        }(),
        h = function() {
            var b = function(b) {
                    a.WebGLRenderCmd.call(this, b);
                    this._debug = !1;
                    this._color = cc.color.WHITE;
                    this._drawNode = new cc.DrawNode
                },
                c = b.prototype = Object.create(a.WebGLRenderCmd.prototype);
            c.constructor = b;
            c.visit = function(a) {
                var b = this._node;
                b._visit && b._visit(a)
            };
            c.updateDebugPoint = function(a) {
                this._drawNode.clear();
                this._drawNode.drawPoly(a, this._color, 0, this._color)
            };
            c.transform = function(b, c) {
                var d = this._node._rootSkeleton;
                a.WebGLRenderCmd.prototype.transform.call(this, b, c);
                d && d._renderCmd._debug && this._drawNode._renderCmd.transform(this)
            };
            return b
        }();
    return f
}();
ccs.SkeletonNode = function() {
    var a = ccs.BoneNode,
        b = a.extend({
            _subBonesMap: null,
            _squareVertices: null,
            _squareColors: null,
            _noMVPVertices: null,
            _skinGroupMap: null,
            _sortedAllBonesDirty: !1,
            _sortedAllBones: null,
            _batchedBoneVetices: null,
            _batchedBoneColors: null,
            _batchedVeticesCount: null,
            _batchBoneCommand: null,
            _subOrderedAllBones: null,
            ctor: function() {
                this._squareVertices = [{
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }, {
                    x: 0,
                    y: 0
                }];
                this._rootSkeleton = this;
                a.prototype.ctor.call(this);
                this._subBonesMap = {};
                this._subOrderedAllBones = [];
                this._skinGroupMap = {};
                this._rackLength = this._rackWidth = 20;
                this._updateVertices()
            },
            getBoneNode: function(a) {
                return (a = this._subBonesMap[a]) ? a : null
            },
            getAllSubBonesMap: function() {
                return this._subBonesMap
            },
            changeSkins: function(a) {
                if ("object" === typeof a) {
                    var b, e;
                    for (e in a) {
                        b = a[e];
                        var f = this.getBoneNode(e);
                        null !== f && f.displaySkin(b, !0)
                    }
                } else(a = this._suitMap[a]) && this.changeSkins(a, !0)
            },
            addSkinGroup: function(a, b) {
                this._skinGroupMap[a] = b
            },
            getBoundingBox: function() {
                var a, b, e,
                    f = 0;
                a = b = e = f;
                var g = this.getVisibleSkinsRect(),
                    h = !0;
                if (0 !== g.x || 0 !== g.y || 0 !== g.width || 0 !== g.height) a = cc.rectGetMinX(g), b = cc.rectGetMinY(g), e = cc.rectGetMaxX(g), f = cc.rectGetMaxY(g), h = !1;
                for (var k = this.getAllSubBones(), m, n = 0; n < k.length; n++)
                    if (m = k[n], m = cc.rectApplyAffineTransform(m.getVisibleSkinsRect(), m.getNodeToParentTransform(m.getRootSkeletonNode())), 0 !== m.x || 0 !== m.y || 0 !== m.width || 0 !== m.height) h ? (a = cc.rectGetMinX(m), b = cc.rectGetMinY(m), e = cc.rectGetMaxX(m), f = cc.rectGetMaxY(m), h = !1) : (a = Math.min(cc.rectGetMinX(m),
                        a), b = Math.min(cc.rectGetMinY(m), b), e = Math.max(cc.rectGetMaxX(m), e), f = Math.max(cc.rectGetMaxY(m), f));
                g.x = a;
                g.y = b;
                g.width = e - a;
                g.height = f - b;
                return cc.rectApplyAffineTransform(g, this.getNodeToParentTransform())
            },
            _visit: function(a) {
                if (this._visible) {
                    var b = this._renderCmd;
                    a = a || b.getParentRenderCmd();
                    b._syncStatus(a);
                    var e;
                    if (0 !== this._children.length)
                        for (a = 0; a < this._children.length; a++) e = this._children[a], e._renderCmd.visit(b);
                    this._checkSubBonesDirty();
                    e = this._subOrderedAllBones;
                    var f;
                    for (a = 0; a < e.length; a++) f =
                        e[a], f._visitSkins();
                    if (b._debug)
                        for (a = 0; a < e.length; a++) b = e[a]._renderCmd, cc.renderer.pushRenderCommand(b._drawNode._renderCmd);
                    this._dirtyFlag = 0
                }
            },
            _checkSubBonesDirty: function() {
                this._subBonesDirty && (this._updateOrderedAllbones(), this._subBonesDirty = !1);
                this._subBonesOrderDirty && (this._sortOrderedAllBones(), this._subBonesOrderDirty = !1)
            },
            _updateOrderedAllbones: function() {
                this._subOrderedAllBones.length = 0;
                for (var a = [], b = this._childBones, e, f = 0; f < b.length; f++) e = b[f], e.isVisible() && a.push(e);
                for (; 0 < a.length;)
                    for (f =
                        a.pop(), b = f._renderCmd, b._syncStatus(b.getParentRenderCmd()), this._subOrderedAllBones.push(f), b = f.getChildBones(), f = 0; f < b.length; f++) e = b[f], e.isVisible() && a.push(e)
            },
            _sortOrderedAllBones: function() {
                this._sortArray(this._subOrderedAllBones)
            },
            _updateVertices: function() {
                var a = this._squareVertices,
                    b = this._renderCmd._anchorPointInPoints;
                if (this._rackLength != a[6].x - b.x || this._rackWidth != a[3].y - b.y) {
                    var e = 0.5 * this._rackLength,
                        f = 0.5 * this._rackWidth,
                        g = 0.25 * e,
                        h = 0.25 * f;
                    a[5].y = a[2].y = a[1].y = a[6].y = a[0].x = a[4].x =
                        a[7].x = a[3].x = 0;
                    a[5].x = -e;
                    a[0].y = -f;
                    a[6].x = e;
                    a[3].y = f;
                    a[1].x = g;
                    a[7].y = h;
                    a[2].x = -g;
                    a[4].y = -h;
                    for (e = 0; e < a.length; e++) a[e].x += b.x, a[e].y += b.y
                }
            },
            _updateAllDrawBones: function() {
                this._subDrawBones = {};
                for (var a in this._subBonesMap) {
                    var b = this._subBonesMap[a];
                    b.isVisible() && b.isDebugDrawEnabled() && this._subDrawBones.push(b)
                }
                this._sortArray(this._sortedAllBones);
                this._subDrawBones = !1
            }
        });
    b.create = function() {
        return new b
    };
    return b
}();
ccs._load = function() {
    var a = function(a, d, h) {
            var k = cc.loader.getRes(a);
            if (!k) return cc.log("%s does not exist", a);
            var m = a.match(c),
                m = (m && m[1] ? m[1] : null).toLocaleLowerCase();
            if ("json" !== m && "exportjson" !== m) return cc.log("%s load error, must be json file", a);
            var n;
            d ? n = b[d] : k.widgetTree ? n = b.ccui : k.nodeTree ? n = b.timeline : k.Content && k.Content.Content ? n = b.timeline : k.gameobjects && (n = b.scene);
            if (!n) return cc.log("Can't find the parser : %s", a), new cc.Node;
            d = k.version || k.Version;
            if (!d && k.armature_data) return cc.warn("%s is armature. please use:",
                a), cc.warn("    ccs.armatureDataManager.addArmatureFileInfoAsync(%s);", a), cc.warn("    var armature \x3d new ccs.Armature('name');"), new cc.Node;
            n = e(n, d);
            return n ? n.parse(a, k, h) || null : (cc.log("Can't find the parser : %s", a), new cc.Node)
        },
        b = {
            ccui: {},
            timeline: {},
            action: {},
            scene: {}
        };
    a.registerParser = function(a, c, d) {
        if (!a || !c || !d) return cc.log("register parser error");
        b[a] || (b[a] = {});
        b[a][c] = d
    };
    a.getParser = function(a, c) {
        return a && c ? b[a] ? b[a][c] : void 0 : a ? b[a] : b
    };
    var c = /\.([^\.]+)$/,
        d = /([^\.](\.\*)?)*$/,
        e = function(a, b) {
            return a[b] ? a[b] : "*" === b ? null : e(a, b.replace(d, "*"))
        };
    return a
}();
ccs._parser = cc.Class.extend({
    ctor: function() {
        this.parsers = {}
    },
    _dirnameReg: /\S*\//,
    _dirname: function(a) {
        return (a = a.match(this._dirnameReg)) && a[0] ? a[0] : ""
    },
    getClass: function(a) {
        return a.classname
    },
    getNodeJson: function(a) {
        return a.widgetTree
    },
    parse: function(a, b, c) {
        c = c || this._dirname(a);
        this.pretreatment(b, c);
        var d = this.parseNode(this.getNodeJson(b), c, a);
        d && this.deferred(b, c, d, a);
        return d
    },
    pretreatment: function(a, b, c) {},
    deferred: function(a, b, c, d) {},
    parseNode: function(a, b) {
        var c = this.parsers[this.getClass(a)],
            d = null;
        c ? d = c.call(this, a, b) : cc.log("Can't find the parser : %s", this.getClass(a));
        return d
    },
    registerParser: function(a, b) {
        this.parsers[a] = b
    }
});
ccs.load = function(a, b) {
    var c = {
        node: null,
        action: null
    };
    c.node = ccs._load(a, null, b);
    c.action = ccs._load(a, "action", b);
    c.action && -1 === c.action.tag && c.node && (c.action.tag = c.node.tag);
    return c
};
ccs.load.validate = {};
ccs.loadWithVisibleSize = function(a, b) {
    var c = ccs.load(a, b),
        d = cc.director.getVisibleSize();
    c.node && d && (c.node.setContentSize(d.width, d.height), ccui.helper.doLayout(c.node));
    return c
};
ccs.actionTimelineCache = {
    createAction: function(a) {
        return ccs._load(a, "action")
    }
};
ccs.csLoader = {
    createNode: function(a) {
        return ccs._load(a)
    }
};
cc.loader.register(["json"], {
    load: function(a, b, c, d) {
        cc.loader.loadJson(a, function(a, c) {
            var g = cc.path;
            if (c && c.Content && c.Content.Content.UsedResources) {
                for (var h = c.Content.Content.UsedResources, k = g.dirname(b), m = [], n, p, s = 0; s < h.length; s++) n = g.join(k, h[s]), p = g._normalize(n), ccs.load.validate[p] || (ccs.load.validate[p] = !0, m.push(n));
                cc.loader.load(m, function() {
                    d(a, c)
                })
            } else d(a, c)
        })
    }
});
(function(a, b) {
    var c = new(b.extend({
        getNodeJson: function(a) {
            return a
        },
        parseNode: function(a, b) {
            var c = this.parsers[this.getClass(a)],
                d = null;
            c ? d = c.call(this, a, b) : cc.log("Can't find the parser : %s", this.getClass(a));
            return d
        },
        deferred: function(a, b, c, d) {
            ccs.triggerManager.parse(a.Triggers || []);
            ccs.sceneReader && (ccs.sceneReader._node = c)
        },
        setPropertyFromJsonDict: function(a, b) {
            var c = cc.isUndefined(b.x) ? 0 : b.x,
                d = cc.isUndefined(b.y) ? 0 : b.y;
            a.setPosition(c, d);
            c = Boolean(cc.isUndefined(b.visible) ? 1 : b.visible);
            a.setVisible(c);
            c = cc.isUndefined(b.objecttag) ? -1 : b.objecttag;
            a.setTag(c);
            c = cc.isUndefined(b.zorder) ? 0 : b.zorder;
            a.setLocalZOrder(c);
            c = cc.isUndefined(b.scalex) ? 1 : b.scalex;
            d = cc.isUndefined(b.scaley) ? 1 : b.scaley;
            a.setScaleX(c);
            a.setScaleY(d);
            c = cc.isUndefined(b.rotation) ? 0 : b.rotation;
            a.setRotation(c);
            a.setName(b.name || "")
        }
    }));
    c.parseChild = function(a, b, c) {
        for (var d = 0; d < b.length; d++) {
            var e, f = b[d];
            f && (e = this.parseNode(f, c));
            e && a.addChild(e)
        }
    };
    var d = {
            CCSprite: function(a, b, c) {
                var d = new cc.Sprite;
                f(b.fileData,
                    c,
                    function(a, b) {
                        if (0 === b) d.setTexture(a);
                        else if (1 === b) {
                            var c = cc.spriteFrameCache.getSpriteFrame(a);
                            d.setSpriteFrame(c)
                        }
                    });
                b = new ccs.ComRender(d, "CCSprite");
                a.addComponent(b);
                return b
            },
            CCTMXTiledMap: function(a, b, c) {
                var d = null;
                f(b.fileData, c, function(a, b) {
                    0 === b && (d = new cc.TMXTiledMap(a))
                });
                b = new ccs.ComRender(d, "CCTMXTiledMap");
                a.addComponent(b);
                return b
            },
            CCParticleSystemQuad: function(a, b, c) {
                var d = null;
                f(b.fileData, c, function(a, b) {
                    0 === b ? d = new cc.ParticleSystem(a) : cc.log("unknown resourcetype on CCParticleSystemQuad!");
                    d.setPosition(0, 0)
                });
                b = new ccs.ComRender(d, "CCParticleSystemQuad");
                a.addComponent(b);
                return b
            },
            CCArmature: function(a, b, c) {
                var d = null;
                f(b.fileData, c, function(a, b) {
                    if (0 === b) {
                        var c = cc.loader.getRes(a);
                        c || cc.log("Please load the resource [%s] first!", a);
                        c = c.armature_data[0].name;
                        ccs.armatureDataManager.addArmatureFileInfo(a);
                        d = new ccs.Armature(c)
                    }
                });
                if (d) return c = new ccs.ComRender(d, "CCArmature"), a.addComponent(c), (a = b.selectedactionname) && d.getAnimation() && d.getAnimation().play(a), c
            },
            CCComAudio: function(a,
                b, c) {
                var d = null;
                f(b.fileData, c, function(c, e) {
                    if (0 === e) {
                        d = new ccs.ComAudio;
                        d.preloadEffect(c);
                        var f = b.name;
                        f && d.setName(f);
                        a.addComponent(d)
                    }
                })
            },
            CCComAttribute: function(a, b, c) {
                var d = null;
                f(b.fileData, c, function(b, c) {
                    0 === c ? (d = new ccs.ComAttribute, "" !== b && d.parse(b), a.addComponent(d)) : cc.log("unknown resourcetype on CCComAttribute!")
                });
                return d
            },
            CCBackgroundAudio: function(a, b, c) {
                var d = null;
                f(b.fileData, c, function(c, e) {
                    if (0 === e) {
                        d = new ccs.ComAudio;
                        d.preloadBackgroundMusic(c);
                        d.setFile(c);
                        var f = Boolean(b.loop ||
                            0);
                        d.setLoop(f);
                        var k = b.name;
                        k && d.setName(k);
                        a.addComponent(d);
                        d.playBackgroundMusic(c, f)
                    }
                })
            },
            GUIComponent: function(a, b, c) {
                var d = null;
                f(b.fileData, c, function(a, b) {
                    d = ccs._load(a, "ccui")
                });
                b = new ccs.ComRender(d, "GUIComponent");
                a.addComponent(b);
                return b
            },
            CCScene: function() {}
        },
        e = {},
        f = function(a, b, c) {
            if (null != a) {
                var d = a.path,
                    f = a.resourceType;
                a = a.plist;
                d && (a && (cc.loader.getRes(b + a) ? (e[b + a] = !0, cc.spriteFrameCache.addSpriteFrames(b + a)) : e[b + a] || cc.log("%s need to be preloaded", b + a)), 0 !== f ? c(d, f) : c(b + d, f))
            }
        };
    c.parseComponents = function(a, b, c) {
        a && b && b.forEach(function(b) {
            var e = d[b.classname],
                f = null;
            e ? f = e(a, b, c) : cc.log("Can't find the component parser : %s", b.classname);
            b = b.name;
            f && b && f.setName(b)
        })
    };
    c.registerParser("CCNode", function(a, b) {
        var c = new cc.Node;
        this.setPropertyFromJsonDict(c, a);
        this.parseChild.call(this, c, a.gameobjects, b);
        this.parseComponents(c, a.components, b);
        var d = a.CanvasSize;
        d && c.setContentSize(cc.size(d._width, d._height));
        return c
    });
    a.registerParser("scene", "*", c)
})(ccs._load, ccs._parser);
(function(a, b) {
    var c = new(b.extend({
        addSpriteFrame: function(a, b) {
            if (a)
                for (var c = 0; c < a.length; c++) cc.spriteFrameCache.addSpriteFrames(b + a[c])
        },
        pretreatment: function(a, b) {
            this.addSpriteFrame(a.textures, b)
        },
        deferred: function(a, b, c, d) {
            c && (ccs.actionManager.initWithDictionary(d, a.animation, c), c.setContentSize(cc.size(a.designWidth, a.designHeight)))
        }
    }));
    c.generalAttributes = function(a, b) {
        var c = b.ignoreSize;
        null != c && a.ignoreContentAdaptWithSize(c);
        b.sizeType && a.setSizeType(b.sizeType);
        b.positionType && a.setPositionType(b.positionType);
        a.setSizePercent(cc.p(b.sizePercentX, b.sizePercentY));
        a.setPositionPercent(cc.p(b.positionPercentX, b.positionPercentY));
        var d = c = 0;
        b.adaptScreen ? (d = cc.director.getWinSize(), c = d.width, d = d.height) : (c = b.width, d = b.height);
        a.setContentSize(c, d);
        a.setTag(b.tag);
        a.setActionTag(b.actiontag);
        a.setTouchEnabled(b.touchAble);
        c = b.name;
        a.setName(c ? c : "default");
        a.setPosition(b.x, b.y);
        a.setScaleX(null != b.scaleX ? b.scaleX : 1);
        a.setScaleY(null != b.scaleY ? b.scaleY : 1);
        a.setRotation(b.rotation || 0);
        c = b.visible || !1;
        null != c &&
            a.setVisible(c);
        a.setLocalZOrder(b.ZOrder);
        if (null != b.layoutParameter) {
            c = b.layoutParameter;
            d = null;
            switch (c.type) {
                case 1:
                    d = new ccui.LinearLayoutParameter;
                    d.setGravity(c.gravity);
                    break;
                case 2:
                    var e = d = new ccui.RelativeLayoutParameter;
                    e.setRelativeName(c.relativeName);
                    e.setRelativeToWidgetName(c.relativeToName);
                    e.setAlign(c.align)
            }
            null != d && (d.setMargin(c.marginLeft || 0, c.marginTop || 0, c.marginRight || 0, c.marginDown || 0), a.setLayoutParameter(d))
        }
    };
    c.colorAttributes = function(a, b) {
        var c = b.opacity;
        null != c && a.setOpacity(c);
        var c = b.colorR,
            d = b.colorG,
            e = b.colorB;
        a.setColor(cc.color(null == c ? 255 : c, null == d ? 255 : d, null == e ? 255 : e));
        a.setFlippedX(b.flipX);
        a.setFlippedY(b.flipY)
    };
    c.anchorPointAttributes = function(a, b) {
        var c = b.anchorPointX,
            d;
        d = null != c ? b.anchorPointX : a.getAnchorPoint().x;
        var e = b.anchorPointY,
            n;
        n = null != e ? b.anchorPointY : a.getAnchorPoint().y;
        null == c && null == e || a.setAnchorPoint(cc.p(d, n))
    };
    c.parseChild = function(a, b, c) {
        b = b.children;
        for (var d = 0; d < b.length; d++) {
            var e = this.parseNode(b[d], c);
            if (e)
                if (a instanceof ccui.PageView) a.addPage(e);
                else if (a instanceof ccui.ListView) a.pushBackCustomItem(e);
            else {
                if (!(a instanceof ccui.Layout)) {
                    if (e.getPositionType() === ccui.Widget.POSITION_PERCENT) {
                        var n = e.getPositionPercent(),
                            p = a.getAnchorPoint();
                        e.setPositionPercent(cc.p(n.x + p.x, n.y + p.y))
                    }
                    n = a.getAnchorPointInPoints();
                    e.setPosition(cc.p(e.getPositionX() + n.x, e.getPositionY() + n.y))
                }
                a.addChild(e)
            }
        }
    };
    var d = function(a, b, c, d) {
        c && (0 === b ? d(a + c, b) : d(c, b))
    };
    c.LayoutAttributes = function(a, b, c) {
        var e = 0,
            m = 0;
        b.adaptScreen ? (m = cc.director.getWinSize(), e = m.width,
            m = m.height) : (e = b.width, m = b.height);
        a.setSize(cc.size(e, m));
        a.setClippingEnabled(b.clipAble);
        e = b.backGroundScale9Enable;
        a.setBackGroundImageScale9Enabled(e);
        var m = b.bgColorR,
            n = b.bgColorG,
            p = b.bgColorB,
            s = b.bgStartColorR,
            r = b.bgStartColorG,
            u = b.bgStartColorB,
            t = b.bgEndColorR,
            v = b.bgEndColorG,
            w = b.bgEndColorB;
        a.setBackGroundColorVector(cc.p(b.vectorX, b.vectorY));
        var A = b.bgColorOpacity;
        a.setBackGroundColorType(b.colorType);
        a.setBackGroundColor(cc.color(s, r, u), cc.color(t, v, w));
        a.setBackGroundColor(cc.color(m,
            n, p));
        a.setBackGroundColorOpacity(A);
        (m = b.backGroundImageData) && d(c, m.resourceType, m.path, function(b, c) {
            a.setBackGroundImage(b, c)
        });
        e && a.setBackGroundImageCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight));
        b.layoutType && a.setLayoutType(b.layoutType)
    };
    c.ButtonAttributes = function(a, b, c) {
        var e = b.scale9Enable;
        a.setScale9Enabled(e);
        var m = b.normalData;
        d(c, m.resourceType, m.path, function(b, c) {
            a.loadTextureNormal(b, c)
        });
        m = b.pressedData;
        d(c, m.resourceType, m.path, function(b, c) {
            a.loadTexturePressed(b,
                c)
        });
        m = b.disabledData;
        d(c, m.resourceType, m.path, function(b, c) {
            a.loadTextureDisabled(b, c)
        });
        e && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), c = b.scale9Width, e = b.scale9Height, null != c && null != e && a.setSize(cc.size(c, e)));
        c = b.text;
        null != c && a.setTitleText(c);
        a.setTitleColor(cc.color(null !== b.textColorR ? b.textColorR : 255, null !== b.textColorG ? b.textColorG : 255, null !== b.textColorB ? b.textColorB : 255));
        null != b.fontSize && a.setTitleFontSize(b.fontSize);
        b.fontName && a.setTitleFontName(b.fontName)
    };
    c.CheckBoxAttributes = function(a, b, c) {
        var e = b.backGroundBoxData;
        d(c, e.resourceType, e.path, function(b, c) {
            a.loadTextureBackGround(b, c)
        });
        var m = b.backGroundBoxSelectedData;
        d(c, m.resourceType || e.resourceType, m.path || e.path, function(b, c) {
            a.loadTextureBackGroundSelected(b, c)
        });
        e = b.frontCrossData;
        d(c, e.resourceType, e.path, function(b, c) {
            a.loadTextureFrontCross(b, c)
        });
        m = b.backGroundBoxDisabledData;
        d(c, m.resourceType || e.resourceType, m.path || e.path, function(b, c) {
            a.loadTextureBackGroundDisabled(b, c)
        });
        e = b.frontCrossDisabledData;
        d(c, e.resourceType, e.path, function(b, c) {
            a.loadTextureFrontCrossDisabled(b, c)
        });
        b.selectedState && a.setSelected(b.selectedState)
    };
    c.ImageViewAttributes = function(a, b, c) {
        var e = b.fileNameData;
        d(c, e.resourceType, e.path, function(b, c) {
            a.loadTexture(b, c)
        });
        c = !1;
        b.scale9Enable && (c = b.scale9Enable);
        a.setScale9Enabled(c);
        c && (c = b.scale9Height, b.scale9Width && c && a.setSize(cc.size(b.scale9Width, b.scale9Height)), a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)))
    };
    c.TextAtlasAttributes =
        function(a, b, c) {
            var d = b.stringValue,
                e = b.charMapFileData,
                n = b.itemWidth,
                p = b.itemHeight,
                s = b.startCharMap;
            if (null != d && e && null != n && null != p && null != s) switch (b = b.charMapFileData, b.resourceType) {
                case 0:
                    a.setProperty(d, c + b.path, n, p, s);
                    break;
                case 1:
                    cc.log("Wrong res type of LabelAtlas!")
            }
        };
    c.TextBMFontAttributes = function(a, b, c) {
        var d = b.fileNameData;
        switch (d.resourceType) {
            case 0:
                a.setFntFile(c + d.path);
                break;
            case 1:
                cc.log("Wrong res type of LabelAtlas!")
        }
        a.setString(b.text)
    };
    var e = /\.ttf$/;
    c.TextAttributes = function(a,
        b, c) {
        a.setTouchScaleChangeEnabled(b.touchScaleEnable);
        a.setString(b.text);
        null != b.fontSize && a.setFontSize(b.fontSize);
        var d = b.fontName;
        null != d && (cc.sys.isNative ? e.test(d) ? a.setFontName(cc.path.join(cc.loader.resPath, c, d)) : a.setFontName(d) : a.setFontName(d.replace(e, "")));
        c = b.areaHeight;
        null != b.areaWidth && null != c && (c = cc.size(b.areaWidth, b.areaHeight), a.setTextAreaSize(c));
        null != b.hAlignment && a.setTextHorizontalAlignment(b.hAlignment);
        null != b.vAlignment && a.setTextVerticalAlignment(b.vAlignment)
    };
    c.ListViewAttributes =
        function(a, b, d) {
            c.ScrollViewAttributes(a, b, d);
            a.setDirection(b.direction);
            a.setGravity(b.gravity);
            a.setItemsMargin(b.itemMargin)
        };
    c.LoadingBarAttributes = function(a, b, c) {
        var e = b.textureData;
        d(c, e.resourceType, e.path, function(b, c) {
            a.loadTexture(b, c)
        });
        c = b.scale9Enable;
        a.setScale9Enabled(c);
        c && (a.setCapInsets(cc.rect(b.capInsetsX, b.capInsetsY, b.capInsetsWidth, b.capInsetsHeight)), a.setSize(cc.size(b.width, b.height)));
        a.setDirection(b.direction);
        a.setPercent(b.percent)
    };
    c.PageViewAttributes = c.LayoutAttributes;
    c.ScrollViewAttributes = function(a, b, d) {
        c.LayoutAttributes(a, b, d);
        a.setInnerContainerSize(cc.size(null != b.innerWidth ? b.innerWidth : 200, null != b.innerHeight ? b.innerHeight : 200));
        a.setDirection(null != b.direction ? b.direction : 1);
        a.setBounceEnabled(b.bounceEnable)
    };
    c.SliderAttributes = function(a, b, c) {
        var e = b.scale9Enable;
        a.setScale9Enabled(e);
        var m = b.length,
            n = b.barFileNameData,
            p = n.resourceType,
            n = n.path;
        null != b.barFileName ? e && (d(c, p, n, function(b, c) {
                a.loadBarTexture(b, c)
            }), a.setSize(cc.size(m, a.getContentSize().height))) :
            d(c, p, n, function(b, c) {
                a.loadBarTexture(b, c)
            });
        e = b.ballNormalData;
        d(c, e.resourceType, e.path, function(b, c) {
            a.loadSlidBallTextureNormal(b, c)
        });
        m = b.ballPressedData;
        d(c, m.resourceType || e.resourceType, m.path || e.path, function(b, c) {
            a.loadSlidBallTexturePressed(b, c)
        });
        e = b.ballDisabledData;
        d(c, e.resourceType, e.path, function(b, c) {
            a.loadSlidBallTextureDisabled(b, c)
        });
        b = b.progressBarData;
        d(c, b.resourceType, b.path, function(b, c) {
            a.loadProgressBarTexture(b, c)
        })
    };
    c.TextFieldAttributes = function(a, b, c) {
        var d = b.placeHolder;
        d && a.setPlaceHolder(d);
        a.setString(b.text || "");
        (d = b.fontSize1) && a.setFontSize(d);
        d = b.fontName;
        null != d && (cc.sys.isNative ? e.test(d) ? a.setFontName(cc.path.join(cc.loader.resPath, c, d)) : a.setFontName(d) : a.setFontName(d.replace(e, "")));
        c = b.touchSizeWidth;
        d = b.touchSizeHeight;
        null != c && null != d && a.setTouchSize(c, d);
        c = b.maxLengthEnable;
        a.setMaxLengthEnabled(c);
        c && a.setMaxLength(b.maxLength);
        c = b.passwordEnable;
        a.setPasswordEnabled(c);
        c && a.setPasswordStyleText(b.passwordStyleText);
        c = b.areaWidth;
        d = b.areaHeight;
        c && d && (c = cc.size(c, d), a.setTextAreaSize(c));
        (c = b.hAlignment) && a.setTextHorizontalAlignment(c);
        (b = b.vAlignment) && a.setTextVerticalAlignment(b)
    };
    [{
        name: "Panel",
        object: ccui.Layout,
        handle: c.LayoutAttributes
    }, {
        name: "Button",
        object: ccui.Button,
        handle: c.ButtonAttributes
    }, {
        name: "CheckBox",
        object: ccui.CheckBox,
        handle: c.CheckBoxAttributes
    }, {
        name: "ImageView",
        object: ccui.ImageView,
        handle: c.ImageViewAttributes
    }, {
        name: "LabelAtlas",
        object: ccui.TextAtlas,
        handle: c.TextAtlasAttributes
    }, {
        name: "LabelBMFont",
        object: ccui.TextBMFont,
        handle: c.TextBMFontAttributes
    }, {
        name: "Label",
        object: ccui.Text,
        handle: c.TextAttributes
    }, {
        name: "ListView",
        object: ccui.ListView,
        handle: c.ListViewAttributes
    }, {
        name: "LoadingBar",
        object: ccui.LoadingBar,
        handle: c.LoadingBarAttributes
    }, {
        name: "PageView",
        object: ccui.PageView,
        handle: c.PageViewAttributes
    }, {
        name: "ScrollView",
        object: ccui.ScrollView,
        handle: c.ScrollViewAttributes
    }, {
        name: "Slider",
        object: ccui.Slider,
        handle: c.SliderAttributes
    }, {
        name: "TextField",
        object: ccui.TextField,
        handle: c.TextFieldAttributes
    }].forEach(function(a) {
        c.registerParser(a.name,
            function(b, d) {
                var e = new a.object,
                    m = b.options;
                c.generalAttributes(e, m);
                a.handle(e, m, d);
                c.colorAttributes(e, m);
                c.anchorPointAttributes(e, m);
                c.parseChild.call(this, e, b, d);
                return e
            })
    });
    a.registerParser("ccui", "*", c)
})(ccs._load, ccs._parser);
(function(a, b) {
    var c = new(b.extend({
        getNodeJson: function(a) {
            return a.action
        },
        parseNode: function(a, b, c) {
            if (!a) return null;
            var g = this,
                h = new ccs.ActionTimeline;
            h.setDuration(a.duration);
            h.setTimeSpeed(a.speed || 1);
            a.timelines.forEach(function(a) {
                var c = g.parsers[a.frameType],
                    d;
                c ? d = c.call(g, a, b) : cc.log("parser does not exist : %s", a.frameType);
                d && h.addTimeline(d);
                "ColorFrame" === a.frameType && h.addTimeline(g.parsers.AlphaFrame.call(g, a, b))
            });
            return h
        }
    }));
    [{
            name: "PositionFrame",
            handle: function(a) {
                var b = new ccs.PositionFrame;
                b.setPosition(cc.p(a.x, a.y));
                return b
            }
        }, {
            name: "VisibleFrame",
            handle: function(a) {
                var b = new ccs.VisibleFrame;
                b.setVisible(a.value);
                return b
            }
        }, {
            name: "ScaleFrame",
            handle: function(a) {
                var b = new ccs.ScaleFrame,
                    c = a.y;
                b.setScaleX(a.x);
                b.setScaleY(c);
                return b
            }
        }, {
            name: "RotationFrame",
            handle: function(a) {
                var b = new ccs.RotationFrame;
                b.setRotation(a.rotation);
                return b
            }
        }, {
            name: "SkewFrame",
            handle: function(a) {
                var b = new ccs.SkewFrame,
                    c = a.y;
                b.setSkewX(a.x);
                b.setSkewY(c);
                return b
            }
        }, {
            name: "RotationSkewFrame",
            handle: function(a) {
                var b =
                    new ccs.RotationSkewFrame,
                    c = a.y;
                b.setSkewX(a.x);
                b.setSkewY(c);
                return b
            }
        }, {
            name: "AnchorFrame",
            handle: function(a) {
                var b = new ccs.AnchorPointFrame;
                b.setAnchorPoint(cc.p(a.x, a.y));
                return b
            }
        }, {
            name: "InnerActionFrame",
            handle: function(a) {
                var b = new ccs.InnerActionFrame,
                    c = a.startFrame;
                b.setInnerActionType(a.innerActionType);
                b.setStartFrameIndex(c);
                return b
            }
        }, {
            name: "ColorFrame",
            handle: function(a) {
                var b = new ccs.ColorFrame;
                b.setColor(cc.color(a.red, a.green, a.blue));
                (new ccs.AlphaFrame).setAlpha(a.alpha);
                return b
            }
        },
        {
            name: "AlphaFrame",
            handle: function(a) {
                var b = new ccs.AlphaFrame;
                b.setAlpha(a.alpha);
                return b
            }
        }, {
            name: "TextureFrame",
            handle: function(a) {
                var b = new ccs.TextureFrame;
                a = a.value;
                if (null != a) {
                    var c = a;
                    null == cc.spriteFrameCache.getSpriteFrame(c) && (c = ccs.csLoader.getJsonPath() + a);
                    b.setTextureName(c)
                }
                return b
            }
        }, {
            name: "EventFrame",
            handle: function(a) {
                var b = new ccs.EventFrame;
                a = a.value;
                null != a && b.setEvent(a);
                return b
            }
        }, {
            name: "ZOrderFrame",
            handle: function(a) {
                var b = new ccs.ZOrderFrame;
                b.setZOrder(a.value);
                return b
            }
        }
    ].forEach(function(a) {
        c.registerParser(a.name,
            function(b, c) {
                var g = new ccs.Timeline;
                g.setActionTag(b.actionTag);
                var h = b.frames;
                h && h.length && h.forEach(function(b) {
                    var c = a.handle(b);
                    c.setFrameIndex(b.frameIndex);
                    c.setTween(b.tween);
                    g.addFrame(c)
                });
                return g
            })
    });
    a.registerParser("action", "*", c)
})(ccs._load, ccs._parser);
(function(a, b) {
    var c = new(b.extend({
            getNodeJson: function(a) {
                return a.Content.Content.Animation
            },
            parseNode: function(a, b, c) {
                if (!a) return null;
                var d = this,
                    k = new ccs.ActionTimeline;
                k.setDuration(a.Duration);
                k.setTimeSpeed(a.Speed || 1);
                a.Timelines.forEach(function(a) {
                    var c = d.parsers[a.Property],
                        e;
                    c ? e = c.call(d, a, b) : cc.log("parser does not exist : %s", a.Property);
                    e && k.addTimeline(e)
                });
                return k
            },
            deferred: function(a, b, c, d) {
                b = (a = a.Content.Content.AnimationList) ? a.length : 0;
                for (d = 0; d < b; d++) {
                    var k = a[d],
                        m = {
                            name: null,
                            startIndex: null,
                            endIndex: null
                        };
                    m.name = k.Name;
                    m.startIndex = k.StartIndex;
                    m.endIndex = k.EndIndex;
                    c.addAnimationInfo(m)
                }
            }
        })),
        d = function(a, b) {
            a.setTweenType(b.Type);
            var c = b.Points,
                d = [];
            c && (c.forEach(function(a) {
                d.push(a.X);
                d.push(a.Y)
            }), a.setEasingParams(d))
        };
    [{
            name: "Position",
            handle: function(a) {
                var b = new ccs.PositionFrame;
                b.setPosition(cc.p(a.X, a.Y));
                return b
            }
        }, {
            name: "VisibleForFrame",
            handle: function(a) {
                var b = new ccs.VisibleFrame;
                b.setVisible(a.Value);
                return b
            }
        }, {
            name: "Scale",
            handle: function(a) {
                var b =
                    new ccs.ScaleFrame,
                    c = a.Y;
                b.setScaleX(a.X);
                b.setScaleY(c);
                return b
            }
        }, {
            name: "Rotation",
            handle: function(a) {
                var b = new ccs.RotationFrame;
                b.setRotation(a.Rotation || a.Value || 0);
                return b
            }
        }, {
            name: "Skew",
            handle: function(a) {
                var b = new ccs.SkewFrame,
                    c = a.Y;
                b.setSkewX(a.X);
                b.setSkewY(c);
                return b
            }
        }, {
            name: "RotationSkew",
            handle: function(a) {
                var b = new ccs.RotationSkewFrame,
                    c = a.Y;
                b.setSkewX(a.X);
                b.setSkewY(c);
                return b
            }
        }, {
            name: "Anchor",
            handle: function(a) {
                var b = new ccs.AnchorPointFrame;
                b.setAnchorPoint(cc.p(a.X, a.Y));
                return b
            }
        },
        {
            name: "AnchorPoint",
            handle: function(a) {
                var b = new ccs.AnchorPointFrame;
                b.setAnchorPoint(cc.p(a.X, a.Y));
                return b
            }
        }, {
            name: "InnerAction",
            handle: function(a) {
                var b = new ccs.InnerActionFrame,
                    c = a.StartFrame;
                b.setInnerActionType(a.InnerActionType);
                b.setStartFrameIndex(c);
                return b
            }
        }, {
            name: "CColor",
            handle: function(a) {
                var b = new ccs.ColorFrame;
                (a = a.Color) || (a = {});
                a.R = void 0 === a.R ? 255 : a.R;
                a.G = void 0 === a.G ? 255 : a.G;
                a.B = void 0 === a.B ? 255 : a.B;
                b.setColor(cc.color(a.R, a.G, a.B));
                return b
            }
        }, {
            name: "Alpha",
            handle: function(a) {
                var b =
                    new ccs.AlphaFrame;
                b.setAlpha(a.Value);
                return b
            }
        }, {
            name: "FileData",
            handle: function(a, b) {
                var c, d, k, m;
                c = new ccs.TextureFrame;
                d = a.TextureFile;
                null != d && (k = d.Plist, d = d.Path, m = cc.spriteFrameCache.getSpriteFrame(d), !m && k && (cc.loader.getRes(b + k) ? (cc.spriteFrameCache.addSpriteFrames(b + k), m = cc.spriteFrameCache.getSpriteFrame(d)) : cc.log("%s need to be preloaded", b + k)), null == m && (d = b + d), c.setTextureName(d));
                return c
            }
        }, {
            name: "FrameEvent",
            handle: function(a) {
                var b = new ccs.EventFrame;
                a = a.Value;
                null != a && b.setEvent(a);
                return b
            }
        }, {
            name: "ZOrder",
            handle: function(a) {
                var b = new ccs.ZOrderFrame;
                b.setZOrder(a.Value);
                return b
            }
        }, {
            name: "ActionValue",
            handle: function(a) {
                var b = new ccs.InnerActionFrame,
                    c = a.InnerActionType,
                    d = a.CurrentAniamtionName,
                    k = a.SingleFrameIndex;
                a = a.FrameIndex;
                void 0 !== a && b.setFrameIndex(a);
                b.setInnerActionType(ccs.InnerActionType[c]);
                b.setSingleFrameIndex(k);
                b.setEnterWithName(!0);
                d && b.setAnimationName(d);
                return b
            }
        }, {
            name: "BlendFunc",
            handle: function(a) {
                var b = new ccs.BlendFuncFrame,
                    c = a.BlendFunc;
                c && void 0 !==
                    c.Src && void 0 !== c.Dst ? b.setBlendFunc(new cc.BlendFunc(c.Src, c.Dst)) : (c = a) && void 0 !== c.Src && void 0 !== c.Dst && b.setBlendFunc(new cc.BlendFunc(c.Src, c.Dst));
                return b
            }
        }
    ].forEach(function(a) {
        c.registerParser(a.name, function(b, c) {
            var h = new ccs.Timeline;
            h.setActionTag(b.ActionTag);
            var k = b.Frames;
            k && k.length && k.forEach(function(b) {
                var f = a.handle(b, c);
                f.setFrameIndex(b.FrameIndex);
                f.setTween(null != b.Tween ? b.Tween : !0);
                (b = b.EasingData) && d(f, b);
                h.addFrame(f)
            });
            return h
        })
    });
    a.registerParser("action", "2.*", c)
})(ccs._load,
    ccs._parser);
(function(a, b) {
    var c = {},
        d = new(b.extend({
            getNodeJson: function(a) {
                return a.nodeTree
            },
            addSpriteFrame: function(a, b, d) {
                if (a && b && a.length === b.length)
                    for (var e = 0; e < a.length; e++) {
                        var m = d + a[e];
                        cc.loader.getRes(m) || c[m] ? c[m] = !0 : cc.log("%s need to be preloaded", m);
                        cc.spriteFrameCache.addSpriteFrames(m, d + b[e])
                    }
            },
            pretreatment: function(a, b, c) {
                this.addSpriteFrame(a.textures, a.texturesPng, b)
            }
        }));
    d.generalAttributes = function(a, b) {
        var c = null != b.width ? b.width : 0,
            d = null != b.height ? b.height : 0,
            e = null != b.x ? b.x : 0,
            n = null !=
            b.y ? b.y : 0,
            p = null != b.scaleX ? b.scaleX : 1,
            s = null != b.scaleY ? b.scaleY : 1,
            r = null != b.rotation ? b.rotation : 0,
            u = null != b.rotationSkewX ? b.rotationSkewX : 0,
            t = null != b.rotationSkewY ? b.rotationSkewY : 0,
            v = null != b.skewX ? b.skewX : 0,
            w = null != b.skewY ? b.skewY : 0,
            A = null != b.anchorPointX ? b.anchorPointX : 0.5,
            C = null != b.anchorPointY ? b.anchorPointY : 0.5,
            E = null != b.opacity ? b.opacity : 255,
            x = null != b.colorR ? b.colorR : 255,
            B = null != b.colorG ? b.colorG : 255,
            z = null != b.colorB ? b.colorB : 255,
            D = null != b.colorR ? b.colorR : 0,
            G = null != b.tag ? b.tag : 0,
            F = null != b.actionTag ?
            b.actionTag : 0,
            y = null != b.visible ? b.visible : !0;
        0 == e && 0 == n || a.setPosition(cc.p(e, n));
        1 != p && a.setScaleX(p);
        1 != s && a.setScaleY(s);
        0 != r && a.setRotation(r);
        0 != u && a.setRotationX(u);
        0 != t && a.setRotationY(t);
        0 != v && a.setSkewX(v);
        0 != w && a.setSkewY(w);
        0.5 == A && 0.5 == C || a.setAnchorPoint(cc.p(A, C));
        0 == c && 0 == d || a.setContentSize(cc.size(c, d));
        0 != D && a.setLocalZOrder(D);
        !0 != y && a.setVisible(y);
        255 != E && a.setOpacity(E);
        255 == x && 255 == B && 255 == z || a.setColor(cc.color(x, B, z));
        a.setTag(G);
        a.setUserObject(new ccs.ActionTimelineData(F))
    };
    d.parseComponent = function(a, b) {
        if (b)
            for (var c = 0; c < b.length; ++c) {
                var d = this.loadComponent(b[c]);
                d && a.addComponent(d)
            }
    };
    d.parseChild = function(a, b, c, d) {
        a = c.children;
        for (c = 0; c < a.length; c++) {
            var e = this.parseNode(a[c], d);
            if (e)
                if (b instanceof ccui.PageView) e instanceof ccui.Layout && b.addPage(e);
                else if (b instanceof ccui.ListView) e instanceof ccui.Widget && b.pushBackCustomItem(e);
            else {
                if (!(b instanceof ccui.Layout) && e instanceof ccui.Widget) {
                    if (e.getPositionType() === ccui.Widget.POSITION_PERCENT) {
                        var n = e.getPositionPercent(),
                            p = b.getAnchorPoint();
                        e.setPositionPercent(cc.p(n.x + p.x, n.y + p.y))
                    }
                    n = b.getAnchorPointInPoints();
                    e.setPosition(cc.p(e.getPositionX() + n.x, e.getPositionY() + n.y))
                }
                b.addChild(e)
            }
        }
    };
    d.initNode = function(a) {
        var b = new cc.Node;
        this.generalAttributes(b, a);
        return b
    };
    d.initSubGraph = function(a) {
        var b = a.fileName,
            b = b && "" !== b ? this.createNode(b) : new ccs.Node;
        this.generalAttributes(b, a);
        return b
    };
    d.initSprite = function(a, b) {
        var c = a.fileName;
        if (null != c) {
            var d = cc.spriteFrameCache.getSpriteFrame(c),
                c = d ? ccs.Sprite.createWithSpriteFrame(d) :
                new ccs.Sprite(b + c);
            c || (c = new cc.Sprite, cc.log("filePath is empty. Create a sprite with no texture"))
        } else c = new ccs.Sprite;
        this.generalAttributes(c, a);
        var d = a.flipX,
            e = a.flipY;
        !1 != d && c.setFlippedX(d);
        !1 != e && c.setFlippedY(e);
        return c
    };
    d.initParticle = function(a, b) {
        var c = a.tmxFile,
            d = new cc.ParticleSystemQuad(a.plistFile);
        d.setTotalParticles(c);
        this.generalAttributes(d, a);
        return d
    };
    d.initTMXTiledMap = function(a, b) {
        var c = a.tmxFile,
            d = a.tmxString,
            e = a.resourcePath,
            n = null;
        c && "" !== c ? n = new cc.TMXTiledMap(c) :
            d && "" !== d && e && "" !== e && (n = new cc.TMXTiledMap(d, e));
        return n
    };
    var e = a.getParser("ccui")["*"];
    d.initWidget = function(a, b) {
        var c = a.classname,
            d = e.parsers[c];
        if (!d) return cc.log("%s parser is not found", c);
        if (c = d.call(e, a, b)) {
            var d = a.rotationSkewX,
                m = a.rotationSkewY,
                n = a.skewX,
                p = a.skewY;
            0 != d && c.setRotationX(d);
            0 != m && c.setRotationY(m);
            0 != n && c.setSkewX(n);
            0 != p && c.setSkewY(p);
            c.setUserObject(new ccs.ActionTimelineData(a.actionTag))
        }
        return c
    };
    [{
            name: "Node",
            handle: d.initNode
        }, {
            name: "SubGraph",
            handle: d.initSubGraph
        },
        {
            name: "Sprite",
            handle: d.initSprite
        }, {
            name: "Particle",
            handle: d.initParticle
        }, {
            name: "TMXTiledMap",
            handle: d.initTMXTiledMap
        }, {
            name: "Widget",
            handle: d.initWidget
        }, {
            name: "Panel",
            handle: d.initWidget
        }, {
            name: "Button",
            handle: d.initWidget
        }, {
            name: "CheckBox",
            handle: d.initWidget
        }, {
            name: "ImageView",
            handle: d.initWidget
        }, {
            name: "LabelAtlas",
            handle: d.initWidget
        }, {
            name: "LabelBMFont",
            handle: d.initWidget
        }, {
            name: "Label",
            handle: d.initWidget
        }, {
            name: "ListView",
            handle: d.initWidget
        }, {
            name: "LoadingBar",
            handle: d.initWidget
        }, {
            name: "PageView",
            handle: d.initWidget
        }, {
            name: "ScrollView",
            handle: d.initWidget
        }, {
            name: "Slider",
            handle: d.initWidget
        }, {
            name: "TextField",
            handle: d.initWidget
        }
    ].forEach(function(a) {
        d.registerParser(a.name, function(b, c, d) {
            var e = a.handle.call(this, b.options);
            this.parseComponent(e, b.components);
            this.parseChild(c, e, b, d);
            return e
        })
    });
    a.registerParser("timeline", "*", d)
})(ccs._load, ccs._parser);
(function(a, b) {
    var c = new(b.extend({
            parse: function(a, b, c) {
                c = void 0 !== c ? c : this._dirname(a);
                this.pretreatment(b, c, a);
                var d = this.parseNode(this.getNodeJson(b), c);
                this.deferred(b, c, d, a);
                return d
            },
            getNodeJson: function(a) {
                a = a.Content;
                return a.ObjectData ? a.ObjectData : a.Content.ObjectData
            },
            getClass: function(a) {
                return a.ctype
            }
        })),
        d = function(a, b) {
            return void 0 === a ? b : a
        };
    c.generalAttributes = function(a, b) {
        null != b.Name && a.setName(b.Name);
        var c = b.Position;
        null == c || null == c.X && null == c.Y || a.setPosition(cc.p(c.X || 0,
            c.Y || 0));
        c = b.Scale;
        null != c && (null != c.ScaleX && a.setScaleX(c.ScaleX), null != c.ScaleY && a.setScaleY(c.ScaleY));
        c = b.RotationSkewX;
        null != c && a.setRotationX(c);
        c = b.RotationSkewY;
        null != b.RotationSkewY && a.setRotationY(c);
        c = b.AnchorPoint;
        null != c && (null == c.ScaleX && (c.ScaleX = 0), null == c.ScaleY && (c.ScaleY = 0), 0.5 == c.ScaleX && 0.5 == c.ScaleY || a.setAnchorPoint(cc.p(c.ScaleX, c.ScaleY)));
        null != b.ZOrder && a.setLocalZOrder(b.ZOrder);
        c = d(b.VisibleForFrame, !0);
        a.setVisible(c);
        (c = b.Size) && s(a, c);
        null != b.Alpha && a.setOpacity(b.Alpha);
        a.setTag(b.Tag || 0);
        var c = b.ActionTag || 0,
            e = new ccs.ComExtensionData,
            g = b.UserData;
        void 0 !== g && e.setCustomProperty(g);
        e.setActionTag(c);
        a.getComponent("ComExtensionData") && a.removeComponent("ComExtensionData");
        a.addComponent(e);
        a.setCascadeColorEnabled(!0);
        a.setCascadeOpacityEnabled(!0);
        f(a, b)
    };
    c.parseChild = function(a, b, c) {
        if (a && b)
            for (var d = 0; d < b.length; d++) {
                var e = this.parseNode(b[d], c);
                if (e)
                    if (a instanceof ccui.PageView) e instanceof ccui.Layout && a.addPage(e);
                    else if (a instanceof ccui.ListView) e instanceof
                ccui.Widget && a.pushBackCustomItem(e);
                else {
                    if (!(a instanceof ccui.Layout) && e instanceof ccui.Widget && e.getPositionType() === ccui.Widget.POSITION_PERCENT) {
                        var f = e.getPositionPercent(),
                            g = a.getAnchorPoint();
                        e.setPositionPercent(cc.p(f.x + g.x, f.y + g.y))
                    }
                    a.addChild(e)
                }
            }
    };
    c.initSingleNode = function(a) {
        var b = new cc.Node;
        this.generalAttributes(b, a);
        a = a.CColor;
        null != a && b.setColor(p(a));
        return b
    };
    c.initSprite = function(a, b) {
        var c = new cc.Sprite;
        n(a.FileData, b, function(a, b) {
            if (0 === b) c.setTexture(a);
            else if (1 === b) {
                var d =
                    cc.spriteFrameCache.getSpriteFrame(a);
                d && c.setSpriteFrame(d)
            }
        });
        var d = a.BlendFunc;
        if (a.BlendFunc) {
            var e = cc.BlendFunc.ALPHA_PREMULTIPLIED;
            void 0 !== d.Src && (e.src = d.Src);
            void 0 !== d.Dst && (e.dst = d.Dst);
            c.setBlendFunc(e)
        }
        a.FlipX && c.setFlippedX(!0);
        a.FlipY && c.setFlippedY(!0);
        this.generalAttributes(c, a);
        d = a.CColor;
        null != d && c.setColor(p(d));
        return c
    };
    c.initParticle = function(a, b) {
        var c, d = this;
        n(a.FileData, b, function(b, e) {
            cc.loader.getRes(b) || cc.log("%s need to be preloaded", b);
            c = new cc.ParticleSystem(b);
            d.generalAttributes(c,
                a);
            c.setPositionType(cc.ParticleSystem.TYPE_GROUPED);
            !cc.sys.isNative && c.setDrawMode(cc.ParticleSystem.TEXTURE_MODE);
            var f = a.BlendFunc;
            if (a.BlendFunc) {
                var g = cc.BlendFunc.ALPHA_PREMULTIPLIED;
                void 0 !== f.Src && (g.src = f.Src);
                void 0 !== f.Dst && (g.dst = f.Dst);
                c.setBlendFunc(g)
            }
        });
        return c
    };
    c.widgetAttributes = function(a, b, c) {
        a.setCascadeColorEnabled(!0);
        a.setCascadeOpacityEnabled(!0);
        a.setUnifySizeEnabled(!1);
        a.ignoreContentAdaptWithSize(!1);
        !c && s(a, b.Size);
        (c = b.Name) && a.setName(c);
        c = b.ActionTag || 0;
        a.setActionTag(c);
        var g = new ccs.ComExtensionData,
            h = b.UserData;
        void 0 !== h && g.setCustomProperty(h);
        g.setActionTag(c);
        a.getComponent("ComExtensionData") && a.removeComponent("ComExtensionData");
        a.addComponent(g);
        (c = b.RotationSkewX) && a.setRotationX(c);
        (c = b.RotationSkewY) && a.setRotationY(c);
        b.FlipX && a.setFlippedX(!0);
        b.FlipY && a.setFlippedY(!0);
        c = b.zOrder;
        null != c && a.setLocalZOrder(c);
        c = d(b.VisibleForFrame, !0);
        a.setVisible(c);
        c = b.Alpha;
        null != c && a.setOpacity(c);
        a.setTag(b.Tag || 0);
        a.setTouchEnabled(b.TouchEnable || !1);
        c = b.CallBackType;
        null != c && a.setCallbackType(c);
        (c = b.CallBackName) && a.setCallbackName(c);
        c = b.Position;
        null != c && a.setPosition(c.X || 0, c.Y || 0);
        g = b.Scale;
        null != g && (c = d(g.ScaleX, 1), g = d(g.ScaleY, 1), a.setScaleX(c), a.setScaleY(g));
        c = b.AnchorPoint;
        null != c && a.setAnchorPoint(c.ScaleX || 0, c.ScaleY || 0);
        c = b.CColor;
        null != c && a.setColor(p(c));
        f(a, b);
        e(a, b)
    };
    var e = function(a, b) {
            var c = b.CallBackType,
                d = b.CallBackName,
                e = function(b) {
                    if ("function" === typeof a[d]) a[d](b)
                };
            "Click" === c ? a.addClickEventListener(e) : "Touch" === c ? a.addTouchEventListener(e) :
                "Event" === c && a.addCCSEventListener(e)
        },
        f = function(a, b) {
            var c = ccui.LayoutComponent.bindLayoutComponent(a);
            if (c) {
                var d = b.PositionPercentXEnable || b.PositionPercentXEnabled || !1,
                    e = b.PositionPercentYEnable || b.PositionPercentYEnabled || !1,
                    f = 0,
                    g = 0,
                    h = b.PrePosition;
                null != h && (f = h.X || 0, g = h.Y || 0);
                var k = b.PercentWidthEnable || b.PercentWidthEnabled || !1,
                    m = b.PercentHeightEnable || b.PercentHeightEnabled || !1,
                    n = 0,
                    p = 0,
                    s = b.PreSize;
                null != h && (n = s.X || 0, p = s.Y || 0);
                var F = b.StretchWidthEnable || !1,
                    y = b.StretchHeightEnable || !1,
                    J = b.HorizontalEdge,
                    h = b.VerticalEdge,
                    s = b.LeftMargin || 0,
                    K = b.RightMargin || 0,
                    H = b.TopMargin || 0,
                    L = b.BottomMargin || 0;
                c.setPositionPercentXEnabled(d);
                c.setPositionPercentYEnabled(e);
                c.setPositionPercentX(f);
                c.setPositionPercentY(g);
                c.setPercentWidthEnabled(k);
                c.setPercentHeightEnabled(m);
                c.setPercentWidth(n);
                c.setPercentHeight(p);
                c.setPercentWidthEnabled(k || m);
                c.setStretchWidthEnabled(F);
                c.setStretchHeightEnabled(y);
                d = ccui.LayoutComponent.horizontalEdge.NONE;
                "LeftEdge" === J ? d = ccui.LayoutComponent.horizontalEdge.LEFT : "RightEdge" ===
                    J ? d = ccui.LayoutComponent.horizontalEdge.RIGHT : "BothEdge" === J && (d = ccui.LayoutComponent.horizontalEdge.CENTER);
                c.setHorizontalEdge(d);
                d = ccui.LayoutComponent.verticalEdge.NONE;
                "TopEdge" === h ? d = ccui.LayoutComponent.verticalEdge.TOP : "BottomEdge" === h ? d = ccui.LayoutComponent.verticalEdge.BOTTOM : "BothEdge" === h && (d = ccui.LayoutComponent.verticalEdge.CENTER);
                c.setVerticalEdge(d);
                c.setTopMargin(H);
                c.setBottomMargin(L);
                c.setLeftMargin(s);
                c.setRightMargin(K);
                c.setVerticalEdge(d);
                c.setTopMargin(H);
                c.setBottomMargin(L);
                c.setLeftMargin(s);
                c.setRightMargin(K)
            }
        },
        g = function(a, b, c, d) {
            2 === a.getBackGroundColorType() ? (c = c || {}, d = d || {}, a.setBackGroundColor(p(c), p(d))) : (b = b || {}, a.setBackGroundColor(p(b)))
        },
        h = function(a, b) {
            a.setBackGroundColorVector(cc.p(b.ScaleX || 0, b.ScaleY || 0))
        };
    c.initPanel = function(a, b) {
        var c = new ccui.Layout;
        this.widgetAttributes(c, a);
        var e = a.ClipAble || !1;
        null != e && c.setClippingEnabled(e);
        e = d(a.ComboBoxIndex, 0);
        c.setBackGroundColorType(e);
        e = d(a.BackColorAlpha, 255);
        null != e && c.setBackGroundColorOpacity(e);
        e = a.Scale9Enable;
        null != e && c.setBackGroundImageScale9Enabled(e);
        var f = d(a.Alpha, 255);
        c.setOpacity(f);
        n(a.FileData, b, function(a, b) {
            c.setBackGroundImage(a, b)
        });
        e ? (c.setBackGroundImageCapInsets(cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0)), s(c, a.Size)) : c.isIgnoreContentAdaptWithSize() || s(c, a.Size);
        g(c, a.SingleColor, a.FirstColor, a.EndColor);
        h(c, a.ColorVector);
        return c
    };
    c.initText = function(a, b) {
        var c = new ccui.Text,
            e = a.TouchScaleChangeAble;
        null != e && c.setTouchScaleChangeEnabled(e);
        e = a.LabelText;
        null != e && c.setString(e);
        e = a.FontSize;
        null != e && c.setFontSize(e);
        e = a.FontName;
        null != e && c.setFontName(e);
        var e = a.AreaWidth,
            f = a.areaHeight;
        e && f && c.setTextAreaSize(cc.size(e, f));
        e = a.HorizontalAlignmentType || "HT_Left";
        switch (e) {
            case "HT_Right":
                e = 2;
                break;
            case "HT_Center":
                e = 1;
                break;
            default:
                e = 0
        }
        c.setTextHorizontalAlignment(e);
        e = a.VerticalAlignmentType || "VT_Top";
        switch (e) {
            case "VT_Bottom":
                e = 2;
                break;
            case "VT_Center":
                e = 1;
                break;
            default:
                e = 0
        }
        c.setTextVerticalAlignment(e);
        e = a.FontResource;
        null != e &&
            (e = e.Path, null != e && (e = cc.sys.isNative ? cc.path.join(cc.loader.resPath, b, e) : (e = e.match(/([^\/]+)\.(\S+)/)) ? e[1] : "", c.setFontName(e)));
        a.OutlineEnabled && a.OutlineColor && c.enableOutline && c.enableOutline(p(a.OutlineColor), d(a.OutlineSize, 1));
        a.ShadowEnabled && a.ShadowColor && c.enableShadow && c.enableShadow(p(a.ShadowColor), cc.size(d(a.ShadowOffsetX, 2), d(a.ShadowOffsetY, -2)), a.ShadowBlurRadius || 0);
        e = a.IsCustomSize;
        null != e && c.ignoreContentAdaptWithSize(!e);
        c.setUnifySizeEnabled(!1);
        e = a.CColor;
        a.CColor = null;
        c.setTextColor(p(e));
        this.widgetAttributes(c, a, c.isIgnoreContentAdaptWithSize());
        a.CColor = e;
        return c
    };
    c.initButton = function(a, b) {
        var c = new ccui.Button;
        n(a.NormalFileData, b, function(a, b) {
            c.loadTextureNormal(a, b)
        });
        n(a.PressedFileData, b, function(a, b) {
            c.loadTexturePressed(a, b)
        });
        n(a.DisabledFileData, b, function(a, b) {
            c.loadTextureDisabled(a, b)
        });
        var e = d(a.Scale9Enable, !1);
        e && c.setScale9Enabled(e);
        var f = a.ButtonText;
        null != f && c.setTitleText(f);
        f = a.FontSize;
        null != f && c.setTitleFontSize(f);
        f = a.FontName;
        null !=
            f && c.setTitleFontName(f);
        f = a.TextColor;
        null != f && c.setTitleColor(p(f));
        f = d(a.DisplayState, !0);
        c.setBright(f);
        c.setEnabled(f);
        f = a.FontResource;
        null != f && (f = f.Path, null != f && (f = cc.sys.isNative ? cc.path.join(cc.loader.resPath, b, f) : (f = f.match(/([^\/]+)\.(\S+)/)) ? f[1] : "", c.setTitleFontName(f)));
        (f = c.getTitleRenderer()) && a.ShadowEnabled && a.ShadowColor && f.enableShadow && f.enableShadow(p(a.ShadowColor), cc.size(d(a.ShadowOffsetX, 2), d(a.ShadowOffsetY, -2)), a.ShadowBlurRadius || 0);
        f && a.OutlineEnabled && a.OutlineColor &&
            f.enableStroke && f.enableStroke(p(a.OutlineColor), d(a.OutlineSize, 1));
        this.widgetAttributes(c, a);
        e && (c.setUnifySizeEnabled(!1), c.ignoreContentAdaptWithSize(!1), e = cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0), c.setCapInsets(e));
        s(c, a.Size);
        return c
    };
    c.initCheckBox = function(a, b) {
        var c = new ccui.CheckBox;
        this.widgetAttributes(c, a);
        [{
            name: "NormalBackFileData",
            handle: c.loadTextureBackGround
        }, {
            name: "PressedBackFileData",
            handle: c.loadTextureBackGroundSelected
        }, {
            name: "NodeNormalFileData",
            handle: c.loadTextureFrontCross
        }, {
            name: "DisableBackFileData",
            handle: c.loadTextureBackGroundDisabled
        }, {
            name: "NodeDisableFileData",
            handle: c.loadTextureFrontCrossDisabled
        }].forEach(function(d) {
            n(a[d.name], b, function(a, b) {
                d.handle.call(c, a, b)
            })
        });
        var e = d(a.CheckedState, !1);
        c.setSelected(e);
        e = d(a.DisplayState, !0);
        c.setBright(e);
        c.setEnabled(e);
        return c
    };
    c.initScrollView = function(a, b) {
        var c = new ccui.ScrollView;
        this.widgetAttributes(c, a);
        n(a.FileData, b, function(a, b) {
            c.setBackGroundImage(a, b)
        });
        c.setClippingEnabled(a.ClipAble ||
            !1);
        var e = d(a.ComboBoxIndex, 0);
        c.setBackGroundColorType(e);
        e = a.BackColorAlpha;
        null != e && c.setBackGroundColorOpacity(e);
        a.Scale9Enable ? (c.setBackGroundImageScale9Enabled(!0), c.setBackGroundImageCapInsets(cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0)), s(c, a.Size)) : c.isIgnoreContentAdaptWithSize() || s(c, a.Size);
        g(c, a.SingleColor, a.FirstColor, a.EndColor);
        h(c, a.ColorVector);
        e = a.InnerNodeSize;
        e = cc.size(e.Width || 0, e.Height || 0);
        c.setInnerContainerSize(e);
        e = 0;
        "Vertical" ===
        a.ScrollDirectionType && (e = 1);
        "Horizontal" === a.ScrollDirectionType && (e = 2);
        "Vertical_Horizontal" === a.ScrollDirectionType && (e = 3);
        c.setDirection(e);
        e = d(a.IsBounceEnabled, !1);
        c.setBounceEnabled(e);
        return c
    };
    c.initImageView = function(a, b) {
        var c = new ccui.ImageView;
        n(a.FileData, b, function(a, b) {
            c.loadTexture(a, b)
        });
        n(a.ImageFileData, b, function(a, b) {
            c.loadTexture(a, b)
        });
        a.Scale9Enable ? (c.setScale9Enabled(!0), c.setUnifySizeEnabled(!1), c.ignoreContentAdaptWithSize(!1), c.setCapInsets(cc.rect(a.Scale9OriginX || 0,
            a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0))) : s(c, a.Size);
        this.widgetAttributes(c, a);
        return c
    };
    c.initLoadingBar = function(a, b) {
        var c = new ccui.LoadingBar;
        this.widgetAttributes(c, a);
        n(a.ImageFileData, b, function(a, b) {
            c.loadTexture(a, b)
        });
        c.setDirection("Right_To_Left" === a.ProgressType ? 1 : 0);
        var e = d(a.ProgressInfo, 80);
        null != e && c.setPercent(e);
        return c
    };
    c.initSlider = function(a, b) {
        var c = new ccui.Slider,
            e = cc.loader;
        this.widgetAttributes(c, a);
        [{
            name: "BackGroundData",
            handle: c.loadBarTexture
        }, {
            name: "BallNormalData",
            handle: c.loadSlidBallTextureNormal
        }, {
            name: "BallPressedData",
            handle: c.loadSlidBallTexturePressed
        }, {
            name: "BallDisabledData",
            handle: c.loadSlidBallTextureDisabled
        }, {
            name: "ProgressBarData",
            handle: c.loadProgressBarTexture
        }].forEach(function(d) {
            n(a[d.name], b, function(a, b) {
                0 !== b || e.getRes(a) || cc.log("%s need to be preloaded", a);
                d.handle.call(c, a, b)
            })
        });
        c.setPercent(a.PercentInfo || 0);
        var f = d(a.DisplayState, !0);
        c.setBright(f);
        c.setEnabled(f);
        return c
    };
    c.initPageView = function(a, b) {
        var c = new ccui.PageView;
        this.widgetAttributes(c,
            a);
        n(a.FileData, b, function(a, b) {
            c.setBackGroundImage(a, b)
        });
        c.setClippingEnabled(a.ClipAble || !1);
        a.Scale9Enable && (c.setBackGroundImageScale9Enabled(!0), c.setBackGroundImageCapInsets(cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0)));
        var e = d(a.ComboBoxIndex, 0);
        c.setBackGroundColorType(e);
        g(c, a.SingleColor, a.FirstColor, a.EndColor);
        h(c, a.ColorVector);
        e = a.BackColorAlpha;
        null != e && c.setBackGroundColorOpacity(e);
        s(c, a.Size);
        return c
    };
    c.initListView = function(a, b) {
        var c = new ccui.ListView;
        this.widgetAttributes(c, a);
        n(a.FileData, b, function(a, b) {
            c.setBackGroundImage(a, b)
        });
        c.setClippingEnabled(a.ClipAble || !1);
        var e = d(a.ComboBoxIndex, 0);
        c.setBackGroundColorType(e);
        e = d(a.BackColorAlpha, 255);
        a.Scale9Enable && (c.setBackGroundImageScale9Enabled(!0), c.setBackGroundImageCapInsets(cc.rect(a.Scale9OriginX || 0, a.Scale9OriginY || 0, a.Scale9Width || 0, a.Scale9Height || 0)));
        var f = d(a.DirectionType, ccui.ListView.DIR_HORIZONTAL),
            k = d(a.VerticalType, "Align_Left"),
            m = d(a.HorizontalType, "Align_Top");
        f ? "Vertical" ===
            f && (c.setDirection(ccui.ScrollView.DIR_VERTICAL), "" === m ? c.setGravity(ccui.ListView.GRAVITY_LEFT) : "Align_Right" === m ? c.setGravity(ccui.ListView.GRAVITY_RIGHT) : "Align_HorizontalCenter" === m && c.setGravity(ccui.ListView.GRAVITY_CENTER_HORIZONTAL)) : (c.setDirection(ccui.ScrollView.DIR_HORIZONTAL), "Align_Bottom" === k ? c.setGravity(ccui.ListView.GRAVITY_BOTTOM) : "Align_VerticalCenter" === k ? c.setGravity(ccui.ListView.GRAVITY_CENTER_VERTICAL) : c.setGravity(ccui.ListView.GRAVITY_TOP));
        f = d(a.IsBounceEnabled, !1);
        c.setBounceEnabled(f);
        c.setItemsMargin(a.ItemMargin || 0);
        f = a.InnerNodeSize;
        null != f && c.setInnerContainerSize(cc.size(f.Widget || 0, f.Height || 0));
        g(c, a.SingleColor, a.FirstColor, a.EndColor);
        h(c, a.ColorVector);
        null != e && c.setBackGroundColorOpacity(e);
        s(c, a.Size);
        return c
    };
    c.initTextAtlas = function(a, b) {
        var c = new ccui.TextAtlas,
            d = a.LabelText,
            e = a.CharWidth,
            f = a.CharHeight,
            g = a.StartChar;
        n(a.LabelAtlasFileImage_CNB, b, function(a, b) {
            cc.loader.getRes(a) || cc.log("%s need to be preloaded", a);
            0 === b && c.setProperty(d, a, e, f, g)
        });
        this.widgetAttributes(c,
            a);
        return c
    };
    c.initTextBMFont = function(a, b) {
        var c = new ccui.TextBMFont;
        this.widgetAttributes(c, a);
        c.setString(a.LabelText);
        n(a.LabelBMFontFile_CNB, b, function(a, b) {
            cc.loader.getRes(a) || cc.log("%s need to be pre loaded", a);
            c.setFntFile(a)
        });
        c.ignoreContentAdaptWithSize(!0);
        return c
    };
    c.initTextField = function(a, b) {
        var c = new ccui.TextField;
        a.PasswordEnable && (c.setPasswordEnabled(!0), c.setPasswordStyleText(a.PasswordStyleText || "*"));
        var d = a.PlaceHolderText;
        null != d && c.setPlaceHolder(d);
        d = a.FontSize;
        null !=
            d && c.setFontSize(d);
        d = a.FontName;
        null != d && c.setFontName(d);
        a.MaxLengthEnable && (c.setMaxLengthEnabled(!0), c.setMaxLength(a.MaxLengthText || 0));
        this.widgetAttributes(c, a);
        d = a.LabelText;
        null != d && c.setString(d);
        d = a.FontResource;
        null != d && (d = d.Path, null != d && (d = cc.sys.isNative ? cc.path.join(cc.loader.resPath, b, d) : (d = d.match(/([^\/]+)\.(\S+)/)) ? d[1] : "", c.setFontName(d)));
        c.setUnifySizeEnabled(!1);
        c.ignoreContentAdaptWithSize(!1);
        d = a.CColor;
        null != d && c.setTextColor(p(d));
        c.isIgnoreContentAdaptWithSize() || (s(c,
            a.Size), cc.sys.isNative && c.getVirtualRenderer().setLineBreakWithoutSpace(!0));
        return c
    };
    c.initSimpleAudio = function(a, b) {
        var c = new ccs.ComAudio;
        c.setLoop(a.Loop || !1);
        n(a.FileData, b, function(a, b) {
            c.setFile(a)
        })
    };
    c.initGameMap = function(a, b) {
        var d = null;
        n(a.FileData, b, function(b, e) {
            0 === e && (d = new cc.TMXTiledMap(b));
            c.generalAttributes(d, a)
        });
        return d
    };
    c.initProjectNode = function(a, b) {
        var d = a.FileData;
        if (null != d && d.Path) {
            d = b + d.Path;
            if (cc.loader.getRes(d)) {
                d = ccs.load(d, b);
                c.generalAttributes(d.node, a);
                if (d.action &&
                    d.node) {
                    d.action.tag = d.node.tag;
                    var e = a.InnerActionSpeed;
                    void 0 !== e && d.action.setTimeSpeed(e);
                    d.node.runAction(d.action);
                    d.action.gotoFrameAndPause(0)
                }
                return d.node
            }
            cc.log("%s need to be preloaded", d)
        }
    };
    var k = function(a) {
        return a ? (a = a.match(/([^\/]+)\.[^\/]+$/)) && a[1] ? a[1] : "" : ""
    };
    c.initArmature = function(a, b) {
        var d = new ccs.Armature,
            e = a.IsLoop,
            f = a.IsAutoPlay,
            g = a.CurrentAnimationName;
        n(a.FileData, b, function(a, b) {
            var c, h, m = cc.loader.getRes(a);
            m ? (c = m.config_file_path, h = m.config_png_path, c.forEach(function(a,
                b) {
                h[b] && cc.spriteFrameCache.addSpriteFrames(a, h[b])
            })) : cc.log("%s need to be preloaded", a);
            ccs.armatureDataManager.addArmatureFileInfo(a);
            d.init(k(a));
            f ? d.getAnimation().play(g, -1, e) : (d.getAnimation().play(g), d.getAnimation().gotoAndPause(0))
        });
        delete a.AnchorPoint;
        delete a.Size;
        c.generalAttributes(d, a);
        d.setColor(p(a.CColor));
        return d
    };
    c.initBoneNode = function(a, b) {
        var d = new ccs.BoneNode,
            e = a.Length;
        void 0 !== e && d.setDebugDrawLength(e);
        (e = a.BlendFunc) && void 0 !== e.Src && void 0 !== e.Dst && d.setBlendFunc(new cc.BlendFunc(e.Src,
            e.Dst));
        c.generalAttributes(d, a);
        e = a.CColor;
        !e || void 0 === e.R && void 0 === e.G && void 0 === e.B || d.setColor(p(e));
        return d
    };
    c.initSkeletonNode = function(a) {
        var b = new ccs.SkeletonNode;
        c.generalAttributes(b, a);
        a = a.CColor;
        !a || void 0 === a.R && void 0 === a.G && void 0 === a.B || b.setColor(p(a));
        return b
    };
    var m = {},
        n = function(a, b, c) {
            if (null != a) {
                var d = a.Path,
                    e;
                e = "Default" === a.Type || "Normal" === a.Type ? 0 : 1;
                if (a = a.Plist) cc.loader.getRes(b + a) ? (m[b + a] = !0, cc.spriteFrameCache.addSpriteFrames(b + a)) : m[b + a] || cc.spriteFrameCache.getSpriteFrame(d) ||
                    cc.log("%s need to be preloaded", b + a);
                0 !== e ? cc.spriteFrameCache.getSpriteFrame(d) ? c(d, e) : cc.log("failed to get spriteFrame: %s", d) : c(b + d, e)
            }
        },
        p = function(a) {
            if (a) return cc.color(null != a.R ? a.R : 255, null != a.G ? a.G : 255, null != a.B ? a.B : 255, null != a.A ? a.A : 255)
        },
        s = function(a, b) {
            var c = b.X || 0,
                d = b.Y || 0;
            b && a.setContentSize(cc.size(c, d))
        };
    [{
            name: "SingleNodeObjectData",
            handle: c.initSingleNode
        }, {
            name: "NodeObjectData",
            handle: c.initSingleNode
        }, {
            name: "LayerObjectData",
            handle: c.initSingleNode
        }, {
            name: "GameNodeObjectData",
            handle: c.initSingleNode
        }, {
            name: "GameLayerObjectData",
            handle: c.initSingleNode
        }, {
            name: "SpriteObjectData",
            handle: c.initSprite
        }, {
            name: "ParticleObjectData",
            handle: c.initParticle
        }, {
            name: "PanelObjectData",
            handle: c.initPanel
        }, {
            name: "TextObjectData",
            handle: c.initText
        }, {
            name: "ButtonObjectData",
            handle: c.initButton
        }, {
            name: "CheckBoxObjectData",
            handle: c.initCheckBox
        }, {
            name: "ScrollViewObjectData",
            handle: c.initScrollView
        }, {
            name: "ImageViewObjectData",
            handle: c.initImageView
        }, {
            name: "LoadingBarObjectData",
            handle: c.initLoadingBar
        },
        {
            name: "SliderObjectData",
            handle: c.initSlider
        }, {
            name: "PageViewObjectData",
            handle: c.initPageView
        }, {
            name: "ListViewObjectData",
            handle: c.initListView
        }, {
            name: "TextAtlasObjectData",
            handle: c.initTextAtlas
        }, {
            name: "TextBMFontObjectData",
            handle: c.initTextBMFont
        }, {
            name: "TextFieldObjectData",
            handle: c.initTextField
        }, {
            name: "SimpleAudioObjectData",
            handle: c.initSimpleAudio
        }, {
            name: "GameMapObjectData",
            handle: c.initGameMap
        }, {
            name: "ProjectNodeObjectData",
            handle: c.initProjectNode
        }, {
            name: "ArmatureNodeObjectData",
            handle: c.initArmature
        },
        {
            name: "BoneNodeObjectData",
            handle: c.initBoneNode
        }, {
            name: "SkeletonNodeObjectData",
            handle: c.initSkeletonNode
        }
    ].forEach(function(a) {
        c.registerParser(a.name, function(b, c) {
            var d = a.handle.call(this, b, c);
            this.parseChild(d, b.Children, c);
            return d
        })
    });
    a.registerParser("timeline", "2.*", c)
})(ccs._load, ccs._parser);
(function() {
    ccs.uiReader = {
        _fileDesignSizes: {},
        widgetFromJsonFile: function(a) {
            var c = cc.loader.getRes(a);
            c && (this._fileDesignSizes[a] = cc.size(c.designWidth || 0, c.designHeight || 0));
            var c = c.Version || c.version,
                d = ccs.uiReader.getVersionInteger(c);
            return !c || 1700 <= d ? (cc.warn("Not supported file types, Please try use the ccs.load"), null) : ccs._load(a, "ccui")
        },
        registerTypeAndCallBack: function(a, c, d, e) {
            var f = ccs._load.getParser("ccui")["*"],
                g = e.bind(d);
            f.registerParser(a, function(e, f) {
                var m = new c,
                    n = e.options;
                d.setPropsFromJsonDictionary && d.setPropsFromJsonDictionary(m, n);
                this.generalAttributes(m, n);
                var p = n.customProperty,
                    p = p ? JSON.parse(p) : {};
                g(a, m, p);
                this.colorAttributes(m, n);
                this.anchorPointAttributes(m, n);
                this.parseChild.call(this, m, e, f);
                return m
            })
        },
        getVersionInteger: function(a) {
            if (!a || "string" !== typeof a) return 0;
            a = a.split(".");
            if (4 !== a.length) return 0;
            var c = 0;
            a.forEach(function(a, b) {
                c += a * Math.pow(10, 3 - b)
            });
            return c
        },
        storeFileDesignSize: function(a, c) {
            this._fileDesignSizes[a] = c
        },
        getFileDesignSize: function(a) {
            return this._fileDesignSizes[a]
        },
        getFilePath: function() {
            return this._filePath
        },
        setFilePath: function(a) {
            this._filePath = a
        },
        getParseObjectMap: function() {
            return ccs._load.getParser("ccui")["*"].parsers
        },
        getParseCallBackMap: function() {
            return ccs._load.getParser("ccui")["*"].parsers
        },
        clear: function() {}
    };
    var a = ccs._load.getParser("ccui")["*"];
    ccs.imageViewReader = {
        setPropsFromJsonDictionary: a.ImageViewAttributes
    };
    ccs.buttonReader = {
        setPropsFromJsonDictionary: a.ButtonAttributes
    };
    ccs.checkBoxReader = {
        setPropsFromJsonDictionary: a.CheckBoxAttributes
    };
    ccs.labelAtlasReader = {
        setPropsFromJsonDictionary: a.TextAtlasAttributes
    };
    ccs.labelBMFontReader = {
        setPropsFromJsonDictionary: a.TextBMFontAttributes
    };
    ccs.labelReader = {
        setPropsFromJsonDictionary: a.TextAttributes
    };
    ccs.layoutReader = {
        setPropsFromJsonDictionary: a.LayoutAttributes
    };
    ccs.listViewReader = {
        setPropsFromJsonDictionary: a.ListViewAttributes
    };
    ccs.loadingBarReader = {
        setPropsFromJsonDictionary: a.LoadingBarAttributes
    };
    ccs.pageViewReader = {
        setPropsFromJsonDictionary: a.PageViewAttributes
    };
    ccs.scrollViewReader = {
        setPropsFromJsonDictionary: a.ScrollViewAttributes
    };
    ccs.sliderReader = {
        setPropsFromJsonDictionary: a.SliderAttributes
    };
    ccs.textFieldReader = {
        setPropsFromJsonDictionary: a.TextFieldAttributes
    }
})();
(function() {
    ccs.sceneReader = {
        _node: null,
        createNodeWithSceneFile: function(a) {
            return this._node = a = ccs._load(a, "scene")
        },
        getNodeByTag: function(a) {
            return null == this._node ? null : this._node.getTag() === a ? this._node : this._nodeByTag(this._node, a)
        },
        _nodeByTag: function(a, b) {
            if (null == a) return null;
            for (var c = null, d = a.getChildren(), e = 0; e < d.length && (!(c = d[e]) || c.getTag() !== b) && !(c = this._nodeByTag(c, b)); e++);
            return c
        },
        version: function() {
            return "*"
        },
        setTarget: function() {},
        clear: function() {
            ccs.triggerManager.removeAll();
            cc.audioEngine.end()
        }
    }
})();
var GAMETYPE_CURTYPE = 4,
    NARUTO_URLROOT = "http://obzv0w0w8.qnssl.com.cdnts.21pink.tk/v19/";
var LoadingScene = cc.Scene.extend({
    _interval: null,
    _label: null,
    _className: "LoadingScene",
    cb: null,
    target: null,
    _bgLayer: null,
    _logo: null,
    _logo2: null,
    _loading: null,
    _dt_logo: null,
    _back: null,
    _pic: null,
    init: function() {
        var a = this,
            b = a._bgLayer = new cc.LayerColor(cc.color(0, 0, 0, 255));
        a.addChild(b, 0);
        var c = {
            x: 640,
            y: 360
        };
        LoadingScene.back && cc.loader.loadImg(LoadingScene.back, {
            isCrossOrigin: !1
        }, function(b, d) {
            a._initStage_back(d, c)
        });
        LoadingScene.pic && cc.loader.loadImg(LoadingScene.pic, {
            isCrossOrigin: !1
        }, function(b,
            d) {
            a._initStage_pic(d, c)
        });
        LoadingScene.pro && cc.loader.loadImg(LoadingScene.pro, {
            isCrossOrigin: !1
        }, function(b, d) {
            a._initStage_pro(d, c)
        });
        LoadingScene.dt_logo && cc.loader.loadImg(LoadingScene.dt_logo, {
            isCrossOrigin: !1
        }, function(b, d) {
            a._initStage_dt_logo(d, c)
        });
        LoadingScene.btn_close && cc.loader.loadImg(LoadingScene.btn_close, {
            isCrossOrigin: !1
        }, function(b, d) {
            0 != g_clienttype && a._initStage_btn_close(d, c)
        });
        var d = a._label = new cc.LabelTTF("0%", "Arial", 22);
        d.setPosition(cc.p(c.x, c.y - 200));
        d.setColor(cc.color(255,
            255, 255));
        b.addChild(this._label, 20);
        d = new cc.LabelTTF("POWERED BY DREAM TECH", "Arial", 14);
        d.setPosition(cc.p(c.x, 20));
        d.setColor(cc.color(180, 180, 180));
        b.addChild(d, 20);
        cc.log("init");
        return !0
    },
    _initStage_btn_close: function(a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        c = new cc.Sprite(c);
        c.setScale(cc.contentScaleFactor());
        c.x = 1251;
        c.y = 691;
        this.addChild(c, 0);
        var d = cc.EventListener.create({
            event: cc.EventListener.TOUCH_ONE_BY_ONE,
            swallowTouches: !0,
            onTouchBegan: function(a,
                b) {
                var c = b.getCurrentTarget(),
                    d = c.convertToNodeSpace(a.getLocation()),
                    c = c.getContentSize(),
                    c = cc.rect(0, 0, c.width, c.height);
                if (cc.rectContainsPoint(c, d)) return close_game(), !0
            }
        });
        cc.eventManager.addListener(d, c)
    },
    _initStage_back: function(a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        c = this._back = new cc.Sprite(c);
        c.setScale(cc.contentScaleFactor());
        c.x = b.x;
        c.y = b.y;
        this._bgLayer.addChild(c, 10)
    },
    _initStage_pic: function(a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        c = this._pic = new cc.Sprite(c);
        c.setScale(cc.contentScaleFactor());
        c.x = b.x - 384;
        c.y = b.y - 160;
        this._bgLayer.addChild(c, 10);
        var d = cc.rotateBy(0.5, 180);
        c.runAction(cc.repeatForever(d))
    },
    _initStage_pro: function(a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        c = new cc.Sprite(c);
        c.setScale(cc.contentScaleFactor());
        this._pro = new cc.ProgressTimer(c);
        this._pro.type = cc.ProgressTimer.TYPE_BAR;
        this._pro.midPoint = cc.p(0, 0);
        this._pro.barChangeRate =
            cc.p(1, 0);
        this._pro.x = b.x + 48;
        this._pro.y = b.y - 167;
        this._bgLayer.addChild(this._pro, 20)
    },
    _initStage_dt_logo: function(a, b) {
        var c = this._texture2d = new cc.Texture2D;
        c.initWithElement(a);
        c.handleLoadedTexture();
        c = this._lcf = new cc.Sprite(c);
        c.setScale(cc.contentScaleFactor());
        c.x = b.x;
        c.y = 70;
        this._bgLayer.addChild(c, 10)
    },
    onEnter: function() {
        cc.Node.prototype.onEnter.call(this);
        this.schedule(this._startLoading, 0.3)
    },
    onExit: function() {
        cc.Node.prototype.onExit.call(this);
        this._label.setString("0%")
    },
    initWithResources: function(a,
        b, c) {
        cc.isString(a) && (a = [a]);
        this.resources = a || [];
        this.cb = b;
        this.target = c
    },
    _startLoading: function() {
        var a = this;
        a.unschedule(a._startLoading);
        cc.loader.load(a.resources, function(b, c, d) {
            b = Math.min(d / c * 100 | 0, 100);
            a._label.setString("" + b + "%");
            a._pro.setPercentage(b)
        }, function() {
            a.cb && (clearInterval(this.timer), a.cb.call(a.target))
        })
    },
    _updateTransform: function() {
        this._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._bgLayer._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty);
        this._label._renderCmd.setDirtyFlag(cc.Node._dirtyFlags.transformDirty)
    },
    changePos: function() {
        cc.log("changePos");
        var a = cc.view.getFrameSize(),
            b = 1,
            b = 100 * a.width / a.height > 1600 / 9 ? a.height / 720 : a.width / 1280;
        cc.log("size.width " + a.width);
        cc.log("size.height " + a.height);
        this._logo.setScale(b);
        this._loading.setScale(b);
        this._label.setScale(b);
        this._logo.setPosition(a.width / 2, a.height / 2);
        this._loading.setPosition(a.width / 2, a.height / 2 - 200 * b);
        this._label.setPosition(a.width / 2, a.height / 2 - 200 * b)
    }
});
LoadingScene.preload = function(a, b, c) {
    var d = null;
    d = new LoadingScene, d.init(), cc.eventManager.addCustomListener(cc.Director.EVENT_PROJECTION_CHANGED, function() {
        d._updateTransform()
    });
    d.initWithResources(a, b, c);
    cc.director.runScene(d);
    return d
};
LoadingScene.btn_close = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADoAAAA6CAYAAADhu0ooAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkQyOTdBQzVFN0ZDNjExRTY5NDk2RkIxOEU5N0U5RUM1IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkQyOTdBQzVGN0ZDNjExRTY5NDk2RkIxOEU5N0U5RUM1Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6RDI5N0FDNUM3RkM2MTFFNjk0OTZGQjE4RTk3RTlFQzUiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6RDI5N0FDNUQ3RkM2MTFFNjk0OTZGQjE4RTk3RTlFQzUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz53U1KpAAARdElEQVR42rxa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\x3d\x3d";
LoadingScene.pro = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAxAAAAAdCAYAAAA6j4q+AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkY3ODNFMjk1NUUwQzExRTY5ODE4RkQ1Mjg3ODNBQ0EyIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkY3ODNFMjk2NUUwQzExRTY5ODE4RkQ1Mjg3ODNBQ0EyIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6Rjc4M0UyOTM1RTBDMTFFNjk4MThGRDUyODc4M0FDQTIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6Rjc4M0UyOTQ1RTBDMTFFNjk4MThGRDUyODc4M0FDQTIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6E9JC0AAATG0lEQVR42uxd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\x3d\x3d";
LoadingScene.dt_logo = "data:image/png;base64,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\x3d";
LoadingScene.pic = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABRCAYAAACqj0o2AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkNGNkU1MjhGNUUwRTExRTZBODNEOTE2MTU3MkExOTRCIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkNGNkU1MjkwNUUwRTExRTZBODNEOTE2MTU3MkExOTRCIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6Q0Y2RTUyOEQ1RTBFMTFFNkE4M0Q5MTYxNTcyQTE5NEIiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6Q0Y2RTUyOEU1RTBFMTFFNkE4M0Q5MTYxNTcyQTE5NEIiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6eIEE+AAAU8klEQVR42tyd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\x3d\x3d";
LoadingScene.back = "data:image/jpg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAAoAAD/4QN/aHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjYtYzA2NyA3OS4xNTc3NDcsIDIwMTUvMDMvMzAtMjM6NDA6NDIgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6OTQzOGUxNmYtYmMyYi00YjQ5LWJmM2YtMTBhN2ZhY2ZhZWZlIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjk1MEM0NDMyNjM4QzExRTZCQzU5RDVCNzlDNDE5NTBEIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk1MEM0NDMxNjM4QzExRTZCQzU5RDVCNzlDNDE5NTBEIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjk4NjdlOTZhLWNlM2ItMDA0Yi1hNmMxLTBlNjNlZGExY2I3OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5NDM4ZTE2Zi1iYzJiLTRiNDktYmYzZi0xMGE3ZmFjZmFlZmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+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";
var res = {};
res.NarutoGameLayer_json = NARUTO_URLROOT + "narutogamelayer.json";
res.NarutoSelectAutoLayer_json = NARUTO_URLROOT + "narutoselectautolayer.json";
res.NarutoDoubleLayer_json = NARUTO_URLROOT + "narutodoublelayer.json";
res.NarutoSoundTipsLayer_json = NARUTO_URLROOT + "narutosoundtipslayer.json";
res.NarutoBoxLayer_json = NARUTO_URLROOT + "narutoboxlayer.json";
res.NarutoBoxResultLayer_json = NARUTO_URLROOT + "narutoboxresultlayer.json";
res.NarutoFreeResultLayer_json = NARUTO_URLROOT + "narutofreeresultlayer.json";
res.NarutoHelpLayer1_json = NARUTO_URLROOT + "narutohelplayer1.json";
res.NarutoHelpLayer2_json = NARUTO_URLROOT + "narutohelplayer2.json";
res.NarutoHelpLayer3_json = NARUTO_URLROOT + "narutohelplayer3.json";
res.NarutoHelpLayer4_json = NARUTO_URLROOT + "narutohelplayer4.json";
res.NarutoDisconnectLayer_json = NARUTO_URLROOT + "narutodisconnectlayer.json";
res.NarutoSetupLayer_json = NARUTO_URLROOT + "narutosetuplayer.json";
res.NarutoGameBackAni_json = NARUTO_URLROOT + "narutogamebackani.json";
res.NarutoBtnAni1_json = NARUTO_URLROOT + "narutobtnani1.json";
res.NarutoBtnAni2_json = NARUTO_URLROOT + "narutobtnani2.json";
res.NarutoBtnAni3_json = NARUTO_URLROOT + "narutobtnani3.json";
res.NarutoDartsAni1_json = NARUTO_URLROOT + "narutodartsani1.json";
res.NarutoDartsAni2_json = NARUTO_URLROOT + "narutodartsani2.json";
res.NarutoDartsAni3_json = NARUTO_URLROOT + "narutodartsani3.json";
res.NarutoDartsAni4_json = NARUTO_URLROOT + "narutodartsani4.json";
res.NarutoDartsAni5_json = NARUTO_URLROOT + "narutodartsani5.json";
res.NarutoDoubleAni1_json = NARUTO_URLROOT + "narutodoubleani1.json";
res.NarutoDoubleAni2_json = NARUTO_URLROOT + "narutodoubleani2.json";
res.NarutoDoubleAni3_json = NARUTO_URLROOT + "narutodoubleani3.json";
res.NarutoDoubleAni4_json = NARUTO_URLROOT + "narutodoubleani4.json";
res.NarutoDoubleAni5_json = NARUTO_URLROOT + "narutodoubleani5.json";
res.NarutoDoubleAni6_json = NARUTO_URLROOT + "narutodoubleani6.json";
res.NarutoWinAni1_json = NARUTO_URLROOT + "narutowinani1.json";
res.NarutoWinAni2_json = NARUTO_URLROOT + "narutowinani2.json";
res.NarutoWinAni3_json = NARUTO_URLROOT + "narutowinani3.json";
res.NarutoWinAni4_json = NARUTO_URLROOT + "narutowinani4.json";
res.NarutoBoxAni1_json = NARUTO_URLROOT + "narutoboxani1.json";
res.NarutoBoxAni2_json = NARUTO_URLROOT + "narutoboxani2.json";
res.NarutoRunAni0_json = NARUTO_URLROOT + "narutorunani0.json";
res.NarutoRunAni1_json = NARUTO_URLROOT + "narutorunani1.json";
res.NarutoRunAni2_json = NARUTO_URLROOT + "narutorunani2.json";
res.NarutoRunAni3_json = NARUTO_URLROOT + "narutorunani3.json";
res.NarutoRunAni4_json = NARUTO_URLROOT + "narutorunani4.json";
res.NarutoRunAni5_json = NARUTO_URLROOT + "narutorunani5.json";
res.NarutoRunAni6_json = NARUTO_URLROOT + "narutorunani6.json";
res.NarutoRunAni7_json = NARUTO_URLROOT + "narutorunani7.json";
res.NarutoRunAni8_json = NARUTO_URLROOT + "narutorunani8.json";
res.NarutoRunAni9_json = NARUTO_URLROOT + "narutorunani9.json";
res.NarutoRunAni10_json = NARUTO_URLROOT + "narutorunani10.json";
res.NarutoRunAni11_json = NARUTO_URLROOT + "narutorunani11.json";
res.NarutoRunAni12_json = NARUTO_URLROOT + "narutorunani12.json";
res.NarutoFreeLogoAni_json = NARUTO_URLROOT + "narutofreelogoani.json";
res.NarutoLightAni1_json = NARUTO_URLROOT + "narutolightani1.json";
res.NarutoPngRes_png = NARUTO_URLROOT + "narutopngres.png";
res.NarutoPngRes_plist = NARUTO_URLROOT + "narutopngres.plist";
res.NarutoJpgRes_jpg = NARUTO_URLROOT + "narutojpgres.jpg";
res.NarutoJpgRes_plist = NARUTO_URLROOT + "narutojpgres.plist";
res.NarutoAniPng_png = NARUTO_URLROOT + "narutoanipng.png";
res.NarutoAniPng_plist = NARUTO_URLROOT + "narutoanipng.plist";
res.NarutoAniJpg_jpg = NARUTO_URLROOT + "narutoanijpg.jpg";
res.NarutoAniJpg_plist = NARUTO_URLROOT + "narutoanijpg.plist";
res.NarutoAniJpg1_jpg = NARUTO_URLROOT + "narutoanijpg1.jpg";
res.NarutoAniJpg1_plist = NARUTO_URLROOT + "narutoanijpg1.plist";
res.NarutoAniJpg2_jpg = NARUTO_URLROOT + "narutoanijpg2.jpg";
res.NarutoAniJpg2_plist = NARUTO_URLROOT + "narutoanijpg2.plist";
res.NarutoGameFont1_png = NARUTO_URLROOT + "narutofon1.png";
res.NarutoGameFont1_fnt = NARUTO_URLROOT + "narutofon1.fnt";
res.NarutoGameFont2_png = NARUTO_URLROOT + "narutofon2.png";
res.NarutoGameFont2_fnt = NARUTO_URLROOT + "narutofon2.fnt";
res.NarutoGameFont3_png = NARUTO_URLROOT + "narutofon3.png";
res.NarutoGameFont3_fnt = NARUTO_URLROOT + "narutofon3.fnt";
res.NarutoGameFont4_png = NARUTO_URLROOT + "narutofon4.png";
res.NarutoGameFont4_fnt = NARUTO_URLROOT + "narutofon4.fnt";
res.NarutoGameFont5_png = NARUTO_URLROOT + "narutofon5.png";
res.NarutoGameFont5_fnt = NARUTO_URLROOT + "narutofon5.fnt";
res.NarutoGameFont6_png = NARUTO_URLROOT + "narutofon6.png";
res.NarutoGameFont6_fnt = NARUTO_URLROOT + "narutofon6.fnt";
res.NarutoGameFont7_png = NARUTO_URLROOT + "narutofon7.png";
res.NarutoGameFont7_fnt = NARUTO_URLROOT + "narutofon7.fnt";
res.NarutoBtnClick_mp3 = NARUTO_URLROOT + "btnclick.mp3";
res.NarutoBtnRun_mp3 = NARUTO_URLROOT + "btnrun.mp3";
res.NarutoBtnStop_mp3 = NARUTO_URLROOT + "btnstop.mp3";
res.NarutoRunWheel_mp3 = NARUTO_URLROOT + "runwheel.mp3";
res.NarutoStopWheel_mp3 = NARUTO_URLROOT + "stopwheel.mp3";
res.NarutoC1Sound_mp3 = NARUTO_URLROOT + "c1sound.mp3";
res.NarutoFastWheel_mp3 = NARUTO_URLROOT + "fastwheel.mp3";
res.NarutoMusci1_mp3 = NARUTO_URLROOT + "narutomusic1.mp3";
res.NarutoMusci2_mp3 = NARUTO_URLROOT + "narutomusic2.mp3";
res.NarutoMusci3_mp3 = NARUTO_URLROOT + "narutomusic3.mp3";
res.NarutoMusci4_mp3 = NARUTO_URLROOT + "narutomusic4.mp3";
res.NarutoFreeMusci1_mp3 = NARUTO_URLROOT + "freemusic1.mp3";
res.NarutoEffWin1_mp3 = NARUTO_URLROOT + "effwin1.mp3";
res.NarutoEffWin2_mp3 = NARUTO_URLROOT + "effwin2.mp3";
res.NarutoEffWin3_mp3 = NARUTO_URLROOT + "effwin3.mp3";
res.NarutoEffWin4_mp3 = NARUTO_URLROOT + "effwin4.mp3";
var g_resources = [],
    i;
for (i in res) g_resources.push(res[i]);

function getCurTime() {
    return Math.floor((new Date).getTime() / 1E3)
}

function getCurTimeMS() {
    return (new Date).getTime()
}
var NetTime = cc.Class.extend({
    ctor: function() {
        this.restime = this.reqtime = this.mytime = this.nettime = 0;
        this.ping = -1;
        this.curping = 0
    },
    onSync: function(a) {
        this.nettime = a;
        this.mytime = getCurTime()
    },
    getCurNetTime: function() {
        return getCurTime() - this.mytime + this.nettime
    },
    getOffNetTime: function(a) {
        return getCurTime() - this.mytime + this.nettime - a
    },
    onReq: function() {
        this.reqtime = getCurTimeMS()
    },
    onRes: function() {
        this.restime = getCurTimeMS();
        this.curping = this.restime - this.reqtime;
        this.ping = 0 > this.ping ? this.curping : Math.floor((this.ping +
            this.curping) / 2);
        cc.log("ping is " + this.ping);
        cc.log("curping is " + this.curping)
    }
});

function removeUnusedTextures(a) {
    cc.spriteFrameCache.removeSpriteFramesFromFile(a);
    cc.sys.isNative && cc.director.getTextureCache().removeUnusedTextures()
}
NetTime.singleton = new NetTime;
NetTime.KEEPALIVE_TIME = 3E4;
NetTime.TIMEOUT_TIME = 3E4;
NetTime.RECONNECT_TIME = 3E4;
var WebSocket = WebSocket || window.WebSocket || window.MozWebSocket,
    WSClientCmd = cc.Class.extend({
        cmdid: "",
        wsc: null
    }),
    WSClientMsg = cc.Class.extend({
        msgid: ""
    }),
    WSClientState = {
        NULL: 0,
        INIT: 1,
        CONNECTED: 2,
        CONNECTING: 3,
        CLOSE: 4,
        DISCONNECTION: 5
    },
    WSClient = cc.Class.extend({
        _host: "",
        _ws: null,
        _funcOpen: null,
        _funcError: null,
        _funcClose: null,
        lstCmdCallback: [],
        mapCmd: {},
        _mapMsg: {},
        ctor: function() {
            cc.log("WSClient.ctor");
            this.wscstate = WSClientState.NULL
        },
        init: function(a, b, c, d) {
            if (this.wscstate != WSClientState.NULL) cc.log("WSClient.init fail!");
            else {
                var e = this;
                e.timerOnSecond = setInterval(function() {
                    e.onSecond()
                }, 1E3);
                e.timeKeepalive = 0;
                e.timeReconnect = 0;
                e.numsReconnect = 0;
                e.timeTimeOut = getCurTime();
                e.lstCmdCallback = [];
                e._host = a;
                b && (e._funcOpen = b);
                c && (e._funcError = c);
                d && (e._funcClose = d);
                e.wscstate = WSClientState.INIT;
                cc.log("WSClient init " + a + " ...");
                e.connect()
            }
        },
        onDisconnection: function() {},
        reconnect: function() {
            var a = getCurTime();
            0 == this.timeReconnect && (this.timeReconnect = a);
            this.numsReconnect++;
            if (3 < this.numsReconnect && a - this.timeReconnect >
                NetTime.RECONNECT_TIME) this.onDisconnection();
            else this.connect()
        },
        connect: function() {
            var a = this;
            a.wscstate = WSClientState.CONNECTING;
            cc.log("WSClient connect " + a._host + " ...");
            a._ws = new WebSocket(a._host);
            a._ws.onopen = function(b) {
                a.onOpen(b)
            };
            a._ws.onmessage = function(b) {
                cc.log("onmessage " + b.data);
                a.onMessage(b.data)
            };
            a._ws.onerror = function(b) {
                a.onError(b)
            };
            a._ws.onclose = function(b) {
                a.onClose(b)
            }
        },
        onOpen: function(a) {
            this.wscstate = WSClientState.CONNECTED;
            cc.log("WSClient open " + this._host);
            this._funcOpen &&
                this._funcOpen(a);
            this.onCmdCallback_connected()
        },
        onMessage: function(a) {
            if ((a = JSON.parse(a)) && a.hasOwnProperty("msgid") && this._mapMsg.hasOwnProperty(a.msgid)) this._mapMsg[a.msgid].onMsg(a)
        },
        onError: function(a) {
            cc.log("WSClient error.");
            this._funcError && this._funcError(a)
        },
        onClose: function(a) {
            this.clearCmd();
            cc.log("WSClient close.");
            this._funcClose && this._funcClose(a);
            this._ws = null;
            this.wscstate != WSClientState.CLOSE && (this.wscstate = WSClientState.DISCONNECTION, this.reconnect())
        },
        send: function(a, b) {
            if (this.wscstate !=
                WSClientState.CONNECTED) this.onError(void 0);
            else this._addCmdCallback(a.cmdid, a, b), this._send(a)
        },
        clearCmd: function() {
            this.lstCmdCallback.splice(0, this.lstCmdCallback.length)
        },
        _send: function(a) {
            null != this._ws && this._ws.send(JSON.stringify(a));
            cc.log(JSON.stringify(a));
            0 == this.timeTimeOut && (this.timeTimeOut = getCurTime())
        },
        addCmd: function(a) {
            a.wsc = this;
            this.mapCmd[a.cmdid] = a
        },
        addMsg: function(a) {
            this._mapMsg[a.msgid] = a
        },
        _addCmdCallback: function(a, b, c) {
            cc.log("_addCmdCallback " + a);
            this.lstCmdCallback.push({
                cmdid: a,
                msgobj: b,
                callback: c
            })
        },
        onCmdCallback: function(a, b) {
            0 < this.lstCmdCallback.length && (cc.log("onCmdCallback1 " + a), cc.log("onCmdCallback2 " + this.lstCmdCallback[0].cmdid), this.lstCmdCallback[0].cmdid == a && (void 0 != this.lstCmdCallback[0].callback && this.lstCmdCallback[0].callback(b), this.lstCmdCallback.shift(), this.timeTimeOut = 0))
        },
        onCmdCallback_connected: function() {
            for (var a = 0; a < this.lstCmdCallback.length; ++a) this._send(this.lstCmdCallback[a].msgobj)
        },
        onSecond: function() {
            if (this.wscstate == WSClientState.CONNECTED) {
                var a =
                    getCurTime();
                0 < this.timeTimeOut && a - this.timeTimeOut > NetTime.TIMEOUT_TIME && (this.timeTimeOut = 0, this.closeWS());
                a - this.timeKeepalive > NetTime.KEEPALIVE_TIME && (this.timeKeepalive = a)
            }
        },
        onKeepalive: function() {},
        closeWS: function() {
            this._ws.close();
            this.onError(void 0)
        }
    });
WSClient.create = function(a, b, c, d) {
    var e = new WSClient;
    e.init(a, b, c, d);
    return e
};
var Wheel = cc.Node.extend({
    ctor: function(a, b, c, d, e, f, g, h, k, m) {
        d = a.getLayoutSize();
        e = Math.floor(d.height / f) + 4;
        0 == e % 2 && ++e;
        this.lsticonnode = [];
        this.lsttopnode = [];
        this.lsttopani = [];
        var n = d.width / 2,
            p = Math.floor(d.height / 2 - Math.floor(e / 2) * f);
        this.curpos = this.sby = p;
        this.cby = d.height / 2;
        for (var s = 0; s < e; ++s) {
            var r = [],
                u = new cc.Sprite;
            a.addChild(u, 1);
            u.setPosition(n, p);
            r.spr = u;
            r.idata = 0;
            this.lsticonnode.push(r);
            void 0 != k && (r = new cc.Sprite, k.addChild(r, 1), r.setPosition(n, p), r.setVisible(!1), this.lsttopnode.push(r));
            p += f
        }
        this.lsize = d;
        this.iconsp = f;
        this.lsticon = b;
        this.lstbicon = c;
        this.lsticonani = m;
        this.lstricon = void 0;
        void 0 != g && this.setWheelData(g, h, !1);
        this.bRun = !1;
        this.speed = this.BeginAniTime = this.RunTime = 0;
        this.StopIndex = -1;
        this.bStoping = !1;
        this.layWheel = a;
        this.layTopWheel = k;
        this.bShowTopIcon = !0;
        this.SpringBackScale = this.SpringBackDis = 0
    },
    update: function(a) {
        if (this.bRun) {
            if (0 < this.BeginAniTime) {
                this.BeginAniTime -= a;
                if (0 < this.BeginAniTime) return;
                this.BeginAniTime = 0;
                void 0 != this.RunSoundName && cc.audioEngine.playEffect(this.RunSoundName, !1);
                if (void 0 != this.lstbicon)
                    for (var b = 0; b < this.lsticonnode.length; ++b) {
                        var c = this.lsticonnode[b].spr,
                            d = this.lsticonnode[b].idata,
                            d = this.lstbicon[d];
                        void 0 != d && 0 != d && (d = cc.spriteFrameCache.getSpriteFrame(d), c.setSpriteFrame(d))
                    }
            }
            0 < this.RunTime && (this.RunTime -= a);
            this.curpos -= this.speed * a;
            c = Math.floor(this.curpos);
            for (b = 0; b < this.lsticonnode.length; ++b) this.lsticonnode[b].spr.setPositionY(c), this.fixAlpha(this.lsticonnode[b].spr), c += this.iconsp;
            for (; this.lsticonnode[0].spr.getPositionY() <= this.sby -
                this.iconsp;) {
                a = this.lsticonnode[0];
                var b = this.lsticonnode[this.lsticonnode.length - 1],
                    c = a.spr,
                    e = b.spr,
                    d = this.getNewData();
                a.idata = d;
                for (b = 0; b < this.lsticonnode.length - 1; ++b) this.lsticonnode[b] = this.lsticonnode[b + 1];
                this.lsticonnode[this.lsticonnode.length - 1] = a;
                d = void 0 == this.lstbicon ? this.lsticon[d] : this.lstbicon[d];
                c.setPositionY(e.getPositionY() + this.iconsp);
                void 0 == d || 0 == d ? c.setVisible(!1) : (d = cc.spriteFrameCache.getSpriteFrame(d), c.setSpriteFrame(d), c.setVisible(!0));
                this.curpos += this.iconsp;
                if (0 >=
                    this.RunTime && 0 <= this.StopIndex && this.curdataindex == this.StopIndex) {
                    this.stopWheel(!0);
                    break
                }
            }
        }
    },
    getNewData: function() {
        if (void 0 == this.lstwheeldata) return 0;
        for (var a = Math.floor(this.lsticonnode.length / 2) + 1, b = this.curdataindex + a; b >= this.lstwheeldata.length;) b -= this.lstwheeldata.length;
        for (++this.curdataindex; this.curdataindex >= this.lstwheeldata.length;) this.curdataindex -= this.lstwheeldata.length;
        if (0 >= this.RunTime && 0 <= this.StopIndex) {
            for (var c = !1, d = 0; d <= a + 1; ++d) {
                for (var e = this.curdataindex + d; 0 > e;) e +=
                    this.lstwheeldata.length;
                for (; e >= this.lstwheeldata.length;) e -= this.lstwheeldata.length;
                if (e == this.StopIndex) {
                    c = !0;
                    break
                }
            }
            if (!c) {
                for (b = 0 == this.lstwheeldata[b] && 0 == this.lstwheeldata[this.StopIndex] || 0 != this.lstwheeldata[b] && 0 != this.lstwheeldata[this.StopIndex] ? this.StopIndex - 2 : this.StopIndex - 1; 0 > b;) b += this.lstwheeldata.length;
                for (; b >= this.lstwheeldata.length;) b -= this.lstwheeldata.length;
                for (this.curdataindex = b - a + 1; 0 > this.curdataindex;) this.curdataindex += this.lstwheeldata.length;
                for (; this.curdataindex >=
                    this.lstwheeldata.length;) this.curdataindex -= this.lstwheeldata.length
            }
        }
        return this.lstwheeldata[b]
    },
    setWheelData: function(a, b, c) {
        this.lstwheeldata = a;
        this.setWheelIndex(b, c)
    },
    setWheelIndex: function(a, b) {
        for (this.curdataindex = a; 0 > this.curdataindex;) this.curdataindex += this.lstwheeldata.length;
        for (; this.curdataindex >= this.lstwheeldata.length;) this.curdataindex -= this.lstwheeldata.length;
        b && this.refreshWheelDisplay()
    },
    refreshWheelDisplay: function() {
        for (var a = this.lsticonnode.length, b = this.curdataindex -
                Math.floor(a / 2); 0 > b;) b += this.lstwheeldata.length;
        for (; b >= this.lstwheeldata.length;) b -= this.lstwheeldata.length;
        for (var c = 0; c < a; ++c) {
            var d = this.lstwheeldata[b],
                e = this.lsticon[d];
            this.lsticonnode[c].idata = d;
            void 0 == e || 0 == e ? this.lsticonnode[c].spr.setVisible(!1) : (d = cc.spriteFrameCache.getSpriteFrame(e), this.lsticonnode[c].spr.setSpriteFrame(d), this.lsticonnode[c].spr.setVisible(!0));
            ++b;
            b >= this.lstwheeldata.length && (b = 0)
        }
    },
    stopWheel: function(a) {
        var b = this.speed;
        this.showLightAni(!1);
        void 0 != this.StopSoundName &&
            a && cc.audioEngine.playEffect(this.StopSoundName, !1);
        for (a = 0; a < this.lsticonnode.length; ++a) {
            var c = this.lsticonnode[a].spr;
            c.stopAllActions()
        }
        c = this.StopIndex - Math.floor(this.lsticonnode.length / 2);
        for (a = 0; a < this.lsticonnode.length; ++a) {
            for (var d = c + a; 0 > d;) d += this.lstwheeldata.length;
            for (; d >= this.lstwheeldata.length;) d -= this.lstwheeldata.length;
            this.lsticonnode[a].idata = this.lstwheeldata[d]
        }
        this.bRun = !1;
        this.speed = this.BeginAniTime = this.RunTime = 0;
        this.StopIndex = -1;
        this.curpos = this.sby;
        var d = !1,
            e = -1,
            f = -1;
        void 0 != this.iLogicNum && void 0 != this.C1Num && void 0 != this.C1SoundName && (d = !0, e = Math.floor(this.lsttopnode.length / 2) - Math.floor(this.iLogicNum / 2), f = e + this.iLogicNum - 1);
        var g = Math.floor(this.curpos);
        for (a = 0; a < this.lsticonnode.length; ++a) {
            var c = this.lsticonnode[a].spr,
                h = this.lsticonnode[a].idata,
                k = this.lsticon[h];
            d && a >= e && a <= f && h == this.C1Num && cc.audioEngine.playEffect(this.C1SoundName, !1);
            void 0 != k && 0 != k ? (h = cc.spriteFrameCache.getSpriteFrame(k), c.setSpriteFrame(h), c.setVisible(!0)) : c.setVisible(!1);
            c.setPositionY(g);
            this.fixAlpha(c);
            g += this.iconsp
        }
        if (0 < this.SpringBackDis)
            for (d = this.lsticonnode.length, b = this.SpringBackDis / b, a = 0; a < d; ++a) c = this.lsticonnode[a].spr, f = cc.p(c.getPositionX(), c.getPositionY() - this.SpringBackDis), e = cc.p(c.getPositionX(), c.getPositionY()), f = cc.moveTo(b, f), f = new cc.EaseBackOut(f), e = cc.moveTo(b * this.SpringBackScale, e), e = new cc.EaseBackOut(e), e = cc.sequence(f, e), c.runAction(e)
    },
    setSound: function(a, b, c, d) {
        this.RunSoundName = a;
        this.StopSoundName = b;
        this.C1Num = c;
        this.C1SoundName =
            d
    },
    setResultColor: function(a, b, c, d) {
        this.ResultR = a;
        this.ResultG = b;
        this.ResultB = c;
        this.ResultA = d
    },
    setResultIcon: function(a) {
        this.lstricon = a
    },
    setLogicNum: function(a) {
        this.iLogicNum = a
    },
    setShowTopIcon: function(a) {
        this.bShowTopIcon = a
    },
    run: function(a, b, c, d) {
        if (!this.bRun) {
            this.bRun = !0;
            this.RunTime = c;
            this.BeginAniTime = b + d;
            this.speed = a;
            this.bStoping = !1;
            if (void 0 == cc.game.bhide || !cc.game.bhide)
                for (a = this.lsticonnode.length, c = 0; c < a; ++c) {
                    var e = this.lsticonnode[c].spr,
                        f = cc.p(e.getPositionX(), e.getPositionY() +
                            30),
                        g = cc.delayTime(d),
                        f = cc.moveTo(b, f),
                        g = cc.sequence(g, f);
                    e.runAction(g)
                }
            this.curpos += 30
        }
    },
    stop_index: function(a) {
        this.StopIndex = a;
        this.bStoping = !0
    },
    setState: function(a) {
        if (0 == a) {
            if (void 0 != this.lstricon)
                for (a = 0; a < this.lsticonnode.length; ++a) {
                    var b = this.lsticonnode[a].idata,
                        b = this.lsticon[b];
                    void 0 != b && 0 != b && (b = cc.spriteFrameCache.getSpriteFrame(b), this.lsticonnode[a].spr.setSpriteFrame(b))
                } else
                    for (b = cc.color(255, 255, 255), a = 0; a < this.lsticonnode.length; ++a) this.lsticonnode[a].spr.setColor(b), this.lsticonnode[a].spr.setOpacity(255),
                        this.fixAlpha(this.lsticonnode[a].spr);
            this.clearTop()
        } else if (1 == a) {
            if (void 0 != this.lstricon)
                for (a = 0; a < this.lsticonnode.length; ++a) b = this.lsticonnode[a].idata, b = this.lstricon[b], void 0 != b && 0 != b && (b = cc.spriteFrameCache.getSpriteFrame(b), this.lsticonnode[a].spr.setSpriteFrame(b));
            else {
                var c = b = a = 64,
                    d = 255;
                void 0 != this.ResultR && (a = this.ResultR);
                void 0 != this.ResultG && (b = this.ResultG);
                void 0 != this.ResultB && (c = this.ResultB);
                void 0 != this.ResultA && (d = this.ResultA);
                b = cc.color(a, b, c);
                for (a = 0; a < this.lsticonnode.length; ++a) this.lsticonnode[a].spr.setColor(b)
            }
            for (a =
                0; a < this.lsticonnode.length; ++a) 0 >= this.getAlpha(this.lsticonnode[a].spr) ? this.lsticonnode[a].spr.setOpacity(0) : this.lsticonnode[a].spr.setOpacity(d)
        }
    },
    clearTop: function() {
        for (var a = 0; a < this.lsttopani.length; ++a) {
            var b = this.lsttopani[a];
            b.node.stopAllActions();
            b.node.getParent().removeChild(b.node)
        }
        this.lsttopani = [];
        for (a = 0; a < this.lsttopnode.length; ++a) this.lsttopnode[a].setVisible(!1), this.lsticonnode[a].spr.setVisible(!0)
    },
    showTop: function(a) {
        if (void 0 != this.layTopWheel) {
            var b = Math.floor(this.lsttopnode.length /
                2) + a;
            this.lsticonnode[b].spr.setVisible(!1);
            a = this.lsttopnode[b];
            var c = this.lsticonnode[b].idata,
                b = this.lsticon[c];
            void 0 != b && 0 != b && (b = cc.spriteFrameCache.getSpriteFrame(b), this.bShowTopIcon || (b = cc.spriteFrameCache.getSpriteFrame("empty.png")), a.setSpriteFrame(b), void 0 != this.lsticonani && (c = this.lsticonani[c], void 0 != c && 0 != c && (c = ccs.load(c), a.addChild(c.node, 1), b = b.getOriginalSizeInPixels(), c.node.setPosition(b.width / 2, b.height / 2), c.node.runAction(c.action), c.action.gotoFrameAndPlay(0, c.action.getDuration(), !0), this.lsttopani.push(c))));
            a.setVisible(!0)
        }
    },
    showTopIcon: function(a) {
        if (void 0 != this.layTopWheel) {
            var b = Math.floor(this.lsttopnode.length / 2) + a;
            this.lsticonnode[b].spr.setVisible(!1);
            a = this.lsttopnode[b];
            a.isVisible() || (b = this.lsticon[this.lsticonnode[b].idata], void 0 != b && 0 != b && (b = cc.spriteFrameCache.getSpriteFrame(b), a.setSpriteFrame(b)), a.setVisible(!0))
        }
    },
    getTopSprite: function(a) {
        return void 0 == this.layTopWheel ? void 0 : this.lsttopnode[Math.floor(this.lsttopnode.length / 2) + a]
    },
    chgIcon: function(a,
        b, c, d) {
        0 > a || (void 0 != this.lsticon && a < this.lsticon.length && (this.lsticon[a] = b), void 0 != this.lstbicon && a < this.lstbicon.length && (this.lstbicon[a] = c), void 0 != this.lsticonani && a < this.lsticonani.length && (this.lsticonani[a] = d))
    },
    setLightAni: function(a, b, c) {
        this.lightaniname = a;
        this.lighttopname = b;
        this.lightsoundname = c
    },
    showLightAni: function(a) {
        if (void 0 != this.lightaniname || void 0 != this.lighttopname)
            if (this.bRun || !a) a ? (void 0 == this.LightAni && void 0 != this.lightaniname && (this.LightAni = ccs.load(this.lightaniname),
                this.layWheel.addChild(this.LightAni.node, 0), this.LightAni.node.runAction(this.LightAni.action), this.LightAni.action.gotoFrameAndPlay(0, this.LightAni.action.getDuration(), !0)), void 0 == this.LightTop && void 0 != this.lighttopname && (this.LightTop = ccs.load(this.lighttopname), this.layTopWheel.addChild(this.LightTop.node, 2), this.LightTop.node.runAction(this.LightTop.action), this.LightTop.action.gotoFrameAndPlay(0, this.LightTop.action.getDuration(), !0)), void 0 != this.lightsoundname && cc.audioEngine.playEffect(this.lightsoundname, !1)) : (void 0 != this.LightAni && (this.LightAni.node.stopAllActions(), this.layWheel.removeChild(this.LightAni.node), this.LightAni = void 0), void 0 != this.LightTop && (this.LightTop.node.stopAllActions(), this.layTopWheel.removeChild(this.LightTop.node), this.LightTop = void 0))
    },
    hasIcon: function(a, b, c) {
        b > c && (c = b = c);
        c = Math.floor(this.lsttopnode.length / 2) + c;
        for (b = Math.floor(this.lsttopnode.length / 2) + b; b <= c; ++b)
            if (this.lsticonnode[b].idata == a) return !0;
        return !1
    },
    setSpringBack: function(a, b) {
        this.SpringBackDis = a;
        this.SpringBackScale =
            b
    },
    setAlphaArea: function(a, b) {
        if (!(b <= a)) {
            this.iBeginDis = a;
            this.iEndDis = b;
            for (var c = 0; c < this.lsticonnode.length; ++c) this.fixAlpha(this.lsticonnode[c].spr)
        }
    },
    getAlpha: function(a) {
        if (void 0 == this.iBeginDis || void 0 == this.iEndDis) return 255;
        a = a.getPositionY();
        var b = this.cby - a;
        a > this.cby && (b = a - this.cby);
        return b <= this.iBeginDis ? 255 : b >= this.iEndDis ? 0 : Math.floor((this.iEndDis - b) / (this.iEndDis - this.iBeginDis) * 255)
    },
    fixAlpha: function(a) {
        if (void 0 != this.iBeginDis && void 0 != this.iEndDis) {
            var b = this.getAlpha(a);
            a.setOpacity(b);
            b = a.getColor();
            a.setColor(b)
        }
    }
});
var CMDID_KEEPALIVE = "keepalive",
    CMDID_LOGIN = "login",
    CMDID_REG = "reg",
    CMDID_TOKENLOGIN = "tokenlogin",
    CMDID_PLOGIN = "plogin",
    CMDID_FLBLOGIN = "flblogin",
    CMDID_GUESTLOGIN = "guestlogin",
    CMDID_COMEINGAME = "comeingame",
    CMDID_SPIN = "spin",
    CMDID_LEFTGAME = "leftgame",
    CMDID_COMEINGAMEEX = "comeingameex",
    CMDID_FLBSPIN = "flbspin",
    CMDID_COMEINGAME2 = "comeingame2",
    CMDID_SPIN2 = "spin2",
    CMDID_LEFTGAME2 = "leftgame2",
    CMDID_GAMECTRL2 = "gamectrl2",
    CMDID_COMEINGAME3 = "comeingame3",
    CMDID_GAMECTRL3 = "gamectrl3",
    CMDID_SGAMECTRL = "sgamectrl";
var MSGID_NOTICE = "notice",
    MSGID_CMDRET = "cmdret",
    MSGID_KEEPALIVERET = "keepaliveret",
    MSGID_USERBASEINFO = "userbaseinfo",
    MSGID_GAMELIST = "gamelist",
    MSGID_ADINFO = "adinfo",
    MSGID_GENINIT = "geninit",
    MSGID_SYMBOLSTRIPES = "symbolstripes",
    MSGID_PAYTABLES = "paytables",
    MSGID_SPINRESULT = "spinresult",
    MSGID_GAMEINFO = "gameinfo",
    MSGID_GAMEUSERINFO = "gameuserinfo",
    MSGID_GAMEMODULEINFO = "gamemoduleinfo",
    MSGID_SGAMEINFO = "sgameinfo";
var MainClient = WSClient.extend({
    ctor: function() {
        this._super();
        this.noSpinTimerID = this.spinTimerID = 0;
        this.guesttoken = void 0;
        this.curSpinID = this.curBetID = -1;
        this.curSGame = "";
        this.isapi2 = !1;
        this.lstCtrl = [];
        this.lastCtrl = void 0
    },
    __procCtrlList: function(a) {
        var b = this,
            c = void 0;
        if (a) void 0 != b.lastCtrl && (c = b.lastCtrl);
        else if (void 0 != b.lastCtrl) return;
        void 0 == c && 0 < b.lstCtrl.length && (c = b.lstCtrl[0], b.lstCtrl.shift(), b.lastCtrl = c);
        void 0 != c && (b.clearSpinTimer(), b.spinTimerID = setTimeout(function() {
                b.closeWS()
            },
            15E3), b.clearNoSpinTimer(), MainClient.singleton.mapCmd[CMDID_GAMECTRL3].send(c.gameid, c.ctrlname, c.ctrlparam, c.callback))
    },
    __onCtrlRet: function(a) {
        a && (this.lastCtrl = void 0)
    },
    __addGameCtrl: function(a, b, c, d) {
        this.lstCtrl.push({
            gameid: a,
            ctrlname: b,
            ctrlparam: c,
            callback: d
        });
        this.__procCtrlList(!1)
    },
    onOpen: function(a) {
        this._super(a);
        MainClient.singleton.autologin(function(a) {
            if (a) {
                var c = GameMgr.singleton.getCurGameID();
                MainClient.singleton.comeingame(c, function(a) {
                    if (a) {
                        if (0 < GameMgr.singleton.myInfo.gameid) GameMgr.singleton.onReconnnect();
                        GameMgr.singleton.myInfo.gameid = c;
                        void 0 == GameMgr.singleton.curGameLayer && cc.director.runScene(new GameScene)
                    }
                })
            }
        })
    },
    onError: function(a) {
        this._super(a);
        GameMgr.singleton.onDisconnect()
    },
    onKeepalive: function() {
        MainClient.singleton.mapCmd[CMDID_KEEPALIVE].send()
    },
    sendex: function(a, b, c) {
        void 0 == c && (c = !0);
        this.send(a, function(a) {
            void 0 != b && b(a)
        })
    },
    autologin: function(a) {
        g_isguest ? void 0 == g_guestuname || "" == g_guestuname ? this.guestlogin(void 0, a) : this.guestlogin(g_guestuname, a) : g_isflblogin ? this.flblogin(g_flblogintoken,
            a) : this.plogin(g_pname, g_uname, a)
    },
    plogin: function(a, b, c) {
        MainClient.singleton.mapCmd[CMDID_PLOGIN].send(a, b, c)
    },
    login: function(a, b, c) {
        MainClient.singleton.mapCmd[CMDID_LOGIN].send(a, b, c)
    },
    tokenlogin: function(a, b) {
        MainClient.singleton.mapCmd[CMDID_TOKENLOGIN].send(a, b)
    },
    reg: function(a, b, c, d) {
        MainClient.singleton.mapCmd[CMDID_REG].send(a, b, c, d)
    },
    flblogin: function(a, b) {
        MainClient.singleton.mapCmd[CMDID_FLBLOGIN].send(a, b)
    },
    comeingame: function(a, b) {
        (this.isapi2 = void 0 != GAMEAPI_ISAPI2 && GAMEAPI_ISAPI2 ?
            !0 : !1) ? this.comeingame3(a, b): 0 < GameMgr.singleton.myInfo.gameid ? MainClient.singleton.mapCmd[CMDID_COMEINGAMEEX].send(a, b) : MainClient.singleton.mapCmd[CMDID_COMEINGAME].send(a, b)
    },
    leftgame: function(a, b) {
        MainClient.singleton.mapCmd[CMDID_LEFTGAME].send(a, b)
    },
    clearSpinTimer: function() {
        0 < this.spinTimerID && (clearTimeout(this.spinTimerID), this.spinTimerID = 0)
    },
    clearNoSpinTimer: function() {
        0 < this.noSpinTimerID && (clearTimeout(this.noSpinTimerID), this.noSpinTimerID = 0)
    },
    startNoSpinTimer: function() {
        this.clearNoSpinTimer();
        this.noSpinTimerID = setTimeout(function() {
            GameMgr.singleton.onError(1)
        }, 6E5)
    },
    newspin: function(a, b, c, d, e, f) {
        this.spin(a, b, c, d, f)
    },
    spin: function(a, b, c, d, e) {
        if (this.isapi2) 0 < g_spinstate ? this.gamectrl3(a, "spin", {
            bet: b,
            times: c,
            lines: d,
            state: g_spinstate
        }, e) : this.gamectrl3(a, "spin", {
            bet: b,
            times: c,
            lines: d
        }, e);
        else {
            var f = this;
            f.clearSpinTimer();
            f.spinTimerID = setTimeout(function() {
                f.closeWS()
            }, 15E3);
            f.clearNoSpinTimer();
            g_isflblogin ? MainClient.singleton.mapCmd[CMDID_FLBSPIN].send(a, b, c, d, e) : MainClient.singleton.mapCmd[CMDID_SPIN].send(a,
                b, c, d, e);
            GameMgr.singleton.myInfo.isspin = !0;
            GameMgr.singleton.myInfo.bet = b;
            GameMgr.singleton.myInfo.times = c;
            GameMgr.singleton.myInfo.lines = d
        }
    },
    guestlogin: function(a, b) {
        MainClient.singleton.mapCmd[CMDID_GUESTLOGIN].send(this.guesttoken, a, b)
    },
    sgamectrl: function(a, b, c, d, e) {
        MainClient.singleton.mapCmd[CMDID_SGAMECTRL].send(a, b, c, d, e)
    },
    comeingame2: function(a, b) {
        0 < GameMgr.singleton.myInfo.gameid ? MainClient.singleton.mapCmd[CMDID_COMEINGAME2].send(a, !0, b) : MainClient.singleton.mapCmd[CMDID_COMEINGAME2].send(a, !1, b)
    },
    leftgame2: function(a, b) {
        MainClient.singleton.mapCmd[CMDID_LEFTGAME2].send(a, b)
    },
    spin2: function(a, b, c, d, e) {
        var f = this;
        f.clearSpinTimer();
        f.spinTimerID = setTimeout(function() {
            f.closeWS()
        }, 15E3);
        f.clearNoSpinTimer();
        MainClient.singleton.mapCmd[CMDID_SPIN2].send(a, b, c, d, e);
        GameMgr.singleton.myInfo.isspin = !0;
        GameMgr.singleton.myInfo.bet = b;
        GameMgr.singleton.myInfo.times = c;
        GameMgr.singleton.myInfo.lines = d
    },
    gamectrl2: function(a, b, c, d) {
        this.gamectrl3(a, b, c, d)
    },
    comeingame3: function(a, b) {
        0 < GameMgr.singleton.myInfo.gameid ?
            MainClient.singleton.mapCmd[CMDID_COMEINGAME3].send(a, !0, b) : MainClient.singleton.mapCmd[CMDID_COMEINGAME3].send(a, !1, b)
    },
    gamectrl3: function(a, b, c, d) {
        this.__addGameCtrl(a, b, c, d)
    }
});
MainClient.singleton = new MainClient;
var WSCCmd_KeepAlive = WSClientCmd.extend({
    cmdid: CMDID_KEEPALIVE,
    send: function() {
        this.wsc.sendex({
            cmdid: this.cmdid
        }, void 0, !1)
    }
});
MainClient.singleton.addCmd(new WSCCmd_KeepAlive);
var WSCMsg_KeepAliveRet = WSClientMsg.extend({
    msgid: MSGID_KEEPALIVERET,
    onMsg: function(a) {
        cc.log("msgobj")
    }
});
MainClient.singleton.addMsg(new WSCMsg_KeepAliveRet);
var WSCMsg_CmdRet = WSClientMsg.extend({
    msgid: MSGID_CMDRET,
    onMsg: function(a) {
        GameMgr.singleton.onCmdRet(a.cmdid);
        a.cmdid == CMDID_TOKENLOGIN && (a.isok || SceneMgr.singleton.initLogin());
        if (a.cmdid == CMDID_SPIN || a.cmdid == CMDID_FLBSPIN || a.cmdid == CMDID_SPIN2 || a.cmdid == CMDID_GAMECTRL2 || a.cmdid == CMDID_GAMECTRL3) GameMgr.singleton.myInfo.isspin = !1, MainClient.singleton.clearSpinTimer(), MainClient.singleton.startNoSpinTimer();
        a.cmdid != CMDID_COMEINGAME && a.cmdid != CMDID_COMEINGAMEEX && a.cmdid != CMDID_COMEINGAME2 && a.cmdid !=
            CMDID_COMEINGAME3 || MainClient.singleton.startNoSpinTimer();
        a.cmdid == CMDID_GAMECTRL3 && MainClient.singleton.__onCtrlRet(a.isok);
        MainClient.singleton.onCmdCallback(a.cmdid, a.isok)
    }
});
MainClient.singleton.addMsg(new WSCMsg_CmdRet);
var WSCMsg_Notice = WSClientMsg.extend({
    msgid: MSGID_NOTICE,
    onMsg: function(a) {
        cc.log("msgobj: " + a.info);
        GameMgr.singleton.onError(0, a.info)
    }
});
MainClient.singleton.addMsg(new WSCMsg_Notice);
var WSCCmd_Login = WSClientCmd.extend({
    cmdid: CMDID_LOGIN,
    send: function(a, b, c) {
        this.wsc.sendex({
            cmdid: this.cmdid,
            uname: a,
            passwd: b
        }, c)
    }
});
MainClient.singleton.addCmd(new WSCCmd_Login);
var WSCCmd_PLogin = WSClientCmd.extend({
    cmdid: CMDID_PLOGIN,
    send: function(a, b, c) {
        this.wsc.sendex({
            cmdid: this.cmdid,
            uname: b,
            pname: a
        }, c)
    }
});
MainClient.singleton.addCmd(new WSCCmd_PLogin);
var WSCCmd_FLBLogin = WSClientCmd.extend({
    cmdid: CMDID_FLBLOGIN,
    send: function(a, b) {
        this.wsc.sendex({
            cmdid: this.cmdid,
            token: a
        }, b)
    }
});
MainClient.singleton.addCmd(new WSCCmd_FLBLogin);
var WSCCmd_Reg = WSClientCmd.extend({
    cmdid: CMDID_REG,
    send: function(a, b, c, d) {
        this.wsc.sendex({
            cmdid: this.cmdid,
            uname: a,
            keycode: c,
            passwd: b
        }, d)
    }
});
MainClient.singleton.addCmd(new WSCCmd_Reg);
var WSCCmd_TokenLogin = WSClientCmd.extend({
    cmdid: CMDID_TOKENLOGIN,
    send: function(a, b) {
        this.wsc.sendex({
            cmdid: this.cmdid,
            token: a
        }, b, !1)
    }
});
MainClient.singleton.addCmd(new WSCCmd_TokenLogin);
var WSCCmd_GuestLogin = WSClientCmd.extend({
    cmdid: CMDID_GUESTLOGIN,
    send: function(a, b, c) {
        var d = {
            cmdid: this.cmdid
        };
        void 0 != a && (d.token = a);
        void 0 != b && (d.guestuname = b);
        this.wsc.sendex(d, c)
    }
});
MainClient.singleton.addCmd(new WSCCmd_GuestLogin);
var WSCMsg_UserBaseInfo = WSClientMsg.extend({
    msgid: MSGID_USERBASEINFO,
    onMsg: function(a) {
        cc.log("onMsg " + this.msgid + ":" + JSON.stringify(a));
        GameMgr.singleton.onMyMoney(a.userbaseinfo.gold);
        GameMgr.singleton.myInfo.uid = a.userbaseinfo.uid;
        GameMgr.singleton.myInfo.spinnums = a.userbaseinfo.spinnums;
        GameMgr.singleton.myInfo.nickname = a.userbaseinfo.nickname;
        if (0 < GameMgr.singleton.lastSpinID && GameMgr.singleton.lastSpinID < GameMgr.singleton.myInfo.spinnums) GameMgr.singleton.onError(2);
        g_isguest && (MainClient.singleton.guesttoken =
            a.token)
    }
});
MainClient.singleton.addMsg(new WSCMsg_UserBaseInfo);
var WSCMsg_GameList = WSClientMsg.extend({
    msgid: MSGID_GAMELIST,
    onMsg: function(a) {
        cc.log("onMsg " + this.msgid + ":" + JSON.stringify(a))
    }
});
MainClient.singleton.addMsg(new WSCMsg_GameList);
var WSCMsg_AdInfo = WSClientMsg.extend({
    msgid: MSGID_ADINFO,
    onMsg: function(a) {
        cc.log("onMsg " + this.msgid + ":" + JSON.stringify(a))
    }
});
MainClient.singleton.addMsg(new WSCMsg_AdInfo);
var WSCCmd_ComeInGame = WSClientCmd.extend({
    cmdid: CMDID_COMEINGAME,
    send: function(a, b) {
        this.wsc.sendex({
            cmdid: this.cmdid,
            gameid: a
        }, function(a) {
            void 0 != b && b(a)
        })
    }
});
MainClient.singleton.addCmd(new WSCCmd_ComeInGame);
var WSCCmd_ComeInGameEx = WSClientCmd.extend({
    cmdid: CMDID_COMEINGAMEEX,
    send: function(a, b) {
        this.wsc.sendex({
            cmdid: this.cmdid,
            gameid: a
        }, function(a) {
            void 0 != b && b(a)
        })
    }
});
MainClient.singleton.addCmd(new WSCCmd_ComeInGameEx);
var WSCMsg_SymbolStripes = WSClientMsg.extend({
    msgid: MSGID_SYMBOLSTRIPES,
    onMsg: function(a) {
        cc.log("onMsg " + this.msgid + ":" + JSON.stringify(a));
        var b = "normal";
        a.hasOwnProperty("wheelname") && (b = a.wheelname);
        GameMgr.singleton.onSymbolStripes(a.symbolstripes.Stripes, b)
    }
});
MainClient.singleton.addMsg(new WSCMsg_SymbolStripes);
var WSCMsg_PayTables = WSClientMsg.extend({
    msgid: MSGID_PAYTABLES,
    onMsg: function(a) {}
});
MainClient.singleton.addMsg(new WSCMsg_PayTables);
var WSCMsg_Geninit = WSClientMsg.extend({
    msgid: MSGID_GENINIT,
    onMsg: function(a) {
        cc.log("onMsg " + this.msgid + ":" + JSON.stringify(a));
        GameMgr.singleton.onGenInit(a.geninit.ReelResults)
    }
});
MainClient.singleton.addMsg(new WSCMsg_Geninit);
var WSCCmd_Spin = WSClientCmd.extend({
    cmdid: CMDID_SPIN,
    send: function(a, b, c, d, e) {
        a = {
            cmdid: this.cmdid,
            gameid: a,
            spinindex: MainClient.singleton.curSpinID,
            bet: b,
            times: c,
            lines: d
        };
        0 < g_spinstate && (a.state = g_spinstate);
        GameMgr.singleton.onSendCmd(a, e);
        this.wsc.sendex(a, e, !1)
    }
});
MainClient.singleton.addCmd(new WSCCmd_Spin);
var WSCCmd_FLBSpin = WSClientCmd.extend({
    cmdid: CMDID_FLBSPIN,
    send: function(a, b, c, d, e) {
        a = {
            cmdid: this.cmdid,
            gameid: a,
            spinindex: MainClient.singleton.curSpinID,
            bet: b,
            times: c,
            lines: d
        };
        0 < g_spinstate && (a.state = g_spinstate);
        GameMgr.singleton.onSendCmd(a, e);
        this.wsc.sendex(a, e, !1)
    }
});
MainClient.singleton.addCmd(new WSCCmd_FLBSpin);
WSCMsg_Geninit = WSClientMsg.extend({
    msgid: MSGID_SPINRESULT,
    onMsg: function(a) {
        cc.log("onMsg " + this.msgid + ":" + JSON.stringify(a));
        a = a.spinresult;
        var b = a.TotalWin,
            c = a.ReelResults,
            d = a.WinResults,
            e = 1;
        void 0 != a.WinMultiple && (e = a.WinMultiple);
        GameMgr.singleton.onSpinResult(b, c, d, e)
    }
});
MainClient.singleton.addMsg(new WSCMsg_Geninit);
var WSCCmd_LeftGame = WSClientCmd.extend({
    cmdid: CMDID_LEFTGAME,
    send: function(a, b) {
        this.wsc.sendex({
            cmdid: this.cmdid,
            gameid: a
        }, void 0, !1)
    }
});
MainClient.singleton.addCmd(new WSCCmd_LeftGame);
var WSCCmd_SGameCtrl = WSClientCmd.extend({
    cmdid: CMDID_SGAMECTRL,
    send: function(a, b, c, d, e) {
        a = {
            cmdid: this.cmdid,
            spinid: MainClient.singleton.curSpinID,
            gameid: a,
            sgame: b,
            ctrl: c,
            param0: d
        };
        GameMgr.singleton.onSendCmd(a, e);
        this.wsc.sendex(a, function(a) {
            void 0 != e && e(a)
        })
    }
});
MainClient.singleton.addCmd(new WSCCmd_SGameCtrl);
var WSCMsg_SGameInfo = WSClientMsg.extend({
    msgid: MSGID_SGAMEINFO,
    onMsg: function(a) {
        cc.log("onMsg " + this.msgid + ":" + JSON.stringify(a));
        GameMgr.singleton.onSGameInfo(a)
    }
});
MainClient.singleton.addMsg(new WSCMsg_SGameInfo);
var WSCMsg_GameInfo = WSClientMsg.extend({
    msgid: MSGID_GAMEINFO,
    onMsg: function(a) {
        cc.log("onMsg " + this.msgid + ":" + JSON.stringify(a));
        MainClient.singleton.curSpinID = a.spinid;
        a.hasOwnProperty("gamescene") && (MainClient.singleton.curSGame = a.gamescene, MainClient.singleton.curBetID = a.betid);
        GameMgr.singleton.onGameInfo(a)
    }
});
MainClient.singleton.addMsg(new WSCMsg_GameInfo);
var NarutoGameLayer = cc.Layer.extend({
    sprite: null,
    ctor: function() {
        this._super();
        var a = ccs.load(res.NarutoGameLayer_json);
        this.addChild(a.node);
        this.GameLayer = a;
        var b = ccui.helper.seekWidgetByName(a.node, "nodBackAni"),
            c = ccs.load(res.NarutoGameBackAni_json);
        b.addChild(c.node);
        c.node.runAction(c.action);
        c.action.gotoFrameAndPlay(0, c.action.getDuration(), !0);
        this.lstSymbol = {
            WW: 0,
            C1: 1,
            M1: 2,
            M2: 3,
            M3: 4,
            M4: 5,
            M5: 6,
            M6: 7,
            M7: 8,
            M8: 9,
            M9: 10,
            MT: 11,
            ME: 12
        };
        this.lstWheelDatas = [
            [8, 11, 10, 9, 6, 7, 10, 11, 9, 8, 5, 11, 10, 9, 7, 11, 6,
                10, 7, 9, 11, 5, 8, 6, 10, 4, 9, 7, 1, 8, 11, 9, 7, 5, 3, 11, 8, 6, 10, 4, 5, 8, 9, 11, 7, 3, 10, 6, 4, 2
            ],
            [11, 10, 9, 11, 7, 10, 8, 11, 10, 9, 11, 3, 7, 10, 11, 9, 6, 8, 4, 5, 6, 1, 7, 11, 4, 9, 0, 10, 8, 7, 6, 11, 2, 9, 1, 3, 8, 5, 10, 0, 8, 11, 6, 2, 3, 4, 7, 10, 9, 5],
            [8, 11, 5, 7, 10, 11, 6, 9, 2, 11, 9, 10, 1, 7, 8, 3, 11, 10, 4, 9, 6, 8, 10, 5, 6, 1, 7, 11, 4, 9, 0, 10, 8, 7, 6, 11, 2, 9, 1, 3, 8, 5, 10, 0, 9, 7, 2, 10, 3, 5, 4, 11, 8, 6],
            [11, 10, 9, 11, 7, 10, 8, 11, 10, 9, 11, 3, 7, 10, 11, 9, 6, 8, 4, 5, 6, 1, 7, 11, 4, 9, 0, 10, 8, 7, 6, 11, 2, 9, 1, 3, 8, 5, 10, 0, 9, 7, 11, 8, 4, 10, 2, 5, 6, 3],
            [8, 11, 10, 9, 6, 7, 10, 11, 9, 8, 5, 11, 10, 9, 7, 11, 6, 10, 7, 9, 11, 5, 8, 6, 10, 4, 9, 7, 1,
                8, 11, 9, 7, 5, 3, 11, 8, 6, 4, 10, 7, 2, 9, 3, 6, 5, 4, 11, 10, 8
            ]
        ];
        this.lstWinSymbol = {
            WW: 0,
            C1: 1,
            M1: 2,
            M2: 3,
            M3: 4,
            M4: 5,
            M5: 6,
            M6: 7,
            M7: 8,
            M8: 9,
            M9: 10,
            MT: 11,
            ME: 12
        };
        var c = "narutoww.png narutoc1.png narutom1.png narutom2.png narutom3.png narutom4.png narutom5.png narutom6.png narutom7.png narutom8.png narutom9.png narutomt.png narutome.png".split(" "),
            d = "narutobww.png narutobc1.png narutobm1.png narutobm2.png narutobm3.png narutobm4.png narutobm5.png narutobm6.png narutobm7.png narutobm8.png narutobm9.png narutobmt.png narutobme.png".split(" "),
            e = [res.NarutoRunAni0_json, res.NarutoRunAni1_json, res.NarutoRunAni2_json, res.NarutoRunAni3_json, res.NarutoRunAni4_json, res.NarutoRunAni5_json, res.NarutoRunAni6_json, res.NarutoRunAni7_json, res.NarutoRunAni8_json, res.NarutoRunAni9_json, res.NarutoRunAni10_json, res.NarutoRunAni11_json, res.NarutoRunAni12_json];
        this.lstwheel = [];
        for (b = 0; 5 > b; ++b) {
            var f = ccui.helper.seekWidgetByName(a.node, "layWheel" + (b + 1)),
                g = ccui.helper.seekWidgetByName(a.node, "layTopWheel" + (b + 1)),
                f = new Wheel(f, c, d, 177, 170, 156, this.lstWheelDatas[b],
                    1, g, e);
            f.setLogicNum(3);
            f.setSound(res.NarutoRunWheel_mp3, res.NarutoStopWheel_mp3, this.lstSymbol.C1, res.NarutoC1Sound_mp3);
            f.setResultColor(64, 64, 64, 128);
            f.setShowTopIcon(!1);
            f.setLightAni(void 0, res.NarutoLightAni1_json, res.NarutoFastWheel_mp3);
            this.lstwheel.push(f)
        }
        this.SpinResult = [0, 0, 0, 0, 0];
        this.bQuickStop = this.bCanStop = this.bRun = !1;
        this.bQuickStopTime = 0;
        this.WaitStopTime = -1;
        this.ErrorLayer = this.DisconnectLayer = void 0;
        b = ccui.helper.seekWidgetByName(a.node, "btnRun");
        b.addTouchEventListener(this.onTouchRun,
            this);
        this.btnRun = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnStop");
        b.addTouchEventListener(this.onTouchStop, this);
        this.btnStop = b;
        this.btnStop.setVisible(!1);
        b = ccui.helper.seekWidgetByName(a.node, "btnAll");
        b.addTouchEventListener(this.onTouchAll, this);
        this.btnAll = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnAuto");
        b.addTouchEventListener(this.onTouchAuto, this);
        this.btnAuto = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnAutoStop");
        b.addTouchEventListener(this.onTouchAutoStop, this);
        this.btnAutoStop = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnLeft1");
        b.addTouchEventListener(this.onTouchLeft1, this);
        this.btnLeft1 = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnRight1");
        b.addTouchEventListener(this.onTouchRight1, this);
        this.btnRight1 = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnLeft2");
        b.addTouchEventListener(this.onTouchLeft2, this);
        this.btnLeft2 = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnRight2");
        b.addTouchEventListener(this.onTouchRight2, this);
        this.btnRight2 = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnDouble");
        b.addTouchEventListener(this.onTouchDouble, this);
        this.btnDouble = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnOpenSound");
        b.addTouchEventListener(this.onTouchOpenSound, this);
        this.btnOpenSound = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnCloseSound");
        b.addTouchEventListener(this.onTouchCloseSound, this);
        this.btnCloseSound = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnOpenEffect");
        b.addTouchEventListener(this.onTouchOpenEffect, this);
        this.btnOpenEffect = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnCloseEffect");
        b.addTouchEventListener(this.onTouchCloseEffect, this);
        this.btnCloseEffect = b;
        b = ccui.helper.seekWidgetByName(a.node, "btnSetup");
        b.addTouchEventListener(this.onTouchSetup, this);
        this.btnSetup = b;
        this.btnSetup.setVisible(0 == g_clienttype);
        b = ccui.helper.seekWidgetByName(a.node, "btnClose");
        b.addTouchEventListener(this.onTouchClose, this);
        this.btnClose = b;
        this.btnClose.setVisible(0 != g_clienttype);
        b = ccui.helper.seekWidgetByName(a.node, "btnHelp");
        b.addTouchEventListener(this.onTouchHelp, this);
        this.btnHelp = b;
        this.lstBtnBlue = [];
        this.lstBtnLBlue = [];
        this.lstBtnGBlue = [];
        for (b = 1; 25 >= b; ++b) c = ccui.helper.seekWidgetByName(a.node, "btnGBlue" + b), c.addTouchEventListener(this.onTouchBtnLine, this), d = ccui.helper.seekWidgetByName(a.node, "btnLBlue" + b), d.addTouchEventListener(this.onTouchBtnLine, this), d.setVisible(!1), e = ccui.helper.seekWidgetByName(a.node, "btnBlue" + b), e.addTouchEventListener(this.onTouchBtnLine, this), this.lstBtnBlue.push(c), this.lstBtnLBlue.push(d), this.lstBtnGBlue.push(e);
        b = ccui.helper.seekWidgetByName(a.node, "textWin");
        b.setString("0");
        this.textWin = b;
        b = ccui.helper.seekWidgetByName(a.node, "textAllBet");
        b.setString("0");
        this.textAllBet = b;
        b = ccui.helper.seekWidgetByName(a.node, "textBet");
        b.setString("0");
        this.textBet = b;
        this.BetX = b.getPositionX();
        b = ccui.helper.seekWidgetByName(a.node, "textLine");
        b.setString("1");
        this.textLine = b;
        this.LineX = b.getPositionX();
        b = ccui.helper.seekWidgetByName(a.node, "textMoney");
        b.setString("0");
        this.textMoney = b;
        b = ccui.helper.seekWidgetByName(a.node, "textAutoNum");
        b.setString("000");
        b.setVisible(!1);
        this.textAutoNum = b;
        b = ccui.helper.seekWidgetByName(a.node, "textName");
        b.getFontName();
        b.setFontName("Microsoft YaHei");
        b.setString(GameMgr.singleton.myInfo.nickname);
        this.textName = b;
        b = a.node.getChildByName("sprAutoNum");
        b.setVisible(!1);
        this.sprAutoNum = b;
        this.lstSprLine = [];
        this.ShowLineTime = 0;
        this.ShowLineFunc = void 0;
        for (b = 1; 25 >= b; ++b) c = a.node.getChildByName("nodeLine" + b), c.setVisible(!1), this.lstSprLine.push(c);
        this.iNewMoney = this.iMyMoney = void 0;
        this.iBet = this.iShowMoney = 0;
        this.iLine = 25;
        this.iWin =
            0;
        this.lstBet = [1, 2, 5, 10, 20, 50, 100, 160, 500, 1E3, 1600, 2E3];
        this.bAutoRun = !1;
        this.DisRunTime = this.WaitAutoTime = this.iAutoNum = 0;
        this.bShowResult = !1;
        this.ShowResultTime = this.iShowResultIndex = 0;
        this.bCanOpenBox = this.bCanDouble = this.bGameInfoDouble = !1;
        this.WaitOpenBoxTime = 0;
        this.lstWinAni = [res.NarutoWinAni1_json, res.NarutoWinAni2_json, res.NarutoWinAni3_json, res.NarutoWinAni4_json];
        this.WinAni2 = this.WinAni = void 0;
        this.lstWaitWinAni = [];
        b = a.node.getChildByName("nodBtnAni1");
        c = ccs.load(res.NarutoBtnAni1_json);
        b.addChild(c.node);
        c.node.runAction(c.action);
        c.action.gotoFrameAndPlay(0, c.action.getDuration(), !0);
        this.nodBtnAni1 = b;
        b = a.node.getChildByName("nodBtnAni2");
        c = ccs.load(res.NarutoBtnAni2_json);
        b.addChild(c.node);
        c.node.runAction(c.action);
        c.action.gotoFrameAndPlay(0, c.action.getDuration(), !0);
        this.nodBtnAni2 = b;
        b = a.node.getChildByName("nodBtnAni3");
        c = ccs.load(res.NarutoBtnAni3_json);
        b.addChild(c.node);
        c.node.runAction(c.action);
        c.action.gotoFrameAndPlay(0, c.action.getDuration(), !0);
        this.nodBtnAni3 =
            b;
        this.sprDarts = a.node.getChildByName("sprDarts");
        this.BtnScale = [1, 1.05];
        this.BtnScaleTime = [1, 0.5];
        this.BtnAniTime = 0;
        this.lstDartsNode = [];
        for (b = 0; 5 > b; ++b) c = a.node.getChildByName("nodDartsAni" + (b + 1)), this.lstDartsNode.push(c);
        this.lstWaitDartsAni = [];
        this.lstPlayDartsAni = [];
        b = a.node.getChildByName("sprFreeRunBack");
        b.setVisible(!1);
        this.sprFreeRunBack = b;
        this.textFreeNum = this.sprFreeRunBack.getChildByName("textFreeNum");
        this.textFreeMul = this.sprFreeRunBack.getChildByName("textFreeMul");
        this.textFreeAll =
            this.sprFreeRunBack.getChildByName("textFreeAll");
        this.nodFreeLogo = a.node.getChildByName("nodFreeLogo");
        this.FreeLogoAni = void 0;
        this.bFreeGame = !1;
        this.iFreeNums = -1;
        this.iFreeMul = this.iNewFreeNums = 0;
        this.iFreeAll = -1;
        this.iFreeBeginWin = this.iNewFreeAll = 0;
        this.lstMusic = [res.NarutoMusci1_mp3, res.NarutoMusci2_mp3, res.NarutoMusci3_mp3, res.NarutoMusci4_mp3];
        this.lstWinEffect = [res.NarutoEffWin1_mp3, res.NarutoEffWin2_mp3, res.NarutoEffWin3_mp3, res.NarutoEffWin4_mp3];
        this.lstWinEffectTime = [4, 4, 4, 4];
        this.lstWaitMusic = [];
        this.lstWaitWinEfect = [];
        this.bPlayFreeMusic = !1;
        this.WinEffectTime = 0;
        this.bInitMusic = this.bStopMusic = this.bPlayKO = !1;
        this.SoundValue = 1;
        cc.sys.isMobile ? (this.setPlaySound(!1), a = new NarutoSoundTipsLayer(this), this.addChild(a, 1)) : this.setPlaySound(!0);
        this.setPlayEffect(!0);
        this.restoreUserSetup();
        this.refreshInfo();
        this.scheduleUpdate();
        a = new NarutoHelpLayer1(this);
        this.addChild(a, 2);
        this.helpLayer1 = a;
        a = new NarutoHelpLayer2(this);
        this.addChild(a, 2);
        this.helpLayer2 = a;
        a = new NarutoHelpLayer3(this);
        this.addChild(a,
            2);
        this.helpLayer3 = a;
        a = new NarutoHelpLayer4(this);
        this.addChild(a, 2);
        this.helpLayer4 = a;
        this.showHelp(0);
        return !0
    },
    restoreUserSetup: function() {
        var a = cc.sys.localStorage.getItem("narutosoundopen"),
            b = cc.sys.localStorage.getItem("narutoeffectopen");
        void 0 != a && (a = parseInt(a), cc.sys.isMobile && 1 == a || this.setPlaySound(1 == a));
        void 0 != b && (b = parseInt(b), this.setPlayEffect(1 == b));
        a = cc.sys.localStorage.getItem("narutouserbet");
        b = cc.sys.localStorage.getItem("narutouserline");
        void 0 != a && (a = parseInt(a), 0 > a && (a = 0),
            a >= this.lstBet.length && (a = this.lstBet.length - 1), this.iBet = a);
        void 0 != b && (b = parseInt(b), 1 > b && (b = 1), 25 < b && (b = 25), this.iLine = b)
    },
    setUserSetup: function(a, b) {
        cc.sys.localStorage.setItem(a, b)
    },
    update: function(a) {
        !this.bInitMusic || this.bStopMusic || cc.audioEngine.isMusicPlaying() || this.playOneMusic();
        this.update_WinEffect(a);
        this.update_ShowMoney(a);
        this.update_Rocker(a);
        this.update_Line(a);
        this.update_ShowResult(a);
        this.update_Ani(a);
        0 < this.WaitOpenBoxTime && (this.WaitOpenBoxTime -= a, 0 >= this.WaitOpenBoxTime &&
            (this.WaitOpenBoxTime = 0, this.bCanOpenBox && (this.openBoxGame(), this.bCanOpenBox = !1)));
        0 < this.bQuickStopTime && (this.bQuickStopTime -= a, 0 >= this.bQuickStopTime && this.refreshInfo());
        0 < this.WaitAutoTime && !this.bRun && void 0 == this.DoubleLayer && void 0 == this.BoxLayer && 0 >= this.WaitOpenBoxTime && (this.WaitAutoTime -= a, 0 >= this.WaitAutoTime && (this.WaitAutoTime = 0, this.beginAuto()));
        0 < this.DisRunTime && (this.DisRunTime -= a, 0 >= this.DisRunTime && (this.DisRunTime = 0, this.refreshInfo()));
        void 0 != this.WinAni2 && this.WinAni2.action.getCurrentFrame() ==
            this.WinAni2.action.getDuration() && (this.WinAni2.node.stopAllActions(), this.GameLayer.node.removeChild(this.WinAni2.node), this.WinAni2 = void 0, this.bFreeGame || this.bAutoRun || !this.bGameInfoDouble || (this.bGameInfoDouble = !1, this.bCanDouble = !0, this.refreshInfo()));
        this.update_WinAni(a);
        for (var b = 0; b < this.lstwheel.length; ++b) this.lstwheel[b].update(a);
        if (this.bRun && this.bCanStop) {
            for (var c = !0, b = 0; b < this.lstwheel.length; ++b)
                if (this.lstwheel[b].bRun) {
                    c = !1;
                    break
                } else b + 1 < this.lstwheel.length && !this.lstwheel[b +
                    1].bStoping && (this.canLight(b + 1) ? (this.lstwheel[b + 1].RunTime = 1, this.lstwheel[b + 1].showLightAni(!0), this.lstwheel[b + 1].stop_index(this.SpinResult[b + 1]), this.addDartsAni(b + 1, 1)) : (this.lstwheel[b + 1].RunTime = 0, this.lstwheel[b + 1].stop_index(this.SpinResult[b + 1]), this.addDartsAni(b + 1, 0)));
            c && (0 > this.WaitStopTime ? this.WaitStopTime = 0.2 : (this.WaitStopTime -= a, 0 >= this.WaitStopTime && (this.WaitStopTime = 0, this.bRun = !1, a = this.iMyMoney, void 0 != this.iNewMoney ? (this.iMyMoney = this.iNewMoney, this.iNewMoney = void 0) : this.iMyMoney +=
                this.SpinWin, this.iWin = this.SpinWin, this.iFreeNums = this.iNewFreeNums, this.iFreeAll = this.iNewFreeAll, this.iNewFreeNums = 0, 0 >= this.iWin ? (this.setAniState(3), this.SpriteInfoTime = 3, this.bCanDouble = !1) : (this.showWinAni(!0, a), this.setAniState(2), this.SpriteInfoTime = 0, this.bCanOpenBox && (this.WaitOpenBoxTime = 1.5)), this.bAutoRun ? (this.WaitAutoTime = 0 >= this.iWin ? 1 : 3.8, this.bFreeGame && (this.WaitAutoTime = 0 >= this.iWin ? 0.5 : 2.8), void 0 != this.ErrorLayer && (this.WaitAutoTime += 3)) : this.DisRunTime = 0 >= this.iWin ? 0 : 2, this.refreshInfo())))
        }
    },
    update_ShowMoney: function(a) {
        void 0 != this.iMyMoney && this.iShowMoney != this.iMyMoney && (this.ShowMoneyTime += a, this.ShowMoneyTime = 0, 10 > Math.abs(this.iShowMoney - this.iMyMoney) ? this.iShowMoney = this.iMyMoney : (a = Math.floor(Math.abs(this.iShowMoney - this.iMyMoney) / 2), this.iShowMoney = 0 >= a ? this.iMyMoney : this.iShowMoney > this.iMyMoney ? this.iShowMoney - a : this.iShowMoney + a), this.textMoney.setString(this.chgString_Gray1(this.iShowMoney, 20)))
    },
    refreshInfo: function() {
        this.bAutoRun ? (this.btnAutoStop.setVisible(!0), this.btnAutoStop.setEnabled(!0),
            this.btnAutoStop.setBright(!0), this.btnAuto.setVisible(!1)) : (this.btnAutoStop.setVisible(!1), this.btnAutoStop.setEnabled(!0), this.btnAutoStop.setBright(!0), this.btnAuto.setVisible(!0));
        this.bRun ? this.bQuickStop ? (this.btnStop.setVisible(!1), this.btnRun.setVisible(!0)) : (this.btnStop.setVisible(!0), this.btnRun.setVisible(!1), this.bCanStop && 0 >= this.bQuickStopTime ? (this.btnStop.setEnabled(!0), this.btnStop.setBright(!0)) : (this.btnStop.setEnabled(!1), this.btnStop.setBright(!1))) : (this.btnStop.setVisible(!1),
            this.btnRun.setVisible(!0));
        this.bAutoRun && !this.bFreeGame ? (this.sprAutoNum.setVisible(!0), this.textAutoNum.setVisible(!0), this.textAutoNum.setString(this.chgString_Gray(this.iAutoNum, 3))) : (this.sprAutoNum.setVisible(!1), this.textAutoNum.setVisible(!1));
        this.bAutoRun || this.bRun || 0 < this.DisRunTime ? (this.btnAll.setEnabled(!1), this.btnAll.setBright(!1), this.btnAuto.setEnabled(!1), this.btnAuto.setBright(!1)) : (this.btnAll.setEnabled(!0), this.btnAll.setBright(!0), this.btnAuto.setEnabled(!0), this.btnAuto.setBright(!0));
        var a = this.lstBet[this.iBet],
            b = a * this.iLine;
        this.textAllBet.setString(this.chgString(b));
        this.textBet.setString(this.chgString(a));
        this.textLine.setString(this.iLine.toString());
        this.textWin.setString(this.chgString_Gray1(this.iWin, 20));
        0 == this.iBet ? this.textBet.setPositionX(this.BetX + 5) : this.textBet.setPositionX(this.BetX);
        1 == this.iLine ? this.textLine.setPositionX(this.LineX + 5) : this.textLine.setPositionX(this.LineX);
        this.bAutoRun || this.bRun ? (this.btnLeft1.setEnabled(!1), this.btnLeft1.setBright(!1),
            this.btnRight1.setEnabled(!1), this.btnRight1.setBright(!1), this.btnLeft2.setEnabled(!1), this.btnLeft2.setBright(!1), this.btnRight2.setEnabled(!1), this.btnRight2.setBright(!1)) : (1 == this.iLine ? (this.btnLeft1.setEnabled(!1), this.btnLeft1.setBright(!1)) : (this.btnLeft1.setEnabled(!0), this.btnLeft1.setBright(!0)), 25 == this.iLine ? (this.btnRight1.setEnabled(!1), this.btnRight1.setBright(!1)) : (this.btnRight1.setEnabled(!0), this.btnRight1.setBright(!0)), 0 == this.iBet ? (this.btnLeft2.setEnabled(!1), this.btnLeft2.setBright(!1)) :
            (this.btnLeft2.setEnabled(!0), this.btnLeft2.setBright(!0)), this.iBet == this.lstBet.length - 1 ? (this.btnRight2.setEnabled(!1), this.btnRight2.setBright(!1)) : (this.btnRight2.setEnabled(!0), this.btnRight2.setBright(!0)));
        this.bAutoRun ? (this.btnRun.setEnabled(!1), this.btnRun.setBright(!1)) : 0 < this.DisRunTime || this.bRun || 0 < this.WaitOpenBoxTime ? (this.btnRun.setEnabled(!1), this.btnRun.setBright(!1)) : (this.btnRun.setEnabled(!0), this.btnRun.setBright(!0));
        this.bAutoRun || this.bRun || (0 < this.DisRunTime || b > this.iMyMoney ?
            (this.btnAuto.setEnabled(!1), this.btnAuto.setBright(!1)) : (this.btnAuto.setEnabled(!0), this.btnAuto.setBright(!0)));
        for (a = 0; 25 > a; ++a) a < this.iLine ? (this.lstBtnBlue[a].setVisible(!0), this.lstBtnGBlue[a].setVisible(!1)) : (this.lstBtnBlue[a].setVisible(!1), this.lstBtnGBlue[a].setVisible(!0)), this.bAutoRun || this.bRun ? (this.lstBtnBlue[a].setEnabled(!1), this.lstBtnBlue[a].setBright(!1), this.lstBtnLBlue[a].setEnabled(!1), this.lstBtnLBlue[a].setBright(!1), this.lstBtnGBlue[a].setEnabled(!1), this.lstBtnGBlue[a].setBright(!1)) :
            (this.lstBtnBlue[a].setEnabled(!0), this.lstBtnBlue[a].setBright(!0), this.lstBtnLBlue[a].setEnabled(!0), this.lstBtnLBlue[a].setBright(!0), this.lstBtnGBlue[a].setEnabled(!0), this.lstBtnGBlue[a].setBright(!0));
        this.bCanDouble ? (this.btnDouble.setEnabled(!0), this.btnDouble.setBright(!0), this.nodBtnAni3.setVisible(!0)) : (this.btnDouble.setEnabled(!1), this.btnDouble.setBright(!1), this.nodBtnAni3.setVisible(!1));
        this.btnRun.isVisible() || !this.btnStop.isEnabled() ? (this.nodBtnAni1.setVisible(!0), this.nodBtnAni2.setVisible(!1)) :
            (this.nodBtnAni1.setVisible(!1), this.nodBtnAni2.setVisible(!0));
        this.bFreeGame ? (this.sprFreeRunBack.setVisible(!0), 0 <= this.iFreeNums ? this.textFreeNum.setString(this.iFreeNums.toString()) : this.textFreeNum.setString(""), this.textFreeMul.setString("X" + this.iFreeMul), this.textFreeAll.setString("\uffe5" + this.chgString_Gray1(this.iFreeAll, 20)), this.btnRun.setEnabled(!1), this.btnRun.setBright(!1), this.btnAll.setEnabled(!1), this.btnAll.setBright(!1), this.btnAuto.setEnabled(!1), this.btnAuto.setBright(!1),
            this.btnAutoStop.setEnabled(!1), this.btnAutoStop.setBright(!1), this.btnLeft1.setEnabled(!1), this.btnLeft1.setBright(!1), this.btnRight1.setEnabled(!1), this.btnRight1.setBright(!1), this.btnLeft2.setEnabled(!1), this.btnLeft2.setBright(!1), this.btnRight2.setEnabled(!1), this.btnRight2.setBright(!1), this.btnDouble.setEnabled(!1), this.btnDouble.setBright(!1), this.nodBtnAni3.setVisible(!1)) : (this.sprFreeRunBack.setVisible(!1), void 0 != this.FreeLogoAni && (this.FreeLogoAni.node.stopAllActions(), this.nodFreeLogo.removeChild(this.FreeLogoAni.node),
            this.FreeLogoAni = void 0))
    },
    chgString: function(a) {
        var b = Math.floor(a / 100).toString();
        0 != a % 100 && (b += ".", a %= 100, 10 > a && (b += "0"), b += a);
        return b
    },
    chgString_Money: function(a) {
        var b = Math.floor(a / 100);
        0 != a % 100 ? (b += ".", a %= 100, 10 > a && (b += "0"), b += a) : b += ".00";
        return b
    },
    chgString_Gray: function(a, b) {
        var c = a.toString();
        return c.length >= b ? c : "" + c
    },
    chgString_Gray1: function(a, b) {
        var c = "",
            d = Math.floor(a / 100).toString(),
            e = b - d.length,
            f = 3 - b % 3;
        3 <= f && (f = 0);
        if (0 < e)
            for (var g = 0; g < e; ++g) ++f, 3 <= f && (f = 0);
        for (g = 0; g < d.length; ++g) c +=
            d[g], ++f, 3 <= f && (f = 0, c += ",");
        c = c.slice(0, c.length - 1);
        0 != a % 100 ? (c += ".", d = a % 100, 10 > d && (c += "0"), c += d) : c += ".00";
        return c
    },
    onMyMoney: function(a) {
        void 0 == this.iMyMoney ? this.iMyMoney = a : this.iNewMoney = a;
        this.refreshInfo()
    },
    onSymbolStripes: function(a) {
        for (var b = 0; 5 > b; ++b) {
            for (var c = [], d = a[b].Symbols.length - 1; 0 <= d; --d) c.push(this.lstSymbol[a[b].Symbols[d]]);
            this.lstwheel[b].setWheelData(c, 0, !1)
        }
    },
    onGenInit: function(a) {
        for (var b = 0; 5 > b; ++b) {
            for (var c = a[b].Idx, d = this.lstwheel[b].lstwheeldata.length - a[b].Pos - 1; 0 >
                d;) d += this.lstwheel[b].lstwheeldata.length;
            for (; d >= this.lstwheel[b].lstwheeldata.length;) d -= this.lstwheel[b].lstwheeldata.length;
            this.lstwheel[c].setWheelIndex(d, !0)
        }
    },
    onSpinResult: function(a, b, c) {
        this.bCanStop || (this.totalwin = a, this.result = b, this.winresult = c)
    },
    onSpinResult1: function() {
        if (!this.bCanStop) {
            for (var a = this.totalwin, b = this.result, c = this.winresult, d = 0; 5 > d; ++d) {
                for (var e = b[d].Idx, f = this.lstwheel[d].lstwheeldata.length - b[d].Pos - 1; 0 > f;) f += this.lstwheel[d].lstwheeldata.length;
                for (; f >= this.lstwheel[d].lstwheeldata.length;) f -=
                    this.lstwheel[d].lstwheeldata.length;
                this.SpinResult[e] = f
            }
            this.lstwheel[0].stop_index(this.SpinResult[0]);
            this.addDartsAni(0, this.lstwheel[0].RunTime + this.lstwheel[0].BeginAniTime);
            this.bCanStop = !0;
            this.SpinWin = a;
            this.WinType = 0 < a ? this.lstWinSymbol[c[0].Symbol] : 0;
            this.refreshInfo()
        }
    },
    onSGameInfo: function(a) {
        if ("pokerrb" == a.sgame) {
            if (void 0 != this.DoubleLayer) this.DoubleLayer.onSGameInfo(a)
        } else if ("pickshell" == a.sgame && void 0 != this.BoxLayer) this.BoxLayer.onSGameInfo(a)
    },
    onGameInfo: function(a) {
        if (a.hasOwnProperty("gamescene"))
            if ("pickshell" ==
                a.gamescene) this.bCanOpenBox = !0, this.bRun || void 0 != this.BoxLayer || (this.WaitOpenBoxTime = 0.1);
            else if ("pokerrb" == a.gamescene)
            if (0 == a.gamescenestate) this.bGameInfoDouble = !0;
            else if (1 == a.gamescenestate && void 0 == this.DoubleLayer) {
            this.bCanDouble = !1;
            this.refreshInfo();
            var b = new NarutoDoubleLayer(this);
            this.addChild(b, 1);
            this.DoubleLayer = b;
            MainClient.singleton.sgamectrl(GameMgr.singleton.getCurGameID(), "pokerrb", "comein", 0, function(a) {})
        }
        if (a.hasOwnProperty("fgi"))
            for (this.bFreeGame || (this.bFreeGame = !0,
                    void 0 == this.BoxLayer && (this.playOneMusic(), this.playFreeLogoAni())), this.bAutoRun = !0, 0 >= this.WaitAutoTime && (this.WaitAutoTime = 1), 0 > this.iFreeNums && (this.iFreeNums = a.fgi.lastnums), 0 > this.iFreeAll && (this.iFreeAll = a.fgi.totalwin), this.iNewFreeNums = a.fgi.lastnums, this.iFreeMul = a.fgi.multiple, this.iNewFreeAll = a.fgi.totalwin, this.iFreeBeginWin = a.fgi.spinwin, this.iBet >= this.lstBet.length && (this.iBet = this.lstBet.length - 1), b = 0; b < this.lstBet.length; ++b)
                if (this.lstBet[b] == a.fgi.bet) {
                    this.iBet = b;
                    break
                }
        this.refreshInfo()
    },
    onDisconnect: function() {
        if (void 0 == this.ErrorLayer) {
            var a = new NarutoDisconnectLayer(this, 1, 0);
            this.addChild(a, 11);
            this.DisconnectLayer = a
        }
    },
    onReconnnect: function() {
        void 0 != this.DisconnectLayer && (this.removeChild(this.DisconnectLayer), this.DisconnectLayer = void 0)
    },
    onError: function(a, b) {
        if (void 0 == this.ErrorLayer) {
            var c = new NarutoDisconnectLayer(this, 3, a, b);
            this.addChild(c, 12);
            this.ErrorLayer = c;
            2 == a && 0 < this.WaitAutoTime && (this.WaitAutoTime += 3)
        }
    },
    onTouchRun: function(a, b) {
        b != ccui.Widget.TOUCH_ENDED || this.bRun ||
            this.bAutoRun || 0 < this.WaitOpenBoxTime || (cc.audioEngine.playEffect(res.NarutoBtnRun_mp3, !1), this.runOne())
    },
    onTouchStop: function(a, b) {
        if (b == ccui.Widget.TOUCH_ENDED) {
            cc.audioEngine.playEffect(res.NarutoBtnStop_mp3, !1);
            this.bQuickStop = !0;
            this.refreshInfo();
            for (var c = 0, d = 0; d < this.lstwheel.length; ++d) this.lstwheel[d].RunTime = 0.1 * d, this.lstwheel[d].bRun && !this.lstwheel[d].bStoping && this.lstwheel[d].stop_index(this.SpinResult[d]), this.lstwheel[d].bRun && (this.addDartsAni(d, c), c += 0.1)
        }
    },
    onTouchAll: function(a,
        b) {
        b != ccui.Widget.TOUCH_ENDED || this.bRun || this.bAutoRun || (this.playBtnSound(), this.iLine = 25, this.setUserSetup("narutouserline", this.iLine), this.refreshInfo(), this.bRun || this.bAutoRun || this.showLine(this.iLine, 0.5, this.runOne))
    },
    onTouchAuto: function(a, b) {
        if (b == ccui.Widget.TOUCH_ENDED && !this.bRun && !this.bAutoRun) {
            this.playBtnSound();
            var c = new NarutoAutoSelectLayer(this);
            this.addChild(c, 1)
        }
    },
    onTouchAutoStop: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.playBtnSound(), this.bAutoRun && this.setAuto(0))
    },
    onTouchLeft1: function(a, b) {
        b != ccui.Widget.TOUCH_ENDED || this.bRun || this.bAutoRun || (this.playBtnSound(), this.setLine(this.iLine - 1), this.chgRocker(2))
    },
    onTouchRight1: function(a, b) {
        b != ccui.Widget.TOUCH_ENDED || this.bRun || this.bAutoRun || (this.playBtnSound(), this.setLine(this.iLine + 1), this.chgRocker(3))
    },
    chgRocker: function(a) {},
    update_Rocker: function(a) {
        0 >= this.iRockerTime || (this.iRockerTime -= a, 0 >= this.iRockerTime && this.chgRocker(1))
    },
    onTouchLeft2: function(a, b) {
        b != ccui.Widget.TOUCH_ENDED || this.bRun || this.bAutoRun ||
            (this.playBtnSound(), --this.iBet, 0 > this.iBet && (this.iBet = 0), this.setUserSetup("narutouserbet", this.iBet), this.refreshInfo())
    },
    onTouchRight2: function(a, b) {
        b != ccui.Widget.TOUCH_ENDED || this.bRun || this.bAutoRun || (this.playBtnSound(), ++this.iBet, this.iBet >= this.lstBet.length && (this.iBet = this.lstBet.length - 1), this.setUserSetup("narutouserbet", this.iBet), this.refreshInfo())
    },
    onTouchDouble: function(a, b) {
        if (b == ccui.Widget.TOUCH_ENDED && !this.bRun && !this.bAutoRun) {
            this.playBtnSound();
            this.bCanDouble = !1;
            this.refreshInfo();
            var c = new NarutoDoubleLayer(this);
            this.addChild(c, 1);
            this.DoubleLayer = c;
            MainClient.singleton.sgamectrl(GameMgr.singleton.getCurGameID(), "pokerrb", "comein", 0, function(a) {})
        }
    },
    leftDouble: function(a) {
        void 0 != this.DoubleLayer && (this.removeChild(this.DoubleLayer), this.DoubleLayer = void 0);
        void 0 != this.iNewMoney && (this.iMyMoney = this.iNewMoney, this.iNewMoney = void 0);
        a && MainClient.singleton.sgamectrl(GameMgr.singleton.getCurGameID(), "pokerrb", "left", 0, function(a) {})
    },
    openBoxGame: function() {
        this.iFreeAll = this.iFreeNums = -1;
        var a = new NarutoBoxLayer(this);
        this.addChild(a, 1);
        this.BoxLayer = a;
        MainClient.singleton.sgamectrl(GameMgr.singleton.getCurGameID(), "pickshell", "comein", 0, function(a) {})
    },
    leftBoxGame: function() {
        void 0 != this.iNewMoney && (this.iMyMoney = this.iNewMoney, this.iNewMoney = void 0);
        void 0 != this.BoxLayer && (this.removeChild(this.BoxLayer), this.BoxLayer = void 0, this.bFreeGame || (this.WaitAutoTime = 0, this.bFreeGame || (this.bFreeGame = !0), this.bShowFreeResult = !1), this.clearResultDis(), this.refreshInfo(), this.bPlayFreeMusic ||
            this.playOneMusic(), this.playFreeLogoAni())
    },
    openFreeResult: function() {
        var a = new NarutoFreeResultLayer(this, this.iFreeBeginWin, this.iFreeAll);
        this.addChild(a, 1);
        this.FreeResultLayer = a
    },
    leftFreeResult: function() {
        void 0 != this.FreeResultLayer && (this.removeChild(this.FreeResultLayer), this.FreeResultLayer = void 0, this.bFreeGame && (this.bFreeGame = !1, this.playOneMusic()), this.iFreeNums = -1, this.iFreeMul = this.iNewFreeNums = 0, this.iFreeAll = -1, this.iFreeBeginWin = this.iNewFreeAll = 0, 0 < this.iAutoNum ? (this.bAutoRun = !0, this.WaitAutoTime = 1) : this.bAutoRun = !1, this.clearResultDis(), this.refreshInfo())
    },
    playFreeLogoAni: function() {
        void 0 != this.FreeLogoAni && (this.FreeLogoAni.node.stopAllActions(), this.nodFreeLogo.removeChild(this.FreeLogoAni.node), this.FreeLogoAni = void 0);
        this.FreeLogoAni = ccs.load(res.NarutoFreeLogoAni_json);
        this.nodFreeLogo.addChild(this.FreeLogoAni.node);
        this.FreeLogoAni.node.runAction(this.FreeLogoAni.action);
        this.FreeLogoAni.action.gotoFrameAndPlay(0, this.FreeLogoAni.action.getDuration(), !1)
    },
    onTouchOpenSound: function(a,
        b) {
        b == ccui.Widget.TOUCH_ENDED && (this.setPlaySound(!1), this.setUserSetup("narutosoundopen", 0))
    },
    onTouchCloseSound: function(a, b) {
        if (b == ccui.Widget.TOUCH_ENDED || b == ccui.Widget.TOUCH_ENDED) this.setPlaySound(!0), this.setUserSetup("narutosoundopen", 1)
    },
    onTouchOpenEffect: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.setPlayEffect(!1), this.setUserSetup("narutoeffectopen", 0))
    },
    onTouchCloseEffect: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.setPlayEffect(!0), this.setUserSetup("narutoeffectopen", 1))
    },
    onTouchSetup: function(a,
        b) {
        if (b == ccui.Widget.TOUCH_ENDED) {
            this.playBtnSound();
            var c = new NarutoSetupLayer(this);
            this.addChild(c, 1)
        }
    },
    onTouchClose: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.playBtnSound(), close_game())
    },
    onTouchHelp: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.playBtnSound(), this.showHelp(1))
    },
    onTouchBtnLine: function(a, b) {
        if (b == ccui.Widget.TOUCH_ENDED) {
            for (var c = -1, d = 0; 25 > d; ++d) {
                if (this.lstBtnBlue[d] == a) {
                    c = d + 1;
                    break
                }
                if (this.lstBtnLBlue[d] == a) {
                    c = d + 1;
                    break
                }
                if (this.lstBtnGBlue[d] == a) {
                    c = d + 1;
                    break
                }
            }
            0 < c &&
                (this.playBtnSound(), this.setLine(c))
        }
    },
    setLine: function(a) {
        this.iLine = a;
        0 >= this.iLine && (this.iLine = 1);
        25 < this.iLine && (this.iLine = 25);
        this.setUserSetup("narutouserline", this.iLine);
        this.refreshInfo();
        this.showLine(this.iLine, 2, void 0)
    },
    showLine: function(a, b, c) {
        for (var d = 0; d < this.lstBtnLBlue.length; ++d) this.lstBtnLBlue[d].setVisible(!1);
        if (0 < this.lstSprLine.length)
            for (d = 0; 25 > d; ++d) d < a && 0 < b ? this.lstSprLine[d].setVisible(!0) : this.lstSprLine[d].setVisible(!1);
        0 >= b ? (this.ShowLineTime = 0, void 0 != c && c(),
            this.ShowLineFunc = void 0) : (this.ShowLineTime = b, this.ShowLineFunc = c)
    },
    update_Line: function(a) {
        if (!(0 >= this.ShowLineTime) && (this.ShowLineTime -= a, 0 >= this.ShowLineTime)) {
            if (0 < this.lstSprLine.length)
                for (a = 0; 25 > a; ++a) this.lstSprLine[a].setVisible(!1);
            void 0 != this.ShowLineFunc && (this.ShowLineFunc(), this.ShowLineFunc = void 0)
        }
    },
    setPlaySound: function(a) {
        a ? (this.bInitMusic || (this.bInitMusic = !0, this.playOneMusic()), cc.audioEngine.setMusicVolume(this.SoundValue), void 0 != this.btnOpenSound && this.btnOpenSound.setVisible(!0),
            void 0 != this.btnCloseSound && this.btnCloseSound.setVisible(!1)) : (cc.audioEngine.setMusicVolume(0), void 0 != this.btnOpenSound && this.btnOpenSound.setVisible(!1), void 0 != this.btnCloseSound && this.btnCloseSound.setVisible(!0))
    },
    setPlayEffect: function(a) {
        a ? (cc.audioEngine.setEffectsVolume(1), void 0 != this.btnOpenEffect && this.btnOpenEffect.setVisible(!0), void 0 != this.btnCloseEffect && this.btnCloseEffect.setVisible(!1)) : (cc.audioEngine.setEffectsVolume(0), void 0 != this.btnOpenEffect && this.btnOpenEffect.setVisible(!1),
            void 0 != this.btnCloseEffect && this.btnCloseEffect.setVisible(!0))
    },
    playBtnSound: function() {
        cc.audioEngine.playEffect(res.NarutoBtnClick_mp3, !1)
    },
    playOneMusic: function() {
        if (this.bInitMusic)
            if (this.bFreeGame) cc.audioEngine.playMusic(res.NarutoFreeMusci1_mp3, !1), this.bPlayFreeMusic = !0;
            else {
                this.bPlayFreeMusic = !1;
                0 >= this.lstWaitMusic.length && this.addWaitMusic();
                var a = this.lstWaitMusic[0];
                this.lstWaitMusic.splice(0, 1);
                cc.audioEngine.playMusic(this.lstMusic[a], !1);
                1 >= this.lstWaitMusic && this.addWaitMusic()
            }
    },
    addWaitMusic: function() {
        if (0 == this.lstWaitMusic.length) {
            for (var a = [], b = this.lstMusic.length, c = 0; c < b; ++c) a.push(c);
            for (c = 0; c < this.lstMusic.length; ++c) {
                var d = Math.floor(Math.random() * b);
                0 > d && (d = 0);
                d >= b && (d = b - 1);
                b = a[d];
                this.lstWaitMusic.push(b);
                a.splice(d, 1);
                b = a.length
            }
        } else {
            for (var a = [], e = this.lstWaitMusic[this.lstWaitMusic.length - 1], c = 0; c < this.lstMusic.length; ++c) c != e && a.push(c);
            b = a.length;
            for (c = 0; c < this.lstMusic.length; ++c) d = Math.floor(Math.random() * b), 0 > d && (d = 0), d >= b && (d = b - 1), b = a[d], this.lstWaitMusic.push(b),
                a.splice(d, 1), 0 == c && a.push(e), b = a.length
        }
    },
    playWinEffect: function() {
        0 >= this.lstWaitWinEfect.length && this.addWaitWinEffect();
        var a = this.lstWaitWinEfect[0];
        this.lstWaitWinEfect.splice(0, 1);
        this.btnOpenEffect.isVisible() && (this.SoundValue = 0.3);
        this.btnCloseEffect.isVisible() ? this.WinEffectTime = 0 : (this.WinEffectTime = this.lstWinEffectTime[a], 0 < cc.audioEngine.getMusicVolume() && cc.audioEngine.setMusicVolume(this.SoundValue), cc.audioEngine.playEffect(this.lstWinEffect[a], !1));
        1 >= this.lstWaitWinEfect && this.addWaitWinEffect()
    },
    addWaitWinEffect: function() {
        if (0 == this.lstWaitWinEfect.length) {
            for (var a = [], b = this.lstWinEffect.length, c = 0; c < b; ++c) a.push(c);
            for (c = 0; c < this.lstWinEffect.length; ++c) {
                var d = Math.floor(Math.random() * b);
                0 > d && (d = 0);
                d >= b && (d = b - 1);
                b = a[d];
                this.lstWaitWinEfect.push(b);
                a.splice(d, 1);
                b = a.length
            }
        } else {
            for (var a = [], e = this.lstWaitWinEfect[this.lstWaitWinEfect.length - 1], c = 0; c < this.lstWinEffect.length; ++c) c != e && a.push(c);
            b = a.length;
            for (c = 0; c < this.lstWinEffect.length; ++c) d = Math.floor(Math.random() * b), 0 > d && (d = 0), d >=
                b && (d = b - 1), b = a[d], this.lstWaitWinEfect.push(b), a.splice(d, 1), 0 == c && a.push(e), b = a.length
        }
    },
    update_WinEffect: function(a) {
        0 >= this.WinEffectTime || (this.WinEffectTime -= a, 0 >= this.WinEffectTime && (this.SoundValue = 1, this.WinEffectTime = 0, this.bStopMusic = !1, 0 < cc.audioEngine.getMusicVolume() && cc.audioEngine.setMusicVolume(this.SoundValue)))
    },
    runOne: function() {
        if (void 0 != this.ErrorLayer || this.bRun) return !1;
        for (var a = 0; 5 > a; ++a)
            if (this.lstwheel[a].bRun) return !1;
        var b = this.lstBet[this.iBet],
            a = b * this.iLine;
        if (!this.bFreeGame &&
            this.iMyMoney < a) return b = new NarutoDisconnectLayer(this, 2, 0), this.addChild(b, 11), !1;
        this.clearResultDis();
        this.setAniState(1);
        this.bCanDouble = !1;
        this.bFreeGame || (this.iMyMoney -= a);
        this.iWin = 0;
        this.runBet = this.iBet;
        this.runLine = this.iLine;
        var c = 3E3,
            d = 0.5;
        this.bFreeGame && (c *= 1.5, d /= 2);
        for (a = 0; 5 > a; ++a) 0 == a ? this.lstwheel[a].run(c, d, 1.5, 0.2 * a) : this.lstwheel[a].run(c, d, 1, 0.2 * a);
        this.bRun = !0;
        this.WaitStopTime = -1;
        this.bQuickStop = this.bCanStop = !1;
        this.bQuickStopTime = 1.3;
        var e = this;
        MainClient.singleton.spin(GameMgr.singleton.getCurGameID(),
            b, 1, this.iLine,
            function(a) {
                if (a) e.onSpinResult1()
            });
        this.refreshInfo();
        return !0
    },
    setAuto: function(a) {
        0 < a ? (this.bAutoRun = !0, this.iAutoNum = a, this.WaitAutoTime = 0.1) : (this.bAutoRun = !1, this.WaitAutoTime = this.iAutoNum = 0);
        this.refreshInfo()
    },
    beginAuto: function() {
        if (this.bFreeGame) {
            if (0 >= this.iFreeNums) {
                this.openFreeResult();
                return
            }--this.iFreeNums
        } else {
            if (!this.bAutoRun) return;
            if (0 >= this.iAutoNum) {
                this.iAutoNum = 0;
                this.setAuto(0);
                return
            }--this.iAutoNum
        }
        this.runOne() || this.setAuto(0)
    },
    setAniState: function(a) {},
    update_Ani: function(a) {
        this.update_BtnAni(a);
        this.update_Darts(a)
    },
    showWinAni: function(a, b) {
        a && this.showAllResult()
    },
    showAllResult: function() {
        for (var a = 0; a < this.lstwheel.length; ++a) this.lstwheel[a].setState(1);
        void 0 != this.helpLayer1 && this.helpLayer1.clearResult();
        void 0 != this.helpLayer2 && this.helpLayer2.clearResult();
        for (var b = -1, c = -1, a = 0; a < this.winresult.length; ++a) {
            var d = this.winresult[a];
            if ("Line" == d.Type) {
                var e = d.Data.Line;
                0 < this.lstSprLine.length && this.lstSprLine[e - 1].setVisible(!0);
                this.lstBtnLBlue[e -
                    1].setVisible(!0)
            }
            for (e = 0; e < d.Positions.length; ++e) this.lstwheel[d.Positions[e].X].showTop(1 - d.Positions[e].Y);
            var e = "Line" == d.Type ? 0 : 1,
                f = this.lstSymbol[d.Symbol],
                g = 0,
                h = d.Positions.length,
                g = void 0 != d.Data && void 0 != d.Data.Line ? d.Data.Line : 0;
            void 0 != this.helpLayer1 && this.helpLayer1.setResult(e, f, g, h);
            void 0 != this.helpLayer2 && this.helpLayer2.setResult(e, f, g, h);
            d = f - 1;
            if (0 > b || d < b) 0 <= b && (0 > c || b < c) && (c = b), b = d
        }
        this.playWinEffect();
        b = this.iWin / (this.lstBet[this.runBet] * this.runLine);
        this.bFreeGame && 0 < this.iFreeMul &&
            (b = this.iWin * this.iFreeMul / (this.lstBet[this.runBet] * this.runLine));
        a = 0;
        17 <= b ? a = 3 : 7 <= b ? a = 2 : 3 <= b && (a = 1);
        void 0 == this.WinAni2 && a < this.lstWinAni.length && (this.WinAni2 = ccs.load(this.lstWinAni[a]), b = this.chgString(this.iWin), c = ccui.helper.seekWidgetByName(this.WinAni2.node, "textNum1"), this.bFreeGame && 0 < this.iFreeMul ? (c.setString(b + "X" + this.iFreeMul), this.iWin *= this.iFreeMul) : c.setString(b), 0 == a && (a = Math.floor(5 * Math.random()), 0 > a && (a = 0), 5 <= a && (a = 4), a += 8, b = void 0, b = 10 > a ? cc.spriteFrameCache.getSpriteFrame("narutowin1_0" +
            a + ".jpg") : cc.spriteFrameCache.getSpriteFrame("narutowin1_" + a + ".jpg"), void 0 != b && null != b && ccui.helper.seekWidgetByName(this.WinAni2.node, "sprPic").setSpriteFrame(b)), this.GameLayer.node.addChild(this.WinAni2.node, 2), this.WinAni2.node.runAction(this.WinAni2.action), this.WinAni2.action.gotoFrameAndPlay(0, this.WinAni2.action.getDuration(), !1), ccui.helper.seekWidgetByName(this.WinAni2.node, "Panel_1").addTouchEventListener(this.onTouchExitPanel, this));
        this.bShowResult = !0;
        this.iShowResultIndex = -1;
        this.ShowResultTime =
            5
    },
    onTouchExitPanel: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.WinAni2.node.stopAllActions(), this.GameLayer.node.removeChild(this.WinAni2.node), this.WinAni2 = void 0, this.bFreeGame || this.bAutoRun || !this.bGameInfoDouble || (this.bGameInfoDouble = !1, this.bCanDouble = !0, this.refreshInfo()), this.bShowResult = !1, this.DisRunTime = this.WaitAutoTime = 0.1, this.refreshInfo())
    },
    update_ShowResult: function(a) {
        if (this.bShowResult && !(0 < this.ShowLineTime) && (this.ShowResultTime -= a, 0 >= this.ShowResultTime)) {
            ++this.iShowResultIndex;
            this.iShowResultIndex >= this.winresult.length && (this.iShowResultIndex = 0);
            for (a = 0; a < this.lstwheel.length; ++a) this.lstwheel[a].clearTop();
            if (0 < this.lstSprLine.length)
                for (a = 0; a < this.lstSprLine.length; ++a) this.lstSprLine[a].setVisible(!1);
            for (a = 0; a < this.lstBtnLBlue.length; ++a) this.lstBtnLBlue[a].setVisible(!1);
            a = this.winresult[this.iShowResultIndex];
            if ("Line" == a.Type) {
                var b = a.Data.Line;
                0 < this.lstSprLine.length && this.lstSprLine[b - 1].setVisible(!0);
                this.lstBtnLBlue[b - 1].setVisible(!0)
            }
            this.clearWaitWinAni();
            for (b = 0; b < a.Positions.length; ++b) {
                var c = a.Positions[b].X,
                    d = 1 - a.Positions[b].Y;
                this.lstwheel[c].showTop(d);
                var e = {};
                e.spr = this.lstwheel[c].getTopSprite(d);
                e.time = b / 12;
                e.type = 0;
                e.ani = void 0;
                this.lstWaitWinAni.push(e);
                2 == b && (e = {}, e.spr = this.lstwheel[c].getTopSprite(d), e.time = 5 / 24, e.type = 1, e.num = a.Win, e.ani = void 0, this.lstWaitWinAni.push(e))
            }
            3 > a.Positions.length && (b = a.Positions.length - 1, c = a.Positions[b].X, d = 1 - a.Positions[b].Y, e = {}, e.spr = this.lstwheel[c].getTopSprite(d), e.time = 5 / 24, e.type = 1, e.num = a.Win,
                e.ani = void 0, this.lstWaitWinAni.push(e));
            this.ShowResultTime = 2.5
        }
    },
    clearResultDis: function() {
        this.bShowResult = !1;
        void 0 != this.helpLayer1 && this.helpLayer1.clearResult();
        void 0 != this.helpLayer2 && this.helpLayer2.clearResult();
        for (var a = 0; a < this.lstwheel.length; ++a) this.lstwheel[a].setState(0);
        if (0 < this.lstSprLine.length)
            for (a = 0; a < this.lstSprLine.length; ++a) this.lstSprLine[a].setVisible(!1);
        for (a = 0; a < this.lstBtnLBlue.length; ++a) this.lstBtnLBlue[a].setVisible(!1);
        this.clearWaitWinAni()
    },
    clearWaitWinAni: function() {
        for (var a =
                0; a < this.lstWaitWinAni.length; ++a) {
            var b = this.lstWaitWinAni[a];
            void 0 != b.ani && (b.ani.node.stopAllActions(), b.ani.node.getParent().removeChild(b.ani.node), b.ani = void 0)
        }
        this.lstWaitWinAni = []
    },
    update_WinAni: function(a) {},
    showHelp: function(a) {
        0 == a ? (void 0 != this.helpLayer1 && this.helpLayer1.setVisible(!1), void 0 != this.helpLayer2 && this.helpLayer2.setVisible(!1), void 0 != this.helpLayer3 && this.helpLayer3.setVisible(!1), void 0 != this.helpLayer4 && this.helpLayer4.setVisible(!1)) : 1 == a ? (void 0 != this.helpLayer1 &&
            this.helpLayer1.setVisible(!0), void 0 != this.helpLayer2 && this.helpLayer2.setVisible(!1), void 0 != this.helpLayer3 && this.helpLayer3.setVisible(!1), void 0 != this.helpLayer4 && this.helpLayer4.setVisible(!1)) : 2 == a ? (void 0 != this.helpLayer1 && this.helpLayer1.setVisible(!1), void 0 != this.helpLayer2 && this.helpLayer2.setVisible(!0), void 0 != this.helpLayer3 && this.helpLayer3.setVisible(!1), void 0 != this.helpLayer4 && this.helpLayer4.setVisible(!1)) : 3 == a ? (void 0 != this.helpLayer1 && this.helpLayer1.setVisible(!1), void 0 !=
            this.helpLayer2 && this.helpLayer2.setVisible(!1), void 0 != this.helpLayer3 && this.helpLayer3.setVisible(!0), void 0 != this.helpLayer4 && this.helpLayer4.setVisible(!1)) : 4 == a && (void 0 != this.helpLayer1 && this.helpLayer1.setVisible(!1), void 0 != this.helpLayer2 && this.helpLayer2.setVisible(!1), void 0 != this.helpLayer3 && this.helpLayer3.setVisible(!1), void 0 != this.helpLayer4 && this.helpLayer4.setVisible(!0))
    },
    update_BtnAni: function(a) {
        this.BtnAniTime += a;
        a = 0;
        a = this.btnRun.isVisible() || !this.btnStop.isEnabled() ? 0 : 1;
        var b =
            Math.floor(1E4 * this.BtnAniTime) % Math.floor(1E4 * this.BtnScaleTime[a]) / 1E4;
        this.sprDarts.setRotation(360 * b / this.BtnScaleTime[a]);
        b > this.BtnScaleTime[a] / 2 && (b = this.BtnScaleTime[a] - b);
        a = this.BtnScale[0] + (this.BtnScale[1] - this.BtnScale[0]) * b / (this.BtnScaleTime[a] / 2);
        this.btnRun.setScale(a);
        this.btnStop.setScale(a);
        this.btnStop.isEnabled() || this.btnStop.setScale(1)
    },
    addDartsAni: function(a, b) {
        for (var c = 0; c < this.lstWaitDartsAni.length; ++c)
            if (this.lstWaitDartsAni[c].index == a) {
                this.lstWaitDartsAni[c].time =
                    b;
                return
            }
        c = {};
        c.index = a;
        c.time = b;
        this.lstWaitDartsAni.push(c)
    },
    update_Darts: function(a) {
        for (var b = 0; b < this.lstWaitDartsAni.length; ++b) {
            var c = this.lstWaitDartsAni[b];
            c.time -= a;
            if (0 >= c.time) {
                var d = ccs.load(res["NarutoDartsAni" + (c.index + 1) + "_json"]);
                this.lstDartsNode[c.index].addChild(d.node);
                d.node.runAction(d.action);
                d.action.gotoFrameAndPlay(0, d.action.getDuration(), !1);
                this.lstPlayDartsAni.push(d);
                this.lstWaitDartsAni.splice(b, 1);
                --b
            }
        }
        for (b = 0; b < this.lstPlayDartsAni.length; ++b) d = this.lstPlayDartsAni[b],
            d.action.getCurrentFrame() == d.action.getDuration() && (d.node.stopAllActions(), d.node.getParent().removeChild(d.node), this.lstPlayDartsAni.splice(b, 1), --b)
    },
    canLight: function(a) {
        if (!(2 > a)) {
            for (var b = 0, c = 0; c < a; ++c) this.lstwheel[c].hasIcon(this.lstSymbol.C1, -1, 1) && ++b;
            return 2 == b
        }
    }
});
var NarutoAutoSelectLayer = cc.Layer.extend({
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoSelectAutoLayer_json);
        this.addChild(b.node);
        this.gamelayer = a;
        ccui.helper.seekWidgetByName(b.node, "imgClick").addTouchEventListener(this.onTouchClick, this);
        ccui.helper.seekWidgetByName(b.node, "btnAuto25").addTouchEventListener(this.onTouchAuto25, this);
        ccui.helper.seekWidgetByName(b.node, "btnAuto50").addTouchEventListener(this.onTouchAuto50, this);
        ccui.helper.seekWidgetByName(b.node, "btnAuto100").addTouchEventListener(this.onTouchAuto100,
            this);
        ccui.helper.seekWidgetByName(b.node, "btnAuto200").addTouchEventListener(this.onTouchAuto200, this);
        ccui.helper.seekWidgetByName(b.node, "btnAuto500").addTouchEventListener(this.onTouchAuto500, this)
    },
    onTouchClick: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.getParent().removeChild(this)
    },
    onTouchAuto25: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.setAuto(25)
    },
    onTouchAuto50: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.setAuto(50)
    },
    onTouchAuto100: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.setAuto(100)
    },
    onTouchAuto200: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.setAuto(200)
    },
    onTouchAuto500: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.setAuto(500)
    },
    setAuto: function(a) {
        this.gamelayer.playBtnSound();
        this.gamelayer.setAuto(a);
        this.getParent().removeChild(this)
    }
});
var NarutoDoubleLayer = cc.Layer.extend({
    sprite: null,
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoDoubleLayer_json);
        this.addChild(b.node);
        this.gamelayer = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnSelect0");
        a.addTouchEventListener(this.onTouchSelect0, this);
        a.setVisible(!1);
        this.btnSelect0 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnSelect1");
        a.addTouchEventListener(this.onTouchSelect1, this);
        a.setVisible(!1);
        this.btnSelect1 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnReturn");
        a.addTouchEventListener(this.onTouchReturn,
            this);
        a.setVisible(!1);
        this.btnReturn = a;
        a = ccui.helper.seekWidgetByName(b.node, "textNum");
        a.setVisible(!1);
        this.textNum = a;
        a = ccui.helper.seekWidgetByName(b.node, "textDouble");
        a.setVisible(!1);
        this.textDouble = a;
        this.lstHistorySprite = [];
        for (a = 0; 5 > a; ++a) {
            for (var c = [], d = 0; 2 > d; ++d) {
                var e = ccui.helper.seekWidgetByName(b.node, "sprHistory" + a.toString() + d.toString());
                e.setVisible(!1);
                c.push(e)
            }
            this.lstHistorySprite.push(c)
        }
        a = ccui.helper.seekWidgetByName(b.node, "sprCardBack");
        a.setVisible(!1);
        this.sprCardBack =
            a;
        this.lstCardSprite = [];
        for (a = 0; 2 > a; ++a) e = ccui.helper.seekWidgetByName(b.node, "sprCard" + a.toString()), e.setVisible(!1), this.lstCardSprite.push(e);
        this.nodAni = ccui.helper.seekWidgetByName(b.node, "nodAni");
        this.iAniState = this.iGameState = 0;
        this.iResultCard = this.curResultAni = this.curAni = void 0;
        this.bFull = this.bGameEnd = !1;
        this.iCurBet = this.ChgBetTime = this.ShowResultTime = 0;
        this.lstHistory = [];
        this.BtnScale = [1, 1.05];
        this.BtnScaleTime = 1;
        this.BtnAniTime = 0;
        this.scheduleUpdate()
    },
    update: function(a) {
        0 < this.ShowResultTime &&
            (this.ShowResultTime -= a, 0 >= this.ShowResultTime && (this.ShowResultTime = 0, this.refreshResult()));
        if (0 < this.ChgBetTime && (this.ChgBetTime -= a, 0 >= this.ChgBetTime && (this.ChgBetTime = 0, !this.bGameEnd))) {
            var b = this.gamelayer.chgString(this.iCurBet),
                c = this.gamelayer.chgString(2 * this.iCurBet);
            this.textNum.setVisible(!0);
            this.textNum.setString("\uffe5" + b);
            this.textDouble.setVisible(!0);
            this.textDouble.setString("\uffe5" + c)
        }
        this.update_Ani(a)
    },
    update_Ani: function(a) {
        this.update_BtnAni(a);
        2 != this.iGameState || 0 !=
            this.iAniState && 1 != this.iAniState || this.curAni.action.getCurrentFrame() != this.curAni.action.getDuration() || (void 0 != this.iResultCard ? (this.playResultAni(this.iResultCard), this.ShowResultTime = 2, this.ChgBetTime = 1.125, this.bGameEnd && (this.textNum.setString("\uffe50"), this.textDouble.setString("\uffe50"))) : this.playSmokeAni())
    },
    update_BtnAni: function(a) {
        this.BtnAniTime += a;
        a = Math.floor(1E4 * this.BtnAniTime) % Math.floor(1E4 * this.BtnScaleTime) / 1E4;
        a > this.BtnScaleTime / 2 && (a = this.BtnScaleTime - a);
        var b = this.BtnScale[0] +
            (this.BtnScale[1] - this.BtnScale[0]) * a / (this.BtnScaleTime / 2);
        this.btnSelect0.setScale(b);
        a = this.BtnScaleTime / 2 - a;
        b = this.BtnScale[0] + (this.BtnScale[1] - this.BtnScale[0]) * a / (this.BtnScaleTime / 2);
        this.btnSelect1.setScale(b)
    },
    onSGameInfo: function(a) {
        if (0 == this.iGameState) {
            this.btnSelect0.setVisible(!0);
            this.btnSelect1.setVisible(!0);
            var b = this.gamelayer.chgString(a.sgi.curbet),
                c = this.gamelayer.chgString(2 * a.sgi.curbet);
            this.textNum.setVisible(!0);
            this.textNum.setString("\uffe5" + b);
            this.textDouble.setVisible(!0);
            this.textDouble.setString("\uffe5" + c);
            this.sprCardBack.setVisible(!0);
            if (void 0 != a.sgi.pokerarr && 0 < a.sgi.pokerarr.length)
                for (this.lstHistory = [], b = 0; b < a.sgi.pokerarr.length; ++b) this.lstHistory.push(a.sgi.pokerarr[b].color);
            this.refreshHistory();
            this.btnReturn.setVisible(0 < this.lstHistory.length)
        } else if (2 == this.iGameState) {
            if (void 0 != a.sgi.pokerarr && 0 < a.sgi.pokerarr.length)
                for (this.iResultCard = a.sgi.pokerarr[a.sgi.pokerarr.length - 1].color, this.lstHistory = [], b = 0; b < a.sgi.pokerarr.length; ++b) this.lstHistory.push(a.sgi.pokerarr[b].color);
            this.bGameEnd = 0 <= a.sgi.failindex;
            this.iCurBet = a.sgi.curbet;
            this.bFull = 1 == a.sgi.isfull
        }
    },
    onTouchSelect0: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.playBtnSound(), this.selectCard(0))
    },
    onTouchSelect1: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.playBtnSound(), this.selectCard(1))
    },
    selectCard: function(a) {
        this.iGameState = 2;
        this.btnSelect0.setVisible(!1);
        this.btnSelect1.setVisible(!1);
        this.btnReturn.setVisible(!1);
        this.sprCardBack.setVisible(!1);
        this.lstCardSprite[0].setVisible(!1);
        this.lstCardSprite[1].setVisible(!1);
        this.iResultCard = void 0;
        this.iAniState = 0;
        void 0 != this.curAni && (this.curAni.node.stopAllActions(), this.curAni.node.getParent().removeChild(this.curAni.node), this.curAni = void 0);
        var b = ccs.load(res.NarutoDoubleAni1_json);
        this.nodAni.addChild(b.node);
        b.node.runAction(b.action);
        b.action.gotoFrameAndPlay(0, b.action.getDuration(), !1);
        this.curAni = b;
        MainClient.singleton.sgamectrl(GameMgr.singleton.getCurGameID(), "pokerrb", "play", a, function(a) {})
    },
    onTouchReturn: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.playBtnSound(),
            this.gamelayer.leftDouble(!this.bGameEnd))
    },
    playSmokeAni: function() {
        this.iAniState = 1;
        void 0 != this.curAni && (this.curAni.node.stopAllActions(), this.curAni.node.getParent().removeChild(this.curAni.node), this.curAni = void 0);
        var a = ccs.load(res.NarutoDoubleAni2_json);
        this.nodAni.addChild(a.node);
        a.node.runAction(a.action);
        a.action.gotoFrameAndPlay(0, a.action.getDuration(), !1);
        this.curAni = a
    },
    playResultAni: function(a) {
        this.iAniState = 2;
        void 0 != this.curAni && (this.curAni.node.stopAllActions(), this.curAni.node.getParent().removeChild(this.curAni.node),
            this.curAni = void 0);
        a = ccs.load(res["NarutoDoubleAni" + (a + 3) + "_json"]);
        this.nodAni.addChild(a.node);
        a.node.runAction(a.action);
        a.action.gotoFrameAndPlay(0, a.action.getDuration(), !1);
        this.curAni = a;
        void 0 != this.curResultAni && (this.curResultAni.node.stopAllActions(), this.curResultAni.node.getParent().removeChild(this.curResultAni.node), this.curResultAni = void 0);
        a = 5;
        this.bGameEnd && (a = 6);
        a = ccs.load(res["NarutoDoubleAni" + a + "_json"]);
        this.nodAni.addChild(a.node);
        a.node.runAction(a.action);
        a.action.gotoFrameAndPlay(0,
            a.action.getDuration(), !1);
        this.curResultAni = a
    },
    refreshResult: function() {
        this.bGameEnd ? this.gamelayer.leftDouble(!this.bGameEnd) : (void 0 != this.curAni && (this.curAni.node.stopAllActions(), this.curAni.node.getParent().removeChild(this.curAni.node), this.curAni = void 0), void 0 != this.curResultAni && (this.curResultAni.node.stopAllActions(), this.curResultAni.node.getParent().removeChild(this.curResultAni.node), this.curResultAni = void 0), this.btnSelect0.setVisible(!this.bFull), this.btnSelect1.setVisible(!this.bFull),
            this.btnReturn.setVisible(!0), this.sprCardBack.setVisible(!0), this.refreshHistory())
    },
    refreshHistory: function() {
        for (var a = 0; a < this.lstHistorySprite.length; ++a)
            for (var b = 0; b < this.lstHistorySprite[a].length; ++b) this.lstHistorySprite[a][b].setVisible(!1);
        var c = 0;
        5 < this.lstHistory.length && (c = this.lstHistory.length - 5);
        for (a = 0; a < this.lstHistorySprite.length && !(c >= this.lstHistory.length); ++a) b = this.lstHistory[c], this.lstHistorySprite[a][b].setVisible(!0), ++c
    },
    playBtnSound: function() {
        this.gamelayer.playBtnSound()
    }
});
var NarutoSoundTipsLayer = cc.Layer.extend({
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoSoundTipsLayer_json);
        this.addChild(b.node);
        this.gamelayer = a;
        ccui.helper.seekWidgetByName(b.node, "layClick").addTouchEventListener(this.onTouchClick, this);
        ccui.helper.seekWidgetByName(b.node, "btnCloseSound").addTouchEventListener(this.onTouchCloseSound, this)
    },
    onTouchClick: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.getParent().removeChild(this)
    },
    onTouchCloseSound: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED &&
            (this.gamelayer.setPlaySound(!0), this.getParent().removeChild(this))
    }
});
var NarutoBoxLayer = cc.Layer.extend({
    sprite: null,
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoBoxLayer_json);
        this.addChild(b.node);
        this.gamelayer = a;
        this.lstBoxBtn = [];
        this.lstCoverSprite = [];
        this.lstAniNode = [];
        this.lstResult = [];
        this.lstWaitAni = [];
        this.lstWaitData = [];
        for (a = 1; 5 >= a; ++a) {
            var c = ccui.helper.seekWidgetByName(b.node, "btnBox" + a);
            c.addTouchEventListener(this.onTouchBox, this);
            this.lstBoxBtn.push(c);
            c = ccui.helper.seekWidgetByName(b.node, "sprBoxCover" + a);
            this.lstCoverSprite.push(c);
            c =
                ccui.helper.seekWidgetByName(b.node, "nodBoxAni" + a);
            this.lstAniNode.push(c);
            this.lstResult.push({
                val: 0
            });
            this.lstWaitAni.push(void 0);
            this.lstWaitData.push(void 0)
        }
        a = ccui.helper.seekWidgetByName(b.node, "textFreeNum");
        a.setString("");
        this.textFreeNum = a;
        b = ccui.helper.seekWidgetByName(b.node, "textFreeMul");
        b.setString("");
        this.textFreeMul = b;
        this.iFreeNum = 0;
        this.iFreeMul = 1;
        this.bWaitResult = !1;
        this.iOpenNum = this.ShowResultTime = 0;
        this.scheduleUpdate();
        this.bInit = !1
    },
    update: function(a) {
        0 < this.ShowResultTime &&
            (this.ShowResultTime -= a, 0 >= this.ShowResultTime && (this.ShowResultTime = 0, this.refreshInfo()));
        for (a = 0; a < this.lstWaitAni.length; ++a)
            if (void 0 != this.lstWaitAni[a]) {
                var b = this.lstWaitAni[a];
                Math.floor(b.action.getCurrentFrame()) == b.action.getDuration() && void 0 != this.lstWaitData[a] && (b.node.stopAllActions(), b.node.getParent().removeChild(b.node), this.lstWaitAni[a] = void 0, this.lstCoverSprite[a].setVisible(!0), this.lstBoxBtn[a].setVisible(!0), this.openBox(this.lstWaitData[a].index, this.lstWaitData[a].type,
                    this.lstWaitData[a].val), this.lstWaitData[a] = void 0)
            }
    },
    onTouchBox: function(a, b) {
        if (b == ccui.Widget.TOUCH_ENDED && this.bInit && !(2 <= this.iOpenNum || this.bWaitResult || 0 < this.ShowResultTime)) {
            for (var c = -1, d = 0; d < this.lstBoxBtn.length; ++d)
                if (this.lstBoxBtn[d] == a) {
                    if (void 0 != this.lstResult[d].type) return;
                    c = d;
                    break
                }
            0 > c || (this.playBtnSound(), this.lstCoverSprite[c].setVisible(!1), this.lstBoxBtn[c].setVisible(!1), d = ccs.load(res.NarutoBoxAni2_json), this.lstAniNode[c].addChild(d.node), d.node.runAction(d.action),
                d.action.gotoFrameAndPlay(0, d.action.getDuration(), !0), this.lstWaitAni[c] = d, this.bWaitResult = !0, MainClient.singleton.sgamectrl(GameMgr.singleton.getCurGameID(), "pickshell", "play", c, function(a) {}))
        }
    },
    openBox: function(a, b, c) {
        if (void 0 != this.lstWaitAni[a]) {
            var d = {};
            d.index = a;
            d.type = b;
            d.val = c;
            this.lstWaitData[a] = d
        } else {
            this.bWaitResult = !1;
            ++this.iOpenNum;
            this.ShowResultTime = 2 > this.iOpenNum ? 0.5 : 1;
            this.lstResult[a].type = b;
            this.lstResult[a].val = c;
            this.lstCoverSprite[a].setVisible(!1);
            var d = ccs.load(res.NarutoBoxAni1_json),
                e = ccui.helper.seekWidgetByName(d.node, "textNum1");
            "nums" == b ? e.setString(c.toString()) : e.setString("X" + c);
            this.lstAniNode[a].addChild(d.node);
            d.node.runAction(d.action);
            d.action.gotoFrameAndPlay(0, d.action.getDuration(), !1)
        }
    },
    refreshInfo: function() {
        this.textFreeNum.setString(this.iFreeNum.toString());
        this.textFreeMul.setString("X" + this.iFreeMul.toString());
        if (2 <= this.iOpenNum) {
            var a = new NarutoBoxResultLayer(this.gamelayer, this.iFreeNum, this.iFreeMul);
            this.addChild(a, 1)
        }
    },
    playBtnSound: function() {
        this.gamelayer.playBtnSound()
    },
    onSGameInfo: function(a) {
        this.bInit = !0;
        this.iFreeNum = a.sgi.nums;
        this.iFreeMul = a.sgi.multiple;
        if (a.sgi.openshell.length > this.iOpenNum)
            for (var b = this.iOpenNum; b < a.sgi.openshell.length; ++b) {
                var c = a.sgi.openshell[b];
                this.openBox(c.position, c.type, c.val)
            }
        0 >= a.sgi.openshell.length && this.refreshInfo()
    }
});
var NarutoBoxResultLayer = cc.Layer.extend({
    sprite: null,
    ctor: function(a, b, c) {
        this._super();
        var d = ccs.load(res.NarutoBoxResultLayer_json);
        this.addChild(d.node);
        this.gamelayer = a;
        ccui.helper.seekWidgetByName(d.node, "btnOK").addTouchEventListener(this.onTouchOK, this);
        ccui.helper.seekWidgetByName(d.node, "textFreeNum").setString(b.toString());
        ccui.helper.seekWidgetByName(d.node, "textFreeMul").setString("X" + c.toString())
    },
    onTouchOK: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.gamelayer.leftBoxGame()
    }
});
var NarutoFreeResultLayer = cc.Layer.extend({
    sprite: null,
    ctor: function(a, b, c) {
        this._super();
        var d = ccs.load(res.NarutoFreeResultLayer_json);
        this.addChild(d.node);
        this.gamelayer = a;
        ccui.helper.seekWidgetByName(d.node, "btnOK").addTouchEventListener(this.onTouchOK, this);
        ccui.helper.seekWidgetByName(d.node, "textGameWin").setString("\uffe5" + a.chgString(b));
        ccui.helper.seekWidgetByName(d.node, "textFreeWin").setString("\uffe5" + a.chgString(c));
        ccui.helper.seekWidgetByName(d.node, "textAllWin").setString("\uffe5" +
            a.chgString(b + c))
    },
    onTouchOK: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.gamelayer.leftFreeResult()
    }
});
var NarutoHelpLayer1 = cc.Layer.extend({
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoHelpLayer1_json);
        this.addChild(b.node);
        this.gamelayer = a;
        this.lstNodPage = [];
        for (a = 1; 4 >= a; ++a) {
            var c = b.node.getChildByName("nodPage" + a);
            c.setVisible(!1);
            this.lstNodPage.push(c)
        }
        this.lstminiconscale = [0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9];
        this.lstmaxiconscale = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        this.lstSprIcon = [];
        this.lstFlashIcon = [];
        for (a = 0; 12 >= a; ++a)
            for (var d = 0; d < this.lstNodPage.length; ++d) {
                var c = this.lstNodPage[d],
                    e = c.getChildByName("sprIcon" + a);
                void 0 != e && null != e && (this.lstSprIcon.push(e), this.lstFlashIcon.push(!1))
            }
        this.minscorescale = 1;
        this.maxscorescale = 1.1;
        this.lstSprScore = [];
        this.lstFlashScore = [];
        for (a = 0; 12 >= a; ++a) {
            c = void 0;
            for (d = 0; d < this.lstNodPage.length && (c = this.lstNodPage[d], e = c.getChildByName("nodScore" + a.toString() + "5"), void 0 == e || null == e); ++d);
            if (void 0 != c && null != c) {
                for (var f = [], g = [], d = 1; 5 >= d; ++d) e = c.getChildByName("nodScore" + a.toString() + d.toString()), f.push(e), g.push(!1), void 0 != e && e.setLocalZOrder(1);
                this.lstSprScore.push(f);
                this.lstFlashScore.push(g)
            }
        }
        a = ccui.helper.seekWidgetByName(b.node, "btnExit");
        a.addTouchEventListener(this.onTouchExit, this);
        this.btnExit = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp1");
        a.addTouchEventListener(this.onTouchHelp1, this);
        this.btnHelp1 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp2");
        a.addTouchEventListener(this.onTouchHelp2, this);
        this.btnHelp2 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp3");
        a.addTouchEventListener(this.onTouchHelp3, this);
        this.btnHelp3 =
            a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp4");
        a.addTouchEventListener(this.onTouchHelp4, this);
        this.btnHelp4 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnLeft");
        a.addTouchEventListener(this.onTouchLeft, this);
        this.btnLeft = a;
        b = ccui.helper.seekWidgetByName(b.node, "btnRight");
        b.addTouchEventListener(this.onTouchRight, this);
        this.btnRight = b;
        this.clearResult();
        this.scheduleUpdate();
        this.falshsp = 0.5 + 1 / 24;
        this.curFlashTime = 0;
        this.lstNodPage[0].setVisible(!0);
        this.iShowPageIndex = 0
    },
    update: function(a) {
        for (this.curFlashTime +=
            a; this.curFlashTime > 2 * this.falshsp;) this.curFlashTime -= 2 * this.falshsp;
        var b = this.curFlashTime / this.falshsp;
        this.curFlashTime > this.falshsp && (b = 2 - b);
        for (var c = a = 0; c < this.lstSprIcon.length; ++c) this.lstFlashIcon[c] && void 0 != this.lstSprIcon[c] && null != this.lstSprIcon[c] && (a = (this.lstmaxiconscale[c] - this.lstminiconscale[c]) * b + this.lstminiconscale[c], this.lstSprIcon[c].setScale(a));
        a = (this.maxscorescale - this.minscorescale) * b + this.minscorescale;
        for (c = 0; c < this.lstSprScore.length; ++c)
            for (b = 0; b < this.lstSprScore[c].length; ++b) this.lstFlashScore[c][b] &&
                void 0 != this.lstSprScore[c][b] && null != this.lstSprScore[c][b] && this.lstSprScore[c][b].setScale(a)
    },
    clearResult: function() {
        for (var a = 0; a < this.lstSprIcon.length; ++a) void 0 != this.lstSprIcon[a] && null != this.lstSprIcon[a] && (this.lstSprIcon[a].setScale(this.lstminiconscale[a]), this.lstSprIcon[a].setVisible(!0), this.lstFlashIcon[a] = !1);
        for (a = 0; a < this.lstSprScore.length; ++a)
            for (var b = 0; b < this.lstSprScore[a].length; ++b) void 0 != this.lstSprScore[a][b] && null != this.lstSprScore[a][b] && (this.lstSprScore[a][b].setScale(this.minscorescale),
                this.lstSprScore[a][b].setLocalZOrder(1), this.lstFlashScore[a][b] = !1)
    },
    setResult: function(a, b, c, d) {
        a = 0 == a ? b : 1;
        this.lstFlashIcon[a] = !0;
        d -= 1;
        void 0 != this.lstSprScore[a][d] && null != this.lstSprScore[a][d] && (this.lstFlashScore[a][d] = !0, void 0 != this.lstSprScore[a][d] && null != this.lstSprScore[a][d] && this.lstSprScore[a][d].setLocalZOrder(2))
    },
    onTouchExit: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(0))
    },
    onTouchHelp1: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED &&
            this.gamelayer.playBtnSound()
    },
    onTouchHelp2: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(2))
    },
    onTouchHelp3: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(3))
    },
    onTouchHelp4: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(4))
    },
    onTouchLeft: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), --this.iShowPageIndex, 0 > this.iShowPageIndex &&
            (this.iShowPageIndex = this.lstNodPage.length - 1), this.refreshShowPage())
    },
    onTouchRight: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), ++this.iShowPageIndex, this.iShowPageIndex >= this.lstNodPage.length && (this.iShowPageIndex = 0), this.refreshShowPage())
    },
    refreshShowPage: function() {
        for (var a = 0; a < this.lstNodPage.length; ++a) this.lstNodPage[a].setVisible(a == this.iShowPageIndex)
    }
});
var NarutoHelpLayer2 = cc.Layer.extend({
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoHelpLayer2_json);
        this.addChild(b.node);
        this.gamelayer = a;
        this.lstSprWin = [];
        this.lstSprLBlue = [];
        this.lstSprLine = [];
        this.lstWin = [];
        for (a = 1; 25 >= a; ++a) {
            var c = b.node.getChildByName("sprLBlue" + a),
                d = b.node.getChildByName("nodeLine" + a);
            this.lstSprLBlue.push(c);
            this.lstSprLine.push(d);
            this.lstWin.push(!1)
        }
        for (a = 1; 12 >= a; ++a) c = b.node.getChildByName("sprWin" + a), this.lstSprWin.push(c), this.lstSprWin.push(c), 1 == a && this.lstSprWin.push(c);
        this.LineFlashTime = 0;
        a = ccui.helper.seekWidgetByName(b.node, "btnExit");
        a.addTouchEventListener(this.onTouchExit, this);
        this.btnExit = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp1");
        a.addTouchEventListener(this.onTouchHelp1, this);
        this.btnHelp1 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp2");
        a.addTouchEventListener(this.onTouchHelp2, this);
        this.btnHelp2 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp3");
        a.addTouchEventListener(this.onTouchHelp3, this);
        this.btnHelp3 = a;
        b = ccui.helper.seekWidgetByName(b.node,
            "btnHelp4");
        b.addTouchEventListener(this.onTouchHelp4, this);
        this.btnHelp4 = b;
        this.clearResult();
        this.scheduleUpdate()
    },
    update: function(a) {
        this.LineFlashTime += a;
        a = Math.floor(1E3 * this.LineFlashTime) % 1500;
        a = 750 > a ? 191 * (750 - a) / 750 + 64 : 191 * (a - 750) / 750 + 64;
        64 > a && (a = 64);
        255 < a && (a = 255);
        a = Math.floor(a);
        for (var b = 0; b < this.lstSprWin.length; ++b) this.lstWin[b] && this.lstSprLine[b].setOpacity(a)
    },
    clearResult: function() {
        for (var a = 0; a < this.lstSprWin.length; ++a) this.lstSprWin[a].setVisible(!1), this.lstSprLBlue[a].setVisible(!1),
            this.lstSprLine[a].setOpacity(204), this.lstWin[a] = !1;
        this.LineFlashTime = 0
    },
    setResult: function(a, b, c, d) {
        0 == a && (a = c - 1, this.lstSprWin[a].setVisible(!0), this.lstSprLBlue[a].setVisible(!0), this.lstWin[a] = !0)
    },
    onTouchExit: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(0))
    },
    onTouchHelp1: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(1))
    },
    onTouchHelp2: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.gamelayer.playBtnSound()
    },
    onTouchHelp3: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(3))
    },
    onTouchHelp4: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(4))
    }
});
var NarutoHelpLayer3 = cc.Layer.extend({
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoHelpLayer3_json);
        this.addChild(b.node);
        this.gamelayer = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnExit");
        a.addTouchEventListener(this.onTouchExit, this);
        this.btnExit = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp1");
        a.addTouchEventListener(this.onTouchHelp1, this);
        this.btnHelp1 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp2");
        a.addTouchEventListener(this.onTouchHelp2, this);
        this.btnHelp2 = a;
        a = ccui.helper.seekWidgetByName(b.node,
            "btnHelp3");
        a.addTouchEventListener(this.onTouchHelp3, this);
        this.btnHelp3 = a;
        b = ccui.helper.seekWidgetByName(b.node, "btnHelp4");
        b.addTouchEventListener(this.onTouchHelp4, this);
        this.btnHelp4 = b
    },
    clearResult: function() {},
    setResult: function(a, b, c, d) {},
    onTouchExit: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(0))
    },
    onTouchHelp1: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(1))
    },
    onTouchHelp2: function(a, b) {
        b ==
            ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(2))
    },
    onTouchHelp3: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.gamelayer.playBtnSound()
    },
    onTouchHelp4: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(4))
    }
});
var NarutoHelpLayer4 = cc.Layer.extend({
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoHelpLayer4_json);
        this.addChild(b.node);
        this.gamelayer = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnExit");
        a.addTouchEventListener(this.onTouchExit, this);
        this.btnExit = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp1");
        a.addTouchEventListener(this.onTouchHelp1, this);
        this.btnHelp1 = a;
        a = ccui.helper.seekWidgetByName(b.node, "btnHelp2");
        a.addTouchEventListener(this.onTouchHelp2, this);
        this.btnHelp2 = a;
        a = ccui.helper.seekWidgetByName(b.node,
            "btnHelp3");
        a.addTouchEventListener(this.onTouchHelp3, this);
        this.btnHelp3 = a;
        b = ccui.helper.seekWidgetByName(b.node, "btnHelp4");
        b.addTouchEventListener(this.onTouchHelp4, this);
        this.btnHelp4 = b
    },
    clearResult: function() {},
    setResult: function(a, b, c, d) {},
    onTouchExit: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(0))
    },
    onTouchHelp1: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(1))
    },
    onTouchHelp2: function(a, b) {
        b ==
            ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(2))
    },
    onTouchHelp3: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), this.gamelayer.showHelp(3))
    },
    onTouchHelp4: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.gamelayer.playBtnSound()
    }
});
var NarutoDisconnectLayer = cc.Layer.extend({
    ctor: function(a, b, c, d) {
        this._super();
        var e = ccs.load(res.NarutoDisconnectLayer_json);
        this.addChild(e.node);
        this.gamelayer = a;
        a = ccui.helper.seekWidgetByName(e.node, "btnOK");
        a.addTouchEventListener(this.onTouchOK, this);
        var f = e.node.getChildByName("sprDisconnect");
        f.setVisible(!1);
        this.sprDisconnect = f;
        var g = e.node.getChildByName("sprNotEnough");
        g.setVisible(!1);
        this.sprNotEnough = g;
        var h = e.node.getChildByName("sprError1");
        h.setVisible(!1);
        this.sprError1 = h;
        var k =
            e.node.getChildByName("sprError2");
        k.setVisible(!1);
        this.sprError2 = k;
        var m = e.node.getChildByName("textError");
        m.setFontName("Microsoft YaHei");
        m.setVisible(!1);
        this.textError = m;
        e = e.node.getChildByName("layErrorBack");
        e.setVisible(!1);
        this.layErrorBack = e;
        this.iType = b;
        this.iTyp1 = c;
        this.CloseTime = 0;
        void 0 != d ? this.textError.setString(d) : this.textError.setString("");
        1 == this.iType ? f.setVisible(!0) : 2 == this.iType ? g.setVisible(!0) : 3 == this.iType && (0 == this.iTyp1 ? (m.setVisible(!0), e.setVisible(!0)) : 1 == this.iTyp1 ?
            h.setVisible(!0) : (k.setVisible(!0), a.setVisible(!1), this.CloseTime = 2));
        this.scheduleUpdate()
    },
    onTouchOK: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), 1 != this.iType && 3 != this.iType || refurbish_main(), this.getParent().removeChild(this))
    },
    update: function(a) {
        0 >= this.CloseTime || (this.CloseTime -= a, 0 >= this.CloseTime && (this.CloseTime = 0, this.gamelayer.ErrorLayer = void 0, this.getParent().removeChild(this)))
    }
});
var NarutoSetupLayer = cc.Layer.extend({
    ctor: function(a) {
        this._super();
        var b = ccs.load(res.NarutoSetupLayer_json);
        this.addChild(b.node);
        this.gamelayer = a;
        ccui.helper.seekWidgetByName(b.node, "imgClick").addTouchEventListener(this.onTouchClick, this);
        ccui.helper.seekWidgetByName(b.node, "btnHistory").addTouchEventListener(this.onTouchHistory, this);
        ccui.helper.seekWidgetByName(b.node, "btnHelp").addTouchEventListener(this.onTouchHelp, this)
    },
    onTouchClick: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && this.getParent().removeChild(this)
    },
    onTouchHistory: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), open_history(g_bkurl), this.getParent().removeChild(this))
    },
    onTouchHelp: function(a, b) {
        b == ccui.Widget.TOUCH_ENDED && (this.gamelayer.playBtnSound(), open_help("naruto_help.html"), this.getParent().removeChild(this))
    }
});
var GAMETYPE_SLAMDUNK = 1,
    GAMETYPE_KOF = 2,
    GAMETYPE_SLAMDUNK2 = 3,
    GAMETYPE_NARUTO = 4,
    GAMETYPE_ONEPIECE = 5,
    GAMETYPE_DBZ = 6,
    GAMETYPE_SAN1 = 7,
    GAMETYPE_FARM = 8,
    GAMETYPE_SAINT = 9,
    GAMETYPE_TGOW = 10,
    GAMETYPE_HEROS108 = 11,
    GAMETYPE_NEWYEAR = 12,
    GAMETYPE_TLOD = 13,
    GAMETYPE_JTW = 14,
    GAMETYPE_WHITESNAKE = 15,
    GAMETYPE_DNP = 16,
    GAMEIDLIST = [0, 202, 104, 107, 108, 109, 110, 111, 112, 203, 113, 114, 115, 116, 117, 301, 118],
    GameMgr = cc.Class.extend({
        ctor: function() {
            this.curGameLayer = void 0;
            this.bDisconnect = !1;
            this.myInfo = {
                uid: 0,
                gameid: 0,
                isspin: !1,
                bet: 1,
                times: 1,
                lines: 1,
                nickname: ""
            };
            this.lstMsg = [];
            this.lastSpinID = 0
        },
        getCurGameID: function() {
            return this.getGameID(GAMETYPE_CURTYPE)
        },
        getGameID: function(a) {
            return GAMEIDLIST[a]
        },
        newCurGameLayer: function() {
            return this.newGameLayer(GAMETYPE_CURTYPE)
        },
        newGameLayer: function(a) {
            var b = void 0;
            switch (a) {
                case GAMETYPE_SLAMDUNK:
                    b = new SlamdunkGameLayer;
                    break;
                case GAMETYPE_KOF:
                    b = new KofGameLayer;
                    break;
                case GAMETYPE_SLAMDUNK2:
                    b = new Slamdunk2GameLayer;
                    break;
                case GAMETYPE_NARUTO:
                    b = new NarutoGameLayer;
                    break;
                case GAMETYPE_ONEPIECE:
                    b =
                        new OnePieceGameLayer;
                    break;
                case GAMETYPE_DBZ:
                    b = new DBZGameLayer;
                    break;
                case GAMETYPE_SAN1:
                    b = new San1GameLayer;
                    break;
                case GAMETYPE_FARM:
                    b = new FarmGameLayer;
                    break;
                case GAMETYPE_SAINT:
                    b = new SaintGameLayer;
                    break;
                case GAMETYPE_TGOW:
                    b = new TgowGameLayer;
                    break;
                case GAMETYPE_HEROS108:
                    b = new Heros108GameLayer;
                    break;
                case GAMETYPE_NEWYEAR:
                    b = new NewYearGameLayer;
                    break;
                case GAMETYPE_TLOD:
                    b = new TlodGameLayer;
                    break;
                case GAMETYPE_JTW:
                    b = new JTWGameLayer;
                    break;
                case GAMETYPE_WHITESNAKE:
                    b = new WhiteSnakeGameLayer;
                    break;
                case GAMETYPE_DNP:
                    b = new DNPGameLayer
            }
            return this.curGameLayer = b
        },
        onMyMoney: function(a) {
            if (void 0 != this.curGameLayer) this.curGameLayer.onMyMoney(a);
            else this.money = a
        },
        onSymbolStripes: function(a, b) {
            if (void 0 != this.curGameLayer) this.curGameLayer.onSymbolStripes(a, wheelname);
            else void 0 == this.arr && (this.arr = {}), this.arr[b] = a
        },
        onGenInit: function(a) {
            if (void 0 != this.curGameLayer) this.curGameLayer.onGenInit(a);
            else this.gendata = a
        },
        onGameModuleInfo: function(a) {
            if (void 0 != this.curGameLayer) this.curGameLayer.onGameModuleInfo(a);
            else void 0 == this.lstgamemoduleinfo && (this.lstgamemoduleinfo = []), this.lstgamemoduleinfo.push(a)
        },
        initData: function() {
            if (void 0 != this.curGameLayer && void 0 != this.money) this.curGameLayer.onMyMoney(this.money);
            if (void 0 != this.curGameLayer && void 0 != this.arr)
                for (var a in this.arr) this.curGameLayer.onSymbolStripes(this.arr[a], a);
            if (void 0 != this.curGameLayer && void 0 != this.gendata) this.curGameLayer.onGenInit(this.gendata);
            if (void 0 != this.curGameLayer && void 0 != this.ErrorType) this.curGameLayer.onError(this.ErrorType,
                this.ErrorString);
            if (void 0 != this.curGameLayer && void 0 != this.curGameLayer.onGameInfo && void 0 != this.gameinfo) this.curGameLayer.onGameInfo(this.gameinfo);
            if (void 0 != this.curGameLayer && void 0 != this.lstgamemoduleinfo) {
                for (a = 0; a < this.lstgamemoduleinfo.length; ++a) this.curGameLayer.onGameModuleInfo(this.lstgamemoduleinfo[a]);
                this.lstgamemoduleinfo = void 0
            }
        },
        initFinish: function() {
            void 0 != this.curGameLayer && void 0 != this.curGameLayer.initFinish && this.curGameLayer.initFinish()
        },
        onSpinResult: function(a, b, c, d) {
            if (void 0 !=
                this.curGameLayer) this.curGameLayer.onSpinResult(a, b, c, d)
        },
        onSpinResult1: function() {
            if (void 0 != this.curGameLayer) this.curGameLayer.onSpinResult1()
        },
        onSGameInfo: function(a) {
            if (void 0 != this.curGameLayer && void 0 != this.curGameLayer.onSGameInfo) this.curGameLayer.onSGameInfo(a)
        },
        onGameInfo: function(a) {
            if (void 0 != this.curGameLayer && void 0 != this.curGameLayer.onGameInfo) this.curGameLayer.onGameInfo(a);
            else this.gameinfo = a
        },
        onDisconnect: function() {
            if (!this.bDisconnect && void 0 != this.curGameLayer) this.curGameLayer.onDisconnect();
            this.bDisconnect = !0
        },
        onReconnnect: function() {
            this.bDisconnect && (this.curGameLayer.onReconnnect(), this.bDisconnect = !1, MainClient.singleton.isapi2 ? MainClient.singleton.__procCtrlList(!0) : 0 < this.lstMsg.length && MainClient.singleton.sendex(this.lstMsg[0].msg, this.lstMsg[0].callback))
        },
        onError: function(a, b) {
            if (void 0 == this.curGameLayer) cc.director.runScene(new GameScene), this.ErrorType = a, this.ErrorString = b;
            else this.curGameLayer.onError(a, b)
        },
        onCmdRet: function(a) {
            MainClient.singleton.isapi2 || 0 < this.lstMsg.length &&
                a == this.lstMsg[0].msg.cmdid && this.lstMsg.splice(0, 1)
        },
        onSendCmd: function(a, b) {
            MainClient.singleton.isapi2 || this.lstMsg.push({
                msg: a,
                callback: b
            })
        }
    });
GameMgr.singleton = new GameMgr;
var GameScene = cc.Scene.extend({
    onEnter: function() {
        this._super();
        var a = GameMgr.singleton.newCurGameLayer();
        this.addChild(a);
        GameMgr.singleton.initData();
        GameMgr.singleton.initFinish();
        cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, function() {});
        cc.eventManager.addCustomListener(cc.game.EVENT_SHOW, function() {})
    }
});
var GAMEAPI_ISAPI2, GAMEAPI_CONSTLINES = !1,
    GAMEAPI_CONSTTIMES = !1,
    g_clienttype;
void 0 == g_clienttype && (g_clienttype = 0);
var g_isguest;
void 0 == g_isguest && (g_isguest = !1);
var g_guestuname;
void 0 == g_guestuname && (g_guestuname = "");
var g_isflblogin, g_flblogintoken;
void 0 == g_isflblogin && (g_isflblogin = !1);
g_isflblogin && void 0 == g_flblogintoken && (g_flblogintoken = "6858cff3ab97bf228e73d4abba29360c");
var g_pname;
void 0 == g_pname && (g_pname = "ptt", g_uname = "ttt005");
var g_servaddr;
void 0 == g_servaddr && (g_servaddr = "ws://114.55.252.31:3712");
var g_mainurl;
void 0 == g_mainurl && (g_mainurl = "index.html");
var g_bkurl;
void 0 == g_bkurl && (g_bkurl = "");
var g_spinstate;
void 0 == g_spinstate && (g_spinstate = 0);
onerror = handleErr;

function handleErr(a, b, c) {
    0 != g_clienttype && close_game()
}
var g_ver;
cc.game.onStart = function() {
    !cc.sys.isNative && document.getElementById("cocosLoading") && document.body.removeChild(document.getElementById("cocosLoading"));
    cc.view.enableRetina(!0);
    cc.view.adjustViewPort(!0);
    cc.view.setDesignResolutionSize(1280, 720, cc.ResolutionPolicy.SHOW_ALL);
    cc.view.resizeWithBrowserSize(!0);
    LoadingScene.preload(g_resources, function() {
        MainClient.singleton.init(g_servaddr)
    }, this)
};
cc.game.run();
